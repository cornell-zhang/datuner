# 1 "/home/sx233/datuner/src/opticalflow_hls/o_flow.prj/solution1/.autopilot/db/optical_flow.pragma.1.cpp"
# 1 "/home/sx233/datuner/src/opticalflow_hls/o_flow.prj/solution1/.autopilot/db/optical_flow.pragma.1.cpp" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 155 "<built-in>" 3
# 1 "<command line>" 1





# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
/* autopilot_ssdm_op.h*/
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 * $Id$
 */
# 145 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
/*#define AP_SPEC_ATTR __attribute__ ((pure))*/
//adu: patched
# 156 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {

    /****** SSDM Intrinsics: OPERATIONS ***/
    // Interface operations

    //typedef unsigned int __attribute__ ((bitwidth(1))) _uint1_;
    typedef bool _uint1_;

    void _ssdm_op_IfRead(...) __attribute__ ((nothrow));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow));

    // Stream Intrinsics
    void _ssdm_StreamRead(...) __attribute__ ((nothrow));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamCanWrite(...) __attribute__ ((nothrow));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow));

    // Misc
    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow));

    void _ssdm_op_Return(...) __attribute__ ((nothrow));

    /* SSDM Intrinsics: SPECIFICATIONS */
    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow));
    /*void* _ssdm_op_SpecProcess(...) SSDM_SPEC_ATTR;
    void* _ssdm_op_SpecEdge(...) SSDM_SPEC_ATTR; */

    /* Presynthesis directive functions */
    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_Unroll(...) __attribute__ ((nothrow));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow));
    void _ssdm_Inline(...) __attribute__ ((nothrow));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow));

    void _ssdm_DataPack(...) __attribute__ ((nothrow));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow));

    void __xilinx_ip_top(...) __attribute__ ((nothrow));


}
# 413 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
/*#define _ssdm_op_WaitUntil(X) while (!(X)) _ssdm_op_Wait(1);
#define _ssdm_op_Delayed(X) X */
# 427 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 7 "<command line>" 2
# 1 "<built-in>" 2
# 1 "/home/sx233/datuner/src/opticalflow_hls/o_flow.prj/solution1/.autopilot/db/optical_flow.pragma.1.cpp" 2
# 1 "optical_flow.cpp"
# 1 "optical_flow.cpp" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 155 "<built-in>" 3
# 1 "<command line>" 1





# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
/* autopilot_ssdm_op.h*/
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 * $Id$
 */
# 145 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
/*#define AP_SPEC_ATTR __attribute__ ((pure))*/
//adu: patched
# 156 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {

    /****** SSDM Intrinsics: OPERATIONS ***/
    // Interface operations

    //typedef unsigned int __attribute__ ((bitwidth(1))) _uint1_;
    typedef bool _uint1_;

    void _ssdm_op_IfRead(...) __attribute__ ((nothrow));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow));

    // Stream Intrinsics
    void _ssdm_StreamRead(...) __attribute__ ((nothrow));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamNbWrite(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamCanRead(...) __attribute__ ((nothrow));
    _uint1_ _ssdm_StreamCanWrite(...) __attribute__ ((nothrow));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow));

    // Misc
    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow));

    void _ssdm_op_Return(...) __attribute__ ((nothrow));

    /* SSDM Intrinsics: SPECIFICATIONS */
    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow));
    /*void* _ssdm_op_SpecProcess(...) SSDM_SPEC_ATTR;
    void* _ssdm_op_SpecEdge(...) SSDM_SPEC_ATTR; */

    /* Presynthesis directive functions */
    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow));

    void _ssdm_Unroll(...) __attribute__ ((nothrow));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow));
    void _ssdm_Inline(...) __attribute__ ((nothrow));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow));

    void _ssdm_DataPack(...) __attribute__ ((nothrow));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow));

    void __xilinx_ip_top(...) __attribute__ ((nothrow));


}
# 413 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
/*#define _ssdm_op_WaitUntil(X) while (!(X)) _ssdm_op_Wait(1);
#define _ssdm_op_Delayed(X) X */
# 427 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_op.h"
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 7 "<command line>" 2
# 1 "<built-in>" 2
# 1 "optical_flow.cpp" 2
//==========================================================================
//digitrec.cpp
//==========================================================================
// @brief: A k-nearest-neighbors implementation for digit recognition



# 1 "./optical_flow.h" 1
//===========================================================================
// optical_flow.h
//===========================================================================
// @brief: This header file defines the interface for the core functions.






# 1 "./typedefs.h" 1
//===========================================================================
// typedefs.h
//===========================================================================
// @brief: This header defines the shorthand of several ap_uint data types.




//#include "ap_fixed.h"

//typedef ap_uint<4> bit4;
//typedef ap_uint<6> bit6;
//typedef ap_uint<32> bit32;
//typedef ap_uint<64> bit64;
//typedef ap_uint<49> digit;

typedef float pixel_t;

typedef struct{
    pixel_t x;
    pixel_t y;
    pixel_t z;
}gradient_t;

typedef struct{
    pixel_t val[6];
}outer_t;

typedef struct{
    pixel_t val[6];
}tensor_t;

typedef struct{
    pixel_t x;
    pixel_t y;
}velocity_t;
# 9 "./optical_flow.h" 2





const int GRAD_WEIGHTS[] = {1,-8,0,8,-1};

const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};

const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};

void optical_flow(pixel_t frame1[436][1024],
    pixel_t frame2[436][1024],
    pixel_t frame3[436][1024],
    pixel_t frame4[436][1024],
    pixel_t frame5[436][1024],
    velocity_t output[436][1024],
    gradient_t grad[436][1024],
    tensor_t tensor_out[436][1024]);

void gradient_xy_calc(pixel_t frame[436][1024],
    pixel_t gradient_x[436][1024],
    pixel_t gradient_y[436][1024]);

void gradient_z_calc(pixel_t frame1[436][1024],
    pixel_t frame2[436][1024],
    pixel_t frame3[436][1024],
    pixel_t frame4[436][1024],
    pixel_t frame5[436][1024],
    pixel_t gradient_z[436][1024]);

void gradient_weight_y(pixel_t gradient_x[436][1024],
    pixel_t gradient_y[436][1024],
    pixel_t gradient_z[436][1024],
    gradient_t filt_grad[436][1024]);

void gradient_weight_x(gradient_t y_filt[436][1024],
    gradient_t filt_grad[436][1024]);

void outer_product(gradient_t gradient[436][1024],
     outer_t outer_product[436][1024]);

void tensor_weight_y(outer_t outer[436][1024],
    tensor_t tensor_y[436][1024]);

void tensor_weight_x(tensor_t tensor_y[436][1024],
    tensor_t tensor[436][1024]);

void flow_calc(tensor_t tensors[436][1024],
    velocity_t output[436][1024]);
# 7 "optical_flow.cpp" 2

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 1 3
// Standard iostream objects -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2005, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/iostream
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.3  Standard iostream objects
//
# 37 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++config.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */




// The current version of the C++ library in compressed ISO date format.


// Macros for various attributes.
//   _GLIBCXX_PURE
//   _GLIBCXX_CONST
//   _GLIBCXX_NORETURN
//   _GLIBCXX_NOTHROW
//   _GLIBCXX_VISIBILITY
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macros for visibility attributes.
//   _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY
//   _GLIBCXX_VISIBILITY
# 76 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macros for deprecated attributes.
//   _GLIBCXX_USE_DEPRECATED
//   _GLIBCXX_DEPRECATED
# 91 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macro for constexpr, to support in mixed 03/0x mode.
# 102 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macro for extern template, ie controling template linkage via use
// of extern keyword on template declaration. As documented in the g++
// manual, it inhibits all implicit instantiations and is used
// throughout the library to avoid multiple weak definitions for
// required types that are already explicitly instantiated in the
// library binary. This substantially reduces the binary size of
// resulting executables.
// Special case: _GLIBCXX_EXTERN_TEMPLATE == -1 disallows extern
// templates only in basic_string, thus activating its debug-mode
// checks even at -O0.


/*
  Outline of libstdc++ namespaces.

  namespace std
  {
    namespace __debug { }
    namespace __parallel { }
    namespace __profile { }
    namespace __cxx1998 { }

    namespace __detail { }

    namespace rel_ops { }

    namespace tr1
    {
      namespace placeholders { }
      namespace regex_constants { }
      namespace __detail { }
    }

    namespace decimal { }

    namespace chrono { }
    namespace placeholders { }
    namespace regex_constants { }
    namespace this_thread { }
  }

  namespace abi { }

  namespace __gnu_cxx
  {
    namespace __detail { }
  }

  For full details see:
  http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html
*/
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}


// Defined if inline namespaces are used for versioning.


// Inline namespace for symbol versioning.
# 208 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Inline namespaces for special modes: debug, parallel, profile.
# 255 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macros for namespace scope. Either namespace std:: or the name
// of some nested namespace within it corresponding to the active mode.
// _GLIBCXX_STD_A
// _GLIBCXX_STD_C
//
// Macros for opening/closing conditional namespaces.
// _GLIBCXX_BEGIN_NAMESPACE_ALGO
// _GLIBCXX_END_NAMESPACE_ALGO
// _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
// _GLIBCXX_END_NAMESPACE_CONTAINER
# 307 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// GLIBCXX_ABI Deprecated
// Define if compatibility should be provided for -mlong-double-64.


// Inline namespace for long double 128 mode.
# 326 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Assert.
# 352 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// Macros for race detectors.
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain
// atomic (lock-free) synchronization to race detectors:
// the race detector will infer a happens-before arc from the former to the
// latter when they share the same argument pointer.
//
// The most frequent use case for these macros (and the only case in the
// current implementation of the library) is atomic reference counting:
//   void _M_remove_reference()
//   {
//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)
//       {
//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
//         _M_destroy(__a);
//       }
//   }
// The annotations in this example tell the race detector that all memory
// accesses occurred when the refcount was positive do not race with
// memory accesses which occurred after the refcount became zero.







// Macros for C linkage: define extern "C" linkage only when using C++.
# 390 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// First includes.

// Pick up any OS-specific definitions.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
// Specific definitions for GNU/Linux  -*- C++ -*-

// Copyright (C) 2000, 2001, 2002, 2003, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/os_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */




// System-specific #define, typedefs, corrections, etc, go here.  This
// file will come before all others.

// This keeps isanum, et al from being propagated as macros.




# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-1993,1995-2007,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
# 122 "/usr/include/features.h" 3 4
/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */




/* Always use ISO C things.  */


/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
# 146 "/usr/include/features.h" 3 4
/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */






/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 177 "/usr/include/features.h" 3 4
/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */







/* This is to enable the ISO C99 extension.  Also recognize the old macro
   which was used prior to the standard acceptance.  This macro will
   eventually go away and the features enabled by default once the ISO C99
   standard is widely adopted.  */





/* This is to enable the ISO C90 Amendment 1:1995 extension.  */





/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
# 326 "/usr/include/features.h" 3 4
/* We do support the IEC 559 math functionality, real and complex.  */



/* wchar_t uses ISO 10646-1 (2nd ed., published 2000-09-15) / Unicode 3.1.  */


/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */



/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */






/* Decide whether a compiler supports the long long datatypes.  */







/* This is here only because every header file already includes this one.  */




# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2001, 2002, 2004, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */





/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# 72 "/usr/include/sys/cdefs.h" 3 4
/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */



/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */




/* This is not a typedef so `const __ptr_t' does the right thing.  */




/* C++ needs to know that types and declarations are C, not C++.  */
# 98 "/usr/include/sys/cdefs.h" 3 4
/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 111 "/usr/include/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# 123 "/usr/include/sys/cdefs.h" 3 4
/* Support for bounded pointers.  */







/* Fortify support.  */
# 150 "/usr/include/sys/cdefs.h" 3 4
/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
# 168 "/usr/include/sys/cdefs.h" 3 4
/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
# 191 "/usr/include/sys/cdefs.h" 3 4
/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; \
	_Pragma("let " #name " = " #alias)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
# 235 "/usr/include/sys/cdefs.h" 3 4
/* gcc allows marking deprecated functions.  */






/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */






/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */







/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */






/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
# 288 "/usr/include/sys/cdefs.h" 3 4
/* Forces a function to be always inlined.  */






/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
# 324 "/usr/include/sys/cdefs.h" 3 4
/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */
# 334 "/usr/include/sys/cdefs.h" 3 4
/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
# 373 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 374 "/usr/include/sys/cdefs.h" 2 3 4
# 362 "/usr/include/features.h" 2 3 4


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */







/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */


# 1 "/usr/include/gnu/stubs.h" 1 3 4
/* This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */



# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 386 "/usr/include/features.h" 2 3 4
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/os_defines.h" 2 3
# 394 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3

// Pick up any CPU-specific definitions.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
// Specific definitions for generic platforms  -*- C++ -*-

// Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cpu_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */
# 397 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3

// If platform uses neither visibility nor psuedo-visibility,
// specify empty default for namespace annotation macros.




// Certain function definitions that are meant to be overridable from
// user code are decorated with this macro.  For some targets, this
// macro causes these definitions to be weak.





// The remainder of the prewritten config is automatic; all the
// user hooks are listed above.

// Create a boolean flag to be used to determine if --fast-math is set.






// This marks string literals in header files to be extracted for eventual
// translation.  It is primarily used for messages in thrown exceptions; see
// src/functexcept.cc.  We use __N because the more traditional _N is used
// for something else under certain OSes (see BADNAMES).


// For example, <windows.h> is known to #define min and max as macros...



// End of prewritten config; the settings discovered at configure time follow.
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to 1 if you have the `acosf' function. */


/* Define to 1 if you have the `acosl' function. */


/* Define to 1 if you have the `asinf' function. */


/* Define to 1 if you have the `asinl' function. */


/* Define to 1 if the target assembler supports .symver directive. */


/* Define to 1 if you have the `atan2f' function. */


/* Define to 1 if you have the `atan2l' function. */


/* Define to 1 if you have the `atanf' function. */


/* Define to 1 if you have the `atanl' function. */


/* Define to 1 if the target assembler supports thread-local storage. */
/* #undef _GLIBCXX_HAVE_CC_TLS */

/* Define to 1 if you have the `ceilf' function. */


/* Define to 1 if you have the `ceill' function. */


/* Define to 1 if you have the <complex.h> header file. */


/* Define to 1 if you have the `cosf' function. */


/* Define to 1 if you have the `coshf' function. */


/* Define to 1 if you have the `coshl' function. */


/* Define to 1 if you have the `cosl' function. */


/* Define to 1 if you have the <dlfcn.h> header file. */


/* Define if EBADMSG exists. */


/* Define if ECANCELED exists. */


/* Define if EIDRM exists. */


/* Define to 1 if you have the <endian.h> header file. */


/* Define if ENODATA exists. */


/* Define if ENOLINK exists. */


/* Define if ENOSR exists. */


/* Define if ENOSTR exists. */


/* Define if ENOTRECOVERABLE exists. */


/* Define if ENOTSUP exists. */


/* Define if EOVERFLOW exists. */


/* Define if EOWNERDEAD exists. */


/* Define if EPROTO exists. */


/* Define if ETIME exists. */


/* Define if ETXTBSY exists. */


/* Define to 1 if you have the <execinfo.h> header file. */


/* Define to 1 if you have the `expf' function. */


/* Define to 1 if you have the `expl' function. */


/* Define to 1 if you have the `fabsf' function. */


/* Define to 1 if you have the `fabsl' function. */


/* Define to 1 if you have the <fenv.h> header file. */


/* Define to 1 if you have the `finite' function. */


/* Define to 1 if you have the `finitef' function. */


/* Define to 1 if you have the `finitel' function. */


/* Define to 1 if you have the <float.h> header file. */


/* Define to 1 if you have the `floorf' function. */


/* Define to 1 if you have the `floorl' function. */


/* Define to 1 if you have the `fmodf' function. */


/* Define to 1 if you have the `fmodl' function. */


/* Define to 1 if you have the `fpclass' function. */
/* #undef _GLIBCXX_HAVE_FPCLASS */

/* Define to 1 if you have the <fp.h> header file. */
/* #undef _GLIBCXX_HAVE_FP_H */

/* Define to 1 if you have the `frexpf' function. */


/* Define to 1 if you have the `frexpl' function. */


/* Define if _Unwind_GetIPInfo is available. */


/* Define if gthr-default.h exists (meaning that threading support is
   enabled). */


/* Define to 1 if you have the `hypot' function. */


/* Define to 1 if you have the `hypotf' function. */


/* Define to 1 if you have the `hypotl' function. */


/* Define if you have the iconv() function. */


/* Define to 1 if you have the <ieeefp.h> header file. */
/* #undef _GLIBCXX_HAVE_IEEEFP_H */

/* Define if int64_t is available in <stdint.h>. */


/* Define if int64_t is a long. */


/* Define if int64_t is a long long. */
/* #undef _GLIBCXX_HAVE_INT64_T_LONG_LONG */

/* Define to 1 if you have the <inttypes.h> header file. */


/* Define to 1 if you have the `isinf' function. */


/* Define to 1 if you have the `isinff' function. */


/* Define to 1 if you have the `isinfl' function. */


/* Define to 1 if you have the `isnan' function. */


/* Define to 1 if you have the `isnanf' function. */


/* Define to 1 if you have the `isnanl' function. */


/* Defined if iswblank exists. */


/* Define if LC_MESSAGES is available in <locale.h>. */


/* Define to 1 if you have the `ldexpf' function. */


/* Define to 1 if you have the `ldexpl' function. */


/* Define to 1 if you have the <libintl.h> header file. */


/* Only used in build directory testsuite_hooks.h. */


/* Only used in build directory testsuite_hooks.h. */


/* Only used in build directory testsuite_hooks.h. */


/* Only used in build directory testsuite_hooks.h. */


/* Only used in build directory testsuite_hooks.h. */


/* Define if futex syscall is available. */


/* Define to 1 if you have the <locale.h> header file. */


/* Define to 1 if you have the `log10f' function. */


/* Define to 1 if you have the `log10l' function. */


/* Define to 1 if you have the `logf' function. */


/* Define to 1 if you have the `logl' function. */


/* Define to 1 if you have the <machine/endian.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_ENDIAN_H */

/* Define to 1 if you have the <machine/param.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_PARAM_H */

/* Define if mbstate_t exists in wchar.h. */


/* Define to 1 if you have the <memory.h> header file. */


/* Define to 1 if you have the `modf' function. */


/* Define to 1 if you have the `modff' function. */


/* Define to 1 if you have the `modfl' function. */


/* Define to 1 if you have the <nan.h> header file. */
/* #undef _GLIBCXX_HAVE_NAN_H */

/* Define if poll is available in <poll.h>. */


/* Define to 1 if you have the `powf' function. */


/* Define to 1 if you have the `powl' function. */


/* Define to 1 if you have the `qfpclass' function. */
/* #undef _GLIBCXX_HAVE_QFPCLASS */

/* Define to 1 if you have the `setenv' function. */


/* Define to 1 if you have the `sincos' function. */


/* Define to 1 if you have the `sincosf' function. */


/* Define to 1 if you have the `sincosl' function. */


/* Define to 1 if you have the `sinf' function. */


/* Define to 1 if you have the `sinhf' function. */


/* Define to 1 if you have the `sinhl' function. */


/* Define to 1 if you have the `sinl' function. */


/* Define to 1 if you have the `sqrtf' function. */


/* Define to 1 if you have the `sqrtl' function. */


/* Define to 1 if you have the <stdbool.h> header file. */


/* Define to 1 if you have the <stdint.h> header file. */


/* Define to 1 if you have the <stdlib.h> header file. */


/* Define if strerror_l is available in <string.h>. */
/* #undef _GLIBCXX_HAVE_STRERROR_L */

/* Define if strerror_r is available in <string.h>. */


/* Define to 1 if you have the <strings.h> header file. */


/* Define to 1 if you have the <string.h> header file. */


/* Define to 1 if you have the `strtof' function. */


/* Define to 1 if you have the `strtold' function. */


/* Define if strxfrm_l is available in <string.h>. */


/* Define to 1 if the target runtime linker supports binding the same symbol
   to different versions. */


/* Define to 1 if you have the <sys/filio.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_FILIO_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */


/* Define to 1 if you have the <sys/ipc.h> header file. */


/* Define to 1 if you have the <sys/isa_defs.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_ISA_DEFS_H */

/* Define to 1 if you have the <sys/machine.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_MACHINE_H */

/* Define to 1 if you have the <sys/param.h> header file. */


/* Define to 1 if you have the <sys/resource.h> header file. */


/* Define to 1 if you have the <sys/sem.h> header file. */


/* Define to 1 if you have the <sys/stat.h> header file. */


/* Define to 1 if you have the <sys/time.h> header file. */


/* Define to 1 if you have the <sys/types.h> header file. */


/* Define to 1 if you have the <sys/uio.h> header file. */


/* Define if S_IFREG is available in <sys/stat.h>. */
/* #undef _GLIBCXX_HAVE_S_IFREG */

/* Define if S_IFREG is available in <sys/stat.h>. */


/* Define to 1 if you have the `tanf' function. */


/* Define to 1 if you have the `tanhf' function. */


/* Define to 1 if you have the `tanhl' function. */


/* Define to 1 if you have the `tanl' function. */


/* Define to 1 if you have the <tgmath.h> header file. */


/* Define to 1 if the target supports thread-local storage. */


/* Define to 1 if you have the <unistd.h> header file. */


/* Defined if vfwscanf exists. */


/* Defined if vswscanf exists. */


/* Defined if vwscanf exists. */


/* Define to 1 if you have the <wchar.h> header file. */


/* Defined if wcstof exists. */


/* Define to 1 if you have the <wctype.h> header file. */


/* Define if writev is available in <sys/uio.h>. */


/* Define to 1 if you have the `_acosf' function. */
/* #undef _GLIBCXX_HAVE__ACOSF */

/* Define to 1 if you have the `_acosl' function. */
/* #undef _GLIBCXX_HAVE__ACOSL */

/* Define to 1 if you have the `_asinf' function. */
/* #undef _GLIBCXX_HAVE__ASINF */

/* Define to 1 if you have the `_asinl' function. */
/* #undef _GLIBCXX_HAVE__ASINL */

/* Define to 1 if you have the `_atan2f' function. */
/* #undef _GLIBCXX_HAVE__ATAN2F */

/* Define to 1 if you have the `_atan2l' function. */
/* #undef _GLIBCXX_HAVE__ATAN2L */

/* Define to 1 if you have the `_atanf' function. */
/* #undef _GLIBCXX_HAVE__ATANF */

/* Define to 1 if you have the `_atanl' function. */
/* #undef _GLIBCXX_HAVE__ATANL */

/* Define to 1 if you have the `_ceilf' function. */
/* #undef _GLIBCXX_HAVE__CEILF */

/* Define to 1 if you have the `_ceill' function. */
/* #undef _GLIBCXX_HAVE__CEILL */

/* Define to 1 if you have the `_cosf' function. */
/* #undef _GLIBCXX_HAVE__COSF */

/* Define to 1 if you have the `_coshf' function. */
/* #undef _GLIBCXX_HAVE__COSHF */

/* Define to 1 if you have the `_coshl' function. */
/* #undef _GLIBCXX_HAVE__COSHL */

/* Define to 1 if you have the `_cosl' function. */
/* #undef _GLIBCXX_HAVE__COSL */

/* Define to 1 if you have the `_expf' function. */
/* #undef _GLIBCXX_HAVE__EXPF */

/* Define to 1 if you have the `_expl' function. */
/* #undef _GLIBCXX_HAVE__EXPL */

/* Define to 1 if you have the `_fabsf' function. */
/* #undef _GLIBCXX_HAVE__FABSF */

/* Define to 1 if you have the `_fabsl' function. */
/* #undef _GLIBCXX_HAVE__FABSL */

/* Define to 1 if you have the `_finite' function. */
/* #undef _GLIBCXX_HAVE__FINITE */

/* Define to 1 if you have the `_finitef' function. */
/* #undef _GLIBCXX_HAVE__FINITEF */

/* Define to 1 if you have the `_finitel' function. */
/* #undef _GLIBCXX_HAVE__FINITEL */

/* Define to 1 if you have the `_floorf' function. */
/* #undef _GLIBCXX_HAVE__FLOORF */

/* Define to 1 if you have the `_floorl' function. */
/* #undef _GLIBCXX_HAVE__FLOORL */

/* Define to 1 if you have the `_fmodf' function. */
/* #undef _GLIBCXX_HAVE__FMODF */

/* Define to 1 if you have the `_fmodl' function. */
/* #undef _GLIBCXX_HAVE__FMODL */

/* Define to 1 if you have the `_fpclass' function. */
/* #undef _GLIBCXX_HAVE__FPCLASS */

/* Define to 1 if you have the `_frexpf' function. */
/* #undef _GLIBCXX_HAVE__FREXPF */

/* Define to 1 if you have the `_frexpl' function. */
/* #undef _GLIBCXX_HAVE__FREXPL */

/* Define to 1 if you have the `_hypot' function. */
/* #undef _GLIBCXX_HAVE__HYPOT */

/* Define to 1 if you have the `_hypotf' function. */
/* #undef _GLIBCXX_HAVE__HYPOTF */

/* Define to 1 if you have the `_hypotl' function. */
/* #undef _GLIBCXX_HAVE__HYPOTL */

/* Define to 1 if you have the `_isinf' function. */
/* #undef _GLIBCXX_HAVE__ISINF */

/* Define to 1 if you have the `_isinff' function. */
/* #undef _GLIBCXX_HAVE__ISINFF */

/* Define to 1 if you have the `_isinfl' function. */
/* #undef _GLIBCXX_HAVE__ISINFL */

/* Define to 1 if you have the `_isnan' function. */
/* #undef _GLIBCXX_HAVE__ISNAN */

/* Define to 1 if you have the `_isnanf' function. */
/* #undef _GLIBCXX_HAVE__ISNANF */

/* Define to 1 if you have the `_isnanl' function. */
/* #undef _GLIBCXX_HAVE__ISNANL */

/* Define to 1 if you have the `_ldexpf' function. */
/* #undef _GLIBCXX_HAVE__LDEXPF */

/* Define to 1 if you have the `_ldexpl' function. */
/* #undef _GLIBCXX_HAVE__LDEXPL */

/* Define to 1 if you have the `_log10f' function. */
/* #undef _GLIBCXX_HAVE__LOG10F */

/* Define to 1 if you have the `_log10l' function. */
/* #undef _GLIBCXX_HAVE__LOG10L */

/* Define to 1 if you have the `_logf' function. */
/* #undef _GLIBCXX_HAVE__LOGF */

/* Define to 1 if you have the `_logl' function. */
/* #undef _GLIBCXX_HAVE__LOGL */

/* Define to 1 if you have the `_modf' function. */
/* #undef _GLIBCXX_HAVE__MODF */

/* Define to 1 if you have the `_modff' function. */
/* #undef _GLIBCXX_HAVE__MODFF */

/* Define to 1 if you have the `_modfl' function. */
/* #undef _GLIBCXX_HAVE__MODFL */

/* Define to 1 if you have the `_powf' function. */
/* #undef _GLIBCXX_HAVE__POWF */

/* Define to 1 if you have the `_powl' function. */
/* #undef _GLIBCXX_HAVE__POWL */

/* Define to 1 if you have the `_qfpclass' function. */
/* #undef _GLIBCXX_HAVE__QFPCLASS */

/* Define to 1 if you have the `_sincos' function. */
/* #undef _GLIBCXX_HAVE__SINCOS */

/* Define to 1 if you have the `_sincosf' function. */
/* #undef _GLIBCXX_HAVE__SINCOSF */

/* Define to 1 if you have the `_sincosl' function. */
/* #undef _GLIBCXX_HAVE__SINCOSL */

/* Define to 1 if you have the `_sinf' function. */
/* #undef _GLIBCXX_HAVE__SINF */

/* Define to 1 if you have the `_sinhf' function. */
/* #undef _GLIBCXX_HAVE__SINHF */

/* Define to 1 if you have the `_sinhl' function. */
/* #undef _GLIBCXX_HAVE__SINHL */

/* Define to 1 if you have the `_sinl' function. */
/* #undef _GLIBCXX_HAVE__SINL */

/* Define to 1 if you have the `_sqrtf' function. */
/* #undef _GLIBCXX_HAVE__SQRTF */

/* Define to 1 if you have the `_sqrtl' function. */
/* #undef _GLIBCXX_HAVE__SQRTL */

/* Define to 1 if you have the `_tanf' function. */
/* #undef _GLIBCXX_HAVE__TANF */

/* Define to 1 if you have the `_tanhf' function. */
/* #undef _GLIBCXX_HAVE__TANHF */

/* Define to 1 if you have the `_tanhl' function. */
/* #undef _GLIBCXX_HAVE__TANHL */

/* Define to 1 if you have the `_tanl' function. */
/* #undef _GLIBCXX_HAVE__TANL */

/* Define as const if the declaration of iconv() needs const. */


/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */


/* Name of package */
/* #undef _GLIBCXX_PACKAGE */

/* Define to the address where bug reports for this package should be sent. */


/* Define to the full name of this package. */


/* Define to the full name and version of this package. */


/* Define to the one symbol short name of this package. */


/* Define to the home page for this package. */


/* Define to the version of this package. */


/* The size of `char', as computed by sizeof. */
/* #undef SIZEOF_CHAR */

/* The size of `int', as computed by sizeof. */
/* #undef SIZEOF_INT */

/* The size of `long', as computed by sizeof. */
/* #undef SIZEOF_LONG */

/* The size of `short', as computed by sizeof. */
/* #undef SIZEOF_SHORT */

/* The size of `void *', as computed by sizeof. */
/* #undef SIZEOF_VOID_P */

/* Define to 1 if you have the ANSI C header files. */


/* Version number of package */
/* #undef _GLIBCXX_VERSION */

/* Define if builtin atomic operations for bool are supported on this host. */


/* Define if builtin atomic operations for short are supported on this host.
   */


/* Define if builtin atomic operations for int are supported on this host. */


/* Define if builtin atomic operations for long long are supported on this
   host. */


/* Define to use concept checking code from the boost libraries. */
/* #undef _GLIBCXX_CONCEPT_CHECKS */

/* Define if a fully dynamic basic_string is wanted. */
/* #undef _GLIBCXX_FULLY_DYNAMIC_STRING */

/* Define if gthreads library is available. */


/* Define to 1 if a full hosted library is built, or 0 if freestanding. */


/* Define if compatibility should be provided for -mlong-double-64. */

/* Define if ptrdiff_t is int. */
/* #undef _GLIBCXX_PTRDIFF_T_IS_INT */

/* Define if using setrlimit to set resource limits during "make check" */


/* Define if size_t is unsigned int. */
/* #undef _GLIBCXX_SIZE_T_IS_UINT */

/* Define if the compiler is configured for setjmp/longjmp exceptions. */
/* #undef _GLIBCXX_SJLJ_EXCEPTIONS */

/* Define to the value of the EOF integer constant. */


/* Define to the value of the SEEK_CUR integer constant. */


/* Define to the value of the SEEK_END integer constant. */


/* Define to use symbol versioning in the shared library. */


/* Define to use darwin versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_DARWIN */

/* Define to use GNU versioning in the shared library. */


/* Define to use GNU namespace versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_GNU_NAMESPACE */

/* Define to use Sun versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_SUN */

/* Define if C99 functions or macros from <wchar.h>, <math.h>, <complex.h>,
   <stdio.h>, and <stdlib.h> can be used or exposed. */


/* Define if C99 functions in <complex.h> should be used in <complex>. Using
   compiler builtins for these functions requires corresponding C99 library
   functions to be present. */


/* Define if C99 functions in <complex.h> should be used in <tr1/complex>.
   Using compiler builtins for these functions requires corresponding C99
   library functions to be present. */


/* Define if C99 functions in <ctype.h> should be imported in <tr1/cctype> in
   namespace std::tr1. */


/* Define if C99 functions in <fenv.h> should be imported in <tr1/cfenv> in
   namespace std::tr1. */


/* Define if C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */


/* Define if wchar_t C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */


/* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std. */


/* Define if C99 functions or macros in <math.h> should be imported in
   <tr1/cmath> in namespace std::tr1. */


/* Define if C99 types in <stdint.h> should be imported in <tr1/cstdint> in
   namespace std::tr1. */


/* Defined if clock_gettime has monotonic clock support. */
/* #undef _GLIBCXX_USE_CLOCK_MONOTONIC */

/* Defined if clock_gettime has realtime clock support. */
/* #undef _GLIBCXX_USE_CLOCK_REALTIME */

/* Define if ISO/IEC TR 24733 decimal floating point types are supported on
   this host. */


/* Defined if gettimeofday is available. */


/* Define if LFS support is available. */


/* Define if code specialized for long long should be used. */


/* Defined if nanosleep is available. */
/* #undef _GLIBCXX_USE_NANOSLEEP */

/* Define if NLS translations are to be used. */


/* Define if /dev/random and /dev/urandom are available for the random_device
   of TR1 (Chapter 5.1). */


/* Defined if sched_yield is available. */
/* #undef _GLIBCXX_USE_SCHED_YIELD */

/* Define if code specialized for wchar_t should be used. */
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 1 3
// Output streams -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ostream
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.6.2  Output streams
//
# 38 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
// 2005, 2006, 2007, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ios
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.4  Iostreams base classes
//
# 37 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 1 3
// Forwarding declarations -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/iosfwd
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.2  Forward declarations
//
# 38 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 1 3
// String support -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
// 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/stringfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21 Strings library
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;

  /**
   *  @defgroup strings Strings
   *
   *  @{
  */

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string; /// A string of @c char


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring; /// A string of @c wchar_t
# 82 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stringfwd.h" 3
 /** @}  */


} // namespace
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 1 3
// Position types -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/postypes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

//
// ISO C++ 14882: 27.4.1 - Types
// ISO C++ 14882: 27.4.3 - Template class fpos
//
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 21.4
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 32 "/usr/include/wchar.h" 3 4
/* Get FILE definition.  */






# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 44 "/usr/include/stdio.h" 3 4
/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;


/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;
# 64 "/usr/include/stdio.h" 3 4
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4
/* Get va_list definition.  */



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdarg.h" 1 3 4
/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */





typedef __builtin_va_list va_list;






/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */






/* Hack required to make standard headers work, at least on Ubuntu */

typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
/* wchar_t type related definitions.
   Copyright (C) 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 43 "/usr/include/wchar.h" 2 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
# 53 "/usr/include/wchar.h" 3 4
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */






typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;



typedef __typeof__(sizeof(int)) size_t;
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */



typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# 64 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
# 74 "/usr/include/wchar.h" 3 4
/* Tell the caller that we provide correct C++ prototypes.  */







/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value; /* Value so far.  */
} __mbstate_t;




/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */



/* Public type.  */
typedef __mbstate_t mbstate_t;






/* These constants might also be defined in <inttypes.h>.  */
# 122 "/usr/include/wchar.h" 3 4
/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */





extern "C" {


/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;

/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */




/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();

/* Compare S1 and S2.  */
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));



/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */


# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];

public :
inline __attribute__((always_inline)) __locale_struct() { _ssdm_SpecConstant(__names); }
# 40 "/usr/include/xlocale.h"
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();



/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();



/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));



/* Find the first occurrence of WC in WCS.  */






extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));

/* Find the last occurrence of WC in WCS.  */






extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));




/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));



/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
/* Find the first occurrence in WCS of any character in ACCEPT.  */







extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

/* Find the first occurrence of NEEDLE in HAYSTACK.  */







extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));


/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();

/* Return the number of wide characters in S.  */
extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));



/* Another name for `wcsstr' from XPG4.  */







extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));




/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));




/* Search N wide characters of S for C.  */







extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));


/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();



/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();




/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) throw ();

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) throw ();

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 404 "/usr/include/wchar.h" 3 4
/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();




/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();



/* The following functions are extensions found in X/Open CAE.  */

/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) throw ();

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();




/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();





/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();




/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();



/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */


/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();


/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();



/* Wide character I/O functions.  */


/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) throw ();


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
# 683 "/usr/include/wchar.h" 3 4
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
# 739 "/usr/include/wchar.h" 3 4
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);




/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);




/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();


/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */





/* Define some macros helping to catch buffer overflows.  */
# 889 "/usr/include/wchar.h" 3 4
}





/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 2 3





// Need to do a bit of trickery here with mbstate_t as char_traits
// assumes it is in wchar.h, regardless of wchar_t specializations.
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std
{
  using ::mbstate_t;
} // namespace std

// Get rid of those macros defined in <wchar.h> in lieu of real functions.
# 136 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



} // namespace







namespace __gnu_cxx
{





  using ::wcstold;
# 258 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3
 using ::wcstoll;
  using ::wcstoull;

} // namespace __gnu_cxx

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
} // namespace
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 2 3

// XXX If <stdint.h> is really needed, make sure to define the macros
// before including it, in order not to break <tr1/cstdint> (and <cstdint>
// in C++0x).  Reconsider all this as soon as possible...
# 69 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  // The types streamoff, streampos and wstreampos and the class
  // template fpos<> are described in clauses 21.1.2, 21.1.3, 27.1.2,
  // 27.2, 27.4.1, 27.4.3 and D.6. Despite all this verbiage, the
  // behaviour of these types is mostly implementation defined or
  // unspecified. The behaviour in this implementation is as noted
  // below.

  /**
   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.
   *
   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an
   *  implementation defined type.
   *  Note: In versions of GCC up to and including GCC 3.3, streamoff
   *  was typedef long.
  */

  typedef long streamoff;
# 98 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
 /// Integral type for I/O operation counts and buffer sizes.
  typedef ptrdiff_t streamsize; // Signed integral type

  /**
   *  @brief  Class representing stream positions.
   *
   *  The standard places no requirements upon the template parameter StateT.
   *  In this implementation StateT must be DefaultConstructible,
   *  CopyConstructible and Assignable.  The standard only requires that fpos
   *  should contain a member of type StateT. In this implementation it also
   *  contains an offset stored as a signed integer.
   *
   *  @param  StateT  Type passed to and returned from state().
   */
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:
      // The standard doesn't require that fpos objects can be default
      // constructed. This implementation provides a default
      // constructor that initializes the offset to 0 and default
      // constructs the state.
      fpos()
      : _M_off(0), _M_state() { }

      // The standard requires that fpos objects can be constructed
      // from streamoff objects using the constructor syntax, and
      // fails to give any meaningful semantics. In this
      // implementation implicit conversion is also allowed, and this
      // constructor stores the streamoff as the offset and default
      // constructs the state.
      /// Construct position from offset.
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }

      /// Convert to streamoff.
      operator streamoff() const { return _M_off; }

      /// Remember the value of @a st.
      void
      state(_StateT __st)
      { _M_state = __st; }

      /// Return the last set value of @a st.
      _StateT
      state() const
      { return _M_state; }

      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implementation it just adds its
      // argument to the stored offset and returns *this.
      /// Add offset to this position.
      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }

      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implementation it just subtracts
      // its argument from the stored offset and returns *this.
      /// Subtract offset from this position.
      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator-. In this
      // implementation it constructs a copy of *this, adds the
      // argument to that copy using operator+= and then returns the
      // copy.
      /// Add position and offset.
      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator+. In this
      // implementation it constructs a copy of *this, subtracts the
      // argument from that copy using operator-= and then returns the
      // copy.
      /// Subtract offset from position.
      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator+. In this
      // implementation it returns the difference between the offset
      // stored in *this and in the argument.
      /// Subtract position to return offset.
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };

  // The standard only requires that operator== must be an
  // equivalence relation. In this implementation two fpos<StateT>
  // objects belong to the same equivalence class if the contained
  // offsets compare equal.
  /// Test if equivalent to another position.
  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }

  // Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos
  // as implementation defined types, but clause 27.2 requires that
  // they must both be typedefs for fpos<mbstate_t>
  /// File position for char streams.
  typedef fpos<mbstate_t> streampos;
  /// File position for wchar_t streams.
  typedef fpos<mbstate_t> wstreampos;
# 241 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/postypes.h" 3
} // namespace
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @defgroup io I/O
   *
   *  Nearly all of the I/O classes are parameterized on the type of
   *  characters they read and write.  (The major exception is ios_base at
   *  the top of the hierarchy.)  This is a change from pre-Standard
   *  streams, which were not templates.
   *
   *  For ease of use and compatibility, all of the basic_* I/O-related
   *  classes are given typedef names for both of the builtin character
   *  widths (wide and narrow).  The typedefs are the same as the
   *  pre-Standard names, for example:
   *
   *  @code
   *     typedef basic_ifstream<char>  ifstream;
   *  @endcode
   *
   *  Because properly forward-declaring these classes can be difficult, you
   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;
   *  header, which contains only declarations of all the I/O classes as
   *  well as the typedefs.  Trying to forward-declare the typedefs
   *  themselves (e.g., <code>class ostream;</code>) is not valid ISO C++.
   *
   *  For more specific declarations, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch24.html
   *
   *  @{
  */
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;


  /// Base class for @c char streams.
  typedef basic_ios<char> ios;

  /// Base class for @c char buffers.
  typedef basic_streambuf<char> streambuf;

  /// Base class for @c char input streams.
  typedef basic_istream<char> istream;

  /// Base class for @c char output streams.
  typedef basic_ostream<char> ostream;

  /// Base class for @c char mixed input and output streams.
  typedef basic_iostream<char> iostream;

  /// Class for @c char memory buffers.
  typedef basic_stringbuf<char> stringbuf;

  /// Class for @c char input memory streams.
  typedef basic_istringstream<char> istringstream;

  /// Class for @c char output memory streams.
  typedef basic_ostringstream<char> ostringstream;

  /// Class for @c char mixed input and output memory streams.
  typedef basic_stringstream<char> stringstream;

  /// Class for @c char file buffers.
  typedef basic_filebuf<char> filebuf;

  /// Class for @c char input file streams.
  typedef basic_ifstream<char> ifstream;

  /// Class for @c char output file streams.
  typedef basic_ofstream<char> ofstream;

  /// Class for @c char mixed input and output file streams.
  typedef basic_fstream<char> fstream;


  /// Base class for @c wchar_t streams.
  typedef basic_ios<wchar_t> wios;

  /// Base class for @c wchar_t buffers.
  typedef basic_streambuf<wchar_t> wstreambuf;

  /// Base class for @c wchar_t input streams.
  typedef basic_istream<wchar_t> wistream;

  /// Base class for @c wchar_t output streams.
  typedef basic_ostream<wchar_t> wostream;

  /// Base class for @c wchar_t mixed input and output streams.
  typedef basic_iostream<wchar_t> wiostream;

  /// Class for @c wchar_t memory buffers.
  typedef basic_stringbuf<wchar_t> wstringbuf;

  /// Class for @c wchar_t input memory streams.
  typedef basic_istringstream<wchar_t> wistringstream;

  /// Class for @c wchar_t output memory streams.
  typedef basic_ostringstream<wchar_t> wostringstream;

  /// Class for @c wchar_t mixed input and output memory streams.
  typedef basic_stringstream<wchar_t> wstringstream;

  /// Class for @c wchar_t file buffers.
  typedef basic_filebuf<wchar_t> wfilebuf;

  /// Class for @c wchar_t input file streams.
  typedef basic_ifstream<wchar_t> wifstream;

  /// Class for @c wchar_t output file streams.
  typedef basic_ofstream<wchar_t> wofstream;

  /// Class for @c wchar_t mixed input and output file streams.
  typedef basic_fstream<wchar_t> wfstream;

  /** @}  */


} // namespace
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 1 3
// Exception Handling support header for -*- C++ -*-

// Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
// 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file exception
 *  This is a Standard C++ Library header.
 */
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
  /**
   * @defgroup exceptions Exceptions
   * @ingroup diagnostics
   *
   * Classes and functions for reporting errors via exception classes.
   * @{
   */

  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();

    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
    virtual const char* what() const throw();
  };

  /** If an %exception is thrown which is not listed in a function's
   *  %exception specification, one of these may be thrown.  */
  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_exception() throw();

    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };

  /// If you write a replacement %terminate handler, it must be of this type.
  typedef void (*terminate_handler) ();

  /// If you write a replacement %unexpected handler, it must be of this type.
  typedef void (*unexpected_handler) ();

  /// Takes a new handler function as an argument, returns the old function.
  terminate_handler set_terminate(terminate_handler) throw();

  /** The runtime will call this function if %exception handling must be
   *  abandoned for any reason.  It can also be called by the user.  */
  void terminate() throw() __attribute__ ((__noreturn__));

  /// Takes a new handler function as an argument, returns the old function.
  unexpected_handler set_unexpected(unexpected_handler) throw();

  /** The runtime will call this function if an %exception is thrown which
   *  violates the function's %exception specification.  */
  void unexpected() __attribute__ ((__noreturn__));

  /** [18.6.4]/1:  'Returns true after completing evaluation of a
   *  throw-expression until either completing initialization of the
   *  exception-declaration in the matching handler or entering @c unexpected()
   *  due to the throw; or after entering @c terminate() for any reason
   *  other than an explicit call to @c terminate().  [Note: This includes
   *  stack unwinding [15.2].  end note]'
   *
   *  2: 'When @c uncaught_exception() is true, throwing an
   *  %exception can result in a call of @c terminate()
   *  (15.5.1).'
   */
  bool uncaught_exception() throw() __attribute__ ((__pure__));

  // @} group exceptions
} // namespace std

namespace __gnu_cxx
{


  /**
   *  @brief A replacement for the standard terminate_handler which
   *  prints more information about the terminating exception (if any)
   *  on stderr.
   *
   *  @ingroup exceptions
   *
   *  Call
   *   @code
   *     std::set_terminate(__gnu_cxx::__verbose_terminate_handler)
   *   @endcode
   *  to use.  For more info, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt02ch06s02.html
   *
   *  In 3.4 and later, this is on by default.
   */
  void __verbose_terminate_handler();


} // namespace

} // extern "C++"

#pragma GCC visibility pop
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 1 3
// Character Traits for use by standard string and iostream -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/char_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21  Strings library
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 1 3
// Core algorithmic facilities -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
// 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 1 3
// Function-Based Exception Support -*- C++ -*-

// Copyright (C) 2001, 2004, 2005, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/functexcept.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 *
 *  This header provides support for -fno-exceptions.
 */

//
// ISO C++ 14882: 19.1  Exception classes
//







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/exception_defines.h" 1 3
// -fno-exceptions Support -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2006, 2007, 2008, 2009,
// 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/exception_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 */





// Iff -fno-exceptions, transform error handling code to work without it.
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // Helper for exception objects in <except>
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));

  // Helper for exception objects in <new>
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  // Helper for exception objects in <typeinfo>
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));

  // Helpers for exception objects in <stdexcept>
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));

  // Helpers for exception objects in <ios>
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));

  // Helpers for exception objects in <functional>
  void
  __throw_bad_function_call() __attribute__((__noreturn__));


} // namespace
# 62 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++

// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ext/type_traits}
 */

// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3



//
// This file provides some compile-time information about various types.
// These representations were designed, on purpose, to be constant-expressions
// and not types as found in <bits/type_traits.h>.  In particular, they
// can be used in control structures and the optimizer hopefully will do
// the obvious thing.
//
// Why integral expressions, and not functions nor types?
// Firstly, these compile-time entities are used as template-arguments
// so function return values won't work:  We need compile-time entities.
// We're left with types and constant  integral expressions.
// Secondly, from the point of view of ease of use, type-based compile-time
// information is -not- *that* convenient.  On has to write lots of
// overloaded functions and to hope that the compiler will select the right
// one. As a net effect, the overall structure isn't very clear at first
// glance.
// Thirdly, partial ordering and overload resolution (of function templates)
// is highly costly in terms of compiler-resource.  It is a Good Thing to
// keep these resource consumption as least as possible.
//
// See valarray_array.h for a case use.
//
// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
//
// Update 2005: types are also provided and <bits/type_traits.h> has been
// removed.
//

// Forward declaration hack, should really include this from somewhere.
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


} // namespace

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };

  // N.B. The conversions to bool are needed due to the issue
  // explained in c++/19404.
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };

  // Compare for equality of types.
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  // Holds if the template-argument is a void type.
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Integer types
  //
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  // Thirteen specializations (yes there are eleven standard integer
  // types; <em>long long</em> and <em>unsigned long long</em> are
  // supported as extensions)
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 198 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
 template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Floating point types
  //
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  // three specializations (float, double and 'long double')
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Pointer types
  //
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Normal iterator type
  //
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // An arithmetic type is an integer type or a floating point type
  //
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };

  //
  // A fundamental type is `void' or and arithmetic type
  //
  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };

  //
  // A scalar type is an arithmetic type or a pointer type
  // 
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };

  //
  // For use in std::copy and std::find overloads for streambuf iterators.
  //
  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Move iterator type
  //
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 422 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cpp_type_traits.h" 3
} // namespace
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 1 3
// -*- C++ -*-

// Copyright (C) 2005, 2006, 2007, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 3, or (at your option) any later
// version.

// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  // Define a nested type if some predicate holds.
  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };


  // Conditional expression for types. If true, first, if false, second.
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };


  // Given an integral builtin type, return the corresponding unsigned type.
  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };

  // Declare but don't define.
  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;


  // Given an integral builtin type, return the corresponding signed type.
  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };

  // Declare but don't define.
  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;


  // For use in string and vstring.
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  // For complex and cmath
  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  // No nested __type member for non-integer non-floating point types,
  // allows this type to be used for SFINAE to constrain overloads in
  // <cmath> and <complex> to only the intended types.
  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


} // namespace
# 64 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 1 3
// -*- C++ -*-

// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 3, or (at your option) any later
// version.

// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/numeric_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */
# 32 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  // Compile time constants for builtin types.
  // Sadly std::numeric_limits member functions cannot be used for this.
# 53 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
 template<typename _Value>
    struct __numeric_traits_integer
    {
      // Only integers for initialization of member constant.
      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);

      // NB: these two also available in std::numeric_limits as compile
      // time constants, but <limits> is big and we avoid including it.
      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 98 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/numeric_traits.h" 3
 template<typename _Value>
    struct __numeric_traits_floating
    {
      // Only floating point types. See N1822. 
      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);

      // See above comment...
      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


} // namespace
# 65 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 1 3
// Pair implementation -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 1 3
// Move, forward and identity for C++0x + swap -*- C++ -*-

// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/move.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 1 3
// Concept-checking control -*- C++ -*-

// Copyright (C) 2001, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/concept_check.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/concept_check.h" 3



// All places in libstdc++-v3 where these are used, or /might/ be used, or
// don't need to be used, or perhaps /should/ be used, are commented with
// "concept requirements" (and maybe some more text).  So grep like crazy
// if you're looking for additional places to use these.

// Concept-checking code is off by default unless users turn it on via
// configure options or editing c++config.h.
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // Used, in C++03 mode too, by allocators, etc.
  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


} // namespace
# 109 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @brief Swaps two values.
   *  @ingroup mutating_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {
      // concept requirements


      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 809. std::swap should be overloaded for array types.
  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


} // namespace
# 61 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 85 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
 /// Struct holding two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type; /// @c first_type is the first bound type
      typedef _T2 second_type; /// @c second_type is the second bound type

      _T1 first; /// @c first is a copy of the first object
      _T2 second; /// @c second is a copy of the second object

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 265.  std::pair::pair() effects overly restrictive
      /** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */
                         pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
                         pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

      /** There is also a templated copy ctor for the @c pair class itself.  */
      template<class _U1, class _U2>
                    pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
# 196 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
 };

  /// Two pairs of the same type are equal iff their members are equal.
  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }

  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }

  /// Uses @c operator== to find the result.
  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 245 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
 /**
   *  @brief A convenience wrapper for creating a pair from two objects.
   *  @param  x  The first object.
   *  @param  y  The second object.
   *  @return   A newly-constructed pair<> object of the appropriate type.
   *
   *  The standard requires that the objects be passed by reference-to-const,
   *  but LWG issue #181 says they should be passed by const value.  We follow
   *  the LWG by default.
   */
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 181.  make_pair() unintended behavior
# 270 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_pair.h" 3
 template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



} // namespace
# 66 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 1 3
// Types used in iterator implementation -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator_base_types.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility types,
 *  such as iterator_traits and struct iterator.
 */
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @defgroup iterators Iterators
   *  Abstractions for uniform iterating through various underlying types.
  */
  //@{ 

  /**
   *  @defgroup iterator_tags Iterator Tags
   *  These are empty types, used to distinguish different iterators.  The
   *  distinction is not made by what they contain, but simply by what they
   *  are.  Different underlying algorithms can then be used based on the
   *  different operations supported by different iterator types.
  */
  //@{ 
  ///  Marking input iterators.
  struct input_iterator_tag { };

  ///  Marking output iterators.
  struct output_iterator_tag { };

  /// Forward iterators support a superset of input iterator operations.
  struct forward_iterator_tag : public input_iterator_tag { };

  /// Bidirectional iterators support a superset of forward iterator
  /// operations.
  struct bidirectional_iterator_tag : public forward_iterator_tag { };

  /// Random-access iterators support a superset of bidirectional
  /// iterator operations.
  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  //@}

  /**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
  */
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      /// One of the @link iterator_tags tag types@endlink.
      typedef _Category iterator_category;
      /// The type "pointed to" by the iterator.
      typedef _Tp value_type;
      /// Distance between iterators is represented as this type.
      typedef _Distance difference_type;
      /// This type represents a pointer-to-value_type.
      typedef _Pointer pointer;
      /// This type represents a reference-to-value_type.
      typedef _Reference reference;
    };

  /**
   *  @brief  Traits class for iterators.
   *
   *  This class does nothing but define nested typedefs.  The general
   *  version simply @a forwards the nested typedefs from the Iterator
   *  argument.  Specialized versions for pointers and pointers-to-const
   *  provide tighter, more correct semantics.
  */
# 162 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
 template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  /// Partial specialization for pointer types.
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  /// Partial specialization for const pointer types.
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };

  /**
   *  This function is not a part of the C++ standard but is syntactic
   *  sugar for internal library use only.
  */
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

  //@}

  // If _Iterator has a base returns it otherwise _Iterator is returned
  // untouched
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


} // namespace
# 67 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 1 3
// Functions used by iterators -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator_base_funcs.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility
 *  functions, such as distance() and advance().
 */
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
      // concept requirements


      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
      // concept requirements


      return __last - __first;
    }

  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  first  An input iterator.
   *  @param  last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that first + n == last.  This requires that @p last
   *  must be reachable from @p first.  Note that @c n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
      // concept requirements -- taken care of in __distance
      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
      // concept requirements

      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {
      // concept requirements


      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
      // concept requirements


      __i += __n;
    }

  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  i  An input iterator.
   *  @param  n  The @a delta by which to change @p i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p n may be negative, in which case @p i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 200 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
} // namespace
# 68 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 1 3
// Iterators -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 */
# 68 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   * @addtogroup iterators
   * @{
   */

  // 24.4.1 Reverse iterators
  /**
   *  Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  <em>This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array.</em> [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
  */
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;

      /**
       *  The default constructor default-initializes member @p current.
       *  If it is a pointer, that means it is zero-initialized.
      */
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 235 No specification of default ctor for reverse_iterator
      reverse_iterator() : current() { }

      /**
       *  This %iterator will move in the opposite direction that @p x does.
      */
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }

      /**
       *  The copy constructor is normal.
      */
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }

      /**
       *  A reverse_iterator across other types can be copied in the normal
       *  fashion.
      */
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }

      /**
       *  @return  @c current, the %iterator used for underlying work.
      */
      iterator_type
      base() const
      { return current; }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      pointer
      operator->() const
      { return &(operator*()); }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }

      /**
       *  @return  TODO
       *
       *  @doctodo
      */
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };

  //@{
  /**
   *  @param  x  A %reverse_iterator.
   *  @param  y  A %reverse_iterator.
   *  @return  A simple bool.
   *
   *  Reverse iterators forward many operations to their underlying base()
   *  iterators.  Others are implemented in terms of one another.
   *
  */
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
  //@}

  // 24.4.2.2.1 back_insert_iterator
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;

      /// The only way to create this %iterator is with a container.
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }

      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      */

      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 444 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
 /// Simply returns *this.
      back_insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      back_insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      back_insert_iterator
      operator++(int)
      { return *this; }
    };

  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of back_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating back_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }

  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator prepends it to the container using
   *  push_front.
   *
   *  Tip:  Using the front_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;

      /// The only way to create this %iterator is with a container.
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }

      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the front, if you like).  Assigning a value to the %iterator will
       *  always prepend the value to the front of the container.
      */

      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 534 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
 /// Simply returns *this.
      front_insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      front_insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      front_insert_iterator
      operator++(int)
      { return *this; }
    };

  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of front_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating front_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }

  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container container_type;

      /**
       *  The only way to create this %iterator is with a container and an
       *  initial position (a normal %iterator into the container).
      */
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}

      /**
       *  @param  value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator maintains its own position in the
       *  container.  Assigning a value to the %iterator will insert the
       *  value into the container at the place before the %iterator.
       *
       *  The position is maintained such that subsequent assignments will
       *  insert values immediately after one another.  For example,
       *  @code
       *     // vector v contains A and Z
       *
       *     insert_iterator i (v, ++v.begin());
       *     i = 1;
       *     i = 2;
       *     i = 3;
       *
       *     // vector v contains A, 1, 2, 3, and Z
       *  @endcode
      */

      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 648 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_iterator.h" 3
 /// Simply returns *this.
      insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      insert_iterator&
      operator++(int)
      { return *this; }
    };

  /**
   *  @param  x  A container of arbitrary type.
   *  @return  An instance of insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

  // @} group iterators


} // namespace

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  // This iterator adapter is @a normal in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

                         __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


} // namespace
# 69 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-

// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */




/** Macros and namespaces used by the implementation outside of debug
 *  wrappers to verify certain properties. The __glibcxx_requires_xxx
 *  macros are merely wrappers around the __glibcxx_check_xxx wrappers
 *  when we are compiling with debug mode, but disappear when we are
 *  in release mode so that there is no checking performed in, e.g.,
 *  the standard library algorithms.
*/

// Debug mode namespaces.

/**
 * @namespace std::__debug
 * @brief GNU debug code, replaces standard behavior with debug behavior.
 */
namespace std
{
  namespace __debug { }
}

/** @namespace __gnu_debug
 *  @brief GNU debug classes for public use.
*/
namespace __gnu_debug
{
  using namespace std::__debug;
}
# 71 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
  // nutshell, we are partially implementing the resolution of DR 187,
  // when it's safe, i.e., the value_types are equal.
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };

  /**
   *  @brief Swaps the contents of two iterators.
   *  @ingroup mutating_algorithms
   *  @param  a  An iterator.
   *  @param  b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;

      // concept requirements
# 135 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }

  /**
   *  @brief Swap the elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  first1  A forward iterator.
   *  @param  last1   A forward iterator.
   *  @param  first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
      // concept requirements




                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements

      //return __b < __a ? __b : __a;
      if (__b < __a)
 return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements

      //return  __a < __b ? __b : __a;
      if (__a < __b)
 return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @param  comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The lesser of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__b, __a) ? __b : __a;
      if (__comp(__b, __a))
 return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  a  A thing of arbitrary type.
   *  @param  b  Another thing of arbitrary type.
   *  @param  comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__a, __b) ? __b : __a;
      if (__comp(__a, __b))
 return __b;
      return __a;
    }

  // If _Iterator is a __normal_iterator return its base (a plain pointer,
  // normally) otherwise return it untouched.  See copy, fill, ... 
  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }

  // Likewise, for move_iterator.
  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }

  // All of these auxiliary structs serve two purposes.  (1) Replace
  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
  // because the input and output ranges are permitted to overlap.)
  // (2) If we're using random access iterators, then write the loop as
  // a for loop with an explicit count.

  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 319 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 357 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }

  // Helpers for streambuf iterators (either istream or ostream).
  // NB: avoid including <iosfwd>, relatively large.
  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  /**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  first  An input iterator.
   *  @param  last   An input iterator.
   *  @param  result An output iterator.
   *  @return   result + (first - last)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {
      // concept requirements



                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 494 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 522 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 552 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  /**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  first  A bidirectional iterator.
   *  @param  last   A bidirectional iterator.
   *  @param  result A bidirectional iterator.
   *  @return   result - (first - last)
   *
   *  The function has the same effect as copy, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range [first,last).  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      // concept requirements





                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 669 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_algobase.h" 3
 template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }

  // Specialization: for char types we can use memset.
  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }

  /**
   *  @brief Fills the range [first,last) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  first  A forward iterator.
   *  @param  last   A forward iterator.
   *  @param  value  A reference-to-const of arbitrary type.
   *  @return   Nothing.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
      // concept requirements


                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }

  /**
   *  @brief Fills the range [first,first+n) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  first  An output iterator.
   *  @param  n      The count of copies to perform.
   *  @param  value  A reference-to-const of arbitrary type.
   *  @return   The iterator at first+n.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @ wmemset.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  */
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {
      // concept requirements


      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  /**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  first   An iterator.
   *  @param  last    Another iterator.
   *  @param  val     The search term.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @a val, or end() if every element is less than 
   *                  @a val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      // concept requirements


                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }

  /// This is a helper function for the sort routines and for random.tcc.
  //  Precondition: __n > 0.
  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }





  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      // concept requirements





                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }

  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {
      // concept requirements


                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }

  /**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  <em>Returns true if the sequence of elements defined by the range
   *  [first1,last1) is lexicographically less than the sequence of elements
   *  defined by the range [first2,last2).  Returns false otherwise.</em>
   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
   *  then this is an inline call to @c memcmp.
  */
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      // concept requirements
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }

  /**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param  last2   An input iterator.
   *  @param  comp  A @link comparison_functors comparison functor@endlink.
   *  @return   A boolean true or false.
   *
   *  The same as the four-parameter @c lexicographical_compare, but uses the
   *  comp parameter instead of @c <.
  */
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      // concept requirements


                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {
      // concept requirements





                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  first1  An input iterator.
   *  @param  last1   An input iterator.
   *  @param  first2  An input iterator.
   *  @param binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      // concept requirements


                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


} // namespace std

// NB: This file is included within many other C++ includes, as a way
// of getting the base algorithms. So, make sure that parallel bits
// come in too if requested. 
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 21.4
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 895 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwchar" 2 3
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @brief  Mapping from character type to associated types.
   *
   *  @note This is an implementation class for the generic version
   *  of char_traits.  It defines int_type, off_type, pos_type, and
   *  state_type.  By default these are unsigned long, streamoff,
   *  streampos, and mbstate_t.  Users who need a different set of
   *  types, but who don't need to change the definitions of any function
   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
   *  while leaving __gnu_cxx::char_traits alone. */
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };


  /**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamental types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   */
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      // NB: Inline std::copy so no recursive dependencies.
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      // NB: Inline std::fill_n so no recursive dependencies.
      std::fill_n(__s, __n, __a);
      return __s;
    }


} // namespace

namespace std __attribute__ ((__visibility__ ("default")))
{


  // 21.1
  /**
   *  @brief  Basis for explicit traits specializations.
   *
   *  @note  For any given actual character type, this definition is
   *  probably wrong.  Since this is just a thin wrapper around
   *  __gnu_cxx::char_traits, it is possible to achieve a more
   *  appropriate definition by specializing __gnu_cxx::char_traits.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.
  */
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };


  /// 21.1.3.1  char_traits specializations
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      // To keep both the byte 0xff and the eof symbol 0xffffffff
      // from ending up as 0xffffffff.
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };



  /// 21.1.3.2  char_traits specializations
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



} // namespace
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/localefwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
// Wrapper for underlying C-language localization -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++locale.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.8  Standard locale categories.
//

// Written by Benjamin Kosnik <bkoz@redhat.com>
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file clocale
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c locale.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 18.2.2  Implementation properties: C library
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
/* Copyright (C) 1991,1992,1995-2002,2007,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */
# 30 "/usr/include/locale.h" 3 4
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
/* Definition of locale category symbol values.
   Copyright (C) 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {

/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
# 53 "/usr/include/locale.h" 3 4
/* Structure giving information about numeric and monetary notation.  */
struct lconv
{
  /* Numeric (non-monetary) information.  */

  char *decimal_point; /* Decimal point character.  */
  char *thousands_sep; /* Thousands separator.  */
  /* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  */
  char *grouping;

  /* Monetary information.  */

  /* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol; /* Local currency symbol.  */
  char *mon_decimal_point; /* Decimal point character.  */
  char *mon_thousands_sep; /* Thousands separator.  */
  char *mon_grouping; /* Like `grouping' element (above).  */
  char *positive_sign; /* Sign for positive values.  */
  char *negative_sign; /* Sign for negative values.  */
  char int_frac_digits; /* Int'l fractional digits.  */
  char frac_digits; /* Local fractional digits.  */
  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
  char p_cs_precedes;
  /* 1 iff a space separates currency_symbol from a positive value.  */
  char p_sep_by_space;
  /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
  char n_cs_precedes;
  /* 1 iff a space separates currency_symbol from a negative value.  */
  char n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and currency_symbol.
     1 The sign string precedes the quantity and currency_symbol.
     2 The sign string follows the quantity and currency_symbol.
     3 The sign string immediately precedes the currency_symbol.
     4 The sign string immediately follows the currency_symbol.  */
  char p_sign_posn;
  char n_sign_posn;

  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
  char int_p_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a positive value.  */
  char int_p_sep_by_space;
  /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
  char int_n_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a negative value.  */
  char int_n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and int_curr_symbol.
     1 The sign string precedes the quantity and int_curr_symbol.
     2 The sign string follows the quantity and int_curr_symbol.
     3 The sign string immediately precedes the int_curr_symbol.
     4 The sign string immediately follows the int_curr_symbol.  */
  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};


/* Set and/or return the current locale.  */
extern char *setlocale (int __category, __const char *__locale) throw ();

/* Return the numeric/monetary information for the current locale.  */
extern struct lconv *localeconv (void) throw ();





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Get locale datatype definition.  */


/* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();

/* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
# 185 "/usr/include/locale.h" 3 4
/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
extern __locale_t duplocale (__locale_t __dataset) throw ();

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */
extern void freelocale (__locale_t __dataset) throw ();

/* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */
extern __locale_t uselocale (__locale_t __dataset) throw ();

/* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */




}
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/clocale" 2 3




// Get rid of those macros defined in <locale.h> in lieu of real functions.



namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
} // namespace std
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


} // namespace


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;

  // Convert numeric value of type double and long double to string and
  // return length of string.  If vsnprintf is available use it, otherwise
  // fall back to the unsafe vsprintf which, in general, can be dangerous
  // and should be avoided.
  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
 __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


} // namespace
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <ccytpe>
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
/* Copyright (C) 1991,92,93,95,96,97,98,99,2001,2002,2004,2007,2008,2009
   	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */







# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */







# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 29 "/usr/include/bits/types.h" 2 3 4

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;





/* quad_t is also 64 bits.  */

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 70 "/usr/include/bits/types.h" 3 4
/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */
# 126 "/usr/include/bits/types.h" 3 4
/* No need to mark the typedef with __extension__.   */






# 1 "/usr/include/bits/typesizes.h" 1 3 4
/* bits/typesizes.h -- underlying types for *_t.  Generic version.
   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 27 "/usr/include/bits/typesizes.h" 3 4
/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */
# 62 "/usr/include/bits/typesizes.h" 3 4
/* Number of descriptors that can fit in an `fd_set'.  */
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t; /* Type of device numbers.  */
typedef unsigned int __uid_t; /* Type of user identifications.  */
typedef unsigned int __gid_t; /* Type of group identifications.  */
typedef unsigned long int __ino_t; /* Type of file serial numbers.  */
typedef unsigned long int __ino64_t; /* Type of file serial numbers (LFS).*/
typedef unsigned int __mode_t; /* Type of file attribute bitmasks.  */
typedef unsigned long int __nlink_t; /* Type of file link counts.  */
typedef long int __off_t; /* Type of file sizes and offsets.  */
typedef long int __off64_t; /* Type of file sizes and offsets (LFS).  */
typedef int __pid_t; /* Type of process identifications.  */
typedef struct { int __val[2]; } __fsid_t; /* Type of file system IDs.  */
typedef long int __clock_t; /* Type of CPU usage counts.  */
typedef unsigned long int __rlim_t; /* Type for resource measurement.  */
typedef unsigned long int __rlim64_t; /* Type for resource measurement (LFS).  */
typedef unsigned int __id_t; /* General type for IDs.  */
typedef long int __time_t; /* Seconds since the Epoch.  */
typedef unsigned int __useconds_t; /* Count of microseconds.  */
typedef long int __suseconds_t; /* Signed count of microseconds.  */

typedef int __daddr_t; /* The type of a disk address.  */
typedef long int __swblk_t; /* Type of a swap block maybe?  */
typedef int __key_t; /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
typedef int __clockid_t;

/* Timer ID returned by `timer_create'.  */
typedef void * __timer_t;

/* Type to represent block size.  */
typedef long int __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

/* Type to count file system blocks.  */
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

/* Type to count file system nodes.  */
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t; /* Type of a byte count, or error.  */

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t; /* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
typedef long int __intptr_t;

/* Duplicate info from sys/socket.h.  */
typedef unsigned int __socklen_t;
# 29 "/usr/include/ctype.h" 2 3 4

extern "C" {


/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */



# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992, 1996, 1997, 2000, 2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */





/* This file defines `__BYTE_ORDER' for the particular machine.  */


# 1 "/usr/include/bits/endian.h" 1 3 4
/* x86_64 is little-endian.  */
# 38 "/usr/include/endian.h" 2 3 4

/* Some machines may need to use a different endianness for floating point
   values.  */
# 60 "/usr/include/endian.h" 3 4
/* Conversion interfaces.  */


# 1 "/usr/include/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2007, 2008, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 29 "/usr/include/bits/byteswap.h" 2 3 4

/* Swap bytes in 16 bit value.  */
# 55 "/usr/include/bits/byteswap.h" 3 4
/* Swap bytes in 32 bit value.  */
# 67 "/usr/include/bits/byteswap.h" 3 4
/* To swap the bytes in a word the i486 processors and up provide the
   `bswap' opcode.  On i386 we have to use three instructions.  */
# 100 "/usr/include/bits/byteswap.h" 3 4
/* Swap bytes in 64 bit value.  */
# 62 "/usr/include/endian.h" 2 3 4
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)), /* UPPERCASE.  */
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)), /* lowercase.  */
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)), /* Alphabetic.  */
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)), /* Numeric.  */
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)), /* Hexadecimal numeric.  */
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)), /* Whitespace.  */
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)), /* Printing.  */
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)), /* Graphical.  */
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)), /* Blank (usually SPC and TAB).  */
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)), /* Control character.  */
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)), /* Punctuation.  */
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8)) /* Alphanumeric.  */
};


/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 98 "/usr/include/ctype.h" 3 4
/* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();


/* Return the lowercase version of C.  */
extern int tolower (int __c) throw ();

/* Return the uppercase version of C.  */
extern int toupper (int __c) throw ();




/* ISO C99 introduced one new function.  */



extern int isblank (int) throw ();





/* Test C for a set of character classes according to MASK.  */
extern int isctype (int __c, int __mask) throw ();




/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) throw ();

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) throw ();

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */
extern int _toupper (int) throw ();
extern int _tolower (int) throw ();


/* This code is needed for the optimized mapping functions.  */
# 220 "/usr/include/ctype.h" 3 4
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */


/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */






/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();


/* Return the lowercase version of C in locale L.  */
extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();

/* Return the uppercase version of C.  */
extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 2 3




// Get rid of those macros defined in <ctype.h> in lieu of real functions.
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
} // namespace std
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  /** 
   *  @defgroup locales Locales
   *
   *  Classes and functions for internationalization and localization.
   */

  // 22.1.1 Locale
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);

  // 22.1.3 Convenience interfaces
  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);

  // 22.2.1 and 22.2.1.3 ctype
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;
  // NB: Specialized for char and wchar_t in locale_facets.h.

  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;

  // 22.2.2 and 22.2.3 numeric

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;

  // 22.2.4 collation
  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;

  // 22.2.5 date and time
  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;

  // 22.2.6 money
  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;

  // 22.2.7 message retrieval
  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


} // namespace
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ios_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */

//
// ISO C++ 14882: 27.4  Iostreams base classes
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 1 3
// Support for atomic operations -*- C++ -*-

// Copyright (C) 2004, 2005, 2006, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/atomicity.h
 *  This file is a GNU extension to the Standard C++ Library.
 */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
/* Threads compatibility routines for libgcc2.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997, 1998, 2004, 2008, 2009 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */





#pragma GCC visibility push(default)


/* If this file is compiled with threads support, it must
       #define __GTHREADS 1
   to indicate that threads support is present.  Also it has define
   function
     int __gthread_active_p ()
   that returns 1 if thread system is active, 0 if not.

   The threads interface must define the following types:
     __gthread_key_t
     __gthread_once_t
     __gthread_mutex_t
     __gthread_recursive_mutex_t

   The threads interface must define the following macros:

     __GTHREAD_ONCE_INIT
     		to initialize __gthread_once_t
     __GTHREAD_MUTEX_INIT
     		to initialize __gthread_mutex_t to get a fast
		non-recursive mutex.
     __GTHREAD_MUTEX_INIT_FUNCTION
     		some systems can't initialize a mutex without a
		function call.  On such systems, define this to a
		function which looks like this:
		  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)
		Don't define __GTHREAD_MUTEX_INIT in this case
     __GTHREAD_RECURSIVE_MUTEX_INIT
     __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION
     		as above, but for a recursive mutex.

   The threads interface must define the following static functions:

     int __gthread_once (__gthread_once_t *once, void (*func) ())

     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))
     int __gthread_key_delete (__gthread_key_t key)

     void *__gthread_getspecific (__gthread_key_t key)
     int __gthread_setspecific (__gthread_key_t key, const void *ptr)

     int __gthread_mutex_destroy (__gthread_mutex_t *mutex);

     int __gthread_mutex_lock (__gthread_mutex_t *mutex);
     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);
     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);

     int __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);

   The following are supported in POSIX threads only. They are required to
   fix a deadlock in static initialization inside libsupc++. The header file
   gthr-posix.h defines a symbol __GTHREAD_HAS_COND to signify that these extra
   features are supported.

   Types:
     __gthread_cond_t

   Macros:
     __GTHREAD_COND_INIT
     __GTHREAD_COND_INIT_FUNCTION

   Interface:
     int __gthread_cond_broadcast (__gthread_cond_t *cond);
     int __gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex);
     int __gthread_cond_wait_recursive (__gthread_cond_t *cond,
					__gthread_recursive_mutex_t *mutex);

   All functions returning int should return zero on success or the error
   number.  If the operation is not supported, -1 is returned.

   If the following are also defined, you should
     #define __GTHREADS_CXX0X 1
   to enable the c++0x thread library.

   Types:
     __gthread_t
     __gthread_time_t

   Interface:
     int __gthread_create (__gthread_t *thread, void *(*func) (void*),
                           void *args);
     int __gthread_join (__gthread_t thread, void **value_ptr);
     int __gthread_detach (__gthread_t thread);
     int __gthread_equal (__gthread_t t1, __gthread_t t2);
     __gthread_t __gthread_self (void);
     int __gthread_yield (void);

     int __gthread_mutex_timedlock (__gthread_mutex_t *m,
                                    const __gthread_time_t *abs_timeout);
     int __gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *m,
                                          const __gthread_time_t *abs_time);

     int __gthread_cond_signal (__gthread_cond_t *cond);
     int __gthread_cond_timedwait (__gthread_cond_t *cond,
                                   __gthread_mutex_t *mutex,
                                   const __gthread_time_t *abs_timeout);
     int __gthread_cond_timedwait_recursive (__gthread_cond_t *cond,
                                             __gthread_recursive_mutex_t *mutex,
                                             const __gthread_time_t *abs_time)

   Currently supported threads packages are
     TPF threads with -D__tpf__
     POSIX/Unix98 threads with -D_PTHREADS
     POSIX/Unix95 threads with -D_PTHREADS95
     DCE threads with -D_DCE_THREADS
     Solaris/UI threads with -D_SOLARIS_THREADS

*/

/* Check first for thread specific defines.  */
# 158 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
/* The pe-coff weak support isn't fully compatible to ELF's weak.
   For static libraries it might would work, but as we need to deal
   with shared versions too, we disable it for mingw-targets.  */
# 170 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
/* Threads compatibility routines for libgcc2 and libobjc.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */




/* POSIX threads specific definitions.
   Easy, since the interface is just one-to-one mapping.  */




/* Some implementations of <pthread.h> require this to be defined.  */






# 1 "/usr/include/pthread.h" 1 3 4
/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */








# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996,1997,1999,2001-2004,2007,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Get type definitions.  */





# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 31 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2003,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 75 "/usr/include/time.h" 3 4
/* Returned by `time'.  */
typedef __time_t time_t;
# 118 "/usr/include/time.h" 3 4
/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec; /* Seconds.  */
    long int tv_nsec; /* Nanoseconds.  */
  };
# 35 "/usr/include/sched.h" 2 3 4


typedef __pid_t pid_t;




/* Get system specific constant and data structure definitions.  */


# 1 "/usr/include/bits/sched.h" 1 3 4
/* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008,2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 29 "/usr/include/bits/sched.h" 3 4
/* Scheduling algorithms.  */
# 41 "/usr/include/bits/sched.h" 3 4
/* Cloning flags.  */
# 73 "/usr/include/bits/sched.h" 3 4
/* The official definition.  */
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {


/* Clone current process.  */
extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();

/* Unshare the specified resources.  */
extern int unshare (int __flags) throw ();

/* Get index of currently used CPU.  */
extern int sched_getcpu (void) throw ();


}






/* Data structure to describe a process' schedulability.  */
struct __sched_param
  {
    int __sched_priority;
  };






/* Size definition for CPU sets.  */



/* Type for array elements in 'cpu_set_t'.  */
typedef unsigned long int __cpu_mask;

/* Basic access functions.  */



/* Data structure to describe CPU mask.  */
typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;

/* Access functions for CPU masks.  */
# 199 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () /* Ignore */;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 44 "/usr/include/sched.h" 2 3 4
/* Define the real names for the elements of `struct sched_param'.  */



extern "C" {

/* Set scheduling parameters for a process.  */
extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();

/* Retrieve scheduling parameters for a particular process.  */
extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();

/* Set scheduling algorithm and/or parameters for a process.  */
extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();

/* Retrieve scheduling algorithm for a particular purpose.  */
extern int sched_getscheduler (__pid_t __pid) throw ();

/* Yield the processor.  */
extern int sched_yield (void) throw ();

/* Get maximum priority value for a scheduler.  */
extern int sched_get_priority_max (int __algorithm) throw ();

/* Get minimum priority value for a scheduler.  */
extern int sched_get_priority_min (int __algorithm) throw ();

/* Get the SCHED_RR interval for the named process.  */
extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();



/* Access macros for `cpu_set'.  */
# 117 "/usr/include/sched.h" 3 4
/* Set the CPU affinity for a task */
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();

/* Get the CPU affinity for a task */
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2003,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 30 "/usr/include/time.h" 3 4
extern "C" {




/* Get size_t and NULL from <stddef.h>.  */




# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 39 "/usr/include/time.h" 2 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */


# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */





/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
# 45 "/usr/include/bits/time.h" 3 4
/* Identifier for system-wide realtime clock.  */

/* Monotonic system-wide clock.  */

/* High-resolution timer from the CPU.  */

/* Thread-specific CPU-time clock.  */

/* Monotonic system-wide clock, not adjusted for frequency scaling.  */

/* Identifier for system-wide realtime clock, updated only on ticks.  */

/* Monotonic system-wide clock, updated only on ticks.  */


/* Flag to indicate time is absolute.  */
# 43 "/usr/include/time.h" 2 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# 59 "/usr/include/time.h" 3 4
/* Returned by `clock'.  */
typedef __clock_t clock_t;
# 91 "/usr/include/time.h" 3 4
/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;
# 132 "/usr/include/time.h" 3 4
/* Used by other time functions.  */
struct tm
{
  int tm_sec; /* Seconds.	[0-60] (1 leap second) */
  int tm_min; /* Minutes.	[0-59] */
  int tm_hour; /* Hours.	[0-23] */
  int tm_mday; /* Day.		[1-31] */
  int tm_mon; /* Month.	[0-11] */
  int tm_year; /* Year	- 1900.  */
  int tm_wday; /* Day of week.	[0-6] */
  int tm_yday; /* Days in year.[0-365]	*/
  int tm_isdst; /* DST.		[-1/0/1]*/


  long int tm_gmtoff; /* Seconds east of UTC.  */
  __const char *tm_zone; /* Timezone abbreviation.  */




};







/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;
# 181 "/usr/include/time.h" 3 4
/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) throw ();

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) throw ();

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) throw ();


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();



/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();



/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */


extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();




/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (__const time_t *__timer) throw ();

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (__const time_t *__timer) throw ();



/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();



/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (__const struct tm *__tp) throw ();

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (__const time_t *__timer) throw ();



/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();



/* Defined in localtime.c.  */
extern char *__tzname[2]; /* Current timezone names.  */
extern int __daylight; /* If daylight-saving time is ever in use.  */
extern long int __timezone; /* Seconds west of UTC.  */



/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;



/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (__const time_t *__when) throw ();



/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */





/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) throw ();

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) throw ();

/* Return the number of days in YEAR.  */
extern int dysize (int __year) throw () __attribute__ ((__const__));




/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();


/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();



/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) throw ();

/* Set timer TIMERID to VALUE, returning old value in OVLAUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();

/* Get current value of timer TIMERID and store it in VLAUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) throw ();




/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
        specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern struct tm *getdate (__const char *__string);



/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 48 "/usr/include/bits/pthreadtypes.h" 3 4
/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 74 "/usr/include/bits/pthreadtypes.h" 3 4
/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;

    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
 } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;



/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
 char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;




/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 29 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
/* Copyright (C) 2001,2002,2003,2005,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */
# 28 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 31 "/usr/include/pthread.h" 2 3 4


/* Detach state.  */
enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};


/* Mutex types.  */
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL


  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};



/* Robust mutex or not flags.  */
enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};




/* Mutex protocols.  */
enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};



/* Mutex initializers.  */
# 113 "/usr/include/pthread.h" 3 4
/* Read-write lock types.  */

enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};

/* Read-write lock initializers.  */
# 146 "/usr/include/pthread.h" 3 4
/* Scheduler inheritance.  */
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};


/* Scope handling.  */
enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};


/* Process shared or private flag.  */
enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};



/* Conditional variable handling.  */



/* Cleanup buffers */
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *); /* Function to call.  */
  void *__arg; /* Its argument.  */
  int __canceltype; /* Saved cancellation type. */
  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
};

/* Cancellation */
enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};



/* Single execution handling.  */




/* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants */




extern "C" {

/* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));

/* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*/
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));

/* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);


/* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();

/* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);


/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  */
extern int pthread_detach (pthread_t __th) throw ();


/* Obtain the identifier of the current thread.  */
extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));

/* Compare two thread identifiers.  */
extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();


/* Thread attribute handling.  */

/* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  */
extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));

/* Destroy thread attribute *ATTR.  */
extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Get detach state attribute.  */
extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set detach state attribute.  */
extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));


/* Get the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));


/* Return in *PARAM the scheduling parameters of *ATTR.  */
extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));

/* Return in *POLICY the scheduling policy of *ATTR.  */
extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling policy in *ATTR according to POLICY.  */
extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));

/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));


/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling contention scope in *ATTR according to SCOPE.  */
extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));

/* Return the previously set address for the stack.  */
extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));

/* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  */
extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));

/* Return the currently used minimal stack size.  */
extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  */
extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));


/* Return the previously set address for the stack.  */
extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));

/* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  */
extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));



/* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  */
extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));

/* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  */
extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


/* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  */
extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));



/* Functions for scheduling control.  */

/* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  */
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));

/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */
extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));

/* Set the scheduling priority for TARGET_THREAD.  */
extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();



/* Get thread name visible in the kernel and its interfaces.  */
extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));

/* Set thread name visible in the kernel and its interfaces.  */
extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));




/* Determine level of concurrency.  */
extern int pthread_getconcurrency (void) throw ();

/* Set new concurrency level to LEVEL.  */
extern int pthread_setconcurrency (int __level) throw ();



/* Yield the processor to another thread or process.
   This function is similar to the POSIX `sched_yield' function but
   might be differently implemented in the case of a m-on-n thread
   implementation.  */
extern int pthread_yield (void) throw ();


/* Limit specified thread TH to run only on the processors represented
   in CPUSET.  */
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));

/* Get bit set in CPUSET representing the processors TH can run on.  */
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));



/* Functions for handling initialization.  */

/* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  */
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));


/* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  */

/* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  */
extern int pthread_setcancelstate (int __state, int *__oldstate);

/* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  */
extern int pthread_setcanceltype (int __type, int *__oldtype);

/* Cancel THREAD immediately or at the next possibility.  */
extern int pthread_cancel (pthread_t __th);

/* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  */
extern void pthread_testcancel (void);


/* Cancellation handling with integration into exception handling.  */

typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));

/* No special attributes by default.  */





/* Structure to hold the cleanup handler information.  */
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 641 "/usr/include/pthread.h" 3 4
/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
# 664 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */







extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;


/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
# 699 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */







extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;


/* Internal interface to initiate cleanup.  */
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;


/* Function used in the macros.  */
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();


/* Mutex handling.  */

/* Initialize a mutex.  */
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy a mutex.  */
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

/* Try locking a mutex.  */
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

/* Lock a mutex.  */
extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


/* Wait until lock becomes available, or specified time passes. */
extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));


/* Unlock a mutex.  */
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


/* Get the priority ceiling of MUTEX.  */
extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  */
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));



/* Declare the state protected by MUTEX as consistent.  */
extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));




/* Functions for handling mutex attributes.  */

/* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  */
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy mutex attribute object ATTR.  */
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));


/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */
extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));

/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */
extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */
extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));


/* Get the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));


/* Set the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));





/* Functions for handling read-write locks.  */

/* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));

/* Destroy read-write lock RWLOCK.  */
extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Acquire read lock for RWLOCK.  */
extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Try to acquire read lock for RWLOCK.  */
extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));


/* Try to acquire read lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));


/* Acquire write lock for RWLOCK.  */
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Try to acquire write lock for RWLOCK.  */
extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


/* Try to acquire write lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));


/* Unlock RWLOCK.  */
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


/* Functions for handling read-write lock attributes.  */

/* Initialize attribute object ATTR with default values.  */
extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy attribute object ATTR.  */
extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set process-shared attribute of ATTR to PSHARED.  */
extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));

/* Return current setting of reader/writer preference.  */
extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set reader/write preference.  */
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));



/* Functions for handling conditional variables.  */

/* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable COND.  */
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));

/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));

/* Wake up all threads waiting for condition variables COND.  */
extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));

/* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));

/* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));

/* Functions for handling condition variable attributes.  */

/* Initialize condition variable attribute ATTR.  */
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable attribute ATTR.  */
extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));


/* Get the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));




/* Functions to handle spinlocks.  */

/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  */
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy the spinlock LOCK.  */
extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Wait until spinlock LOCK is retrieved.  */
extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Try to lock spinlock LOCK.  */
extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));

/* Release spinlock LOCK.  */
extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


/* Functions to handle barriers.  */

/* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  */
extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy a previously dynamically initialized barrier BARRIER.  */
extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));

/* Wait on barrier BARRIER.  */
extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


/* Initialize barrier attribute ATTR.  */
extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy previously dynamically initialized barrier attribute ATTR.  */
extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



/* Functions for handling thread-specific data.  */

/* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  */
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));

/* Destroy KEY.  */
extern int pthread_key_delete (pthread_key_t __key) throw ();

/* Return current value of the thread-specific data slot identified by KEY.  */
extern void *pthread_getspecific (pthread_key_t __key) throw ();

/* Store POINTER in the thread-specific data slot identified by KEY. */
extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;



/* Get ID of CPU-time clock for thread THREAD_ID.  */
extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));



/* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  */

extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1143 "/usr/include/pthread.h" 3 4
}
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */






extern "C" {

/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */


/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
# 50 "/usr/include/unistd.h" 3 4
/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */



/* The utilities on GNU systems also correspond to this version.  */
# 67 "/usr/include/unistd.h" 3 4
/* The utilities on GNU systems also correspond to this version.  */


/* If defined, the implementation supports the
   C Language Bindings Option.  */


/* If defined, the implementation supports the
   C Language Development Utilities Option.  */


/* If defined, the implementation supports the
   Software Development Utilities Option.  */


/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */


/* X/Open version number to which the library conforms.  It is selectable.  */
# 97 "/usr/include/unistd.h" 3 4
/* Commands and utilities from XPG4 are available.  */


/* We are compatible with the old published standards as well.  */




/* The X/Open Unix extensions are available.  */


/* Encryption is present.  */


/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */


/* The legacy interfaces are also available.  */



/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   */



# 1 "/usr/include/bits/posix_opt.h" 1 3 4
/* Define POSIX options for Linux.
   Copyright (C) 1996-2004, 2006, 2008, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */




/* Job control is supported.  */


/* Processes have a saved set-user-ID and a saved set-group-ID.  */


/* Priority scheduling is supported.  */


/* Synchronizing file data is supported.  */


/* The fsync function is present.  */


/* Mapping of files to memory is supported.  */


/* Locking of all memory is supported.  */


/* Locking of ranges of memory is supported.  */


/* Setting of memory protections is supported.  */


/* Some filesystems allow all users to change file ownership.  */


/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */


/* Filenames are not silently truncated.  */


/* X/Open realtime support is available.  */


/* X/Open thread realtime support is available.  */


/* XPG4.2 shared memory is supported.  */


/* Tell we have POSIX threads.  */


/* We have the reentrant functions described in POSIX.  */



/* We provide priority scheduling for threads.  */


/* We support user-defined stack sizes.  */


/* We support user-defined stacks.  */


/* We support priority inheritence.  */


/* We support priority protection, though only for non-robust
   mutexes.  */



/* We support priority inheritence for robust mutexes.  */


/* We do not support priority protection for robust mutexes.  */



/* We support POSIX.1b semaphores.  */


/* Real-time signals are supported.  */


/* We support asynchronous I/O.  */


/* Alternative name for Unix98.  */

/* Support for prioritization is also available.  */


/* The LFS support in asynchronous I/O is also available.  */


/* The rest of the LFS is also available.  */




/* POSIX shared memory objects are implemented.  */


/* CPU-time clocks support needs to be checked at runtime.  */


/* Clock support in threads must be also checked at runtime.  */


/* GNU libc provides regular expression handling.  */


/* Reader/Writer locks are available.  */


/* We have a POSIX shell.  */


/* We support the Timeouts option.  */


/* We support spinlocks.  */


/* The `spawn' function family is supported.  */


/* We have POSIX timers.  */


/* The barrier functions are available.  */


/* POSIX message queues are available.  */


/* Thread process-shared synchronization is supported.  */


/* The monotonic clock might be available.  */


/* The clock selection interfaces are available.  */


/* Advisory information interfaces are available.  */


/* IPv6 support is available.  */


/* Raw socket support is available.  */


/* We have at least one terminal.  */


/* Neither process nor thread sporadic server interfaces is available.  */



/* trace.h is not available.  */





/* Typed memory objects are not available.  */


/* Streams are not available.  */
# 204 "/usr/include/unistd.h" 2 3 4

/* Get the environment definitions from Unix98.  */



# 1 "/usr/include/bits/environments.h" 1 3 4
/* Copyright (C) 1999, 2001, 2004, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */







# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 24 "/usr/include/bits/environments.h" 2 3 4

/* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*/



/* Environments with 32-bit wide pointers are optionally provided.
   Therefore following macros aren't defined:
   # undef _POSIX_V7_ILP32_OFF32
   # undef _POSIX_V7_ILP32_OFFBIG
   # undef _POSIX_V6_ILP32_OFF32
   # undef _POSIX_V6_ILP32_OFFBIG
   # undef _XBS5_ILP32_OFF32
   # undef _XBS5_ILP32_OFFBIG
   and users need to check at runtime.  */

/* We also have no use (for now) for an environment with bigger pointers
   and offsets.  */




/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
# 208 "/usr/include/unistd.h" 2 3 4


/* Standard file descriptors.  */





/* All functions that are not declared anywhere else.  */




typedef __ssize_t ssize_t;







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 228 "/usr/include/unistd.h" 2 3 4


/* The Single Unix specification says that some more types are
   available here.  */

typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;




/* Values for the second argument to access.
   These may be OR'd together.  */





/* Test for access to NAME using the real UID and real GID.  */
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));


/* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  */
extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));

/* An alias for `euidaccess', used by some other systems.  */
extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));



/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) /* Ignore */;



/* Values for the WHENCE argument to lseek.  */







/* Old BSD names for the same constants; just for compatibility.  */






/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */

extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 342 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();


/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int close (int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) /* Ignore */;

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t write (int __fd, __const void *__buf, size_t __n) /* Ignore */;



/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) /* Ignore */;

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) /* Ignore */;
# 398 "/usr/include/unistd.h" 3 4
/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  */
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) /* Ignore */;
/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  */
extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) /* Ignore */;



/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
extern int pipe (int __pipedes[2]) throw () /* Ignore */;


/* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  */
extern int pipe2 (int __pipedes[2], int __flags) throw () /* Ignore */;


/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
extern unsigned int alarm (unsigned int __seconds) throw ();

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern unsigned int sleep (unsigned int __seconds);



/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int usleep (__useconds_t __useconds);



/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pause (void);


/* Change the owner and group of FILE.  */
extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* Change the owner and group of the file that FD is open on.  */
extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () /* Ignore */;


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) /* Ignore */;


/* Change the process's working directory to PATH.  */
extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* Change the process's working directory to the one FD is open on.  */
extern int fchdir (int __fd) throw () /* Ignore */;


/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
extern char *getcwd (char *__buf, size_t __size) throw () /* Ignore */;


/* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  */
extern char *get_current_dir_name (void) throw ();




/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) /* Ignore */;



/* Duplicate FD, returning a new file descriptor on the same file.  */
extern int dup (int __fd) throw () /* Ignore */;

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
extern int dup2 (int __fd, int __fd2) throw ();


/* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  */
extern int dup3 (int __fd, int __fd2, int __flags) throw ();


/* NULL-terminated array of "NAME=VALUE" environment variables.  */
extern char **__environ;

extern char **environ;



/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));


/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));



/* Execute PATH with arguments ARGV and environment from `environ'.  */
extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));


/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




/* Add INC to priority of the current process.  */
extern int nice (int __inc) throw () /* Ignore */;



/* Terminate program execution with the low-order 8 bits of STATUS.  */
extern void _exit (int __status) __attribute__ ((__noreturn__));


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */


# 1 "/usr/include/bits/confname.h" 1 3 4
/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993,1995-1998,2000,2001,2003,2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };

/* Values for the argument to `sysconf'.  */
enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,


    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,


    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,

    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };

/* Values for the NAME argument to `confstr'.  */
enum
  {
    _CS_PATH, /* The default search path.  */


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 607 "/usr/include/unistd.h" 2 3 4

/* Get file-specific configuration information about PATH.  */
extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));

/* Get file-specific configuration about descriptor FD.  */
extern long int fpathconf (int __fd, int __name) throw ();

/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) throw ();


/* Get the value of the string-valued system variable NAME.  */
extern size_t confstr (int __name, char *__buf, size_t __len) throw ();



/* Get the process ID of the calling process.  */
extern __pid_t getpid (void) throw ();

/* Get the process ID of the calling process's parent.  */
extern __pid_t getppid (void) throw ();

/* Get the process group ID of the calling process.
   This function is different on old BSD. */

extern __pid_t getpgrp (void) throw ();
# 642 "/usr/include/unistd.h" 3 4
/* Get the process group ID of process PID.  */
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();



/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();


/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   The default in GNU is to provide the System V function.  The BSD
   function is available under -D_BSD_SOURCE.  */



/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
extern int setpgrp (void) throw ();
# 683 "/usr/include/unistd.h" 3 4
/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
extern __pid_t setsid (void) throw ();


/* Return the session ID of the given process.  */
extern __pid_t getsid (__pid_t __pid) throw ();


/* Get the real user ID of the calling process.  */
extern __uid_t getuid (void) throw ();

/* Get the effective user ID of the calling process.  */
extern __uid_t geteuid (void) throw ();

/* Get the real group ID of the calling process.  */
extern __gid_t getgid (void) throw ();

/* Get the effective group ID of the calling process.  */
extern __gid_t getegid (void) throw ();

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
extern int getgroups (int __size, __gid_t __list[]) throw () /* Ignore */;


/* Return nonzero iff the calling process is in group GID.  */
extern int group_member (__gid_t __gid) throw ();


/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
extern int setuid (__uid_t __uid) throw ();


/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();



/* Set the effective user ID of the calling process to UID.  */
extern int seteuid (__uid_t __uid) throw ();


/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
extern int setgid (__gid_t __gid) throw ();


/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();



/* Set the effective group ID of the calling process to GID.  */
extern int setegid (__gid_t __gid) throw ();



/* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  */
extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();

/* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  */
extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();

/* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  */
extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();

/* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  */
extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();



/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t fork (void) throw ();



/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t vfork (void) throw ();



/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
extern char *ttyname (int __fd) throw ();

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) /* Ignore */;

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
extern int isatty (int __fd) throw ();



/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
extern int ttyslot (void) throw ();



/* Make a link to FROM named TO.  */
extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) /* Ignore */;


/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) /* Ignore */;



/* Make a symbolic link to FROM named TO.  */
extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) /* Ignore */;

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) /* Ignore */;



/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) /* Ignore */;

/* Like readlink but a relative PATH is interpreted relative to FD.  */
extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) /* Ignore */;


/* Remove the link NAME.  */
extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));


/* Remove the link NAME relative to FD.  */
extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));


/* Remove the directory PATH.  */
extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));


/* Return the foreground process group ID of FD.  */
extern __pid_t tcgetpgrp (int __fd) throw ();

/* Set the foreground process group ID of FD set PGRP_ID.  */
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();


/* Return the login name of the user.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern char *getlogin (void);

/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));



/* Set the login name returned by `getlogin'.  */
extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));




/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */



# 1 "/usr/include/getopt.h" 1 3 4
/* Declarations for getopt.
   Copyright (C) 1989-1994,1996-1999,2001,2003,2004,2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */







/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */
# 50 "/usr/include/getopt.h" 3 4
extern "C" {


/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;
# 124 "/usr/include/getopt.h" 3 4
/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 187 "/usr/include/getopt.h" 3 4
}


/* Make sure we later can get all the definitions and declarations.  */
# 891 "/usr/include/unistd.h" 2 3 4




/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));




/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
extern int sethostid (long int __id) throw () /* Ignore */;


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
extern int vhangup (void) throw ();

/* Revoke the access of all descriptors currently open on FILE.  */
extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
extern int acct (__const char *__name) throw ();


/* Successive calls return the shells listed in `/etc/shells'.  */
extern char *getusershell (void) throw ();
extern void endusershell (void) throw (); /* Discard cached info.  */
extern void setusershell (void) throw (); /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
extern int daemon (int __nochdir, int __noclose) throw () /* Ignore */;




/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));




/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fsync (int __fd);





/* Return identifier for the current host.  */
extern long int gethostid (void);

/* Make all changes done to all files actually appear on disk.  */
extern void sync (void) throw ();



/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
extern int getpagesize (void) throw () __attribute__ ((__const__));


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
extern int getdtablesize (void) throw ();







/* Truncate FILE to LENGTH bytes.  */

extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;
# 1019 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;



/* Truncate the file FD is open on to LENGTH bytes.  */

extern int ftruncate (int __fd, __off_t __length) throw () /* Ignore */;
# 1036 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () /* Ignore */;
# 1045 "/usr/include/unistd.h" 3 4
/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
extern int brk (void *__addr) throw () /* Ignore */;

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
extern void *sbrk (intptr_t __delta) throw ();




/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
extern long int syscall (long int __sysno, ...) throw ();





/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  */







extern int lockf (int __fd, int __cmd, __off_t __len) /* Ignore */;
# 1101 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) /* Ignore */;






/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  */
# 1120 "/usr/include/unistd.h" 3 4
/* Synchronize at least the data part of a file with the underlying
   media.  */
extern int fdatasync (int __fildes);



/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */

/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
   block in place.  */
extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));


/* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  */
extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));



/* The Single Unix specification demands this prototype to be here.
   It is also found in <stdio.h>.  */

/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) throw ();



/* Define some macros helping to catch buffer overflows.  */




}
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;

/* POSIX like conditional variables are supported.  Please look at comments
   in gthr.h for details. */
# 81 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
/* Typically, __gthrw_foo is a weak reference to symbol foo.  */


/* On Tru64, /usr/include/pthread.h uses #pragma extern_prefix "__" to
   map a subset of the POSIX pthread API to mangled versions of their
   names.  */
# 118 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 183 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
/* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if
   -pthreads is not specified.  The functions are dummies and most return an
   error value.  However pthread_once returns 0 without invoking the routine
   it is passed so we cannot pretend that the interface is active if -pthreads
   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so
   we need to play the usual game with weak symbols.  On Solaris 10 and up, a
   working interface is always exposed.  On FreeBSD 6 and later, libc also
   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up
   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,
   which means the alternate __gthread_active_p below cannot be used there.  */
# 239 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;






  return __gthread_active_ptr != 0;
}
# 657 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 800 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 171 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3

/* Fallback to single thread definitions.  */





#pragma GCC visibility pop
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
// Low-level type for atomic operations -*- C++ -*-

// Copyright (C) 2004, 2009 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file atomic_word.h
 *  This file is a GNU extension to the Standard C++ Library.
 */




typedef int _Atomic_word;

// Define these two macros using the appropriate memory barrier for the target.
// The commented out versions below are the defaults.
// See ia64/atomic_word.h for an alternative approach.

// This one prevents loads from being hoisted across the barrier;
// in other words, this is a Load-Load acquire barrier.
// This is necessary iff TARGET_RELAXED_ORDERING is defined in tm.h.  
// #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")

// This one prevents stores from being sunk across the barrier; in other
// words, a Store-Store release barrier.
// #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  // Functions for portable atomic access.
  // To abstract locking primitives across all thread policies, use:
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch

  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/atomicity.h" 3
 static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


} // namespace

// Even if the CPU doesn't need a memory barrier, we need to ensure
// that the compiler doesn't reorder memory accesses across the
// barriers.
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_classes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
// 2005, 2006, 2007, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/string
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 21  Strings library
//
# 38 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 3




# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 1 3
// Allocators -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
// 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */




// Define the base class to std::allocator.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
// Base to std::allocator -*- C++ -*-

// Copyright (C) 2004, 2005, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */




// Define new_allocator as the base class to std::allocator.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 1 3
// Allocator that wraps operator new -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/new_allocator.h
 *  This file is a GNU extension to the Standard C++ Library.
 */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 1 3
// The -*- C++ -*- dynamic memory management header.

// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007, 2009, 2010
// Free Software Foundation

// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file new
 *  This is a Standard C++ Library header.
 *
 *  The header @c new defines several functions to manage dynamic memory and
 *  handling memory allocation errors; see
 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
 */
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{
  /**
   *  @brief  Exception possibly thrown by @c new.
   *  @ingroup exceptions
   *
   *  @c bad_alloc (or classes derived from it) is used to report allocation
   *  errors from the throwing forms of @c new.  */
  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_alloc() throw();

    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;

  /** If you write your own error handler to be called by @c new, it must
   *  be of this type.  */
  typedef void (*new_handler)();

  /// Takes a replacement handler as the argument, returns the
  /// previous handler.
  new_handler set_new_handler(new_handler) throw();
} // namespace std

//@{
/** These are replaceable signatures:
 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 *  - normal array new and delete (same)
 *  - @c nothrow single new and delete (take a @c nothrow argument, return
 *    @c NULL on error)
 *  - @c nothrow array new and delete (same)
 *
 *  Placement new and delete signatures (take a memory address argument,
 *  does nothing) may not be replaced by a user's program.
*/
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }

// Default placement versions of operator delete.
inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }
//@}
} // extern "C++"

#pragma GCC visibility pop
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;

  /**
   *  @brief  An allocator that uses global new, as per [20.4].
   *  @ingroup allocators
   *
   *  This is precisely the allocator defined in the C++ Standard. 
   *    - all allocation calls operator new
   *    - all deallocation calls operator delete
   */
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_] allocator::construct
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 117 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ext/new_allocator.h" 3
 void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


} // namespace
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   * @defgroup allocators Allocators
   * @ingroup memory
   *
   * Classes encapsulating memory operations.
   */

  template<typename _Tp>
    class allocator;

  /// allocator<void> specialization.
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };

  /**
   * @brief  The @a standard allocator, as per [20.4].
   * @ingroup allocators
   *
   *  Further details:
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
   */
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }

      // Inherit everything else.
    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class allocator<char>;
  extern template class allocator<wchar_t>;


  // Undefine.


  // To implement Option 3 of DR 431.
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {
 // Precondition: swappable allocators.
 if (__one != __two)
   swap(__one, __two);
      }
    };

  // Optimize for stateless allocators.
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 237 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/allocator.h" 3
} // namespace std
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 1 3
// Helpers for ostream inserters -*- C++ -*-

// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ostream_insert.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 1 3
// cxxabi.h subset for cancellation -*- C++ -*-

// Copyright (C) 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cxxabi_forced.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cxxabi.h}
 */
# 34 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{
  /** 
   *  @brief Thrown as part of forced unwinding.
   *  @ingroup exceptions
   *
   *  A magic placeholder class that can be caught by reference to
   *  recognize forced unwinding.
   */
# 47 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h"
class __forced_unwind
  {
            ~__forced_unwind() throw();

    // Prevent catch by value.
# 53 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h"
 };
# 54 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/cxxabi_forced.h"

}


#pragma GCC visibility pop
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




} // namespace std
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 1 3
// Functor implementations -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */




namespace std __attribute__ ((__visibility__ ("default")))
{


  // 20.3.1 base classes
  /** @defgroup functors Function Objects
   * @ingroup utilities
   *
   *  Function objects, or @e functors, are objects with an @c operator()
   *  defined and accessible.  They can be passed as arguments to algorithm
   *  templates and used in place of a function pointer.  Not only is the
   *  resulting expressiveness of the library increased, but the generated
   *  code can be more efficient than what you might write by hand.  When we
   *  refer to @a functors, then, generally we include function pointers in
   *  the description as well.
   *
   *  Often, functors are only created as temporaries passed to algorithm
   *  calls, rather than being created as named variables.
   *
   *  Two examples taken from the standard itself follow.  To perform a
   *  by-element addition of two vectors @c a and @c b containing @c double,
   *  and put the result in @c a, use
   *  \code
   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
   *  \endcode
   *  To negate every element in @c a, use
   *  \code
   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
   *  \endcode
   *  The addition and negation functions will be inlined directly.
   *
   *  The standard functors are derived from structs named @c unary_function
   *  and @c binary_function.  These two classes contain nothing but typedefs,
   *  to aid in generic (template) programming.  If you write your own
   *  functors, you might consider doing the same.
   *
   *  @{
   */
  /**
   *  This is one of the @link functors functor base classes@endlink.
   */
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      /// @c argument_type is the type of the argument
      typedef _Arg argument_type;

      /// @c result_type is the return type
      typedef _Result result_type;
    };

  /**
   *  This is one of the @link functors functor base classes@endlink.
   */
  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      /// @c first_argument_type is the type of the first argument
      typedef _Arg1 first_argument_type;

      /// @c second_argument_type is the type of the second argument
      typedef _Arg2 second_argument_type;

      /// @c result_type is the return type
      typedef _Result result_type;
    };
  /** @}  */

  // 20.3.2 arithmetic
  /** @defgroup arithmetic_functors Arithmetic Classes
   * @ingroup functors
   *
   *  Because basic math often needs to be done during an algorithm,
   *  the library provides functors for those operations.  See the
   *  documentation for @link functors the base classes@endlink
   *  for examples of their use.
   *
   *  @{
   */
  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
  /** @}  */

  // 20.3.3 comparisons
  /** @defgroup comparison_functors Comparison Classes
   * @ingroup functors
   *
   *  The library provides six wrapper functors for all the basic comparisons
   *  in C++, like @c <.
   *
   *  @{
   */
  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
  /** @}  */

  // 20.3.4 logical operations
  /** @defgroup logical_functors Boolean Operations Classes
   * @ingroup functors
   *
   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
   *  and @c !.
   *
   *  @{
   */
  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
  /** @}  */

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 660. Missing Bitwise Operations.
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  // 20.3.5 negators
  /** @defgroup negators Negators
   * @ingroup functors
   *
   *  The functions @c not1 and @c not2 each take a predicate functor
   *  and return an instance of @c unary_negate or
   *  @c binary_negate, respectively.  These classes are functors whose
   *  @c operator() performs the stored predicate function and then returns
   *  the negation of the result.
   *
   *  For example, given a vector of integers and a trivial predicate,
   *  \code
   *  struct IntGreaterThanThree
   *    : public std::unary_function<int, bool>
   *  {
   *      bool operator() (int x) { return x > 3; }
   *  };
   *
   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
   *  \endcode
   *  The call to @c find_if will locate the first index (i) of @c v for which
   *  <code>!(v[i] > 3)</code> is true.
   *
   *  The not1/unary_negate combination works on predicates taking a single
   *  argument.  The not2/binary_negate combination works on predicates which
   *  take two arguments.
   *
   *  @{
   */
  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  /** @}  */

  // 20.3.7 adaptors pointers functions
  /** @defgroup pointer_adaptors Adaptors for pointers to functions
   * @ingroup functors
   *
   *  The advantage of function objects over pointers to functions is that
   *  the objects in the standard library declare nested typedefs describing
   *  their argument and result types with uniform names (e.g., @c result_type
   *  from the base classes @c unary_function and @c binary_function).
   *  Sometimes those typedefs are required, not just optional.
   *
   *  Adaptors are provided to turn pointers to unary (single-argument) and
   *  binary (double-argument) functions into function objects.  The
   *  long-winded functor @c pointer_to_unary_function is constructed with a
   *  function pointer @c f, and its @c operator() called with argument @c x
   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
   *  thing, but with a double-argument @c f and @c operator().
   *
   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
   *  an instance of the appropriate functor.
   *
   *  @{
   */
  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
  /** @}  */

  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
# 508 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 3
 };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };

  // 20.3.8 adaptors pointers members
  /** @defgroup memory_adaptors Adaptors for pointers to members
   * @ingroup functors
   *
   *  There are a total of 8 = 2^3 function objects in this family.
   *   (1) Member functions taking no arguments vs member functions taking
   *        one argument.
   *   (2) Call through pointer vs call through reference.
   *   (3) Const vs non-const member function.
   *
   *  All of this complexity is in the function objects themselves.  You can
   *   ignore it by using the helper function mem_fun and mem_fun_ref,
   *   which create whichever type of adaptor is appropriate.
   *
   *  @{
   */
  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };

  // Mem_fun adaptor helper functions.  There are only two:
  // mem_fun and mem_fun_ref.
  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  /** @}  */


} // namespace




# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/backward/binders.h" 1 3
// Functor implementations -*- C++ -*-

// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file backward/binders.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */




namespace std __attribute__ ((__visibility__ ("default")))
{


  // 20.3.6 binders
  /** @defgroup binders Binder Classes
   * @ingroup functors
   *
   *  Binders turn functions/functors with two arguments into functors
   *  with a single argument, storing an argument to be applied later.
   *  For example, a variable @c B of type @c binder1st is constructed
   *  from a functor @c f and an argument @c x. Later, B's @c
   *  operator() is called with a single argument @c y. The return
   *  value is the value of @c f(x,y). @c B can be @a called with
   *  various arguments (y1, y2, ...) and will in turn call @c
   *  f(x,y1), @c f(x,y2), ...
   *
   *  The function @c bind1st is provided to save some typing. It takes the
   *  function and an argument as parameters, and returns an instance of
   *  @c binder1st.
   *
   *  The type @c binder2nd and its creator function @c bind2nd do the same
   *  thing, but the stored argument is passed as the second parameter instead
   *  of the first, e.g., @c bind2nd(std::minus<float>,1.3) will create a
   *  functor whose @c operator() accepts a floating-point number, subtracts
   *  1.3 from it, and returns the result. (If @c bind1st had been used,
   *  the functor would perform <em>1.3 - x</em> instead.
   *
   *  Creator-wrapper functions like @c bind1st are intended to be used in
   *  calling algorithms. Their return values will be temporary objects.
   *  (The goal is to not require you to type names like
   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the
   *  return value from @c bind1st(std::plus<int>,5).
   *
   *  These become more useful when combined with the composition functions.
   *
   *  @{
   */
  /// One of the @link binders binder functors@endlink.
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
  /** @}  */


} // namespace
# 732 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/stl_function.h" 2 3
# 50 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 1 3
// <range_access.h> -*- C++ -*-

// Copyright (C) 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/range_access.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/range_access.h" 3
# 53 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21 Strings library
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 1 3
// std::initializer_list support -*- C++ -*-

// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file initializer_list
 *  This is a Standard C++ Library header.
 */
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/initializer_list" 3
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   *
   *  @doctodo
   *
   *
   *  Documentation?  What's that?
   *  Nathan Myers <ncm@cantrip.org>.
   *
   *  A string looks like this:
   *
   *  @code
   *                                        [_Rep]
   *                                        _M_length
   *   [basic_string<char_type>]            _M_capacity
   *   _M_dataplus                          _M_refcount
   *   _M_p ---------------->               unnamed array of char_type
   *  @endcode
   *
   *  Where the _M_p points to the first character in the string, and
   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
   *  pointer to the header.
   *
   *  This approach has the enormous advantage that a string object
   *  requires only one allocation.  All the ugliness is confined
   *  within a single %pair of inline functions, which each compile to
   *  a single @a add instruction: _Rep::_M_data(), and
   *  string::_M_rep(); and the allocation function which gets a
   *  block of raw bytes and with room enough and constructs a _Rep
   *  object at the front.
   *
   *  The reason you want _M_data pointing to the character %array and
   *  not the _Rep is so that the debugger can see the string
   *  contents. (Probably we should add a non-inline member to get
   *  the _Rep for the debugger to use, so users can check the actual
   *  string length.)
   *
   *  Note that the _Rep object is a POD so that you can have a
   *  static <em>empty string</em> _Rep object already @a constructed before
   *  static constructors have run.  The reference-count encoding is
   *  chosen so that a 0 indicates one reference, so you never try to
   *  destroy the empty-string _Rep object.
   *
   *  All but the last paragraph is considered pretty conventional
   *  for a C++ string implementation.
  */
  // 21.3  Template class basic_string
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;

      // Types:
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
      // _Rep: string representation
      //   Invariants:
      //   1. String really contains _M_length + 1 characters: due to 21.3.4
      //      must be kept null-terminated.
      //   2. _M_capacity >= _M_length
      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
      //   3. _M_refcount has three states:
      //      -1: leaked, one reference, no ref-copies allowed, non-const.
      //       0: one reference, non-const.
      //     n>0: n + 1 references, operations require a lock, const.
      //   4. All fields==0 is an empty string, given the extra storage
      //      beyond-the-end for a null terminator; thus, the shared
      //      empty string representation needs no constructor.

      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {
 // Types:
 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;

 // (Public) Data members:

 // The maximum number of individual char_type elements of an
 // individual string is determined by _S_max_size. This is the
 // value that will be returned by max_size().  (Whereas npos
 // is the maximum number of bytes the allocator can allocate.)
 // If one was to divvy up the theoretical largest size string,
 // with a terminating character and m _CharT elements, it'd
 // look like this:
 // npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
 // Solving for m:
 // m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
 // In addition, this implementation quarters this amount.
 static const size_type _S_max_size;
 static const _CharT _S_terminal;

 // The following storage is init'd to 0 by the linker, resulting
        // (carefully) in an empty string with one reference.
        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {
   // NB: Mild hack to avoid strict-aliasing warnings.  Note that
   // _S_empty_rep_storage is never modified and the punning should
   // be reasonably safe in this case.
   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable(); // One reference.
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);
       // grrr. (per 21.3.4)
       // You cannot leave those LWG people alone for a second.
     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }

 // Create & Destroy
 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       // Be race-detector-friendly.  For more info see bits/c++config.
                                                                  ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
                                                              ;
    _M_destroy(__a);
  }
     }
 } // XXX MT

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 } // XXX MT

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p; // The actual data.
      };

    public:
      // Data Members (public):
      // NB: This is an unsigned type, and thus represents the maximum
      // size that the allocator can hold.
      ///  Value returned by various member functions when they fail.
      static const size_type npos = static_cast<size_type>(-1);

    private:
      // Data Members (private):
      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }

      // For the internal use we have functions similar to `begin'/`end'
      // but they do not call _M_leak.
      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak() // for use in begin() & non-const op[]
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }

      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }

      // True if _Rep and source do not overlap.
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }

      // When __n = 1 way faster than the general multichar
      // traits_type::copy/move/assign.
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }

      // _S_copy_chars is a separate template to permit specialization
      // to optimize for the common case of pointers as iterators.
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1); // These types are off.
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:
      // Construct/copy/destroy:
      // NB: We overload ctors in some cases instead of using default
      // arguments, per 17.4.4.4 para. 2 item 2.

      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }




      /**
       *  @brief  Construct an empty string using allocator @a a.
       */
      explicit
      basic_string(const _Alloc& __a);

      // NB: per LWG issue 42, semantics different from IS:
      /**
       *  @brief  Construct string with copy of value of @a str.
       *  @param  str  Source string.
       */
      basic_string(const basic_string& __str);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  str  Source string.
       *  @param  pos  Index of first character to copy from.
       *  @param  n  Number of characters to copy (default remainder).
       */
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  str  Source string.
       *  @param  pos  Index of first character to copy from.
       *  @param  n  Number of characters to copy.
       *  @param  a  Allocator to use.
       */
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);

      /**
       *  @brief  Construct string initialized by a character %array.
       *  @param  s  Source character %array.
       *  @param  n  Number of characters to copy.
       *  @param  a  Allocator to use (default is default allocator).
       *
       *  NB: @a s must have at least @a n characters, &apos;\\0&apos;
       *  has no special meaning.
       */
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as copy of a C string.
       *  @param  s  Source C string.
       *  @param  a  Allocator to use (default is default allocator).
       */
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as multiple characters.
       *  @param  n  Number of characters.
       *  @param  c  Character to use.
       *  @param  a  Allocator to use (default is default allocator).
       */
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 519 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Construct string as copy of a range.
       *  @param  beg  Start of range.
       *  @param  end  End of range.
       *  @param  a  Allocator to use (default is default allocator).
       */
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }

      /**
       *  @brief  Assign the value of @a str to this string.
       *  @param  str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }

      /**
       *  @brief  Copy contents of @a s into this string.
       *  @param  s  Source null-terminated string.
       */
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }

      /**
       *  @brief  Set value to string of length 1.
       *  @param  c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       */
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 593 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 // Iterators:
      /**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.  Unshares the string.
       */
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      begin() const
      { return const_iterator(_M_data()); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.  Unshares the string.
       */
      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }

      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }

      /**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.  Unshares the string.
       */
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }

      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.  Unshares the string.
       */
      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 704 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 public:
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const
      { return _M_rep()->_M_length; }

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const
      { return _M_rep()->_M_length; }

      ///  Returns the size() of the largest possible %string.
      size_type
      max_size() const
      { return _Rep::_S_max_size; }

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  n  Number of characters the %string should contain.
       *  @param  c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a c.
       */
      void
      resize(size_type __n, _CharT __c);

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       */
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 762 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       */
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }

      /**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  res_arg  Number of characters required.
       *  @throw  std::length_error  If @a res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       */
      void
      reserve(size_type __res_arg = 0);

      /**
       *  Erases the string, making it empty.
       */
      void
      clear()
      { _M_mutate(0, this->size(), 0); }

      /**
       *  Returns true if the %string is empty.  Equivalent to 
       *  <code>*this == ""</code>.
       */
      bool
      empty() const
      { return this->size() == 0; }

      // Element access:
      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }

      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)  Unshares the string.
       */
      reference
      operator[](size_type __pos)
      {
        // allow pos == size() as v3 extension:
                                       ;
        // but be strict in pedantic mode:
                                         ;
 _M_leak();
 return _M_data()[__pos];
      }

      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 896 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.  Success results in
       *  unsharing the string.
       */
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }

      // Modifiers:
      /**
       *  @brief  Append a string to this string.
       *  @param str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }

      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }

      /**
       *  @brief  Append a character.
       *  @param c  The character to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 958 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Append a string to this string.
       *  @param str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const basic_string& __str);

      /**
       *  @brief  Append a substring.
       *  @param str  The string to append.
       *  @param pos  Index of the first character of str to append.
       *  @param n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function appends @a n characters from @a str starting at @a pos
       *  to this string.  If @a n is is larger than the number of available
       *  characters in @a str, the remainder of @a str is appended.
       */
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);

      /**
       *  @brief  Append a C substring.
       *  @param s  The C string to append.
       *  @param n  The number of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s, size_type __n);

      /**
       *  @brief  Append a C string.
       *  @param s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }

      /**
       *  @brief  Append multiple characters.
       *  @param n  The number of characters to append.
       *  @param c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends n copies of c to this string.
       */
      basic_string&
      append(size_type __n, _CharT __c);
# 1024 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Append a range of characters.
       *  @param first  Iterator referencing the first character to append.
       *  @param last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [first,last) to this string.
       */
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }

      /**
       *  @brief  Append a single character.
       *  @param c  Character to append.
       */
      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }

      /**
       *  @brief  Set value to contents of another string.
       *  @param  str  Source string to use.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(const basic_string& __str);
# 1076 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Set value to a substring of a string.
       *  @param str  The string to use.
       *  @param pos  Index of the first character of str.
       *  @param n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a str consisting
       *  of @a n characters at @a pos.  If @a n is is larger than the number
       *  of available characters in @a str, the remainder of @a str is used.
       */
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }

      /**
       *  @brief  Set value to a C substring.
       *  @param s  The C string to use.
       *  @param n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a n
       *  characters of @a s.  If @a n is is larger than the number of
       *  available characters in @a s, the remainder of @a s is used.
       */
      basic_string&
      assign(const _CharT* __s, size_type __n);

      /**
       *  @brief  Set value to contents of a C string.
       *  @param s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a s.
       *  The data is copied, so there is no dependence on @a s once the
       *  function returns.
       */
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }

      /**
       *  @brief  Set value to multiple characters.
       *  @param n  Length of the resulting string.
       *  @param c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a n copies of
       *  character @a c.
       */
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }

      /**
       *  @brief  Set value to a range of characters.
       *  @param first  Iterator referencing the first character to append.
       *  @param last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [first,last).
      */
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1160 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Insert multiple characters.
       *  @param p  Iterator referencing location in string to insert at.
       *  @param n  Number of characters to insert
       *  @param c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a n copies of character @a c starting at the position
       *  referenced by iterator @a p.  If adding characters causes the length
       *  to exceed max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }

      /**
       *  @brief  Insert a range of characters.
       *  @param p  Iterator referencing location in string to insert at.
       *  @param beg  Start of range.
       *  @param end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [beg,end).  If adding characters causes
       *  the length to exceed max_size(), length_error is thrown.  The value
       *  of the string doesn't change if an error is thrown.
      */
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1207 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 /**
       *  @brief  Insert value of a string.
       *  @param pos1  Iterator referencing location in string to insert at.
       *  @param str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a str starting at @a pos1.  If adding characters
       *  causes the length to exceed max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }

      /**
       *  @brief  Insert a substring.
       *  @param pos1  Iterator referencing location in string to insert at.
       *  @param str  The string to insert.
       *  @param pos2  Start of characters in str to insert.
       *  @param n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a n character of @a str beginning with
       *  @a pos2.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a pos1 is beyond the end of
       *  this string or @a pos2 is beyond the end of @a str, out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }

      /**
       *  @brief  Insert a C substring.
       *  @param pos  Iterator referencing location in string to insert at.
       *  @param s  The C string to insert.
       *  @param n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a s starting at @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);

      /**
       *  @brief  Insert a C string.
       *  @param pos  Iterator referencing location in string to insert at.
       *  @param s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a s starting at @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Insert multiple characters.
       *  @param pos  Index in string to insert at.
       *  @param n  Number of characters to insert
       *  @param c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts @a n copies of character @a c starting at index @a pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a pos > length(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }

      /**
       *  @brief  Insert one character.
       *  @param p  Iterator referencing position in string to insert at.
       *  @param c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a c at position referenced by @a p.  If adding
       *  character causes the length to exceed max_size(), length_error is
       *  thrown.  If @a p is beyond end of string, out_of_range is thrown.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove characters.
       *  @param pos  Index of first character to remove (default 0).
       *  @param n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a n characters from this string starting at @a pos.  The
       *  length of the string is reduced by @a n.  If there are < @a n
       *  characters to remove, the remainder of the string is truncated.  If
       *  @a p is beyond end of string, out_of_range is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }

      /**
       *  @brief  Remove one character.
       *  @param position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a position from this string. The value
       *  of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove a range of characters.
       *  @param first  Iterator referencing the first character to remove.
       *  @param last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __first, iterator __last);

      /**
       *  @brief  Replace characters with value from another string.
       *  @param pos  Index of first character to replace.
       *  @param n  Number of characters to be replaced.
       *  @param str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos+n) from this string.
       *  In place, the value of @a str is inserted.  If @a pos is beyond end
       *  of string, out_of_range is thrown.  If the length of the result
       *  exceeds max_size(), length_error is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace characters with value from another string.
       *  @param pos1  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param str  String to insert.
       *  @param pos2  Index of first character of str to use.
       *  @param n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >
       *  str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos1,pos1 + n) from this
       *  string.  In place, the value of @a str is inserted.  If @a pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }

      /**
       *  @brief  Replace characters with value of a C substring.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param s  C string to insert.
       *  @param n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, the first @a n2 characters of @a s are inserted, or all
       *  of @a s if @a n2 is too large.  If @a pos is beyond end of string,
       *  out_of_range is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);

      /**
       *  @brief  Replace characters with value of a C string.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, the characters of @a s are inserted.  If @a pos is beyond
       *  end of string, out_of_range is thrown.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace characters with multiple characters.
       *  @param pos  Index of first character to replace.
       *  @param n1  Number of characters to be replaced.
       *  @param n2  Number of characters to insert.
       *  @param c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this string.
       *  In place, @a n2 copies of @a c are inserted.  If @a pos is beyond
       *  end of string, out_of_range is thrown.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }

      /**
       *  @brief  Replace range of characters with string.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the value of
       *  @a str is inserted.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace range of characters with C substring.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param s  C string value to insert.
       *  @param n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the first @a
       *  n characters of @a s are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }

      /**
       *  @brief  Replace range of characters with C string.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, the
       *  characters of @a s are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace range of characters with multiple characters
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param n  Number of characters to insert.
       *  @param c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, @a n copies
       *  of @a c are inserted.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't change if
       *  an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }

      /**
       *  @brief  Replace range of characters with range.
       *  @param i1  Iterator referencing start of range to replace.
       *  @param i2  Iterator referencing end of range to replace.
       *  @param k1  Iterator referencing start of range to insert.
       *  @param k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [i1,i2).  In place, characters
       *  in the range [k1,k2) are inserted.  If the length of result exceeds
       *  max_size(), length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }

      // Specializations for the common case of pointer and iterator:
      // useful to avoid the overhead of temporary buffering in _M_replace.
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1663 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);

      // _S_construct_aux is used to implement the 21.3.1 para 15 which
      // requires special behaviour if _InIter is an integral type
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }

      // For Input Iterators, used in istreambuf_iterators, etc.
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);

      // For forward_iterators up to random_access_iterators, used for
      // string::iterator, _CharT*, etc.
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:

      /**
       *  @brief  Copy substring into C string.
       *  @param s  C string to copy value into.
       *  @param n  Number of characters to copy.
       *  @param pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If pos > size().
       *
       *  Copies up to @a n characters starting at @a pos into the C string @a
       *  s.  If @a pos is %greater than size(), out_of_range is thrown.
      */
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      /**
       *  @brief  Swap contents with another string.
       *  @param s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a s in constant
       *  time.
      */
      void
      swap(basic_string& __s);

      // String operations:
      /**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      c_str() const
      { return _M_data(); }

      /**
       *  @brief  Return const pointer to contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      data() const
      { return _M_data(); }

      /**
       *  @brief  Return copy of allocator used to construct this string.
      */
      allocator_type
      get_allocator() const
      { return _M_dataplus; }

      /**
       *  @brief  Find position of a C substring.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search from.
       *  @param n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for the first @a n characters
       *  in @a s within this string.  If found, returns the index where it
       *  begins.  If not found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a string.
       *  @param str  String to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for value of @a str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a C string.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a pos, searches forward for the value of @a s within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find(_CharT __c, size_type __pos = 0) const;

      /**
       *  @brief  Find last position of a string.
       *  @param str  String to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a pos, searches backward for value of @a str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a C substring.
       *  @param s  C string to locate.
       *  @param pos  Index of character to search back from.
       *  @param n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a pos, searches backward for the first @a n
       *  characters in @a s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a C string.
       *  @param s  C string to locate.
       *  @param pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a pos, searches backward for the value of @a s within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;

      /**
       *  @brief  Find position of a character of string.
       *  @param str  String containing characters to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the characters of
       *  @a str within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character of C substring.
       *  @param s  String containing characters to locate.
       *  @param pos  Index of character to search from.
       *  @param n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the first @a n
       *  characters of @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a character of C string.
       *  @param s  String containing characters to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for one of the characters of
       *  @a s within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for the character @a c within
       *  this string.  If found, returns the index where it was found.  If
       *  not found, returns npos.
       *
       *  Note: equivalent to find(c, pos).
      */
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }

      /**
       *  @brief  Find last position of a character of string.
       *  @param str  String containing characters to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the characters of
       *  @a str within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character of C substring.
       *  @param s  C string containing characters to locate.
       *  @param pos  Index of character to search back from.
       *  @param n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the first @a n
       *  characters of @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a character of C string.
       *  @param s  C string containing characters to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for one of the characters of
       *  @a s within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param c  Character to locate.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for @a c within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
       *
       *  Note: equivalent to rfind(c, pos).
      */
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }

      /**
       *  @brief  Find position of a character not in string.
       *  @param str  String containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in @a str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character not in C substring.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from.
       *  @param n  Number of characters from s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in the first @a n characters of @a s within this string.  If found,
       *  returns the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;

      /**
       *  @brief  Find position of a character not in C string.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character not contained
       *  in @a s within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a different character.
       *  @param c  Character to avoid.
       *  @param pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a pos, searches forward for a character other than @a c
       *  within this string.  If found, returns the index where it was found.
       *  If not found, returns npos.
      */
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;

      /**
       *  @brief  Find last position of a character not in string.
       *  @param str  String containing characters to avoid.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in @a str within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character not in C substring.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search back from.
       *  @param n  Number of characters from s to consider.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in the first @a n characters of @a s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      /**
       *  @brief  Find last position of a character not in C string.
       *  @param s  C string containing characters to avoid.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for a character not
       *  contained in @a s within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a different character.
       *  @param c  Character to avoid.
       *  @param pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a pos, searches backward for a character other than
       *  @a c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;

      /**
       *  @brief  Get a substring.
       *  @param pos  Index of first character (default 0).
       *  @param n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If pos > size().
       *
       *  Construct and return a new string using the @a n characters starting
       *  at @a pos.  If the string is too short, use the remainder of the
       *  characters.  If @a pos is beyond the end of the string, out_of_range
       *  is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }

      /**
       *  @brief  Compare to a string.
       *  @param str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a str, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a str.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and str.size().  The function
       *  then compares the two strings by calling traits::compare(data(),
       *  str.data(),rlen).  If the result of the comparison is nonzero returns
       *  it, otherwise the shorter one is ordered first.
      */
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }

      /**
       *  @brief  Compare substring to a string.
       *  @param pos  Index of first character of substring.
       *  @param n  Number of characters in substring.
       *  @param str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n characters starting
       *  at @a pos.  Returns an integer < 0 if the substring is ordered
       *  before @a str, 0 if their values are equivalent, or > 0 if the
       *  substring is ordered after @a str.  Determines the effective length
       *  rlen of the strings to compare as the smallest of the length of the
       *  substring and @a str.size().  The function then compares the two
       *  strings by calling traits::compare(substring.data(),str.data(),rlen).
       *  If the result of the comparison is nonzero returns it, otherwise the
       *  shorter one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      /**
       *  @brief  Compare substring to a substring.
       *  @param pos1  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param str  String to compare against.
       *  @param pos2  Index of first character of substring of str.
       *  @param n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos1.  Form the substring of @a str from the @a n2 characters
       *  starting at @a pos2.  Returns an integer < 0 if this substring is
       *  ordered before the substring of @a str, 0 if their values are
       *  equivalent, or > 0 if this substring is ordered after the substring
       *  of @a str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the lengths of the substrings.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it, otherwise the
       *  shorter one is ordered first.
      */
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;

      /**
       *  @brief  Compare to a C string.
       *  @param s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(const _CharT* __s) const;

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 5 String::compare specification questionable
      /**
       *  @brief  Compare substring to a C string.
       *  @param pos  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos.  Returns an integer < 0 if the substring is ordered
       *  before @a s, 0 if their values are equivalent, or > 0 if the
       *  substring is ordered after @a s.  Determines the effective length
       *  rlen of the strings to compare as the smallest of the length of the 
       *  substring and the length of a string constructed from @a s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      /**
       *  @brief  Compare substring against a character %array.
       *  @param pos1  Index of first character of substring.
       *  @param n1  Number of characters in substring.
       *  @param s  character %array to compare against.
       *  @param n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a n1 characters starting
       *  at @a pos1.  Form a string from the first @a n2 characters of @a s.
       *  Returns an integer < 0 if this substring is ordered before the string
       *  from @a s, 0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a s.   Determines the effective
       *  length rlen of the strings to compare as the smallest of the length
       *  of the substring and @a n2.  The function then compares the two
       *  strings by calling traits::compare(substring.data(),s,rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
       *  no special meaning.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  // operator+
  /**
   *  @brief  Concatenate two strings.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with value of @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  /**
   *  @brief  Concatenate C string and string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with value of @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  /**
   *  @brief  Concatenate character and string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  /**
   *  @brief  Concatenate string and C string.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  /**
   *  @brief  Concatenate string and character.
   *  @param lhs  First string.
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2417 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.h" 3
 // operator ==
  /**
   *  @brief  Test equivalence of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }

  /**
   *  @brief  Test equivalence of C string and string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  /**
   *  @brief  Test equivalence of string and C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }

  // operator !=
  /**
   *  @brief  Test difference of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   *  @brief  Test difference of C string and string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   *  @brief  Test difference of string and C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }

  // operator <
  /**
   *  @brief  Test if string precedes string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   *  @brief  Test if string precedes C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   *  @brief  Test if C string precedes string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs precedes @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }

  // operator >
  /**
   *  @brief  Test if string follows string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  /**
   *  @brief  Test if string follows C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }

  /**
   *  @brief  Test if C string follows string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs follows @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }

  // operator <=
  /**
   *  @brief  Test if string doesn't follow string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   *  @brief  Test if string doesn't follow C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   *  @brief  Test if C string doesn't follow string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }

  // operator >=
  /**
   *  @brief  Test if string doesn't precede string.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   *  @brief  Test if string doesn't precede C string.
   *  @param lhs  String.
   *  @param rhs  C string.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   *  @brief  Test if C string doesn't precede string.
   *  @param lhs  C string.
   *  @param rhs  String.
   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }

  /**
   *  @brief  Swap contents of two strings.
   *  @param lhs  First string.
   *  @param rhs  Second string.
   *
   *  Exchanges the contents of @a lhs and @a rhs in constant time.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }

  /**
   *  @brief  Read stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a is into @a str until whitespace is found, the
   *  end of the stream is encountered, or str.max_size() is reached.  If
   *  is.width() is non-zero, that is the limit on the number of characters
   *  stored into @a str.  Any previous contents of @a str are erased.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);

  /**
   *  @brief  Write string to a stream.
   *  @param os  Output stream.
   *  @param str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a str into os following the same rules as for
   *  writing a C string.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
    }

  /**
   *  @brief  Read a line from stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @param delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a is into @a str until @a delim is found, the
   *  end of the stream is encountered, or str.max_size() is reached.  If
   *  is.width() is non-zero, that is the limit on the number of characters
   *  stored into @a str.  Any previous contents of @a str are erased.  If @a
   *  delim was encountered, it is extracted but not stored into @a str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  /**
   *  @brief  Read a line from stream into a string.
   *  @param is  Input stream.
   *  @param str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a str until &apos;\n&apos; is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  If is.width() is non-zero, that is the limit on the
   *  number of characters stored into @a str.  Any previous contents
   *  of @a str are erased.  If end of line was encountered, it is
   *  extracted but not stored into @a str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



} // namespace
# 54 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_string.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21  Strings library
//

// Written by Jason Merrill based upon the specification by Takanori Adachi
// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
  // at static init time (before static ctors are run).
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];

  // NB: This is the special case for Input Iterators, used in
  // istreambuf_iterators, etc.
  // Input Iterators have a cost structure very different from
  // pointers, calling for a different coding style.
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();

 // Avoid reallocation for common case.
 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {
      // Allocate more space.
      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     __r->_M_destroy(__a);
                            ;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();

 // NB: Not required, but considered best practice.
 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));
 // Check for out_of_range and length_error exceptions.
 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 if (true)
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 if (false)
   {
     __r->_M_destroy(__a);
                            ;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();

      // Check for out_of_range and length_error exceptions.
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 241 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_string.tcc" 3
 template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {
   // XXX MT
   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {
   // Work in-place.
   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
           // Work in-place.
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;

       // NB: This isn't just an optimization (bail out early when
       // there is nothing to do, really), it's also a correctness
       // issue vs MT, see libstdc++/40518.
       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {
    // Work in-place: non-overlapping case.
    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {
    // Todo: overlapping case.
    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {
   // Must reallocate.
   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {
   // Work in-place.
   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   // Make sure we don't shrink below the current size
   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }
      // The code below can usually be optimized away.
      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 83.  String::npos vs. string::max_size()
      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));

      // The standard places no restriction on allocating more memory
      // than is strictly needed within this layer at the moment or as
      // requested by an explicit application call to reserve().

      // Many malloc implementations perform quite poorly when an
      // application attempts to allocate memory in a stepwise fashion
      // growing each allocation size by only 1 char.  Additionally,
      // it makes little sense to allocate less linear memory than the
      // natural blocking size of the malloc implementation.
      // Unfortunately, we would need a somewhat low-level calculation
      // with tuned parameters to get this perfect for any particular
      // malloc implementation.  Fortunately, generalizations about
      // common features seen among implementations seems to suffice.

      // __pagesize need not match the actual VM page size for good
      // results in practice, thus we pick a common value on the low
      // side.  __malloc_header_size is an estimate of the amount of
      // overhead per memory allocation (in practice seen N * sizeof
      // (void*) where N is 0, 2 or 4).  According to folklore,
      // picking this value on the high side is better than
      // low-balling it (especially when this algorithm is used with
      // malloc implementations that allocate memory blocks rounded up
      // to a size which is a power of 2).
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);

      // The below implements an exponential growth policy, necessary to
      // meet amortized linear time requirements of the library: see
      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
      // It's active for allocations requiring an amount of memory above
      // system pagesize. This is consistent with the requirements of the
      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;

      // NB: Need an array of char_type[__capacity], plus a terminating
      // null char_type() element, plus enough for the _Rep data structure.
      // Whew. Seemingly so needy, yet so elemental.
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);
   // Never allocate a string bigger than _S_max_size.
   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }

      // NB: Might throw, but no worries about a leak, mate: _Rep()
      // does not throw.
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      // ABI compatibility - 3.4.x set in _S_create both
      // _M_refcount and _M_length.  All callers of _S_create
      // in basic_string.tcc then set just _M_length.
      // In 4.0.x and later both _M_refcount and _M_length
      // are initialized in the callers, unfortunately we can
      // have 3.4.x compiled code with _S_create callers inlined
      // calling 4.0.x+ _S_create.
      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
      // Requested capacity of the clone.
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);
      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);
      // 21.3.5.7 par 3: do not append null.  (good.)
      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  // 21.3.7.9 basic_string::getline and operators
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {
       // Avoid reallocation for common case.
       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 91. Description of operator>> and getline() for string<>
       // might cause endless loop
       __in._M_setstate(__ios_base::badbit);
     }
 }
      // 211.  operator>>(istream&, string&) doesn't set failbit
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 91. Description of operator>> and getline() for string<>
       // might cause endless loop
       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




} // namespace std
# 55 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/string" 2 3
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  // 22.1.1 Class locale
  /**
   *  @brief  Container class for localization functionality.
   *  @ingroup locales
   *
   *  The locale class is first a class wrapper for C library locales.  It is
   *  also an extensible container for user-defined localization.  A locale is
   *  a collection of facets that implement various localization features such
   *  as money, time, and number printing.
   *
   *  Constructing C++ locales does not change the C library locale.
   *
   *  This library supports efficient construction and copying of locales
   *  through a reference counting implementation of the locale class.
  */
  class locale
  {
  public:
    // Types:
    /// Definition of locale::category.
    typedef int category;

    // Forward decls and friends:
    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

    //@{
    /**
     *  @brief  Category values.
     *
     *  The standard category values are none, ctype, numeric, collate, time,
     *  monetary, and messages.  They form a bitmask that supports union and
     *  intersection.  The category all is the union of these values.
     *
     *  NB: Order must match _S_facet_categories definition in locale.cc
    */
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
    //@}

    // Construct/copy/destroy:

    /**
     *  @brief  Default constructor.
     *
     *  Constructs a copy of the global locale.  If no locale has been
     *  explicitly set, this is the C locale.
    */
    locale() throw();

    /**
     *  @brief  Copy constructor.
     *
     *  Constructs a copy of @a other.
     *
     *  @param  other  The locale to copy.
    */
    locale(const locale& __other) throw();

    /**
     *  @brief  Named locale constructor.
     *
     *  Constructs a copy of the named C library locale.
     *
     *  @param  s  Name of the locale to construct.
     *  @throw  std::runtime_error if s is null or an undefined locale.
    */
    explicit
    locale(const char* __s);

    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale named by @a s.  If base is
     *  named, this locale instance will also be named.
     *
     *  @param  base  The locale to copy.
     *  @param  s  Name of the locale to use facets from.
     *  @param  cat  Set of categories defining the facets to use from s.
     *  @throw  std::runtime_error if s is null or an undefined locale.
    */
    locale(const locale& __base, const char* __s, category __cat);

    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale @a add.  If @a base and @a
     *  add are named, this locale instance will also be named.
     *
     *  @param  base  The locale to copy.
     *  @param  add  The locale to use facets from.
     *  @param  cat  Set of categories defining the facets to use from add.
    */
    locale(const locale& __base, const locale& __add, category __cat);

    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs a copy of the locale @a other.  The facet @f is added to
     *  @other, replacing an existing facet of type Facet if there is one.  If
     *  @f is null, this locale is a copy of @a other.
     *
     *  @param  other  The locale to copy.
     *  @param  f  The facet to add in.
    */
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);

    /// Locale destructor.
    ~locale() throw();

    /**
     *  @brief  Assignment operator.
     *
     *  Set this locale to be a copy of @a other.
     *
     *  @param  other  The locale to copy.
     *  @return  A reference to this locale.
    */
    const locale&
    operator=(const locale& __other) throw();

    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs and returns a new copy of this locale.  Adds or replaces an
     *  existing facet of type Facet from the locale @a other into the new
     *  locale.
     *
     *  @param  Facet  The facet type to copy from other
     *  @param  other  The locale to copy from.
     *  @return  Newly constructed locale.
     *  @throw  std::runtime_error if other has no facet of type Facet.
    */
    template<typename _Facet>
      locale
      combine(const locale& __other) const;

    // Locale operations:
    /**
     *  @brief  Return locale name.
     *  @return  Locale name or "*" if unnamed.
    */
    string
    name() const;

    /**
     *  @brief  Locale equality.
     *
     *  @param  other  The locale to compare against.
     *  @return  True if other and this refer to the same locale instance, are
     *		 copies, or have the same name.  False otherwise.
    */
    bool
    operator==(const locale& __other) const throw();

    /**
     *  @brief  Locale inequality.
     *
     *  @param  other  The locale to compare against.
     *  @return  ! (*this == other)
    */
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }

    /**
     *  @brief  Compare two strings according to collate.
     *
     *  Template operator to compare two strings using the compare function of
     *  the collate facet in this locale.  One use is to provide the locale to
     *  the sort function.  For example, a vector v of strings could be sorted
     *  according to locale loc by doing:
     *  @code
     *  std::sort(v.begin(), v.end(), loc);
     *  @endcode
     *
     *  @param  s1  First string to compare.
     *  @param  s2  Second string to compare.
     *  @return  True if collate<Char> facet compares s1 < s2, else false.
    */
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;

    // Global locale objects:
    /**
     *  @brief  Set global locale
     *
     *  This function sets the global locale to the argument and returns a
     *  copy of the previous global locale.  If the argument has a name, it
     *  will also call std::setlocale(LC_ALL, loc.name()).
     *
     *  @param  locale  The new locale to make global.
     *  @return  Copy of the old global locale.
    */
    static locale
    global(const locale&);

    /**
     *  @brief  Return reference to the C locale.
    */
    static const locale&
    classic();

  private:
    // The (shared) implementation
    _Impl* _M_impl;

    // The "C" reference locale
    static _Impl* _S_classic;

    // Current global locale
    static _Impl* _S_global;

    // Names of underlying locale categories.
    // NB: locale::global() has to know how to modify all the
    // underlying categories, not just the ones required by the C++
    // standard.
    static const char* const* const _S_categories;

    // Number of standard categories. For C++, these categories are
    // collate, ctype, monetary, numeric, time, and messages. These
    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,
    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE
    // 1003.1-2001) specifies LC_MESSAGES.
    // In addition to the standard categories, the underlying
    // operating system is allowed to define extra LC_*
    // macros. For GNU systems, the following are also valid:
    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,
    // and LC_IDENTIFICATION.
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };


  // 22.1.1.1.2  Class locale::facet
  /**
   *  @brief  Localization functionality base class.
   *  @ingroup locales
   *
   *  The facet class is the base class for a localization feature, such as
   *  money, time, and number printing.  It provides common support for facets
   *  and reference management.
   *
   *  Facets may not be copied or assigned.
  */
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;

    // Contains data from the underlying "C" library for the classic locale.
    static __c_locale _S_c_locale;

    // String literal for the name of the classic locale.
    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
    /**
     *  @brief  Facet constructor.
     *
     *  This is the constructor provided by the standard.  If refs is 0, the
     *  facet is destroyed when the last referencing locale is destroyed.
     *  Otherwise the facet will never be destroyed.
     *
     *  @param refs  The initial value for reference count.
    */
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }

    /// Facet destructor.
    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);

    // Returns data from the underlying "C" library data for the
    // classic locale.
    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      // Be race-detector-friendly.  For more info see bits/c++config.
                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    facet(const facet&); // Not defined.

    facet&
    operator=(const facet&); // Not defined.
  };


  // 22.1.1.1.3 Class locale::id
  /**
   *  @brief  Facet ID class.
   *  @ingroup locales
   *
   *  The ID class provides facets with an index used to identify them.
   *  Every facet class must define a public static member locale::id, or be
   *  derived from a facet that provides this member, otherwise the facet
   *  cannot be used in a locale.  The locale::id ensures that each class
   *  type gets a unique identifier.
  */
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    // NB: There is no accessor for _M_index because it may be used
    // before the constructor is run; the effect of calling a member
    // function (even an inline) would be undefined.
    mutable size_t _M_index;

    // Last id number assigned.
    static _Atomic_word _S_refcount;

    void
    operator=(const id&); // Not defined.

    id(const id&); // Not defined.

  public:
    // NB: This class is always a static data member, and thus can be
    // counted on to be zero-initialized.
    /// Constructor.
    id() { }

    size_t
    _M_id() const throw();
  };


  // Implementation object for locale.
  class locale::_Impl
  {
  public:
    // Friends.
    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:
    // Data Members.
    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      // Be race-detector-friendly.  For more info see bits/c++config.
                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&); // Not defined.

    void
    operator=(const _Impl&); // Not defined.

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
 // We must actually compare all the _M_names: can be all equal!
 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };


  /**
   *  @brief  Test for the presence of a facet.
   *
   *  has_facet tests the locale argument for the presence of the facet type
   *  provided as the template parameter.  Facets derived from the facet
   *  parameter will also return true.
   *
   *  @param  Facet  The facet type to test the presence of.
   *  @param  locale  The locale to test.
   *  @return  true if locale contains a facet of type Facet, else false.
  */
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  /**
   *  @brief  Return a facet.
   *
   *  use_facet looks for and returns a reference to a facet of type Facet
   *  where Facet is the template parameter.  If has_facet(locale) is true,
   *  there is a suitable facet to return.  It throws std::bad_cast if the
   *  locale doesn't contain a facet of type Facet.
   *
   *  @param  Facet  The facet type to access.
   *  @param  locale  The locale to use.
   *  @return  Reference to facet of type Facet.
   *  @throw  std::bad_cast if locale doesn't contain a facet of type Facet.
  */
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);


  /**
   *  @brief  Facet for localized string comparison.
   *
   *  This facet encapsulates the code to compare strings in a localized
   *  manner.
   *
   *  The collate template uses protected virtual functions to provide
   *  the actual results.  The public accessors forward the call to
   *  the virtual functions.  These virtual functions are hooks for
   *  developers to implement the behavior they require from the
   *  collate facet.
  */
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}

    protected:
      // Underlying "C" library locale information saved from
      // initialization, needed by collate_byname as well.
      __c_locale _M_c_locale_collate;

    public:
      /// Numpunct facet id.
      static locale::id id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }

      /**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param cloc  The C locale.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }

      /**
       *  @brief  Compare two strings.
       *
       *  This function compares two strings and returns the result by calling
       *  collate::do_compare().
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }

      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a wrapper for strxfrm functionality.  It takes the
       *  input string and returns a modified string that can be directly
       *  compared to other transformed strings.  In the C locale, this
       *  function just returns a copy of the input string.  In some other
       *  locales, it may replace two chars with one, change a char for
       *  another, etc.  It does so by returning collate::do_transform().
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Transformed string_type.
      */
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }

      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  It
       *  does so by returning collate::do_hash().
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Hash value.
      */
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }

      // Used to abstract out _CharT bits in virtual member functions, below.
      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:
      /// Destructor.
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }

      /**
       *  @brief  Compare two strings.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see compare().
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;

      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.
       *
       *  @param lo1  Start of string 1.
       *  @param hi1  End of string 1.
       *  @param lo2  Start of string 2.
       *  @param hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;

      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  This
       *  function is a hook for derived classes to change the value returned.
       *
       *  @param lo  Start of string.
       *  @param hi  End of string.
       *  @return  Hash value.
      */
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;

  // Specializations.
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();


  /// class collate_byname [22.2.4.2].
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}

      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_classes.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//
# 37 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
                          ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0; // Unnamed.
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
                          ;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }


  // Generic version does nothing.
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }

  // Generic version does nothing.
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {
      // strcoll assumes zero-terminated strings so we make a copy
      // and then put a zero at the end.
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();

      // strcoll stops when it sees a nul character so we break
      // the strings into zero-terminated substrings and pass those
      // to strcoll.
      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;

      // strxfrm assumes zero-terminated strings so we make a copy
      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      if (true)
 {
   // strxfrm stops when it sees a nul character so we break
   // the string into zero-terminated substrings and pass those
   // to strxfrm.
   for (;;)
     {
       // First try a buffer perhaps big enough.
       size_t __res = _M_transform(__c, __p, __len);
       // If the buffer was not large enough, try again with the
       // correct size.
       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
                          ;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




} // namespace std
# 823 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_classes.h" 2 3
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // The following definitions of bitmask types are enums, not ints,
  // as permitted (but not required) in the standard, in order to provide
  // better type safety in iostream calls.  A side effect is that
  // expressions involving them are no longer compile-time constants.
  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };

  // 27.4.2  Class ios_base
  /**
   *  @brief  The base of the I/O class hierarchy.
   *  @ingroup io
   *
   *  This class defines everything that can be defined about I/O that does
   *  not depend on the type of characters being input or output.  Most
   *  people will only see @c ios_base when they need to specify the full
   *  name of the various I/O flags (e.g., the openmodes).
  */
  class ios_base
  {
  public:

    /** 
     *  @brief These are thrown to indicate problems with io.
     *  @ingroup exceptions
     *
     *  27.4.2.1.1  Class ios_base::failure
     */
    class failure : public exception
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 48.  Use of non-existent exception constructor
      explicit
      failure(const string& __str) throw();

      // This declaration is not useless:
      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html
      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };

    // 27.4.2.1.2  Type ios_base::fmtflags
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type fmtflags are:
     *  - boolalpha
     *  - dec
     *  - fixed
     *  - hex
     *  - internal
     *  - left
     *  - oct
     *  - right
     *  - scientific
     *  - showbase
     *  - showpoint
     *  - showpos
     *  - skipws
     *  - unitbuf
     *  - uppercase
     *  - adjustfield
     *  - basefield
     *  - floatfield
    */
    typedef _Ios_Fmtflags fmtflags;

    /// Insert/extract @c bool in alphabetic rather than numeric format.
    static const fmtflags boolalpha = _S_boolalpha;

    /// Converts integer input or generates integer output in decimal base.
    static const fmtflags dec = _S_dec;

    /// Generate floating-point output in fixed-point notation.
    static const fmtflags fixed = _S_fixed;

    /// Converts integer input or generates integer output in hexadecimal base.
    static const fmtflags hex = _S_hex;

    /// Adds fill characters at a designated internal point in certain
    /// generated output, or identical to @c right if no such point is
    /// designated.
    static const fmtflags internal = _S_internal;

    /// Adds fill characters on the right (final positions) of certain
    /// generated output.  (I.e., the thing you print is flush left.)
    static const fmtflags left = _S_left;

    /// Converts integer input or generates integer output in octal base.
    static const fmtflags oct = _S_oct;

    /// Adds fill characters on the left (initial positions) of certain
    /// generated output.  (I.e., the thing you print is flush right.)
    static const fmtflags right = _S_right;

    /// Generates floating-point output in scientific notation.
    static const fmtflags scientific = _S_scientific;

    /// Generates a prefix indicating the numeric base of generated integer
    /// output.
    static const fmtflags showbase = _S_showbase;

    /// Generates a decimal-point character unconditionally in generated
    /// floating-point output.
    static const fmtflags showpoint = _S_showpoint;

    /// Generates a + sign in non-negative generated numeric output.
    static const fmtflags showpos = _S_showpos;

    /// Skips leading white space before certain input operations.
    static const fmtflags skipws = _S_skipws;

    /// Flushes output after each output operation.
    static const fmtflags unitbuf = _S_unitbuf;

    /// Replaces certain lowercase letters with their uppercase equivalents
    /// in generated output.
    static const fmtflags uppercase = _S_uppercase;

    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.
    static const fmtflags adjustfield = _S_adjustfield;

    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.
    static const fmtflags basefield = _S_basefield;

    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.
    static const fmtflags floatfield = _S_floatfield;

    // 27.4.2.1.3  Type ios_base::iostate
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Iostate is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type iostate are:
     *  - badbit
     *  - eofbit
     *  - failbit
     *  - goodbit
    */
    typedef _Ios_Iostate iostate;

    /// Indicates a loss of integrity in an input or output sequence (such
    /// as an irrecoverable read error from a file).
    static const iostate badbit = _S_badbit;

    /// Indicates that an input operation reached the end of an input sequence.
    static const iostate eofbit = _S_eofbit;

    /// Indicates that an input operation failed to read the expected
    /// characters, or that an output operation failed to generate the
    /// desired characters.
    static const iostate failbit = _S_failbit;

    /// Indicates all is well.
    static const iostate goodbit = _S_goodbit;

    // 27.4.2.1.4  Type ios_base::openmode
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Openmode is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type openmode are:
     *  - app
     *  - ate
     *  - binary
     *  - in
     *  - out
     *  - trunc
    */
    typedef _Ios_Openmode openmode;

    /// Seek to end before each write.
    static const openmode app = _S_app;

    /// Open and seek to end immediately after opening.
    static const openmode ate = _S_ate;

    /// Perform input and output in binary mode (as opposed to text mode).
    /// This is probably not what you think it is; see
    /// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch27s02.html
    static const openmode binary = _S_bin;

    /// Open for input.  Default for @c ifstream and fstream.
    static const openmode in = _S_in;

    /// Open for output.  Default for @c ofstream and fstream.
    static const openmode out = _S_out;

    /// Open for input.  Default for @c ofstream.
    static const openmode trunc = _S_trunc;

    // 27.4.2.1.5  Type ios_base::seekdir
    /**
     *  @brief This is an enumerated type.
     *
     *  @c @a _Ios_Seekdir is implementation-defined.  Defined values
     *  of type seekdir are:
     *  - beg
     *  - cur, equivalent to @c SEEK_CUR in the C standard library.
     *  - end, equivalent to @c SEEK_END in the C standard library.
    */
    typedef _Ios_Seekdir seekdir;

    /// Request a seek relative to the beginning of the stream.
    static const seekdir beg = _S_beg;

    /// Request a seek relative to the current position within the sequence.
    static const seekdir cur = _S_cur;

    /// Request a seek relative to the current end of the sequence.
    static const seekdir end = _S_end;

    // Annex D.6
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;

    // Callbacks;
    /**
     *  @brief  The set of events that may be passed to an event callback.
     *
     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used
     *  during imbue().  copyfmt_event is used during copyfmt().
    */
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };

    /**
     *  @brief  The type of an event callback function.
     *  @param  event  One of the members of the event enum.
     *  @param  ios_base  Reference to the ios_base object.
     *  @param  int  The integer provided when the callback was registered.
     *
     *  Event callbacks are user defined functions that get called during
     *  several ios_base and basic_ios functions, specifically imbue(),
     *  copyfmt(), and ~ios().
    */
    typedef void (*event_callback) (event, ios_base&, int);

    /**
     *  @brief  Add the callback __fn with parameter __index.
     *  @param  __fn  The function to add.
     *  @param  __index  The integer to pass to the function when invoked.
     *
     *  Registers a function as an event callback with an integer parameter to
     *  be passed to the function when invoked.  Multiple copies of the
     *  function are allowed.  If there are multiple callbacks, they are
     *  invoked in the order they were registered.
    */
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;

    // 27.4.2.6  Members for callbacks
    // 27.4.2.6  ios_base callbacks
    struct _Callback_list
    {
      // Data Members
      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount; // 0 means one reference.

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

      // 0 => OK to delete.
      int
      _M_remove_reference()
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();

    // 27.4.2.5  Members for iword/pword storage
    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };

    // Only for failed iword/pword calls.
    _Words _M_word_zero;

    // Guaranteed storage.
    // The first 5 iword and pword slots are reserved for internal use.
    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];

    // Allocated storage.
    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);

    // Members for locale and locale caching.
    locale _M_ios_locale;

    void
    _M_init() throw();

  public:

    // 27.4.2.1.6  Class ios_base::Init
    // Used to initialize standard streams. In theory, g++ could use
    // -finit-priority to order this stuff correctly without going
    // through these machinations.
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };

    // [27.4.2.2] fmtflags state functions
    /**
     *  @brief  Access to format flags.
     *  @return  The format control flags for both input and output.
    */
    fmtflags
    flags() const
    { return _M_flags; }

    /**
     *  @brief  Setting new format flags all at once.
     *  @param  fmtfl  The new flags to set.
     *  @return  The previous format control flags.
     *
     *  This function overwrites all the format flags with @a fmtfl.
    */
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }

    /**
     *  @brief  Setting new format flags.
     *  @param  fmtfl  Additional flags to set.
     *  @return  The previous format control flags.
     *
     *  This function sets additional flags in format control.  Flags that
     *  were previously set remain set.
    */
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }

    /**
     *  @brief  Setting new format flags.
     *  @param  fmtfl  Additional flags to set.
     *  @param  mask  The flags mask for @a fmtfl.
     *  @return  The previous format control flags.
     *
     *  This function clears @a mask in the format flags, then sets
     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.
    */
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }

    /**
     *  @brief  Clearing format flags.
     *  @param  mask  The flags to unset.
     *
     *  This function clears @a mask in the format flags.
    */
    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }

    /**
     *  @brief  Flags access.
     *  @return  The precision to generate on certain output operations.
     *
     *  Be careful if you try to give a definition of @a precision here; see
     *  DR 189.
    */
    streamsize
    precision() const
    { return _M_precision; }

    /**
     *  @brief  Changing flags.
     *  @param  prec  The new precision value.
     *  @return  The previous value of precision().
    */
    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }

    /**
     *  @brief  Flags access.
     *  @return  The minimum field width to generate on output operations.
     *
     *  <em>Minimum field width</em> refers to the number of characters.
    */
    streamsize
    width() const
    { return _M_width; }

    /**
     *  @brief  Changing flags.
     *  @param  wide  The new width value.
     *  @return  The previous value of width().
    */
    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }

    // [27.4.2.4] ios_base static members
    /**
     *  @brief  Interaction with the standard C I/O objects.
     *  @param  sync  Whether to synchronize or not.
     *  @return  True if the standard streams were previously synchronized.
     *
     *  The synchronization referred to is @e only that between the standard
     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,
     *  cout).  User-declared streams are unaffected.  See
     *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch28s02.html
    */
    static bool
    sync_with_stdio(bool __sync = true);

    // [27.4.2.3] ios_base locale functions
    /**
     *  @brief  Setting a new locale.
     *  @param  loc  The new locale.
     *  @return  The previous locale.
     *
     *  Sets the new locale for this stream, and then invokes each callback
     *  with imbue_event.
    */
    locale
    imbue(const locale& __loc) throw();

    /**
     *  @brief  Locale access
     *  @return  A copy of the current locale.
     *
     *  If @c imbue(loc) has previously been called, then this function
     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),
     *  the global C++ locale.
    */
    locale
    getloc() const
    { return _M_ios_locale; }

    /**
     *  @brief  Locale access
     *  @return  A reference to the current locale.
     *
     *  Like getloc above, but returns a reference instead of
     *  generating a copy.
    */
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }

    // [27.4.2.5] ios_base storage functions
    /**
     *  @brief  Access to unique indices.
     *  @return  An integer different from all previous calls.
     *
     *  This function returns a unique integer every time it is called.  It
     *  can be used for any purpose, but is primarily intended to be a unique
     *  index for the iword and pword functions.  The expectation is that an
     *  application calls xalloc in order to obtain an index in the iword and
     *  pword arrays that can be used without fear of conflict.
     *
     *  The implementation maintains a static variable that is incremented and
     *  returned on each invocation.  xalloc is guaranteed to return an index
     *  that is safe to use in the iword and pword arrays.
    */
    static int
    xalloc() throw();

    /**
     *  @brief  Access to integer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to an integer associated with the index.
     *
     *  The iword function provides access to an array of integers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All integers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }

    /**
     *  @brief  Access to void pointer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to a void* associated with the index.
     *
     *  The pword function provides access to an array of pointers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All pointers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }

    // Destructor
    /**
     *  Invokes each callback with erase_event.  Destroys local storage.
     *
     *  Note that the ios_base object for the standard streams never gets
     *  destroyed.  As a result, any callbacks registered with the standard
     *  streams will not get invoked with erase_event (unless copyfmt is
     *  used).
    */
    virtual ~ios_base();

  protected:
    ios_base() throw ();

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 50.  Copy constructor and assignment operator of ios_base
  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };

  // [27.4.5.1] fmtflags manipulators
  /// Calls base.setf(ios_base::boolalpha).
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }

  /// Calls base.unsetf(ios_base::boolalpha).
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }

  /// Calls base.setf(ios_base::showbase).
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showbase).
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }

  /// Calls base.setf(ios_base::showpoint).
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showpoint).
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }

  /// Calls base.setf(ios_base::showpos).
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showpos).
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }

  /// Calls base.setf(ios_base::skipws).
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }

  /// Calls base.unsetf(ios_base::skipws).
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }

  /// Calls base.setf(ios_base::uppercase).
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }

  /// Calls base.unsetf(ios_base::uppercase).
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }

  /// Calls base.setf(ios_base::unitbuf).
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }

  /// Calls base.unsetf(ios_base::unitbuf).
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }

  // [27.4.5.2] adjustfield manipulators
  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }

  /// Calls base.setf(ios_base::left, ios_base::adjustfield).
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }

  /// Calls base.setf(ios_base::right, ios_base::adjustfield).
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }

  // [27.4.5.3] basefield manipulators
  /// Calls base.setf(ios_base::dec, ios_base::basefield).
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }

  /// Calls base.setf(ios_base::hex, ios_base::basefield).
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }

  /// Calls base.setf(ios_base::oct, ios_base::basefield).
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }

  // [27.4.5.4] floatfield manipulators
  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }

  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


} // namespace
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 1 3
// Stream buffer classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/streambuf
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.5  Stream buffers
//
# 37 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);

  /**
   *  @brief  The actual work of input and output (interface).
   *  @ingroup io
   *
   *  This is a base class.  Derived stream buffers each control a
   *  pair of character sequences:  one for input, and one for output.
   *
   *  Section [27.5.1] of the standard describes the requirements and
   *  behavior of stream buffer classes.  That section (three paragraphs)
   *  is reproduced here, for simplicity and accuracy.
   *
   *  -# Stream buffers can impose various constraints on the sequences
   *     they control.  Some constraints are:
   *     - The controlled input sequence can be not readable.
   *     - The controlled output sequence can be not writable.
   *     - The controlled sequences can be associated with the contents of
   *       other representations for character sequences, such as external
   *       files.
   *     - The controlled sequences can support operations @e directly to or
   *       from associated sequences.
   *     - The controlled sequences can impose limitations on how the
   *       program can read characters from a sequence, write characters to
   *       a sequence, put characters back into an input sequence, or alter
   *       the stream position.
   *     .
   *  -# Each sequence is characterized by three pointers which, if non-null,
   *     all point into the same @c charT array object.  The array object
   *     represents, at any moment, a (sub)sequence of characters from the
   *     sequence.  Operations performed on a sequence alter the values
   *     stored in these pointers, perform reads and writes directly to or
   *     from associated sequences, and alter <em>the stream position</em> and
   *     conversion state as needed to maintain this subsequence relationship.
   *     The three pointers are:
   *     - the <em>beginning pointer</em>, or lowest element address in the
   *       array (called @e xbeg here);
   *     - the <em>next pointer</em>, or next element address that is a
   *       current candidate for reading or writing (called @e xnext here);
   *     - the <em>end pointer</em>, or first element address beyond the
   *       end of the array (called @e xend here).
   *     .
   *  -# The following semantic constraints shall always apply for any set
   *     of three pointers for a sequence, using the pointer names given
   *     immediately above:
   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall
   *       also be non-null pointers into the same @c charT array, as
   *       described above; otherwise, @e xbeg and @e xend shall also be null.
   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an
   *       output sequence, then a <em>write position</em> is available.
   *       In this case, @e *xnext shall be assignable as the next element
   *       to write (to put, or to store a character value, into the sequence).
   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an
   *       input sequence, then a <em>putback position</em> is available.
   *       In this case, @e xnext[-1] shall have a defined value and is the
   *       next (preceding) element to store a character that is put back
   *       into the input sequence.
   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an
   *       input sequence, then a <em>read position</em> is available.
   *       In this case, @e *xnext shall have a defined value and is the
   *       next element to read (to get, or to obtain a character value,
   *       from the sequence).
  */
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependant on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      //@}

      //@{
      /// This is a non-standard type.
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      //@}

      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
      //@{
      /**
       *  This is based on _IO_FILE, just reordered to be more consistent,
       *  and is intended to be the most minimal abstraction for an
       *  internal buffer.
       *  -  get == input == read
       *  -  put == output == write
      */
      char_type* _M_in_beg; // Start of get area. 
      char_type* _M_in_cur; // Current read area. 
      char_type* _M_in_end; // End of get area. 
      char_type* _M_out_beg; // Start of put area. 
      char_type* _M_out_cur; // Current put area. 
      char_type* _M_out_end; // End of put area.

      /// Current locale setting.
      locale _M_buf_locale;

  public:
      /// Destructor deallocates no buffer space.
      virtual
      ~basic_streambuf()
      { }

      // [27.5.2.2.1] locales
      /**
       *  @brief  Entry point for imbue().
       *  @param  loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls the derived imbue(loc).
      */
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }

      /**
       *  @brief  Locale access.
       *  @return  The current locale in effect.
       *
       *  If pubimbue(loc) has been called, then the most recent @c loc
       *  is returned.  Otherwise the global locale in effect at the time
       *  of construction is returned.
      */
      locale
      getloc() const
      { return _M_buf_locale; }

      // [27.5.2.2.2] buffer management and positioning
      //@{
      /**
       *  @brief  Entry points for derived buffer functions.
       *
       *  The public versions of @c pubfoo dispatch to the protected
       *  derived @c foo member functions, passing the arguments (if any)
       *  and returning the result unchanged.
      */
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
      //@}

      // [27.5.2.2.3] get area
      /**
       *  @brief  Looking ahead into the stream.
       *  @return  The number of characters available.
       *
       *  If a read position is available, returns the number of characters
       *  available for reading before the buffer must be refilled.
       *  Otherwise returns the derived @c showmanyc().
      */
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  Calls @c sbumpc(), and if that function returns
       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().
      */
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character
       *  and increments the read pointer, otherwise calls and returns
       *  @c uflow().
      */
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character,
       *  otherwise calls and returns @c underflow().  Does not move the 
       *  read position after fetching the character.
      */
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }

      /**
       *  @brief  Entry point for xsgetn.
       *  @param  s  A buffer area.
       *  @param  n  A count.
       *
       *  Returns xsgetn(s,n).  The effect is to fill @a s[0] through
       *  @a s[n-1] with characters from the input sequence, if possible.
      */
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }

      // [27.5.2.2.4] putback
      /**
       *  @brief  Pushing characters back into the input stream.
       *  @param  c  The character to push back.
       *  @return  The previous character, if possible.
       *
       *  Similar to sungetc(), but @a c is pushed onto the stream
       *  instead of <em>the previous character.</em> If successful,
       *  the next character fetched from the input stream will be @a
       *  c.
      */
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }

      /**
       *  @brief  Moving backwards in the input stream.
       *  @return  The previous character, if possible.
       *
       *  If a putback position is available, this function decrements
       *  the input pointer and returns that character.  Otherwise,
       *  calls and returns pbackfail().  The effect is to @a unget
       *  the last character @a gotten.
      */
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }

      // [27.5.2.2.5] put area
      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  c  A character to output.
       *  @return  @a c, if possible.
       *
       *  One of two public output functions.
       *
       *  If a write position is available for the output sequence (i.e.,
       *  the buffer is not full), stores @a c in that position, increments
       *  the position, and returns @c traits::to_int_type(c).  If a write
       *  position is not available, returns @c overflow(c).
      */
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }

      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  s  A buffer read area.
       *  @param  n  A count.
       *
       *  One of two public output functions.
       *
       *
       *  Returns xsputn(s,n).  The effect is to write @a s[0] through
       *  @a s[n-1] to the output sequence, if possible.
      */
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
      /**
       *  @brief  Base constructor.
       *
       *  Only called from derived constructors, and sets up all the
       *  buffer data to zero, including the pointers described in the
       *  basic_streambuf class description.  Note that, as a result,
       *  - the class starts with no read nor write positions available,
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }

      // [27.5.2.3.1] get area access
      //@{
      /**
       *  @brief  Access to the get area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - eback() returns the beginning pointer for the input sequence
       *  - gptr() returns the next pointer for the input sequence
       *  - egptr() returns the end pointer for the input sequence
      */
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
      //@}

      /**
       *  @brief  Moving the read position.
       *  @param  n  The delta by which to move.
       *
       *  This just advances the read position without returning any data.
      */
      void
      gbump(int __n) { _M_in_cur += __n; }

      /**
       *  @brief  Setting the three read area pointers.
       *  @param  gbeg  A pointer.
       *  @param  gnext  A pointer.
       *  @param  gend  A pointer.
       *  @post  @a gbeg == @c eback(), @a gnext == @c gptr(), and
       *         @a gend == @c egptr()
      */
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }

      // [27.5.2.3.2] put area access
      //@{
      /**
       *  @brief  Access to the put area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - pbase() returns the beginning pointer for the output sequence
       *  - pptr() returns the next pointer for the output sequence
       *  - epptr() returns the end pointer for the output sequence
      */
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
      //@}

      /**
       *  @brief  Moving the write position.
       *  @param  n  The delta by which to move.
       *
       *  This just advances the write position without returning any data.
      */
      void
      pbump(int __n) { _M_out_cur += __n; }

      /**
       *  @brief  Setting the three write area pointers.
       *  @param  pbeg  A pointer.
       *  @param  pend  A pointer.
       *  @post  @a pbeg == @c pbase(), @a pbeg == @c pptr(), and
       *         @a pend == @c epptr()
      */
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }

      // [27.5.2.4] virtual functions
      // [27.5.2.4.1] locales
      /**
       *  @brief  Changes translations.
       *  @param  loc  A new locale.
       *
       *  Translations done during I/O which depend on the current
       *  locale are changed by this call.  The standard adds,
       *  <em>Between invocations of this function a class derived
       *  from streambuf can safely cache results of calls to locale
       *  functions and to members of facets so obtained.</em>
       *
       *  @note  Base class version does nothing.
      */
      virtual void
      imbue(const locale&)
      { }

      // [27.5.2.4.2] buffer management and positioning
      /**
       *  @brief  Manipulates the buffer.
       *
       *  Each derived class provides its own appropriate behavior.  See
       *  the next-to-last paragraph of 
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html
       *  for more on this function.
       *
       *  @note  Base class version does nothing, returns @c this.
      */
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }

      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      /**
       *  @brief  Synchronizes the buffer arrays with the controlled sequences.
       *  @return  -1 on failure.
       *
       *  Each derived class provides its own appropriate behavior,
       *  including the definition of @a failure.
       *  @note  Base class version does nothing, returns zero.
      */
      virtual int
      sync() { return 0; }

      // [27.5.2.4.3] get area
      /**
       *  @brief  Investigating the data available.
       *  @return  An estimate of the number of characters available in the
       *           input sequence, or -1.
       *
       *  <em>If it returns a positive value, then successive calls to
       *  @c underflow() will not return @c traits::eof() until at
       *  least that number of characters have been supplied.  If @c
       *  showmanyc() returns -1, then calls to @c underflow() or @c
       *  uflow() will fail.</em> [27.5.2.4.3]/1
       *
       *  @note  Base class version does nothing, returns zero.
       *  @note  The standard adds that <em>the intention is not only that the
       *         calls [to underflow or uflow] will not return @c eof() but
       *         that they will return immediately.</em>
       *  @note  The standard adds that <em>the morphemes of @c showmanyc are
       *         @b es-how-many-see, not @b show-manic.</em>
      */
      virtual streamsize
      showmanyc() { return 0; }

      /**
       *  @brief  Multiple character extraction.
       *  @param  s  A buffer area.
       *  @param  n  Maximum number of characters to assign.
       *  @return  The number of characters assigned.
       *
       *  Fills @a s[0] through @a s[n-1] with characters from the input
       *  sequence, as if by @c sbumpc().  Stops when either @a n characters
       *  have been copied, or when @c traits::eof() would be copied.
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function is called when the input buffer is
       *  exhausted (or does not exist, as buffering need not actually be
       *  done).  If a buffer exists, it is @a refilled.  In either case, the
       *  next available character is returned, or @c traits::eof() to
       *  indicate a null pending sequence.
       *
       *  For a formal definition of the pending sequence, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.
       *
       *  A functioning input streambuf can be created by overriding only
       *  this function (no buffer area will be used).  For an example, see
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      underflow()
      { return traits_type::eof(); }

      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function does the same thing as @c underflow(),
       *  and in fact is required to call that function.  It also returns
       *  the new character, like @c underflow() does.  However, this
       *  function also moves the read position forward by one.
      */
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }

      // [27.5.2.4.4] putback
      /**
       *  @brief  Tries to back up the input sequence.
       *  @param  c  The character to be inserted back into the sequence.
       *  @return  eof() on failure, <em>some other value</em> on success
       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()
       *         are the same as for @c underflow().
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      pbackfail(int_type /* __c */ = traits_type::eof())
      { return traits_type::eof(); }

      // Put area:
      /**
       *  @brief  Multiple character insertion.
       *  @param  s  A buffer area.
       *  @param  n  Maximum number of characters to write.
       *  @return  The number of characters written.
       *
       *  Writes @a s[0] through @a s[n-1] to the output sequence, as if
       *  by @c sputc().  Stops when either @a n characters have been
       *  copied, or when @c sputc() would return @c traits::eof().
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);

      /**
       *  @brief  Consumes data from the buffer; writes to the
       *          controlled sequence.
       *  @param  c  An additional character to consume.
       *  @return  eof() to indicate failure, something else (usually
       *           @a c, or not_eof())
       *
       *  Informally, this function is called when the output buffer
       *  is full (or does not exist, as buffering need not actually
       *  be done).  If a buffer exists, it is @a consumed, with
       *  <em>some effect</em> on the controlled sequence.
       *  (Typically, the buffer is written out to the sequence
       *  verbatim.)  In either case, the character @a c is also
       *  written out, if @a c is not @c eof().
       *
       *  For a formal definition of this function, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.
       *
       *  A functioning output streambuf can be created by overriding only
       *  this function (no buffer area will be used).
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      overflow(int_type /* __c */ = traits_type::eof())
      { return traits_type::eof(); }


    // Annex D.6
    public:
      /**
       *  @brief  Tosses a character.
       *
       *  Advances the read pointer, ignoring the character that would have
       *  been read.
       *
       *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html
       */
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


      // Also used by specializations for char and wchar_t in src.
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // Side effect of DR 50. 
      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };

  // Explicit specialization declarations, defined in src/streambuf.cc.
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 1 3
// Stream buffer classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/streambuf.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{streambuf}
 */

//
// ISO C++ 14882: 27.5  Stream buffers
//
# 38 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }

  // Conceivably, this could be used to implement buffer-to-buffer
  // copies, if this was ever desired in an un-ambiguous way by the
  // standard.
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




} // namespace std
# 808 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/streambuf" 2 3
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_ios.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 3



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 3

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <cwctype>
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
/* Copyright (C) 1996-2002,2005,2007-2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.25
 *	Wide character classification and mapping utilities  <wctype.h>
 */
# 32 "/usr/include/wctype.h" 3 4
/* Get wint_t from <wchar.h>.  */



# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 895 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
# 35 "/usr/include/wctype.h" 2 3 4

/* Constant expression of type `wint_t' whose value does not correspond
   to any member of the extended character set.  */







/* The following part is also used in the <wcsmbs.h> header when compiled
   in the Unix98 compatibility mode.  */




/* Scalar type that can hold values which represent locale-specific
   character classifications.  */
typedef unsigned long int wctype_t;



/* The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */
# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0, /* UPPERCASE.  */
  __ISwlower = 1, /* lowercase.  */
  __ISwalpha = 2, /* Alphabetic.  */
  __ISwdigit = 3, /* Numeric.  */
  __ISwxdigit = 4, /* Hexadecimal numeric.  */
  __ISwspace = 5, /* Whitespace.  */
  __ISwprint = 6, /* Printing.  */
  __ISwgraph = 7, /* Graphical.  */
  __ISwblank = 8, /* Blank (usually SPC and TAB).  */
  __ISwcntrl = 9, /* Control character.  */
  __ISwpunct = 10, /* Punctuation.  */
  __ISwalnum = 11, /* Alphanumeric.  */

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))), /* UPPERCASE.  */
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))), /* lowercase.  */
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))), /* Alphabetic.  */
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))), /* Numeric.  */
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))), /* Hexadecimal numeric.  */
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))), /* Whitespace.  */
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))), /* Printing.  */
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))), /* Graphical.  */
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))), /* Blank (usually SPC and TAB).  */
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))), /* Control character.  */
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))), /* Punctuation.  */
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24)))) /* Alphanumeric.  */
};



extern "C" {


/*
 * Wide-character classification functions: 7.15.2.1.
 */

/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum (wint_t __wc) throw ();

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha (wint_t __wc) throw ();

/* Test for any control wide character.  */
extern int iswcntrl (wint_t __wc) throw ();

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit (wint_t __wc) throw ();

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph (wint_t __wc) throw ();

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower (wint_t __wc) throw ();

/* Test for any printing wide character.  */
extern int iswprint (wint_t __wc) throw ();

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct (wint_t __wc) throw ();

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace (wint_t __wc) throw ();

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper (wint_t __wc) throw ();

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit (wint_t __wc) throw ();

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */

extern int iswblank (wint_t __wc) throw ();


/*
 * Extensible wide-character classification functions: 7.15.2.2.
 */

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype (__const char *__property) throw ();

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype (wint_t __wc, wctype_t __desc) throw ();



/*
 * Wide-character case-mapping functions: 7.15.3.1.
 */


/* Scalar type that can hold values which represent locale-specific
   character mappings.  */
typedef __const __int32_t *wctrans_t;






/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower (wint_t __wc) throw ();

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper (wint_t __wc) throw ();


}




/* The remaining definitions and declarations must not appear in the
   <wchar.h> header.  */


/*
 * Extensible wide-character mapping functions: 7.15.3.2.
 */

extern "C" {


/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans (__const char *__property) throw ();

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();



/* Declare the interface to extended locale model.  */


/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any control wide character.  */
extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any printing wide character.  */
extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */
extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();


/*
 * Wide-character case-mapping functions.
 */

/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();

/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 52 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 2 3





// Get rid of those macros defined in <wctype.h> in lieu of real functions.
# 81 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
} // namespace
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <ccytpe>
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cctype" 3
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_base.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ctype_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

// Information as gleaned from /usr/include/ctype.h

namespace std __attribute__ ((__visibility__ ("default")))
{


  /// @brief  Base class for ctype.
  struct ctype_base
  {
    // Non-standard typedefs.
    typedef const int* __to_type;

    // NB: Offsets into ctype<char>::_M_table force a particular size
    // on the mask type. Because of this, we don't use an enum.
    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


} // namespace
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 1 3
// Streambuf iterators

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/streambuf_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   * @addtogroup iterators
   * @{
   */

  // 24.5.3 Template class istreambuf_iterator
  /// Provides input iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
      //@}

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:
      // 24.5.3 istreambuf_iterator
      // p 1
      // If the end of stream is reached (streambuf_type::sgetc()
      // returns traits_type::eof()), the iterator becomes equal to
      // the "end of stream" iterator value.
      // NB: This implementation assumes the "end of stream" value
      // is EOF, or -1.
      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:
      ///  Construct end of input stream iterator.
                         istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }

      ///  Construct start of input stream iterator.
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }

      ///  Construct start of streambuf iterator.
      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }

      ///  Return the current character pointed to by iterator.  This returns
      ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of
      ///  operator*() on an end of stream is undefined.
      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }

      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }

      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 110 istreambuf_iterator::equal not const
      // NB: there is also number 111 (NAD, Future) pending on this function.
      /// Return true both iterators are end or both are not end.
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }

  /// Provides output iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
      //@}

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
      ///  Construct output iterator from ostream.
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

      ///  Construct output iterator from streambuf.
      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

      ///  Write character to streambuf.  Calls streambuf.sputc().
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }

      /// Return *this.
      ostreambuf_iterator&
      operator*()
      { return *this; }

      /// Return *this.
      ostreambuf_iterator&
      operator++(int)
      { return *this; }

      /// Return *this.
      ostreambuf_iterator&
      operator++()
      { return *this; }

      /// Return true if previous operator=() failed.
      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };

  // Overloads for streambuf iterators.
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

// @} group iterators


} // namespace
# 50 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // NB: Don't instantiate required wchar_t facets if no wchar_t support.






  // Convert string to numeric value of type _Tp and store results.
  // NB: This is specialized for all required types, there is no
  // generic definition.
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();

  // Explicit specializations for required types.
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();

  // NB: __pad is a struct, rather than a function, so it can be
  // partially-specialized.
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };

  // Used by both numeric and monetary facets.
  // Inserts "group separator" characters into an array of characters.
  // It's recursive, one iteration per group.  It moves the characters
  // in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this
  // only with __gsize != 0.
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);

  // This template permits specializing facet output code for
  // ostreambuf_iterator.  For ostreambuf_iterator, sputn is
  // significantly more efficient than incrementing iterators.
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }

  // This is the unspecialized form of the template.
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }


  // 22.2.1.1  Template class ctype
  // Include host and configuration specific ctype enums for ctype_base.

  /**
   *  @brief  Common base for ctype facet
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter
      typedef _CharT char_type;

      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *  It does so by returning the value of ctype<char_type>::do_is().
       *
       *  @param c  The char_type to compare the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the char array.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }

      /**
       *  @brief  Find char_type matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.  It does so by returning
       *  ctype<char_type>::do_scan_is().
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to matching char_type if found, else @a hi.
      */
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }

      /**
       *  @brief  Find char_type not matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is false.  It does so by returning
       *  ctype<char_type>::do_scan_not().
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to non-matching char if found, else @a hi.
      */
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }

      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.  It does
       *  so by returning ctype<char_type>::do_toupper().
       *
       *  @param c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_toupper(lo, hi).
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the argument to lowercase if possible.  If
       *  not possible (for example, '2'), returns the argument.  It does so
       *  by returning ctype<char_type>::do_tolower(c).
       *
       *  @param c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_tolower(lo, hi).
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      /**
       *  @brief  Widen char to char_type
       *
       *  This function converts the char argument to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted char_type.
      */
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }

      /**
       *  @brief  Widen array to char_type
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }

      /**
       *  @brief  Narrow char_type to char
       *
       *  This function converts the char_type to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  It does so by returning
       *  ctype<char_type>::do_narrow(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char_type to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }

      /**
       *  @brief  Narrow array to char array
       *
       *  This function converts each char_type in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char_type in the input that cannot be
       *  converted, @a dfault is used instead.  It does so by returning
       *  ctype<char_type>::do_narrow(lo, hi, dfault, to).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }

      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param c  The char_type to find the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const = 0;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;

      /**
       *  @brief  Find char_type matching mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching char_type if found, else @a hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;

      /**
       *  @brief  Find char_type not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  char_type c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char_type if found, else @a hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char_type argument to uppercase
       *  if possible.  If not possible (for example, '2'), returns the
       *  argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const = 0;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char_type in the range [lo,hi)
       *  to uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const = 0;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char_type in the range [lo,hi)
       *  to lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;

      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted char_type
      */
      virtual char_type
      do_widen(char) const = 0;

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;

      /**
       *  @brief  Narrow char_type to char
       *
       *  This virtual function converts the argument to char using the
       *  simplest reasonable transformation.  If the conversion fails, dfault
       *  is returned instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char_type to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type, char __dfault) const = 0;

      /**
       *  @brief  Narrow char_type array to char
       *
       *  This virtual function converts each char_type in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any element in the input that
       *  cannot be converted, @a dfault is used instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };

  /**
   *  @brief  Primary class template ctype facet.
   *  @ingroup locales
   *
   *  This template class defines classification and conversion functions for
   *  character sets.  It wraps cctype functionality.  Ctype gets used by
   *  streams for many I/O operations.
   *
   *  This template provides the protected virtual functions the developer
   *  will have to replace in a derived class or specialization to make a
   *  working facet.  The public functions that access them are defined in
   *  __ctype_abstract_base, to allow for implementation flexibility.  See
   *  ctype<wchar_t> for an example.  The functions are documented in
   *  __ctype_abstract_base.
   *
   *  Note: implementations are provided for all the protected virtual
   *  functions, but will likely not be useful.
  */
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
      // Types:
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;

      /// The facet id for ctype<char_type>
      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;

  /**
   *  @brief  The ctype<char> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for
   *  the char type.  It gets used by char streams for many I/O
   *  operations.  The char specialization provides a number of
   *  optimizations as well.
  */
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter char.
      typedef char char_type;

    protected:
      // Data Members:
      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok; // 0 uninitialized, 1 init,
      // 2 memcpy can't be used

    public:
      /// The facet id for ctype<char>
      static locale::id id;
      /// The size of the mask table.  It is SCHAR_MAX + 1.
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param table If non-zero, table is used as the per-char mask.
       *               Else classic_table() is used.
       *  @param del   If true, passes ownership of table to this facet.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);

      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param cloc  Handle to C locale data.
       *  @param table If non-zero, table is used as the per-char mask.
       *  @param del   If true, passes ownership of table to this facet.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);

      /**
       *  @brief  Test char classification.
       *
       *  This function compares the mask table[c] to @a m.
       *
       *  @param c  The char to compare the mask of.
       *  @param m  The mask to compare against.
       *  @return  True if m & table[c] is true, false otherwise.
      */
      inline bool
      is(mask __m, char __c) const;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char in the range [lo, hi) and
       *  successively writes it to vec.  vec must have as many elements as
       *  the char array.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;

      /**
       *  @brief  Find char matching a mask
       *
       *  This function searches for and returns the first char in [lo,hi) for
       *  which is(m,char) is true.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching char if found, else @a hi.
      */
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;

      /**
       *  @brief  Find char not matching a mask
       *
       *  This function searches for and returns a pointer to the first char
       *  in [lo,hi) for which is(m,char) is false.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char if found, else @a hi.
      */
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the char argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  toupper() acts as if it returns ctype<char>::do_toupper(c).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param c  The char to convert.
       *  @return  The uppercase char if convertible, else @a c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char in the range [lo,hi) to uppercase
       *  if possible.  Other chars remain untouched.
       *
       *  toupper() acts as if it returns ctype<char>:: do_toupper(lo, hi).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the char argument to lowercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  tolower() acts as if it returns ctype<char>::do_tolower(c).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param c  The char to convert.
       *  @return  The lowercase char if convertible, else @a c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char in the range [lo,hi) to lowercase
       *  if possible.  Other chars remain untouched.
       *
       *  tolower() acts as if it returns ctype<char>:: do_tolower(lo, hi).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      /**
       *  @brief  Widen char
       *
       *  This function converts the char to char_type using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }

      /**
       *  @brief  Narrow char
       *
       *  This function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c
       *  will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(c).
       *  do_narrow() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted character.
      */
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }

      /**
       *  @brief  Narrow char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char in the input that cannot be
       *  converted, @a dfault is used instead.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
       *  dfault, to).  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 695. ctype<char>::classic_table() not accessible.
      /// Returns a pointer to the mask table provided to the constructor, or
      /// the default from classic_table() if none was provided.
      const mask*
      table() const throw()
      { return _M_table; }

      /// Returns a pointer to the C locale mask table.
      static const mask*
      classic_table() throw();
    protected:

      /**
       *  @brief  Destructor.
       *
       *  This function deletes table() if @a del was true in the
       *  constructor.
      */
      virtual
      ~ctype();

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The char to convert.
       *  @return  The uppercase char if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  uppercase if possible.  Other chars remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the char argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The char to convert.
       *  @return  The lowercase char if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  lowercase if possible.  Other chars remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to first char in range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted character.
      */
      virtual char_type
      do_widen(char __c) const
      { return __c; }

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the range [lo,hi) to char using
       *  the simplest reasonable transformation.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

      /**
       *  @brief  Narrow char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c will be
       *  returned unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }

      /**
       *  @brief  Narrow char array to char array
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any char in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };


  /**
   *  @brief  The ctype<wchar_t> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for the
   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
   *  The wchar_t specialization provides a number of optimizations as well.
   *
   *  ctype<wchar_t> inherits its public methods from
   *  __ctype_abstract_base<wchar_t>.
  */
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
      // Types:
      /// Typedef for the template parameter wchar_t.
      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;

      // Pre-computed narrowed and widened chars.
      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];

      // Pre-computed elements for do_is.
      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:
      // Data Members:
      /// The facet id for ctype<wchar_t>
      static locale::id id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(size_t __refs = 0);

      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param cloc  Handle to C locale data.
       *  @param refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();

      /// Destructor
      virtual
      ~ctype();

      /**
       *  @brief  Test wchar_t classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param c  The wchar_t to find the mask of.
       *  @param m  The mask to compare against.
       *  @return  (M & m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each wchar_t in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param vec  Pointer to an array of mask storage.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      /**
       *  @brief  Find wchar_t matching mask
       *
       *  This function searches for and returns the first wchar_t c in
       *  [lo,hi) for which is(m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a matching wchar_t if found, else @a hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Find wchar_t not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  wchar_t c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param m  The mask to compare against.
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  Pointer to a non-matching wchar_t if found, else @a hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the wchar_t argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param c  The wchar_t to convert.
       *  @return  The uppercase wchar_t if convertible, else @a c.
      */
      virtual char_type
      do_toupper(char_type) const;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param c  The wchar_t to convert.
       *  @return  The lowercase wchar_t if convertible, else @a c.
      */
      virtual char_type
      do_tolower(char_type) const;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Widen char to wchar_t
       *
       *  This virtual function converts the char to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be cast to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The char to convert.
       *  @return  The converted wchar_t.
      */
      virtual char_type
      do_widen(char) const;

      /**
       *  @brief  Widen char array to wchar_t array
       *
       *  This function converts each char in the input to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be copied, casting each element to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start range.
       *  @param hi  Pointer to end of range.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      /**
       *  @brief  Narrow wchar_t to char
       *
       *  This virtual function converts the argument to char using
       *  the simplest reasonable transformation.  If the conversion
       *  fails, dfault is returned instead.  For an underived
       *  ctype<wchar_t> facet, @a c will be cast to char and
       *  returned.
       *
       *  do_narrow() is a hook for a derived facet to change the
       *  behavior of narrowing.  do_narrow() must always return the
       *  same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param c  The wchar_t to convert.
       *  @param dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type, char __dfault) const;

      /**
       *  @brief  Narrow wchar_t array to char array
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any wchar_t in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<wchar_t> facet, the argument will be copied, casting each
       *  element to char.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param lo  Pointer to start of range.
       *  @param hi  Pointer to end of range.
       *  @param dfault  Char to use if conversion fails.
       *  @param to  Pointer to the destination array.
       *  @return  @a hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;

      // For use at construction time only.
      void
      _M_initialize_ctype() throw();
    };


  /// class ctype_byname [22.2.1.2].
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };

  /// 22.2.1.4  Class ctype_byname specializations.
  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



} // namespace

// Include host and configuration specific ctype inlines.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 2000, 2002, 2009, 2010 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ctype_inline.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
// functions go in ctype.cc

namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


} // namespace
# 1512 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // 22.2.2  The numeric category.
  class __num_base
  {
  public:
    // NB: Code depends on the order of _S_atoms_out elements.
    // Below are the indices into _S_atoms_out.
    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14, // For scientific notation, 'e'
        _S_oE = _S_oudigits + 14, // For scientific notation, 'E'
 _S_oend = _S_oudigits_end
      };

    // A list of valid numeric literals for output.  This array
    // contains chars that will be passed through the current locale's
    // ctype<_CharT>.widen() and then used to render numbers.
    // For the standard "C" locale, this is
    // "-+xX0123456789abcdef0123456789ABCDEF".
    static const char* _S_atoms_out;

    // String literal of acceptable (narrow) input, for num_get.
    // "-+xX0123456789abcdefABCDEF"
    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };

    // num_put
    // Construct and return valid scanf format for floating point types.
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;

      // A list of valid numeric literals for output: in the standard
      // "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT _M_atoms_out[__num_base::_S_oend];

      // A list of valid numeric literals for input: in the standard
      // "C" locale, this is "-+xX0123456789abcdefABCDEF"
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

  /**
   *  @brief  Primary class template numpunct.
   *  @ingroup locales
   *
   *  This facet stores several pieces of information related to printing and
   *  scanning numbers, such as the decimal point character.  It takes a
   *  template parameter specifying the char type.  The numpunct facet is
   *  used by streams for many I/O operations involving numbers.
   *
   *  The numpunct template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from a numpunct facet.
  */
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      //@}
      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:
      /// Numpunct facet id.
      static locale::id id;

      /**
       *  @brief  Numpunct constructor.
       *
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }

      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up the
       *  predefined locale facets.
       *
       *  @param  cache  __numpunct_cache object.
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }

      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  cloc  The C locale.
       *  @param  refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }

      /**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  numpunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      */
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      /**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  numpunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      */
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      /**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of a number.  Groupings indicate where thousands
       *  separators should be inserted in the integer part of a number.
       *
       *  Each char in the return string is interpret as an integer
       *  rather than a character.  These numbers represent the number
       *  of digits in a group.  The first char in the string
       *  represents the number of digits in the least significant
       *  group.  If a char is negative, it indicates an unlimited
       *  number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is
       *  applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was "32", this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  numpunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      */
      string
      grouping() const
      { return this->do_grouping(); }

      /**
       *  @brief  Return string representation of bool true.
       *
       *  This function returns a string_type containing the text
       *  representation for true bool variables.  It does so by calling
       *  numpunct<char_type>::do_truename().
       *
       *  @return  string_type representing printed form of true.
      */
      string_type
      truename() const
      { return this->do_truename(); }

      /**
       *  @brief  Return string representation of bool false.
       *
       *  This function returns a string_type containing the text
       *  representation for false bool variables.  It does so by calling
       *  numpunct<char_type>::do_falsename().
       *
       *  @return  string_type representing printed form of false.
      */
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:
      /// Destructor.
      virtual
      ~numpunct();

      /**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      */
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }

      /**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      */
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }

      /**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      */
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }

      /**
       *  @brief  Return string representation of bool true.
       *
       *  Returns a string_type containing the text representation for true
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of true.
      */
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }

      /**
       *  @brief  Return string representation of bool false.
       *
       *  Returns a string_type containing the text representation for false
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of false.
      */
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }

      // For use at construction time only.
      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);


  /// class numpunct_byname [22.2.3.2].
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };



  /**
   *  @brief  Primary class template num_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a number
   *  from a string.  It is used by the istream numeric extraction
   *  operators.
   *
   *  The num_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_get facet.
  */
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _InIter iter_type;
      //@}

      /// Numpunct facet id.
      static locale::id id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }

      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the bool @a v.  It does so by calling
       *  num_get::do_get().
       *
       *  If ios_base::boolalpha is set, attempts to read
       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
       *  @a v to true or false if successful.  Sets err to
       *  ios_base::failbit if reading the string fails.  Sets err to
       *  ios_base::eofbit if the stream is emptied.
       *
       *  If ios_base::boolalpha is not set, proceeds as with reading a long,
       *  except if the value is 1, sets @a v to true, if the value is 0, sets
       *  @a v to false, and otherwise set err to ios_base::failbit.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  Parsing is affected by the flag settings in @a io.
       *
       *  The basic parse is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, parses like the
       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
       *  specifier.  Else if basefield equal to 0, parses like the %i
       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
       *  types.  The matching type length modifier is also used.
       *
       *  Digit grouping is interpreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      //@}

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %g specifier.  The
       *  matching type length modifier is also used.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Digit grouping is interpreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      //@}

      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the pointer variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %p specifier.
       *
       *  Digit grouping is interpreted according to numpunct::grouping() and
       *  numpunct::thousands_sep().  If the pattern of digit groups isn't
       *  consistent, sets err to ios_base::failbit.
       *
       *  Note that the digit grouping effect for pointers is a bit ambiguous
       *  in the standard and shouldn't be relied on.  See DR 344.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:
      /// Destructor.
      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the variable @a v.  This function is a
       *  hook for derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param  in  Start of input stream.
       *  @param  end  End of input stream.
       *  @param  io  Source of locale and flags.
       *  @param  err  Error flags to set.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;

      // XXX GLIBCXX_ABI Deprecated





      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;

      // XXX GLIBCXX_ABI Deprecated





      //@}
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;


  /**
   *  @brief  Primary class template num_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to convert a number to a string.  It is
   *  used by the ostream numeric insertion operators.
   *
   *  The num_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_put facet.
  */
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      //@}

      /// Numpunct facet id.
      static locale::id id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param refs  Passed to the base facet class.
      */
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }

      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the boolean @a v and inserts it into a stream.  It does so
       *  by calling num_put::do_put().
       *
       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the integral value @a v and inserts it into a
       *  stream.  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, formats like the
       *  printf %o specifier.  Else if equal to ios_base::hex, formats like
       *  %x or %X with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
       *  for unsigned values.  Note that if both oct and hex are set, neither
       *  will take effect.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showbase is set, '0' precedes octal values (except 0)
       *  and '0[xX]' precedes hex values.
       *
       *  Thousands separators are inserted according to numpunct::grouping()
       *  and numpunct::thousands_sep().  The decimal point character used is
       *  numpunct::decimal_point().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      //@}

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the floating point value @a v and inserts it into a stream.
       *  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
       *  printf %f specifier.  Else if equal to ios_base::scientific, formats
       *  like %e or %E with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %g or %G depending on uppercase.  Note that
       *  if both fixed and scientific are set, the effect will also be like
       *  %g or %G.
       *
       *  The output precision is given by io.precision().  This precision is
       *  capped at numeric_limits::digits10 + 2 (different for double and
       *  long double).  The default precision is 6.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showpoint is set, a decimal point will always be
       *  output.
       *
       *  Thousands separators are inserted according to numpunct::grouping()
       *  and numpunct::thousands_sep().  The decimal point character used is
       *  numpunct::decimal_point().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      //@}

      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the pointer value @a v and inserts it into a stream.  It
       *  does so by calling num_put::do_put().
       *
       *  This function formats @a v as an unsigned long with ios_base::hex
       *  and ios_base::showbase set.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;

      /// Destructor.
      virtual
      ~num_put() { };

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  These functions do the work of formatting numeric values and
       *  inserting them into a stream. This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  s  Stream to write to.
       *  @param  io  Source of locale and flags.
       *  @param  fill  Char_type to use for filling.
       *  @param  v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      // XXX GLIBCXX_ABI Deprecated




      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;

      // XXX GLIBCXX_ABI Deprecated




      //@}
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;



  // Subclause convenience interfaces, inlines.
  // NB: These are inline because, when used in a loop, some compilers
  // can hoist the body out of the loop; then it's just as fast as the
  // C is*() function.

  /// Convenience interface to ctype.is(ctype_base::space, __c).
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  /// Convenience interface to ctype.is(ctype_base::print, __c).
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  /// Convenience interface to ctype.is(ctype_base::cntrl, __c).
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  /// Convenience interface to ctype.is(ctype_base::upper, __c).
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  /// Convenience interface to ctype.is(ctype_base::lower, __c).
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  /// Convenience interface to ctype.is(ctype_base::alpha, __c).
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  /// Convenience interface to ctype.is(ctype_base::digit, __c).
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  /// Convenience interface to ctype.is(ctype_base::punct, __c).
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  /// Convenience interface to ctype.is(ctype_base::xdigit, __c).
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  /// Convenience interface to ctype.is(ctype_base::alnum, __c).
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  /// Convenience interface to ctype.is(ctype_base::graph, __c).
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  /// Convenience interface to ctype.toupper(__c).
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  /// Convenience interface to ctype.tolower(__c).
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_facets.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  // Routine to access a cache for the facet.  If the cache didn't
  // exist before, it gets constructed on the fly.
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };

  // Specializations.
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
                         ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      if (true)
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      if (false)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
                          ;
 }
    }

  // Used by both numeric and monetary facets.
  // Check to make sure that the __grouping_tmp string constructed in
  // money_get or num_get matches the canonical grouping for a given
  // locale.
  // __grouping_tmp is parsed L to R
  // 1,222,444 == __grouping_tmp of "\1\3\3"
  // __grouping is parsed R to L
  // 1,222,444 == __grouping of "\3" == "\3\3\3"
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();

      // True if __beg becomes equal to __end.
      bool __testeof = __beg == __end;

      // First check for sign.
      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }

      // Next, look for leading zeros.
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }

      // Only need acceptable digits for floating point numbers.
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)
 // "C" locale
 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {
  // Scientific notation.
  __xtrc += 'e';
  __found_sci = true;

  // Remove optional plus or minus sign, if they exist.
  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {
     // According to 22.2.2.1.2, p8-9, first look for thousands_sep
     // and decimal_point.
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {
      // NB: Thousands separator at the beginning of a string
      // is a no-no, as is two consecutive thousands separators.
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   // NB: __convert_to_v will not assign __v and will
   // set the failbit.
   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {
      // If no grouping chars are seen, no grouping check
      // is applied. Therefore __found_grouping is adjusted
      // only if decimal_point comes after some thousands_sep.
      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {
      // Scientific notation.
      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;

      // Remove optional plus or minus sign, if they exist.
      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }

      // Digit grouping is checked. If grouping and found_grouping don't
      // match, then get very very upset, and set failbit.
      if (__found_grouping.size())
        {
          // Add the ending grouping if a decimal or 'e'/'E' wasn't found.
   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();

 // NB: Iff __basefield == 0, __base can change based on contents.
 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);

 // True if __beg becomes equal to __end.
 bool __testeof = __beg == __end;

 // First check for sign.
 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }

 // Next, look for leading zeros and check required digits
 // for base formats.
 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }

 // At this point, base is determined. If not hex, only allow
 // base digits as valid input.
 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);

 // Extract.
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)
   // "C" locale
   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {
       // According to 22.2.2.1.2, p8-9, first look for thousands_sep
       // and decimal_point.
       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {
    // NB: Thousands separator at the beginning of a string
    // is a no-no, as is two consecutive thousands separators.
    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }

 // Digit grouping is checked. If grouping and found_grouping don't
 // match, then get very very upset, and set failbit.
 if (__found_grouping.size())
   {
     // Add the ending grouping.
     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }

 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 23. Num_get overflow result.
 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 17.  Bad bool parsing
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
   // Parse bool values as long.
          // NB: We can't just call do_get(long) here, as it might
          // refer to a derived class.
   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 23. Num_get overflow result.
       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {
   // Parse bool values as alphanumeric.
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 23. Num_get overflow result.
       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 731 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
 template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
      // Prepare for hex formatted input.
      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);

      // Reset from hex formatted input.
      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }

  // For use by integer and floating-point types after they have been
  // converted into a char_type string.
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {
      // [22.2.2.2.2] Stage 3.
      // If necessary, pad.
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {
   // Decimal.
   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {
   // Octal.
   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {
   // Hex.
   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();

 // Long enough to hold hex, dec, and octal representations.
 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));

 // [22.2.2.2.2] Stage 1, numeric conversion to character.
 // Result is returned right-justified in the buffer.
 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;

 // Add grouping, if necessary.
 if (__lc->_M_use_grouping)
   {
     // Grouping can add (almost) as many separators as the number
     // of digits + space is reserved for numeric base or sign.
     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }

 // Complete Stage 1, prepend numeric base or sign.
 if (__builtin_expect(__dec, true))
   {
     // Decimal.
     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {
  // 'x' or 'X'
  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];
  // '0'
  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }

 // Pad.
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);

 // [22.2.2.2.2] Stage 4.
 // Write resulting, fully-formatted string to output iterator.
 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 282. What types does numpunct grouping refer to?
      // Add grouping, if necessary.
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);

      // Tack on decimal part.
      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }

  // The following code uses vsnprintf (or vsprintf(), when
  // _GLIBCXX_USE_C99 is not defined) to convert floating point values
  // for insertion into a stream.  An optimization would be to replace
  // them with code that works directly on a wide buffer and then use
  // __pad to do the padding.  It would be good to replace them anyway
  // to gain back the efficiency that C++ provides by knowing up front
  // the type of the values to insert.  Also, sprintf is dangerous
  // since may lead to accidental buffer overruns.  This
  // implementation follows the C++ standard fairly directly as
  // outlined in 22.2.2.2 [lib.locale.num.put]
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);

 // Use default precision if out of range.
 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;

 // [22.2.2.2.2] Stage 1, numeric conversion to character.
 int __len;
 // Long enough for the max format spec.
 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);


 // First try a buffer perhaps big enough (most probably sufficient
 // for non-ios_base::fixed outputs)
 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);

 // If the buffer was not large enough, try again with the correct size.
 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1026 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
 // [22.2.2.2.2] Stage 2, convert to char_type, using correct
 // numpunct.decimal_point() values for '.' and adding grouping.
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);

 // Replace decimal point.
 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }

 // Add grouping, if necessary.
 // N.B. Make sure to not group things like 2e20, i.e., no decimal
 // point, scientific notation.
 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {
     // Grouping can add (almost) as many separators as the
     // number of digits, but no more.
     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }

 // Pad.
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);

 // [22.2.2.2.2] Stage 4.
 // Write resulting, fully-formatted string to output iterator.
 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1153 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.tcc" 3
 template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }



  // Construct correctly padded string, as per 22.2.2.2.2
  // Assumes
  // __newlen > __oldlen
  // __news is allocated for __newlen size

  // NB: Of the two parameters, _CharT can be deduced from the
  // function arguments. The other (_Traits) has to be explicitly specified.
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

      // Padding last.
      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {
   // Pad after the sign, if there is one.
   // Pad after 0[xX], if there is one.
   // Who came up with these rules, anyway? Jeeze.
          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   // else Padding first.
 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




} // namespace
# 2608 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/locale_facets.h" 2 3
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }

  // 27.4.5  Template class basic_ios
  /**
   *  @brief  Virtual base class for all stream classes.
   *  @ingroup io
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
  */
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependant on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      //@}

      //@{
      /**
       *  These are non-standard types.
      */
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;
      //@}

      // Data members:
    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;

      // Cached use_facet<ctype>, which is based on the current locale info.
      const __ctype_type* _M_ctype;
      // For ostream.
      const __num_put_type* _M_num_put;
      // For istream.
      const __num_get_type* _M_num_get;

    public:
      //@{
      /**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
      */
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
      //@}

      /**
       *  @brief  Returns the error state of the stream buffer.
       *  @return  A bit pattern (well, isn't everything?)
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      */
      iostate
      rdstate() const
      { return _M_streambuf_state; }

      /**
       *  @brief  [Re]sets the error state.
       *  @param  state  The new state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will not need to pass an argument.
      */
      void
      clear(iostate __state = goodbit);

      /**
       *  @brief  Sets additional flags in the error state.
       *  @param  state  The additional state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.
      */
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }

      // Flip the internal state on for the proper state bits, then re
      // throws the propagated exception if bit also set in
      // exceptions().
      void
      _M_setstate(iostate __state)
      {
 // 27.6.1.2.1 Common requirements.
 // Turn this on without causing an ios::failure to be thrown.
 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
                          ;
      }

      /**
       *  @brief  Fast error checking.
       *  @return  True if no error flags are set.
       *
       *  A wrapper around rdstate.
      */
      bool
      good() const
      { return this->rdstate() == 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if the eofbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if either the badbit or the failbit is set.
       *
       *  Checking the badbit in fail() is historical practice.
       *  Note that other iostate flags may also be set.
      */
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if the badbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }

      /**
       *  @brief  Throwing exceptions on errors.
       *  @return  The current exceptions mask.
       *
       *  This changes nothing in the stream.  See the one-argument version
       *  of exceptions(iostate) for the meaning of the return value.
      */
      iostate
      exceptions() const
      { return _M_exception; }

      /**
       *  @brief  Throwing exceptions on errors.
       *  @param  except  The new exceptions mask.
       *
       *  By default, error flags are set silently.  You can set an
       *  exceptions mask for each stream; if a bit in the mask becomes set
       *  in the error flags, then an exception of type
       *  std::ios_base::failure is thrown.
       *
       *  If the error flag is already set when the exceptions mask is
       *  added, the exception is immediately thrown.  Try running the
       *  following under GCC 3.1 or later:
       *  @code
       *  #include <iostream>
       *  #include <fstream>
       *  #include <exception>
       *
       *  int main()
       *  {
       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
       *
       *      std::ifstream f ("/etc/motd");
       *
       *      std::cerr << "Setting badbit\n";
       *      f.setstate (std::ios_base::badbit);
       *
       *      std::cerr << "Setting exception mask\n";
       *      f.exceptions (std::ios_base::badbit);
       *  }
       *  @endcode
      */
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }

      // Constructor/destructor:
      /**
       *  @brief  Constructor performs initialization.
       *
       *  The parameter is passed by derived streams.
      */
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }

      /**
       *  @brief  Empty.
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }

      // Members:
      /**
       *  @brief  Fetches the current @e tied stream.
       *  @return  A pointer to the tied stream, or NULL if the stream is
       *           not tied.
       *
       *  A stream may be @e tied (or synchronized) to a second output
       *  stream.  When this stream performs any I/O, the tied stream is
       *  first flushed.  For example, @c std::cin is tied to @c std::cout.
      */
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }

      /**
       *  @brief  Ties this stream to an output stream.
       *  @param  tiestr  The output stream.
       *  @return  The previously tied output stream, or NULL if the stream
       *           was not tied.
       *
       *  This sets up a new tie; see tie() for more.
      */
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }

      /**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current stream buffer.
       *
       *  This does not change the state of the stream.
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }

      /**
       *  @brief  Changing the underlying buffer.
       *  @param  sb  The new stream buffer.
       *  @return  The previous stream buffer.
       *
       *  Associates a new buffer with the current stream, and clears the
       *  error state.
       *
       *  Due to historical accidents which the LWG refuses to correct, the
       *  I/O library suffers from a design error:  this function is hidden
       *  in derived classes by overrides of the zero-argument @c rdbuf(),
       *  which is non-virtual for hysterical raisins.  As a result, you
       *  must use explicit qualifications to access this function via any
       *  derived class.  For example:
       *
       *  @code
       *  std::fstream     foo;         // or some other derived type
       *  std::streambuf*  p = .....;
       *
       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
       *  @endcode
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);

      /**
       *  @brief  Copies fields of __rhs into this.
       *  @param  __rhs  The source values for the copies.
       *  @return  Reference to this object.
       *
       *  All fields of __rhs are copied into this object except that rdbuf()
       *  and rdstate() remain unchanged.  All values in the pword and iword
       *  arrays are copied.  Before copying, each callback is invoked with
       *  erase_event.  After copying, each (new) callback is invoked with
       *  copyfmt_event.  The final step is to copy exceptions().
      */
      basic_ios&
      copyfmt(const basic_ios& __rhs);

      /**
       *  @brief  Retrieves the @a empty character.
       *  @return  The current fill character.
       *
       *  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }

      /**
       *  @brief  Sets a new @a empty character.
       *  @param  ch  The new character.
       *  @return  The previous fill character.
       *
       *  The fill character is used to fill out space when P+ characters
       *  have been requested (e.g., via setw), Q characters are actually
       *  used, and Q<P.  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }

      // Locales:
      /**
       *  @brief  Moves to a new locale.
       *  @param  loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
       *  with this stream, calls that buffer's @c pubimbue(loc).
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      locale
      imbue(const locale& __loc);

      /**
       *  @brief  Squeezes characters.
       *  @param  c  The character to narrow.
       *  @param  dfault  The character to narrow.
       *  @return  The narrowed character.
       *
       *  Maps a character of @c char_type to a character of @c char,
       *  if possible.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }

      /**
       *  @brief  Widens characters.
       *  @param  c  The character to widen.
       *  @return  The widened character.
       *
       *  Maps a character of @c char to a character of @c char_type.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:
      // 27.4.5.1  basic_ios constructors
      /**
       *  @brief  Empty.
       *
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }

      /**
       *  @brief  All setup is performed here.
       *
       *  This is called from the public constructor.  It is not virtual and
       *  cannot be redefined.
      */
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 1 3
// basic_ios member functions -*- C++ -*-

// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
// 2009, 2010, 2011  Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_ios.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */
# 34 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 292. effects of a.copyfmt (a)
      if (this != &__rhs)
 {
   // Per 27.1.1, do not call imbue, yet must trash all caches
   // associated with imbue()

   // Alloc any new word array first, so if it fails we have "rollback".
   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];

   // Bump refs before doing callbacks, for safety.
   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();

   // NB: Don't want any added during above.
   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);

   // The next is required to be the last assignment.
   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  // Locales:
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
      // NB: This may be called more than once on the same object.
      ios_base::_M_init();

      // Cache locale data and specific facets used by iostreams.
      _M_cache_locale(_M_ios_locale);

      // NB: The 27.4.4.1 Postconditions Table specifies requirements
      // after basic_ios::init() has been called. As part of this,
      // fill() must return widen(' ') any time after init() has been
      // called, which needs an imbued ctype facet of char_type to
      // return without throwing an exception. Unfortunately,
      // ctype<char_type> is not necessarily a required facet, so
      // streams with char_type != [char, wchar_t] will not have it by
      // default. Because of this, the correct value for _M_fill is
      // constructed on the first call of fill(). That way,
      // unformatted input and output with non-required basic_ios
      // instantiations is possible even without imbuing the expected
      // ctype<char_type> facet.
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




} // namespace std
# 473 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/basic_ios.h" 2 3
# 45 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ios" 2 3
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  // [27.6.2.1] Template class basic_ostream
  /**
   *  @brief  Controlling output.
   *  @ingroup io
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  */
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios (27.4.4)):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;

      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;

      // [27.6.2.2] constructor/destructor
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }

      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_ostream() { }

      // [27.6.2.3] prefix/suffix
      class sentry;
      friend class sentry;

      // [27.6.2.5] formatted output
      // [27.6.2.5.3]  basic_ostream::operator<<
      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::endl and @c std::hex use these
       *  functions in constructs like "std::cout << std::endl".  For more
       *  information, see the iomanip header.
      */
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // DR 60. What is a formatted input function?
 // The inserters for manipulators are *not* formatted output functions.
 __pf(*this);
 return *this;
      }
      //@}

      // [27.6.2.5.2] arithmetic inserters
      /**
       *  @name Arithmetic Inserters
       *
       *  All the @c operator<< functions (aka <em>formatted output
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_ostream::sentry.
       *  This can have several effects, concluding with the setting of a
       *  status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Basic arithmetic inserters
       *  @param  A variable of builtin type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {
 // _GLIBCXX_RESOLVE_LIB_DEFECTS
 // 117. basic_ostream uses nonexistent num_put member functions.
 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }

      /**
       *  @brief  Extracting from another streambuf.
       *  @param  sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @a sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from @a sb and inserted into @c *this
       *  until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output sequence fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs while getting a character from @a sb, which
       *    sets failbit in the error state
       *
       *  If the function inserts no characters, failbit is set.
      */
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      //@}

      // [27.6.2.6] unformatted output functions
      /**
       *  @name Unformatted Output Functions
       *
       *  All the unformatted output functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_ostream::sentry.  This has several effects, concluding
       *  with the setting of a status flag; see the sentry documentation
       *  for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state.  If badbit is on in
       *  the stream's exceptions mask, the exception will be rethrown
       *  without completing its actions.
      */
      //@{
      /**
       *  @brief  Simple insertion.
       *  @param  c  The character to insert.
       *  @return  *this
       *
       *  Tries to insert @a c.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      put(char_type __c);

      // Core write functionality, without sentry.
      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }

      /**
       *  @brief  Character string insertion.
       *  @param  s  The array to insert.
       *  @param  n  Maximum number of characters to insert.
       *  @return  *this
       *
       *  Characters are copied from @a s and inserted into the stream until
       *  one of the following happens:
       *
       *  - @a n characters are inserted
       *  - inserting into the output sequence fails (in this case, badbit
       *    will be set in the stream's error state)
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      //@}

      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  *this
       *
       *  If @c rdbuf() is a null pointer, changes nothing.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit.
      */
      __ostream_type&
      flush();

      // [27.6.2.4] seek members
      /**
       *  @brief  Getting the current write position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
      */
      pos_type
      tellp();

      /**
       *  @brief  Changing the current write position.
       *  @param  pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
      */
      __ostream_type&
      seekp(pos_type);

      /**
       *  @brief  Changing the current write position.
       *  @param  off  A file offset object.
       *  @param  dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
      */
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };

  /**
   *  @brief  Performs setup work for output streams.
   *
   *  Objects of this class are created before all of the standard
   *  inserters are run.  It is responsible for <em>exception-safe prefix and
   *  suffix operations</em>.
  */
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
      // Data Members.
      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
      /**
       *  @brief  The constructor performs preparatory work.
       *  @param  os  The output stream to guard.
       *
       *  If the stream state is good (@a os.good() is true), then if the
       *  stream is tied to another output stream, @c is.tie()->flush()
       *  is called to synchronize the output sequences.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      */
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

      /**
       *  @brief  Possibly flushes the stream.
       *
       *  If @c ios_base::unitbuf is set in @c os.flags(), and
       *  @c std::uncaught_exception() is true, the sentry destructor calls
       *  @c flush() on the output stream.
      */
      ~sentry()
      {
 // XXX MT
 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {
     // Can't call flush directly or else will get into recursive lock.
     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }

      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */



      operator bool() const
      { return _M_ok; }
    };

  // [27.6.2.5.4] character insertion templates
  //@{
  /**
   *  @brief  Character inserters
   *  @param  out  An output stream.
   *  @param  c  A character.
   *  @return  out
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts a single character and any required
   *  padding (as determined by [22.2.2.2.2]).  @c out.width(0) is then
   *  called.
   *
   *  If @a c is of type @c char and the character type of the stream is not
   *  @c char, the character is widened before insertion.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }

  // Specialization
  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }

  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  //@}

  //@{
  /**
   *  @brief  String inserters
   *  @param  out  An output stream.
   *  @param  s  A character string.
   *  @return  out
   *  @pre  @a s must be a non-NULL pointer
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts @c traits::length(s) characters starting
   *  at @a s, widened if necessary, followed by any required padding (as
   *  determined by [22.2.2.2.2]).  @c out.width(0) is then called.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);

  // Partial specializations
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  //@}

  // [27.6.2.7] standard basic_ostream manipulators
  /**
   *  @brief  Write a newline and flush the stream.
   *
   *  This manipulator is often mistakenly used when a simple newline is
   *  desired, leading to poor buffering performance.  See
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }

  /**
   *  @brief  Write a null character into the output sequence.
   *
   *  <em>Null character</em> is @c CharT() by definition.  For CharT of @c char,
   *  this correctly writes the ASCII @c NUL character string terminator.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }

  /**
   *  @brief  Flushes the output stream.
   *
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 585 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 3
} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 1 3
// ostream classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ostream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */

//
// ISO C++ 14882: 27.6.2  Output streams
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
      // XXX MT
      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::put(char_type) is an unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::write(const char_type*, streamsize) is an
      // unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::flush() is *not* an unformatted output function.
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);

       // 129. Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 136.  seekp, seekg setting wrong streams?
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);

       // 129. Need error indication from seekp() and seekg()
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 167.  Improper use of traits_type::length()
   const size_t __clen = char_traits<char>::length(__s);
   if (true)
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   if (false)
     {
       __out._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




} // namespace std
# 588 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/ostream" 2 3
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 2 3
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 1 3
// Input streams -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

//
// ISO C++ 14882: 27.6.1  Input streams
//

/** @file include/istream
 *  This is a Standard C++ Library header.
 */
# 38 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  // [27.6.1.1] Template class basic_istream
  /**
   *  @brief  Controlling input.
   *  @ingroup io
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios (27.4.4)):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;

      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:
      // Data Members:
      /**
       *  The number of characters extracted in the previous unformatted
       *  function; see gcount().
      */
      streamsize _M_gcount;

    public:
      // [27.6.1.1.1] constructor/destructor
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }

      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }

      // [27.6.1.1.2] prefix/suffix
      class sentry;
      friend class sentry;

      // [27.6.1.2] formatted input
      // [27.6.1.2.3] basic_istream::operator>>
      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::ws and @c std::dec use these
       *  functions in constructs like 
       *  <code>std::cin >> std::ws</code>. 
       *  For more information, see the iomanip header.
      */
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
      //@}

      // [27.6.1.2.2] arithmetic extractors
      /**
       *  @name Arithmetic Extractors
       *
       *  All the @c operator>> functions (aka <em>formatted input
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_istream::sentry
       *  with the second argument (noskipws) set to false.  This has several
       *  effects, concluding with the setting of a status flag; see the
       *  sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Basic arithmetic extractors
       *  @param  A variable of builtin type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      */
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }

      /**
       *  @brief  Extracting into another streambuf.
       *  @param  sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @a sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from this stream and inserted into the
       *  @a sb streambuf until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs (and in this case is caught)
       *
       *  If the function inserts no characters, failbit is set.
      */
      __istream_type&
      operator>>(__streambuf_type* __sb);
      //@}

      // [27.6.1.3] unformatted input
      /**
       *  @brief  Character counting
       *  @return  The number of characters extracted by the previous
       *           unformatted input function dispatched for this stream.
      */
      streamsize
      gcount() const
      { return _M_gcount; }

      /**
       *  @name Unformatted Input Functions
       *
       *  All the unformatted input functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_istream::sentry with the second argument (noskipws)
       *  set to true.  This has several effects, concluding with the
       *  setting of a status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  The number of characters extracted is stored for later retrieval
       *  by gcount().
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */
      //@{
      /**
       *  @brief  Simple extraction.
       *  @return  A character, or eof().
       *
       *  Tries to extract a character.  If none are available, sets failbit
       *  and returns traits::eof().
      */
      int_type
      get();

      /**
       *  @brief  Simple extraction.
       *  @param  c  The character in which to store data.
       *  @return  *this
       *
       *  Tries to extract a character and store it in @a c.  If none are
       *  available, sets failbit and returns traits::eof().
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type& __c);

      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  s  Pointer to an array.
       *  @param  n  Maximum number of characters to store in @a s.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and stored into @a s until one of the
       *  following happens:
       *
       *  - @c n-1 characters are stored
       *  - the input sequence reaches EOF
       *  - the next character equals @a delim, in which case the character
       *    is not extracted
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
       *
       * In any case, a null character is stored into the next location in
       * the array.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);

      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  s  Pointer to an array.
       *  @param  n  Maximum number of characters to store in @a s.
       *  @return  *this
       *
       *  Returns @c get(s,n,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }

      /**
       *  @brief  Extraction into another streambuf.
       *  @param  sb  A streambuf in which to store data.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and inserted into @a sb until one of the
       *  following happens:
       *
       *  - the input sequence reaches EOF
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted)
       *  - the next character equals @a delim (in this case, the character
       *    is not extracted)
       *  - an exception occurs (and in this case is caught)
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
      */
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);

      /**
       *  @brief  Extraction into another streambuf.
       *  @param  sb  A streambuf in which to store data.
       *  @return  *this
       *
       *  Returns @c get(sb,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }

      /**
       *  @brief  String extraction.
       *  @param  s  A character array in which to store the data.
       *  @param  n  Maximum number of characters to extract.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts and stores characters into @a s until one of the
       *  following happens.  Note that these criteria are required to be
       *  tested in the order listed here, to allow an input line to exactly
       *  fill the @a s array without setting failbit.
       *
       *  -# the input sequence reaches end-of-file, in which case eofbit
       *     is set in the stream error state
       *  -# the next character equals @c delim, in which case the character
       *     is extracted (and therefore counted in @c gcount()) but not stored
       *  -# @c n-1 characters are stored, in which case failbit is set
       *     in the stream error state
       *
       *  If no characters are extracted, failbit is set.  (An empty line of
       *  input should therefore not cause failbit to be set.)
       *
       *  In any case, a null character is stored in the next location in
       *  the array.
      */
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);

      /**
       *  @brief  String extraction.
       *  @param  s  A character array in which to store the data.
       *  @param  n  Maximum number of characters to extract.
       *  @return  *this
       *
       *  Returns @c getline(s,n,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }

      /**
       *  @brief  Discarding characters
       *  @param  n  Number of characters to discard.
       *  @param  delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts characters and throws them away until one of the
       *  following happens:
       *  - if @a n @c != @c std::numeric_limits<int>::max(), @a n
       *    characters are extracted
       *  - the input sequence reaches end-of-file
       *  - the next character equals @a delim (in this case, the character
       *    is extracted); note that this condition will never occur if
       *    @a delim equals @c traits::eof().
       *
       *  NB: Provide three overloads, instead of the single function
       *  (with defaults) mandated by the Standard: this leads to a
       *  better performing implementation, while still conforming to
       *  the Standard.
      */
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);

      /**
       *  @brief  Looking ahead in the stream
       *  @return  The next character, or eof().
       *
       *  If, after constructing the sentry object, @c good() is false,
       *  returns @c traits::eof().  Otherwise reads but does not extract
       *  the next input character.
      */
      int_type
      peek();

      /**
       *  @brief  Extraction without delimiters.
       *  @param  s  A character array.
       *  @param  n  Maximum number of characters to store.
       *  @return  *this
       *
       *  If the stream state is @c good(), extracts characters and stores
       *  them into @a s until one of the following happens:
       *  - @a n characters are stored
       *  - the input sequence reaches end-of-file, in which case the error
       *    state is set to @c failbit|eofbit.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      read(char_type* __s, streamsize __n);

      /**
       *  @brief  Extraction until the buffer is exhausted, but no more.
       *  @param  s  A character array.
       *  @param  n  Maximum number of characters to store.
       *  @return  The number of characters extracted.
       *
       *  Extracts characters and stores them into @a s depending on the
       *  number of characters remaining in the streambuf's buffer,
       *  @c rdbuf()->in_avail(), called @c A here:
       *  - if @c A @c == @c -1, sets eofbit and extracts no characters
       *  - if @c A @c == @c 0, extracts no characters
       *  - if @c A @c > @c 0, extracts @c min(A,n)
       *
       *  The goal is to empty the current buffer, and to not request any
       *  more from the external input sequence controlled by the streambuf.
      */
      streamsize
      readsome(char_type* __s, streamsize __n);

      /**
       *  @brief  Unextracting a single character.
       *  @param  c  The character to push back into the input stream.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
       *
       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      */
      __istream_type&
      putback(char_type __c);

      /**
       *  @brief  Unextracting the previous character.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
       *
       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      */
      __istream_type&
      unget();

      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  0 on success, -1 on failure
       *
       *  If @c rdbuf() is a null pointer, returns -1.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit and returns -1.
       *
       *  Otherwise, returns 0.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      int
      sync();

      /**
       *  @brief  Getting the current read position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().  At variance with putback, unget and
       *         seekg, eofbit is not cleared first.
      */
      pos_type
      tellg();

      /**
       *  @brief  Changing the current read position.
       *  @param  pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      */
      __istream_type&
      seekg(pos_type);

      /**
       *  @brief  Changing the current read position.
       *  @param  off  A file offset object.
       *  @param  dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      */
      __istream_type&
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };

  // Explicit specialization declarations, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);


  /**
   *  @brief  Performs setup work for input streams.
   *
   *  Objects of this class are created before all of the standard
   *  extractors are run.  It is responsible for <em>exception-safe
   *  prefix and suffix operations,</em> although only prefix actions
   *  are currently required by the standard.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
      // Data Members.
      bool _M_ok;

    public:
      /// Easy access to dependant types.
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;

      /**
       *  @brief  The constructor performs all the work.
       *  @param  is  The input stream to guard.
       *  @param  noskipws  Whether to consume whitespace or not.
       *
       *  If the stream state is good (@a is.good() is true), then the
       *  following actions are performed, otherwise the sentry state
       *  is false (<em>not okay</em>) and failbit is set in the
       *  stream state.
       *
       *  The sentry's preparatory actions are:
       *
       *  -# if the stream is tied to an output stream, @c is.tie()->flush()
       *     is called to synchronize the output sequence
       *  -# if @a noskipws is false, and @c ios_base::skipws is set in
       *     @c is.flags(), the sentry extracts and discards whitespace
       *     characters from the stream.  The currently imbued locale is
       *     used to determine whether each character is whitespace.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      */
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);

      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */



      operator bool() const
      { return _M_ok; }
    };

  // [27.6.1.2.3] character extraction templates
  //@{
  /**
   *  @brief  Character extractors
   *  @param  in  An input stream.
   *  @param  c  A character reference.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts a character (if one is available) and
   *  stores it in @a c.  Otherwise, sets failbit in the input stream.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  //@}

  //@{
  /**
   *  @brief  Character string extractors
   *  @param  in  An input stream.
   *  @param  s  A pointer to a character array.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts up to @c n characters and stores them
   *  into the array starting at @a s.  @c n is defined as:
   *
   *  - if @c width() is greater than zero, @c n is width() otherwise
   *  - @c n is <em>the number of elements of the largest array of *
   *  - @c char_type that can store a terminating @c eos.</em>
   *  - [27.6.1.2.3]/6
   *
   *  Characters are extracted and stored until one of the following happens:
   *  - @c n-1 characters are stored
   *  - EOF is reached
   *  - the next character is whitespace according to the current locale
   *  - the next character is a null byte (i.e., @c charT() )
   *
   *  @c width(0) is then called for the input stream.
   *
   *  If no characters are extracted, sets failbit.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  // Explicit specialization declaration, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  //@}

  // 27.6.1.5 Template class basic_iostream
  /**
   *  @brief  Merging istream and ostream capabilities.
   *  @ingroup io
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
  */
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 271. basic_iostream missing typedefs
      // Types (inherited):
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;

      // Non-standard Types:
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;

      /**
       *  @brief  Constructor does nothing.
       *
       *  Both of the parent classes are initialized with the same
       *  streambuf pointer passed to this constructor.
      */
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }

      /**
       *  @brief  Destructor does nothing.
      */
      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };

  // [27.6.1.4] standard basic_istream manipulators
  /**
   *  @brief  Quick and easy way to eat whitespace
   *
   *  This manipulator extracts whitespace characters, stopping when the
   *  next character is non-whitespace, or when the input sequence is empty.
   *  If the sequence is empty, @c eofbit is set in the stream, but not
   *  @c failbit.
   *
   *  The current locale is used to distinguish whitespace characters.
   *
   *  Example:
   *  @code
   *     MyClass   mc;
   *
   *     std::cin >> std::ws >> mc;
   *  @endcode
   *  will skip leading whitespace before calling operator>> on cin and your
   *  object.  Note that the same effect can be achieved by creating a
   *  std::basic_istream::sentry inside your definition of operator>>.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 856 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 3
} // namespace



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 1 3
// istream classes -*- C++ -*-

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/istream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{istream}
 */

//
// ISO C++ 14882: 27.6.1  Input streams
//
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();

       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 195. Should basic_istream::sentry's constructor ever
       // set eofbit?
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);

       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 696. istream::operator>>(int&) broken.
       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);

       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 696. istream::operator>>(int&) broken.
       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::failbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();
       // 27.6.1.1 paragraph 3
       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();
       // 27.6.1.1 paragraph 3
       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }

  // We provide three overloads, since the first two are much simpler
  // than the general case. Also, the latter two can thus adopt the
  // same "batchy" strategy used by getline above.
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

       // N.B. On LFS-enabled platforms streamsize is still 32 bits
       // wide: if we want to implement the standard mandated behavior
       // for n == max() (see 27.6.1.3/24) we are at risk of signed
       // integer overflow: thus these contortions. Also note that,
       // by definition, when more than 2G chars are actually ignored,
       // _M_gcount (the return value of gcount, that is) cannot be
       // really correct, being unavoidably too small.
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

       // See comment above.
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       // Cannot compare int_type with streamsize generically.
       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {
    // 136.  seekp, seekg setting wrong streams?
    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);

    // 129.  Need error indication from seekp() and seekg()
    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {
    // 136.  seekp, seekg setting wrong streams?
    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);

    // 129.  Need error indication from seekp() and seekg()
    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  // 27.6.1.2.3 Character extraction templates
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {
       // Figure out how many characters to extract.
       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;

       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 68.  Extractors for char* should store null at end
       *__s = char_type();
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  // 27.6.1.4 Standard basic_istream manipulators
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.

  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




} // namespace std
# 859 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/istream" 2 3
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @name Standard Stream Objects
   *
   *  The &lt;iostream&gt; header declares the eight <em>standard stream
   *  objects</em>.  For other declarations, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch24.html
   *  and the @link iosfwd I/O forward declarations @endlink
   *
   *  They are required by default to cooperate with the global C
   *  library's @c FILE streams, and to be available during program
   *  startup and termination. For more information, see the HOWTO
   *  linked to above.
  */
  //@{
  extern istream cin; /// Linked to standard input
  extern ostream cout; /// Linked to standard output
  extern ostream cerr; /// Linked to standard error (unbuffered)
  extern ostream clog; /// Linked to standard error (buffered)


  extern wistream wcin; /// Linked to standard input
  extern wostream wcout; /// Linked to standard output
  extern wostream wcerr; /// Linked to standard error (unbuffered)
  extern wostream wclog; /// Linked to standard error (buffered)

  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;


} // namespace
# 9 "optical_flow.cpp" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2011-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/*
 * HLS Video Header File
 */
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h"
/* for safety*/






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/*
 * HLS AXI I/O Function Header File
 */






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_axi_sdata.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 *****************************************************************************/

/*
 * This file contains the definition of the data types for AXI streaming. 
 * ap_axi_s is a signed interpretation of the AXI stream
 * ap_axi_u is an unsigned interpretation of the AXI stream
 */






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int.h" 1
// -*- c++ -*-
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 */
# 60 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_half.h" 1
// half - IEEE 754-based half-precision floating point library.
//
// Copyright (c) 2012-2013 Christian Rau <rauy@users.sourceforge.net>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation 
// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// Version 1.11.0

/// \file
/// Main header file for half precision functionality.
# 32 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_half.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 1 3
// -*- C++ -*- C forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010, 2011
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cmath
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c math.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 26.5  C library
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3




extern "C" {

# 1 "/usr/include/math.h" 1 3 4
/* Declarations for math functions.
   Copyright (C) 1991-1993, 1995-1999, 2001, 2002, 2004, 2006, 2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */






extern "C" {

/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */


# 1 "/usr/include/bits/huge_val.h" 1 3 4
/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
/* Default `HUGE_VALL' constant.
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1996, 1997, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 38 "/usr/include/math.h" 2 3 4

/* Get machine-dependent INFINITY value.  */


# 1 "/usr/include/bits/inf.h" 1 3 4
/* `INFINITY' constant for IEEE 754 machines.
   Copyright (C) 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity.  */
# 41 "/usr/include/math.h" 2 3 4

/* Get machine-dependent NAN value (returned for some domain errors).  */


# 1 "/usr/include/bits/nan.h" 1 3 4
/* `NAN' constant for IEEE 754 machines.
   Copyright (C) 1992,1996,1997,1999,2004,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* IEEE Not A Number.  */
# 44 "/usr/include/math.h" 2 3 4


/* Get general and ISO C99 specific information.  */


# 1 "/usr/include/bits/mathdef.h" 1 3 4
/* Copyright (C) 2001, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 27 "/usr/include/bits/mathdef.h" 2 3 4


/* The x86-64 architecture computes values with the precission of the
   used type.  Similarly for -m32 -mfpmath=sse.  */
typedef float float_t; /* `float' expressions are evaluated as `float'.  */
typedef double double_t; /* `double' expressions are evaluated
				   as `double'.  */
# 44 "/usr/include/bits/mathdef.h" 3 4
/* The values returned by `ilogb' for 0 and NaN respectively.  */
# 48 "/usr/include/math.h" 2 3 4

/* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();
/* Arc sine of X.  */
extern double asin (double __x) throw (); extern double __asin (double __x) throw ();
/* Arc tangent of X.  */
extern double atan (double __x) throw (); extern double __atan (double __x) throw ();
/* Arc tangent of Y/X.  */
extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();

/* Cosine of X.  */
extern double cos (double __x) throw (); extern double __cos (double __x) throw ();
/* Sine of X.  */
extern double sin (double __x) throw (); extern double __sin (double __x) throw ();
/* Tangent of X.  */
extern double tan (double __x) throw (); extern double __tan (double __x) throw ();

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();
/* Hyperbolic sine of X.  */
extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();
/* Hyperbolic tangent of X.  */
extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



/* Cosine and sine of X.  */
extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();





/* Hyperbolic arc cosine of X.  */
extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();
/* Hyperbolic arc sine of X.  */
extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();
/* Hyperbolic arc tangent of X.  */
extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern double exp (double __x) throw (); extern double __exp (double __x) throw ();

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();

/* X times (two to the EXP power).  */
extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();

/* Natural logarithm of X.  */
extern double log (double __x) throw (); extern double __log (double __x) throw ();

/* Base-ten logarithm of X.  */
extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();

/* Break VALUE into integral and fractional parts.  */
extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();



/* A function missing in all standards: compute exponent to base ten.  */
extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();
/* Another name occasionally used.  */
extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();




/* Return exp(X) - 1.  */
extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();

/* Return log(1 + X).  */
extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();

/* Return the base 2 signed integral exponent of X.  */
extern double logb (double __x) throw (); extern double __logb (double __x) throw ();





/* Compute base-2 exponential of X.  */
extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();

/* Compute base-2 logarithm of X.  */
extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();




/* Power functions.  */


/* Return X to the Y power.  */
extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();

/* Return the square root of X.  */
extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();




/* Return `sqrt(X*X + Y*Y)'.  */
extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();





/* Return the cube root of X.  */
extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));

/* Absolute value of X.  */
extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinf (double __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finite (double __value) throw () __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinf (double __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finite (double __value) throw () __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern double significand (double __x) throw (); extern double __significand (double __x) throw ();




/* Return X with its signed changed to Y's.  */
extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnan (double __value) throw () __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnan (double __value) throw () __attribute__ ((__const__));

/* Bessel functions.  */
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





/* Error and gamma functions.  */
extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();





/* True gamma function.  */
extern double tgamma (double) throw (); extern double __tgamma (double) throw ();




/* Obsolete alias for `lgamma'.  */
extern double gamma (double) throw (); extern double __gamma (double) throw ();



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern double rint (double __x) throw (); extern double __rint (double __x) throw ();

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();


/* Return X times (2 to the Nth power).  */
extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();



/* Return X times (2 to the Nth power).  */
extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();


/* Return positive difference between X and Y.  */
extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();

/* Return maximum numeric value from X and Y.  */
extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();

/* Return minimum numeric value from X and Y.  */
extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();


/* Classify given number.  */
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();







/* Return X times (2 to the Nth power).  */
extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4








/* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  */
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();
/* Arc sine of X.  */
extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();
/* Arc tangent of X.  */
extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();
/* Arc tangent of Y/X.  */
extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();

/* Cosine of X.  */
extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();
/* Sine of X.  */
extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();
/* Tangent of X.  */
extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();
/* Hyperbolic sine of X.  */
extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();
/* Hyperbolic tangent of X.  */
extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



/* Cosine and sine of X.  */
extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();





/* Hyperbolic arc cosine of X.  */
extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();
/* Hyperbolic arc sine of X.  */
extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();
/* Hyperbolic arc tangent of X.  */
extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern float expf (float __x) throw (); extern float __expf (float __x) throw ();

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();

/* X times (two to the EXP power).  */
extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();

/* Natural logarithm of X.  */
extern float logf (float __x) throw (); extern float __logf (float __x) throw ();

/* Base-ten logarithm of X.  */
extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();

/* Break VALUE into integral and fractional parts.  */
extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();



/* A function missing in all standards: compute exponent to base ten.  */
extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();
/* Another name occasionally used.  */
extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();




/* Return exp(X) - 1.  */
extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();

/* Return log(1 + X).  */
extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();

/* Return the base 2 signed integral exponent of X.  */
extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();





/* Compute base-2 exponential of X.  */
extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();

/* Compute base-2 logarithm of X.  */
extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();




/* Power functions.  */


/* Return X to the Y power.  */
extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();

/* Return the square root of X.  */
extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();




/* Return `sqrt(X*X + Y*Y)'.  */
extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();





/* Return the cube root of X.  */
extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));

/* Absolute value of X.  */
extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinff (float __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitef (float __value) throw () __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinff (float __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitef (float __value) throw () __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();




/* Return X with its signed changed to Y's.  */
extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanf (float __value) throw () __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnanf (float __value) throw () __attribute__ ((__const__));

/* Bessel functions.  */
extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





/* Error and gamma functions.  */
extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();





/* True gamma function.  */
extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();




/* Obsolete alias for `lgamma'.  */
extern float gammaf (float) throw (); extern float __gammaf (float) throw ();



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();


/* Return X times (2 to the Nth power).  */
extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();



/* Return X times (2 to the Nth power).  */
extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();


/* Return positive difference between X and Y.  */
extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();

/* Return maximum numeric value from X and Y.  */
extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();

/* Return minimum numeric value from X and Y.  */
extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();


/* Classify given number.  */
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();







/* Return X times (2 to the Nth power).  */
extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();
/* Arc sine of X.  */
extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();
/* Arc tangent of X.  */
extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();
/* Arc tangent of Y/X.  */
extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();

/* Cosine of X.  */
extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();
/* Sine of X.  */
extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();
/* Tangent of X.  */
extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();
/* Hyperbolic sine of X.  */
extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();
/* Hyperbolic tangent of X.  */
extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



/* Cosine and sine of X.  */
extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();





/* Hyperbolic arc cosine of X.  */
extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();
/* Hyperbolic arc sine of X.  */
extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();
/* Hyperbolic arc tangent of X.  */
extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();

/* X times (two to the EXP power).  */
extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();

/* Natural logarithm of X.  */
extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();

/* Base-ten logarithm of X.  */
extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();

/* Break VALUE into integral and fractional parts.  */
extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();



/* A function missing in all standards: compute exponent to base ten.  */
extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();
/* Another name occasionally used.  */
extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();




/* Return exp(X) - 1.  */
extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();

/* Return log(1 + X).  */
extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();

/* Return the base 2 signed integral exponent of X.  */
extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();





/* Compute base-2 exponential of X.  */
extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();

/* Compute base-2 logarithm of X.  */
extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();




/* Power functions.  */


/* Return X to the Y power.  */
extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();

/* Return the square root of X.  */
extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();




/* Return `sqrt(X*X + Y*Y)'.  */
extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();





/* Return the cube root of X.  */
extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));

/* Absolute value of X.  */
extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinfl (long double __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitel (long double __value) throw () __attribute__ ((__const__));



/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinfl (long double __value) throw () __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitel (long double __value) throw () __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();




/* Return X with its signed changed to Y's.  */
extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));





/* Return representation of NaN for double type.  */
extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern int isnanl (long double __value) throw () __attribute__ ((__const__));

/* Bessel functions.  */
extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





/* Error and gamma functions.  */
extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();





/* True gamma function.  */
extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();




/* Obsolete alias for `lgamma'.  */
extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();


/* Return X times (2 to the Nth power).  */
extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();



/* Return X times (2 to the Nth power).  */
extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();


/* Return positive difference between X and Y.  */
extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();

/* Return maximum numeric value from X and Y.  */
extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();

/* Return minimum numeric value from X and Y.  */
extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();


/* Classify given number.  */
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();







/* Return X times (2 to the Nth power).  */
extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 142 "/usr/include/math.h" 2 3 4
# 156 "/usr/include/math.h" 3 4
/* This variable is used by `gamma' and `lgamma'.  */
extern int signgam;



/* ISO C99 defines some generic macros which work on any data type.  */


/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions

    FLT_EVAL_METHOD
		Defined to
		  0	if `float_t' is `float' and `double_t' is `double'
		  1	if `float_t' and `double_t' are `double'
		  2	if `float_t' and `double_t' are `long double'
		  else	`float_t' and `double_t' are unspecified

    INFINITY	representation of the infinity value of type `float'

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.

    DECIMAL_DIG	Number of decimal digits supported by conversion between
		decimal and all internal floating-point formats.

*/

/* All floating-point numbers can be put in one of these categories.  */
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };

/* Return number of classification appropriate for X.  */
# 224 "/usr/include/math.h" 3 4
/* Return nonzero value if sign of X is negative.  */
# 236 "/usr/include/math.h" 3 4
/* Return nonzero value if X is not +-Inf or NaN.  */
# 248 "/usr/include/math.h" 3 4
/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */


/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */
# 264 "/usr/include/math.h" 3 4
/* Return nonzero value is X is positive or negative infinity.  */
# 276 "/usr/include/math.h" 3 4
/* Bitmasks for the math_errhandling macro.  */



/* By default all functions support both errno and exception handling.
   In gcc's fast math mode and if inline functions are defined this
   might not be true.  */







/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1, /* According to IEEE 754/IEEE 854.  */
  _SVID_, /* According to System V, release 4.  */
  _XOPEN_, /* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_ /* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
   to change the hardware FPU exception settings).  */
extern _LIB_VERSION_TYPE _LIB_VERSION;




/* In SVID error handling, `matherr' is called with this description
   of the exceptional condition.

   We have a problem when using C++ since `exception' is a reserved
   name in C++.  */

struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();






/* Types of exceptions in the `type' field.  */







/* SVID mode specifies returning this large value instead of infinity.  */
# 355 "/usr/include/math.h" 3 4
/* Some useful constants.  */
# 372 "/usr/include/math.h" 3 4
/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
# 392 "/usr/include/math.h" 3 4
/* When compiling in strict ISO C compatible mode we must not use the
   inline functions since they, among other things, do not set the
   `errno' variable correctly.  */





/* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in before 3.0.0, but not all cpus added their patterns.  We define
   versions that use the builtins here, and <bits/mathinline.h> will
   undef/redefine as appropriate for the specific GCC version in use.  */
# 414 "/usr/include/math.h" 3 4
/* Get machine-dependent inline versions (if there are any).  */





/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if X is greater than Y.  */







/* Return nonzero value if X is greater than or equal to Y.  */







/* Return nonzero value if X is less than Y.  */







/* Return nonzero value if X is less than or equal to Y.  */







/* Return nonzero value if either X is less than Y or Y is less than X.  */







/* Return nonzero value if arguments are unordered.  */
# 472 "/usr/include/math.h" 3 4
}
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 2 3
}
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath"





// Get rid of those macros defined in <math.h> in lieu of real functions.
# 76 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }


  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 550. What should the return type of pow(float,int) be?
  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


} // namespace




// These are possible macros imported from C99-land.
# 480 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 730 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cmath" 3
 template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




} // namespace
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_half.h" 2
using std::fpclassify;
using std::isfinite;




using std::isinf;
using std::isnan;

using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



//#error hls_half simulation header file is not applicable for synthesis (synthesis header to be added)
typedef __fp16 half;
# 3272 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_half.h"
// implemented in lib_hlsm.cpp
//extern int __signbit(half a_re);
extern half half_nan(const char *tagp);
// extern int __isfinite(half t_in);
// extern int __isinf(half t_in);
// extern int __isnan(half t_in);
// extern int __isnormal(half t_in);
// extern int __fpclassify(half t_in);
extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);
//extern half copysign(half x, half y);
extern half half_fabs(half x);
//extern half fabs(half x);
extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);
//extern half fmax(half x, half y);
extern half half_fmin(half x, half y);
//extern half fmin(half x, half y);
extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern int half_ilogb(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);
//half floor(half x)
extern half half_ceil(half x);
//half ceil(half x)
extern half half_trunc(half x);
// half trunc(half x)
extern half half_round(half x);
//half round(half x)
extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);
// half modf(half x, half *intpart)
extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 61 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h" 1
/* -*- c++ -*-*/
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 */
# 73 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/limits.h" 1 3
/*===---- limits.h - Standard header for integer sizes --------------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/




/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
   Avert this #include_next madness. */




/* System headers include a number of constants from POSIX in <limits.h>.
   Include it if we're hosted. */




# 1 "/usr/include/limits.h" 1 3 4
/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */







/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */



/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
# 118 "/usr/include/limits.h" 3 4
 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */





/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */
# 144 "/usr/include/limits.h" 3 4
/* POSIX adds things to <limits.h>.  */


# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-1993,96,98,2000-2003,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */





/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */


/* Minimal number of outstanding asynchronous I/O operations.  */


/* Maximum length of arguments to `execve', including environment.  */


/* Maximum simultaneous processes per real user ID.  */






/* Minimal number of timer expiration overruns.  */


/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */


/* Maximum link count of a file.  */


/* Maximum length of login name.  */


/* Number of bytes in a terminal canonical input queue.  */


/* Number of bytes for which space will be
   available in a terminal input queue.  */


/* Maximum number of message queues open for a process.  */


/* Maximum number of supported message priorities.  */


/* Number of bytes in a filename.  */


/* Number of simultaneous supplementary group IDs per process.  */






/* Number of files one process can have open at once.  */







/* Number of descriptors that a process may examine with `pselect' or
   `select'.  */



/* Number of bytes in a pathname.  */


/* Number of bytes than can be written atomically to a pipe.  */


/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */


/* Minimal number of realtime signals reserved for the application.  */


/* Number of semaphores a process can have.  */


/* Maximal value of a semaphore.  */


/* Number of pending realtime signals.  */


/* Largest value of a `ssize_t'.  */


/* Number of streams a process can have open at once.  */


/* The number of bytes in a symbolic link.  */


/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */


/* Number of timer for a process.  */


/* Maximum number of characters in a tty name.  */


/* Maximum length of a timezone name (element of `tzname').  */



/* Maximum number of connections that can be queued on a socket.  */


/* Maximum number of bytes that can be buffered on a socket for send
   or receive.  */


/* Maximum number of elements in an `iovec' array.  */



/* Maximum clock resolution in nanoseconds.  */



/* Get the implementation-specific values for the above.  */


# 1 "/usr/include/bits/local_lim.h" 1 3 4
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-1998,2000,2002-2004,2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */
# 38 "/usr/include/bits/local_lim.h" 3 4
/* The kernel sources contain a file with all the needed information.  */


# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4

/* Have to remove NR_OPEN?  */




/* Have to remove LINK_MAX?  */




/* Have to remove OPEN_MAX?  */




/* Have to remove ARG_MAX?  */





/* The number of data keys per process.  */

/* This is the value this implementation supports.  */


/* Controlling the iterations of destructors for thread-specific data.  */

/* Number of iterations this implementation does.  */


/* The number of threads per process.  */

/* We have no predefined limit on the number of threads.  */


/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */


/* Minimum size for a thread.  We are free to choose a reasonable value.  */


/* Maximum number of timer expiration overruns.  */


/* Maximum tty name length.  */


/* Maximum login name length.  This is arbitrary.  */


/* Maximum host name length.  */


/* Maximum message queue priority level.  */


/* Maximum value the semaphore can have.  */
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4







/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
/* Copyright (C) 1991, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */





/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */


/* The maximum number of elements allowed in an array by the `bc' utility.  */


/* The maximum `scale' value allowed by the `bc' utility.  */


/* The maximum length of a string constant accepted by the `bc' utility.  */


/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */


/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */


/* The maximum length, in bytes, of an input line.  */


/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */


/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */



/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */
# 88 "/usr/include/bits/posix2_lim.h" 3 4
/* This value is defined like this in regex.h.  */
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <limits.h> instead.
 */

/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  */







# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4

/* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*/


/* Maximum number of `iovec' structures that one process has available
   for use with `readv' or writev'.  */



/* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  */


/* Maximum number of bytes in a `LANG' name.  We have no limit.  */


/* Maximum message number.  We have no limit.  */


/* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  */


/* Maximum set number.  We have no limit.  */


/* Maximum number of bytes in a message.  We have no limit.  */


/* Default process priority.  */



/* Number of bits in a word of type `int'.  */
# 120 "/usr/include/bits/xopen_lim.h" 3 4
/* Number of bits in a word of type `long int'.  */
# 132 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
# 154 "/usr/include/limits.h" 2 3 4
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/limits.h" 2 3


/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
# 60 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/limits.h" 3
/* C90/99 5.2.4.2.1 */
# 90 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/limits.h" 3
/* C99 5.2.4.2.1: Added long long. */
# 102 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/limits.h" 3
/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
   that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
# 74 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h" 2






/* for safety*/




/* for safety*/




/*for safety*/
# 111 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 typedef unsigned long long ap_ulong;
    typedef signed long long ap_slong;
# 129 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
/*support SC mode*/
# 147 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
extern "C" void _ssdm_string2bits(...);
//#ifdef C99STRING






/* Basic AP data types.
 ----------------------------------------------------------------
*/
template<int _AP_N, bool _AP_S> struct ssdm_int;
# 184 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_dt.def" 1


template<> struct ssdm_int<1 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<2 + 1024 * 0,true> { int V __attribute__ ((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<2 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(2 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<2 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<3 + 1024 * 0,true> { int V __attribute__ ((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<3 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(3 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<3 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<4 + 1024 * 0,true> { int V __attribute__ ((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<4 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(4 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<4 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<5 + 1024 * 0,true> { int V __attribute__ ((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<5 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(5 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<5 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<6 + 1024 * 0,true> { int V __attribute__ ((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<6 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(6 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<6 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<7 + 1024 * 0,true> { int V __attribute__ ((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<7 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(7 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<7 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<8 + 1024 * 0,true> { int V __attribute__ ((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<8 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(8 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<8 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<9 + 1024 * 0,true> { int V __attribute__ ((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<9 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(9 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<9 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<10 + 1024 * 0,true> { int V __attribute__ ((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<10 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(10 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<10 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<11 + 1024 * 0,true> { int V __attribute__ ((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<11 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(11 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<11 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<12 + 1024 * 0,true> { int V __attribute__ ((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<12 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(12 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<12 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<13 + 1024 * 0,true> { int V __attribute__ ((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<13 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(13 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<13 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<14 + 1024 * 0,true> { int V __attribute__ ((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<14 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(14 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<14 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<15 + 1024 * 0,true> { int V __attribute__ ((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<15 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(15 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<15 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<16 + 1024 * 0,true> { int V __attribute__ ((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<16 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(16 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<16 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<17 + 1024 * 0,true> { int V __attribute__ ((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<17 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(17 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<17 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<18 + 1024 * 0,true> { int V __attribute__ ((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<18 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(18 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<18 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<19 + 1024 * 0,true> { int V __attribute__ ((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<19 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(19 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<19 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<20 + 1024 * 0,true> { int V __attribute__ ((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<20 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(20 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<20 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<21 + 1024 * 0,true> { int V __attribute__ ((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<21 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(21 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<21 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<22 + 1024 * 0,true> { int V __attribute__ ((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<22 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(22 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<22 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<23 + 1024 * 0,true> { int V __attribute__ ((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<23 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(23 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<23 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<24 + 1024 * 0,true> { int V __attribute__ ((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<24 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(24 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<24 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<25 + 1024 * 0,true> { int V __attribute__ ((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<25 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(25 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<25 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<26 + 1024 * 0,true> { int V __attribute__ ((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<26 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(26 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<26 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<27 + 1024 * 0,true> { int V __attribute__ ((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<27 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(27 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<27 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<28 + 1024 * 0,true> { int V __attribute__ ((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<28 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(28 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<28 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<29 + 1024 * 0,true> { int V __attribute__ ((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<29 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(29 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<29 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<30 + 1024 * 0,true> { int V __attribute__ ((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<30 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(30 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<30 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<31 + 1024 * 0,true> { int V __attribute__ ((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<31 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(31 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<31 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<32 + 1024 * 0,true> { int V __attribute__ ((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<32 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(32 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<32 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<33 + 1024 * 0,true> { int V __attribute__ ((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<33 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(33 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<33 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<34 + 1024 * 0,true> { int V __attribute__ ((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<34 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(34 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<34 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<35 + 1024 * 0,true> { int V __attribute__ ((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<35 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(35 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<35 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<36 + 1024 * 0,true> { int V __attribute__ ((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<36 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(36 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<36 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<37 + 1024 * 0,true> { int V __attribute__ ((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<37 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(37 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<37 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<38 + 1024 * 0,true> { int V __attribute__ ((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<38 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(38 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<38 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<39 + 1024 * 0,true> { int V __attribute__ ((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<39 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(39 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<39 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<40 + 1024 * 0,true> { int V __attribute__ ((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<40 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(40 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<40 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<41 + 1024 * 0,true> { int V __attribute__ ((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<41 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(41 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<41 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<42 + 1024 * 0,true> { int V __attribute__ ((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<42 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(42 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<42 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<43 + 1024 * 0,true> { int V __attribute__ ((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<43 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(43 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<43 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<44 + 1024 * 0,true> { int V __attribute__ ((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<44 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(44 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<44 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<45 + 1024 * 0,true> { int V __attribute__ ((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<45 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(45 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<45 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<46 + 1024 * 0,true> { int V __attribute__ ((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<46 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(46 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<46 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<47 + 1024 * 0,true> { int V __attribute__ ((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<47 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(47 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<47 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<48 + 1024 * 0,true> { int V __attribute__ ((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<48 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(48 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<48 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<49 + 1024 * 0,true> { int V __attribute__ ((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<49 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(49 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<49 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<50 + 1024 * 0,true> { int V __attribute__ ((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<50 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(50 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<50 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<51 + 1024 * 0,true> { int V __attribute__ ((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<51 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(51 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<51 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<52 + 1024 * 0,true> { int V __attribute__ ((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<52 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(52 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<52 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<53 + 1024 * 0,true> { int V __attribute__ ((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<53 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(53 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<53 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<54 + 1024 * 0,true> { int V __attribute__ ((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<54 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(54 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<54 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<55 + 1024 * 0,true> { int V __attribute__ ((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<55 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(55 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<55 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<56 + 1024 * 0,true> { int V __attribute__ ((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<56 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(56 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<56 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<57 + 1024 * 0,true> { int V __attribute__ ((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<57 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(57 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<57 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<58 + 1024 * 0,true> { int V __attribute__ ((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<58 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(58 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<58 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<59 + 1024 * 0,true> { int V __attribute__ ((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<59 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(59 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<59 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<60 + 1024 * 0,true> { int V __attribute__ ((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<60 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(60 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<60 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<61 + 1024 * 0,true> { int V __attribute__ ((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<61 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(61 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<61 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<62 + 1024 * 0,true> { int V __attribute__ ((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<62 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(62 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<62 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<63 + 1024 * 0,true> { int V __attribute__ ((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<63 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(63 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<63 + 1024 * 0 , false>() { }; };


template<> struct ssdm_int<64 + 1024 * 0,true> { int V __attribute__ ((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<64 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(64 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<64 + 1024 * 0 , false>() { }; };


/*#if AUTOPILOT_VERSION >= 1 */

template<> struct ssdm_int<65 + 1024 * 0,true> { int V __attribute__ ((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<65 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(65 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<65 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<66 + 1024 * 0,true> { int V __attribute__ ((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<66 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(66 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<66 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<67 + 1024 * 0,true> { int V __attribute__ ((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<67 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(67 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<67 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<68 + 1024 * 0,true> { int V __attribute__ ((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<68 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(68 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<68 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<69 + 1024 * 0,true> { int V __attribute__ ((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<69 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(69 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<69 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<70 + 1024 * 0,true> { int V __attribute__ ((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<70 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(70 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<70 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<71 + 1024 * 0,true> { int V __attribute__ ((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<71 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(71 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<71 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<72 + 1024 * 0,true> { int V __attribute__ ((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<72 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(72 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<72 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<73 + 1024 * 0,true> { int V __attribute__ ((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<73 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(73 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<73 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<74 + 1024 * 0,true> { int V __attribute__ ((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<74 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(74 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<74 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<75 + 1024 * 0,true> { int V __attribute__ ((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<75 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(75 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<75 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<76 + 1024 * 0,true> { int V __attribute__ ((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<76 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(76 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<76 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<77 + 1024 * 0,true> { int V __attribute__ ((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<77 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(77 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<77 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<78 + 1024 * 0,true> { int V __attribute__ ((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<78 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(78 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<78 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<79 + 1024 * 0,true> { int V __attribute__ ((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<79 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(79 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<79 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<80 + 1024 * 0,true> { int V __attribute__ ((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<80 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(80 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<80 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<81 + 1024 * 0,true> { int V __attribute__ ((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<81 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(81 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<81 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<82 + 1024 * 0,true> { int V __attribute__ ((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<82 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(82 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<82 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<83 + 1024 * 0,true> { int V __attribute__ ((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<83 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(83 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<83 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<84 + 1024 * 0,true> { int V __attribute__ ((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<84 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(84 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<84 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<85 + 1024 * 0,true> { int V __attribute__ ((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<85 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(85 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<85 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<86 + 1024 * 0,true> { int V __attribute__ ((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<86 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(86 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<86 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<87 + 1024 * 0,true> { int V __attribute__ ((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<87 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(87 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<87 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<88 + 1024 * 0,true> { int V __attribute__ ((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<88 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(88 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<88 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<89 + 1024 * 0,true> { int V __attribute__ ((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<89 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(89 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<89 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<90 + 1024 * 0,true> { int V __attribute__ ((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<90 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(90 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<90 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<91 + 1024 * 0,true> { int V __attribute__ ((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<91 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(91 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<91 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<92 + 1024 * 0,true> { int V __attribute__ ((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<92 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(92 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<92 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<93 + 1024 * 0,true> { int V __attribute__ ((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<93 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(93 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<93 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<94 + 1024 * 0,true> { int V __attribute__ ((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<94 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(94 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<94 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<95 + 1024 * 0,true> { int V __attribute__ ((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<95 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(95 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<95 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<96 + 1024 * 0,true> { int V __attribute__ ((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<96 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(96 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<96 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<97 + 1024 * 0,true> { int V __attribute__ ((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<97 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(97 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<97 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<98 + 1024 * 0,true> { int V __attribute__ ((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<98 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(98 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<98 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<99 + 1024 * 0,true> { int V __attribute__ ((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<99 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(99 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<99 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<100 + 1024 * 0,true> { int V __attribute__ ((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<100 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(100 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<100 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<101 + 1024 * 0,true> { int V __attribute__ ((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<101 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(101 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<101 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<102 + 1024 * 0,true> { int V __attribute__ ((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<102 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(102 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<102 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<103 + 1024 * 0,true> { int V __attribute__ ((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<103 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(103 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<103 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<104 + 1024 * 0,true> { int V __attribute__ ((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<104 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(104 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<104 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<105 + 1024 * 0,true> { int V __attribute__ ((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<105 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(105 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<105 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<106 + 1024 * 0,true> { int V __attribute__ ((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<106 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(106 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<106 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<107 + 1024 * 0,true> { int V __attribute__ ((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<107 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(107 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<107 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<108 + 1024 * 0,true> { int V __attribute__ ((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<108 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(108 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<108 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<109 + 1024 * 0,true> { int V __attribute__ ((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<109 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(109 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<109 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<110 + 1024 * 0,true> { int V __attribute__ ((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<110 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(110 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<110 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<111 + 1024 * 0,true> { int V __attribute__ ((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<111 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(111 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<111 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<112 + 1024 * 0,true> { int V __attribute__ ((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<112 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(112 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<112 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<113 + 1024 * 0,true> { int V __attribute__ ((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<113 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(113 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<113 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<114 + 1024 * 0,true> { int V __attribute__ ((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<114 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(114 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<114 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<115 + 1024 * 0,true> { int V __attribute__ ((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<115 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(115 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<115 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<116 + 1024 * 0,true> { int V __attribute__ ((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<116 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(116 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<116 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<117 + 1024 * 0,true> { int V __attribute__ ((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<117 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(117 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<117 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<118 + 1024 * 0,true> { int V __attribute__ ((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<118 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(118 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<118 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<119 + 1024 * 0,true> { int V __attribute__ ((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<119 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(119 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<119 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<120 + 1024 * 0,true> { int V __attribute__ ((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<120 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(120 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<120 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<121 + 1024 * 0,true> { int V __attribute__ ((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<121 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(121 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<121 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<122 + 1024 * 0,true> { int V __attribute__ ((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<122 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(122 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<122 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<123 + 1024 * 0,true> { int V __attribute__ ((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<123 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(123 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<123 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<124 + 1024 * 0,true> { int V __attribute__ ((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<124 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(124 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<124 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<125 + 1024 * 0,true> { int V __attribute__ ((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<125 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(125 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<125 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<126 + 1024 * 0,true> { int V __attribute__ ((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<126 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(126 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<126 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<127 + 1024 * 0,true> { int V __attribute__ ((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<127 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(127 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<127 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<128 + 1024 * 0,true> { int V __attribute__ ((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<128 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(128 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<128 + 1024 * 0 , false>() { }; };

/*#endif*/


/*#ifdef EXTENDED_GCC*/

template<> struct ssdm_int<129 + 1024 * 0,true> { int V __attribute__ ((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<129 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(129 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<129 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<130 + 1024 * 0,true> { int V __attribute__ ((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<130 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(130 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<130 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<131 + 1024 * 0,true> { int V __attribute__ ((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<131 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(131 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<131 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<132 + 1024 * 0,true> { int V __attribute__ ((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<132 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(132 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<132 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<133 + 1024 * 0,true> { int V __attribute__ ((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<133 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(133 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<133 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<134 + 1024 * 0,true> { int V __attribute__ ((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<134 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(134 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<134 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<135 + 1024 * 0,true> { int V __attribute__ ((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<135 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(135 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<135 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<136 + 1024 * 0,true> { int V __attribute__ ((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<136 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(136 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<136 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<137 + 1024 * 0,true> { int V __attribute__ ((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<137 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(137 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<137 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<138 + 1024 * 0,true> { int V __attribute__ ((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<138 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(138 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<138 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<139 + 1024 * 0,true> { int V __attribute__ ((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<139 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(139 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<139 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<140 + 1024 * 0,true> { int V __attribute__ ((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<140 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(140 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<140 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<141 + 1024 * 0,true> { int V __attribute__ ((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<141 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(141 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<141 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<142 + 1024 * 0,true> { int V __attribute__ ((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<142 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(142 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<142 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<143 + 1024 * 0,true> { int V __attribute__ ((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<143 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(143 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<143 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<144 + 1024 * 0,true> { int V __attribute__ ((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<144 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(144 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<144 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<145 + 1024 * 0,true> { int V __attribute__ ((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<145 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(145 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<145 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<146 + 1024 * 0,true> { int V __attribute__ ((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<146 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(146 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<146 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<147 + 1024 * 0,true> { int V __attribute__ ((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<147 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(147 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<147 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<148 + 1024 * 0,true> { int V __attribute__ ((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<148 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(148 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<148 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<149 + 1024 * 0,true> { int V __attribute__ ((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<149 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(149 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<149 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<150 + 1024 * 0,true> { int V __attribute__ ((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<150 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(150 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<150 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<151 + 1024 * 0,true> { int V __attribute__ ((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<151 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(151 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<151 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<152 + 1024 * 0,true> { int V __attribute__ ((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<152 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(152 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<152 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<153 + 1024 * 0,true> { int V __attribute__ ((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<153 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(153 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<153 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<154 + 1024 * 0,true> { int V __attribute__ ((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<154 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(154 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<154 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<155 + 1024 * 0,true> { int V __attribute__ ((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<155 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(155 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<155 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<156 + 1024 * 0,true> { int V __attribute__ ((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<156 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(156 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<156 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<157 + 1024 * 0,true> { int V __attribute__ ((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<157 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(157 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<157 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<158 + 1024 * 0,true> { int V __attribute__ ((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<158 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(158 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<158 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<159 + 1024 * 0,true> { int V __attribute__ ((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<159 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(159 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<159 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<160 + 1024 * 0,true> { int V __attribute__ ((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<160 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(160 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<160 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<161 + 1024 * 0,true> { int V __attribute__ ((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<161 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(161 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<161 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<162 + 1024 * 0,true> { int V __attribute__ ((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<162 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(162 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<162 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<163 + 1024 * 0,true> { int V __attribute__ ((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<163 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(163 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<163 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<164 + 1024 * 0,true> { int V __attribute__ ((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<164 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(164 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<164 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<165 + 1024 * 0,true> { int V __attribute__ ((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<165 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(165 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<165 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<166 + 1024 * 0,true> { int V __attribute__ ((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<166 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(166 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<166 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<167 + 1024 * 0,true> { int V __attribute__ ((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<167 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(167 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<167 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<168 + 1024 * 0,true> { int V __attribute__ ((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<168 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(168 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<168 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<169 + 1024 * 0,true> { int V __attribute__ ((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<169 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(169 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<169 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<170 + 1024 * 0,true> { int V __attribute__ ((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<170 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(170 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<170 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<171 + 1024 * 0,true> { int V __attribute__ ((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<171 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(171 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<171 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<172 + 1024 * 0,true> { int V __attribute__ ((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<172 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(172 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<172 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<173 + 1024 * 0,true> { int V __attribute__ ((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<173 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(173 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<173 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<174 + 1024 * 0,true> { int V __attribute__ ((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<174 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(174 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<174 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<175 + 1024 * 0,true> { int V __attribute__ ((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<175 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(175 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<175 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<176 + 1024 * 0,true> { int V __attribute__ ((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<176 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(176 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<176 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<177 + 1024 * 0,true> { int V __attribute__ ((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<177 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(177 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<177 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<178 + 1024 * 0,true> { int V __attribute__ ((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<178 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(178 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<178 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<179 + 1024 * 0,true> { int V __attribute__ ((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<179 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(179 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<179 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<180 + 1024 * 0,true> { int V __attribute__ ((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<180 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(180 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<180 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<181 + 1024 * 0,true> { int V __attribute__ ((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<181 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(181 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<181 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<182 + 1024 * 0,true> { int V __attribute__ ((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<182 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(182 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<182 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<183 + 1024 * 0,true> { int V __attribute__ ((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<183 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(183 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<183 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<184 + 1024 * 0,true> { int V __attribute__ ((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<184 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(184 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<184 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<185 + 1024 * 0,true> { int V __attribute__ ((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<185 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(185 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<185 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<186 + 1024 * 0,true> { int V __attribute__ ((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<186 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(186 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<186 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<187 + 1024 * 0,true> { int V __attribute__ ((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<187 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(187 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<187 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<188 + 1024 * 0,true> { int V __attribute__ ((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<188 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(188 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<188 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<189 + 1024 * 0,true> { int V __attribute__ ((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<189 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(189 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<189 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<190 + 1024 * 0,true> { int V __attribute__ ((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<190 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(190 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<190 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<191 + 1024 * 0,true> { int V __attribute__ ((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<191 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(191 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<191 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<192 + 1024 * 0,true> { int V __attribute__ ((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<192 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(192 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<192 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<193 + 1024 * 0,true> { int V __attribute__ ((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<193 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(193 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<193 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<194 + 1024 * 0,true> { int V __attribute__ ((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<194 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(194 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<194 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<195 + 1024 * 0,true> { int V __attribute__ ((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<195 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(195 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<195 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<196 + 1024 * 0,true> { int V __attribute__ ((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<196 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(196 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<196 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<197 + 1024 * 0,true> { int V __attribute__ ((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<197 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(197 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<197 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<198 + 1024 * 0,true> { int V __attribute__ ((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<198 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(198 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<198 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<199 + 1024 * 0,true> { int V __attribute__ ((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<199 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(199 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<199 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<200 + 1024 * 0,true> { int V __attribute__ ((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<200 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(200 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<200 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<201 + 1024 * 0,true> { int V __attribute__ ((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<201 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(201 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<201 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<202 + 1024 * 0,true> { int V __attribute__ ((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<202 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(202 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<202 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<203 + 1024 * 0,true> { int V __attribute__ ((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<203 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(203 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<203 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<204 + 1024 * 0,true> { int V __attribute__ ((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<204 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(204 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<204 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<205 + 1024 * 0,true> { int V __attribute__ ((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<205 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(205 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<205 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<206 + 1024 * 0,true> { int V __attribute__ ((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<206 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(206 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<206 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<207 + 1024 * 0,true> { int V __attribute__ ((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<207 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(207 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<207 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<208 + 1024 * 0,true> { int V __attribute__ ((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<208 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(208 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<208 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<209 + 1024 * 0,true> { int V __attribute__ ((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<209 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(209 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<209 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<210 + 1024 * 0,true> { int V __attribute__ ((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<210 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(210 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<210 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<211 + 1024 * 0,true> { int V __attribute__ ((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<211 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(211 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<211 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<212 + 1024 * 0,true> { int V __attribute__ ((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<212 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(212 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<212 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<213 + 1024 * 0,true> { int V __attribute__ ((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<213 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(213 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<213 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<214 + 1024 * 0,true> { int V __attribute__ ((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<214 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(214 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<214 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<215 + 1024 * 0,true> { int V __attribute__ ((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<215 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(215 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<215 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<216 + 1024 * 0,true> { int V __attribute__ ((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<216 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(216 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<216 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<217 + 1024 * 0,true> { int V __attribute__ ((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<217 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(217 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<217 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<218 + 1024 * 0,true> { int V __attribute__ ((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<218 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(218 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<218 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<219 + 1024 * 0,true> { int V __attribute__ ((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<219 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(219 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<219 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<220 + 1024 * 0,true> { int V __attribute__ ((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<220 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(220 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<220 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<221 + 1024 * 0,true> { int V __attribute__ ((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<221 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(221 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<221 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<222 + 1024 * 0,true> { int V __attribute__ ((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<222 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(222 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<222 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<223 + 1024 * 0,true> { int V __attribute__ ((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<223 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(223 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<223 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<224 + 1024 * 0,true> { int V __attribute__ ((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<224 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(224 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<224 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<225 + 1024 * 0,true> { int V __attribute__ ((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<225 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(225 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<225 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<226 + 1024 * 0,true> { int V __attribute__ ((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<226 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(226 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<226 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<227 + 1024 * 0,true> { int V __attribute__ ((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<227 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(227 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<227 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<228 + 1024 * 0,true> { int V __attribute__ ((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<228 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(228 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<228 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<229 + 1024 * 0,true> { int V __attribute__ ((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<229 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(229 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<229 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<230 + 1024 * 0,true> { int V __attribute__ ((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<230 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(230 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<230 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<231 + 1024 * 0,true> { int V __attribute__ ((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<231 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(231 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<231 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<232 + 1024 * 0,true> { int V __attribute__ ((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<232 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(232 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<232 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<233 + 1024 * 0,true> { int V __attribute__ ((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<233 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(233 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<233 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<234 + 1024 * 0,true> { int V __attribute__ ((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<234 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(234 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<234 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<235 + 1024 * 0,true> { int V __attribute__ ((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<235 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(235 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<235 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<236 + 1024 * 0,true> { int V __attribute__ ((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<236 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(236 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<236 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<237 + 1024 * 0,true> { int V __attribute__ ((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<237 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(237 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<237 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<238 + 1024 * 0,true> { int V __attribute__ ((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<238 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(238 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<238 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<239 + 1024 * 0,true> { int V __attribute__ ((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<239 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(239 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<239 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<240 + 1024 * 0,true> { int V __attribute__ ((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<240 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(240 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<240 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<241 + 1024 * 0,true> { int V __attribute__ ((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<241 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(241 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<241 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<242 + 1024 * 0,true> { int V __attribute__ ((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<242 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(242 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<242 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<243 + 1024 * 0,true> { int V __attribute__ ((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<243 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(243 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<243 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<244 + 1024 * 0,true> { int V __attribute__ ((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<244 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(244 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<244 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<245 + 1024 * 0,true> { int V __attribute__ ((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<245 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(245 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<245 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<246 + 1024 * 0,true> { int V __attribute__ ((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<246 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(246 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<246 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<247 + 1024 * 0,true> { int V __attribute__ ((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<247 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(247 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<247 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<248 + 1024 * 0,true> { int V __attribute__ ((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<248 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(248 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<248 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<249 + 1024 * 0,true> { int V __attribute__ ((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<249 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(249 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<249 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<250 + 1024 * 0,true> { int V __attribute__ ((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<250 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(250 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<250 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<251 + 1024 * 0,true> { int V __attribute__ ((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<251 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(251 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<251 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<252 + 1024 * 0,true> { int V __attribute__ ((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<252 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(252 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<252 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<253 + 1024 * 0,true> { int V __attribute__ ((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<253 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(253 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<253 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<254 + 1024 * 0,true> { int V __attribute__ ((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<254 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(254 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<254 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<255 + 1024 * 0,true> { int V __attribute__ ((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<255 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(255 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<255 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<256 + 1024 * 0,true> { int V __attribute__ ((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<256 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(256 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<256 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<257 + 1024 * 0,true> { int V __attribute__ ((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<257 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(257 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<257 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<258 + 1024 * 0,true> { int V __attribute__ ((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<258 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(258 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<258 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<259 + 1024 * 0,true> { int V __attribute__ ((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<259 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(259 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<259 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<260 + 1024 * 0,true> { int V __attribute__ ((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<260 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(260 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<260 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<261 + 1024 * 0,true> { int V __attribute__ ((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<261 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(261 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<261 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<262 + 1024 * 0,true> { int V __attribute__ ((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<262 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(262 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<262 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<263 + 1024 * 0,true> { int V __attribute__ ((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<263 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(263 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<263 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<264 + 1024 * 0,true> { int V __attribute__ ((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<264 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(264 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<264 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<265 + 1024 * 0,true> { int V __attribute__ ((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<265 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(265 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<265 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<266 + 1024 * 0,true> { int V __attribute__ ((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<266 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(266 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<266 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<267 + 1024 * 0,true> { int V __attribute__ ((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<267 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(267 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<267 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<268 + 1024 * 0,true> { int V __attribute__ ((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<268 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(268 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<268 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<269 + 1024 * 0,true> { int V __attribute__ ((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<269 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(269 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<269 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<270 + 1024 * 0,true> { int V __attribute__ ((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<270 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(270 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<270 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<271 + 1024 * 0,true> { int V __attribute__ ((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<271 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(271 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<271 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<272 + 1024 * 0,true> { int V __attribute__ ((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<272 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(272 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<272 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<273 + 1024 * 0,true> { int V __attribute__ ((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<273 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(273 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<273 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<274 + 1024 * 0,true> { int V __attribute__ ((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<274 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(274 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<274 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<275 + 1024 * 0,true> { int V __attribute__ ((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<275 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(275 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<275 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<276 + 1024 * 0,true> { int V __attribute__ ((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<276 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(276 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<276 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<277 + 1024 * 0,true> { int V __attribute__ ((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<277 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(277 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<277 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<278 + 1024 * 0,true> { int V __attribute__ ((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<278 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(278 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<278 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<279 + 1024 * 0,true> { int V __attribute__ ((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<279 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(279 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<279 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<280 + 1024 * 0,true> { int V __attribute__ ((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<280 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(280 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<280 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<281 + 1024 * 0,true> { int V __attribute__ ((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<281 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(281 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<281 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<282 + 1024 * 0,true> { int V __attribute__ ((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<282 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(282 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<282 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<283 + 1024 * 0,true> { int V __attribute__ ((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<283 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(283 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<283 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<284 + 1024 * 0,true> { int V __attribute__ ((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<284 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(284 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<284 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<285 + 1024 * 0,true> { int V __attribute__ ((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<285 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(285 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<285 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<286 + 1024 * 0,true> { int V __attribute__ ((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<286 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(286 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<286 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<287 + 1024 * 0,true> { int V __attribute__ ((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<287 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(287 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<287 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<288 + 1024 * 0,true> { int V __attribute__ ((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<288 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(288 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<288 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<289 + 1024 * 0,true> { int V __attribute__ ((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<289 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(289 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<289 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<290 + 1024 * 0,true> { int V __attribute__ ((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<290 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(290 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<290 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<291 + 1024 * 0,true> { int V __attribute__ ((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<291 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(291 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<291 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<292 + 1024 * 0,true> { int V __attribute__ ((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<292 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(292 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<292 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<293 + 1024 * 0,true> { int V __attribute__ ((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<293 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(293 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<293 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<294 + 1024 * 0,true> { int V __attribute__ ((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<294 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(294 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<294 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<295 + 1024 * 0,true> { int V __attribute__ ((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<295 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(295 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<295 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<296 + 1024 * 0,true> { int V __attribute__ ((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<296 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(296 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<296 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<297 + 1024 * 0,true> { int V __attribute__ ((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<297 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(297 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<297 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<298 + 1024 * 0,true> { int V __attribute__ ((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<298 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(298 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<298 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<299 + 1024 * 0,true> { int V __attribute__ ((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<299 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(299 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<299 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<300 + 1024 * 0,true> { int V __attribute__ ((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<300 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(300 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<300 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<301 + 1024 * 0,true> { int V __attribute__ ((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<301 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(301 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<301 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<302 + 1024 * 0,true> { int V __attribute__ ((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<302 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(302 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<302 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<303 + 1024 * 0,true> { int V __attribute__ ((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<303 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(303 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<303 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<304 + 1024 * 0,true> { int V __attribute__ ((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<304 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(304 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<304 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<305 + 1024 * 0,true> { int V __attribute__ ((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<305 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(305 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<305 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<306 + 1024 * 0,true> { int V __attribute__ ((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<306 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(306 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<306 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<307 + 1024 * 0,true> { int V __attribute__ ((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<307 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(307 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<307 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<308 + 1024 * 0,true> { int V __attribute__ ((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<308 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(308 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<308 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<309 + 1024 * 0,true> { int V __attribute__ ((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<309 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(309 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<309 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<310 + 1024 * 0,true> { int V __attribute__ ((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<310 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(310 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<310 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<311 + 1024 * 0,true> { int V __attribute__ ((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<311 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(311 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<311 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<312 + 1024 * 0,true> { int V __attribute__ ((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<312 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(312 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<312 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<313 + 1024 * 0,true> { int V __attribute__ ((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<313 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(313 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<313 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<314 + 1024 * 0,true> { int V __attribute__ ((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<314 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(314 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<314 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<315 + 1024 * 0,true> { int V __attribute__ ((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<315 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(315 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<315 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<316 + 1024 * 0,true> { int V __attribute__ ((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<316 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(316 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<316 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<317 + 1024 * 0,true> { int V __attribute__ ((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<317 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(317 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<317 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<318 + 1024 * 0,true> { int V __attribute__ ((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<318 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(318 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<318 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<319 + 1024 * 0,true> { int V __attribute__ ((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<319 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(319 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<319 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<320 + 1024 * 0,true> { int V __attribute__ ((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<320 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(320 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<320 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<321 + 1024 * 0,true> { int V __attribute__ ((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<321 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(321 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<321 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<322 + 1024 * 0,true> { int V __attribute__ ((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<322 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(322 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<322 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<323 + 1024 * 0,true> { int V __attribute__ ((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<323 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(323 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<323 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<324 + 1024 * 0,true> { int V __attribute__ ((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<324 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(324 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<324 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<325 + 1024 * 0,true> { int V __attribute__ ((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<325 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(325 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<325 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<326 + 1024 * 0,true> { int V __attribute__ ((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<326 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(326 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<326 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<327 + 1024 * 0,true> { int V __attribute__ ((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<327 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(327 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<327 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<328 + 1024 * 0,true> { int V __attribute__ ((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<328 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(328 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<328 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<329 + 1024 * 0,true> { int V __attribute__ ((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<329 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(329 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<329 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<330 + 1024 * 0,true> { int V __attribute__ ((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<330 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(330 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<330 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<331 + 1024 * 0,true> { int V __attribute__ ((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<331 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(331 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<331 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<332 + 1024 * 0,true> { int V __attribute__ ((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<332 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(332 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<332 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<333 + 1024 * 0,true> { int V __attribute__ ((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<333 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(333 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<333 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<334 + 1024 * 0,true> { int V __attribute__ ((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<334 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(334 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<334 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<335 + 1024 * 0,true> { int V __attribute__ ((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<335 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(335 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<335 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<336 + 1024 * 0,true> { int V __attribute__ ((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<336 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(336 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<336 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<337 + 1024 * 0,true> { int V __attribute__ ((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<337 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(337 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<337 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<338 + 1024 * 0,true> { int V __attribute__ ((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<338 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(338 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<338 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<339 + 1024 * 0,true> { int V __attribute__ ((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<339 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(339 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<339 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<340 + 1024 * 0,true> { int V __attribute__ ((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<340 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(340 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<340 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<341 + 1024 * 0,true> { int V __attribute__ ((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<341 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(341 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<341 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<342 + 1024 * 0,true> { int V __attribute__ ((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<342 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(342 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<342 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<343 + 1024 * 0,true> { int V __attribute__ ((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<343 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(343 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<343 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<344 + 1024 * 0,true> { int V __attribute__ ((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<344 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(344 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<344 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<345 + 1024 * 0,true> { int V __attribute__ ((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<345 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(345 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<345 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<346 + 1024 * 0,true> { int V __attribute__ ((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<346 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(346 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<346 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<347 + 1024 * 0,true> { int V __attribute__ ((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<347 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(347 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<347 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<348 + 1024 * 0,true> { int V __attribute__ ((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<348 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(348 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<348 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<349 + 1024 * 0,true> { int V __attribute__ ((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<349 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(349 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<349 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<350 + 1024 * 0,true> { int V __attribute__ ((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<350 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(350 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<350 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<351 + 1024 * 0,true> { int V __attribute__ ((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<351 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(351 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<351 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<352 + 1024 * 0,true> { int V __attribute__ ((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<352 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(352 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<352 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<353 + 1024 * 0,true> { int V __attribute__ ((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<353 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(353 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<353 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<354 + 1024 * 0,true> { int V __attribute__ ((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<354 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(354 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<354 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<355 + 1024 * 0,true> { int V __attribute__ ((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<355 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(355 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<355 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<356 + 1024 * 0,true> { int V __attribute__ ((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<356 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(356 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<356 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<357 + 1024 * 0,true> { int V __attribute__ ((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<357 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(357 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<357 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<358 + 1024 * 0,true> { int V __attribute__ ((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<358 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(358 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<358 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<359 + 1024 * 0,true> { int V __attribute__ ((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<359 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(359 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<359 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<360 + 1024 * 0,true> { int V __attribute__ ((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<360 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(360 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<360 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<361 + 1024 * 0,true> { int V __attribute__ ((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<361 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(361 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<361 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<362 + 1024 * 0,true> { int V __attribute__ ((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<362 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(362 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<362 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<363 + 1024 * 0,true> { int V __attribute__ ((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<363 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(363 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<363 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<364 + 1024 * 0,true> { int V __attribute__ ((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<364 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(364 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<364 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<365 + 1024 * 0,true> { int V __attribute__ ((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<365 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(365 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<365 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<366 + 1024 * 0,true> { int V __attribute__ ((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<366 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(366 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<366 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<367 + 1024 * 0,true> { int V __attribute__ ((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<367 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(367 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<367 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<368 + 1024 * 0,true> { int V __attribute__ ((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<368 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(368 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<368 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<369 + 1024 * 0,true> { int V __attribute__ ((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<369 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(369 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<369 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<370 + 1024 * 0,true> { int V __attribute__ ((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<370 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(370 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<370 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<371 + 1024 * 0,true> { int V __attribute__ ((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<371 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(371 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<371 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<372 + 1024 * 0,true> { int V __attribute__ ((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<372 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(372 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<372 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<373 + 1024 * 0,true> { int V __attribute__ ((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<373 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(373 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<373 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<374 + 1024 * 0,true> { int V __attribute__ ((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<374 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(374 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<374 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<375 + 1024 * 0,true> { int V __attribute__ ((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<375 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(375 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<375 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<376 + 1024 * 0,true> { int V __attribute__ ((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<376 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(376 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<376 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<377 + 1024 * 0,true> { int V __attribute__ ((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<377 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(377 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<377 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<378 + 1024 * 0,true> { int V __attribute__ ((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<378 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(378 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<378 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<379 + 1024 * 0,true> { int V __attribute__ ((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<379 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(379 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<379 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<380 + 1024 * 0,true> { int V __attribute__ ((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<380 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(380 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<380 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<381 + 1024 * 0,true> { int V __attribute__ ((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<381 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(381 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<381 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<382 + 1024 * 0,true> { int V __attribute__ ((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<382 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(382 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<382 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<383 + 1024 * 0,true> { int V __attribute__ ((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<383 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(383 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<383 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<384 + 1024 * 0,true> { int V __attribute__ ((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<384 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(384 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<384 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<385 + 1024 * 0,true> { int V __attribute__ ((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<385 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(385 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<385 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<386 + 1024 * 0,true> { int V __attribute__ ((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<386 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(386 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<386 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<387 + 1024 * 0,true> { int V __attribute__ ((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<387 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(387 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<387 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<388 + 1024 * 0,true> { int V __attribute__ ((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<388 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(388 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<388 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<389 + 1024 * 0,true> { int V __attribute__ ((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<389 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(389 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<389 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<390 + 1024 * 0,true> { int V __attribute__ ((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<390 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(390 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<390 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<391 + 1024 * 0,true> { int V __attribute__ ((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<391 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(391 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<391 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<392 + 1024 * 0,true> { int V __attribute__ ((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<392 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(392 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<392 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<393 + 1024 * 0,true> { int V __attribute__ ((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<393 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(393 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<393 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<394 + 1024 * 0,true> { int V __attribute__ ((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<394 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(394 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<394 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<395 + 1024 * 0,true> { int V __attribute__ ((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<395 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(395 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<395 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<396 + 1024 * 0,true> { int V __attribute__ ((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<396 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(396 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<396 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<397 + 1024 * 0,true> { int V __attribute__ ((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<397 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(397 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<397 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<398 + 1024 * 0,true> { int V __attribute__ ((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<398 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(398 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<398 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<399 + 1024 * 0,true> { int V __attribute__ ((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<399 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(399 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<399 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<400 + 1024 * 0,true> { int V __attribute__ ((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<400 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(400 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<400 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<401 + 1024 * 0,true> { int V __attribute__ ((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<401 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(401 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<401 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<402 + 1024 * 0,true> { int V __attribute__ ((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<402 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(402 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<402 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<403 + 1024 * 0,true> { int V __attribute__ ((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<403 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(403 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<403 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<404 + 1024 * 0,true> { int V __attribute__ ((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<404 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(404 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<404 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<405 + 1024 * 0,true> { int V __attribute__ ((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<405 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(405 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<405 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<406 + 1024 * 0,true> { int V __attribute__ ((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<406 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(406 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<406 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<407 + 1024 * 0,true> { int V __attribute__ ((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<407 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(407 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<407 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<408 + 1024 * 0,true> { int V __attribute__ ((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<408 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(408 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<408 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<409 + 1024 * 0,true> { int V __attribute__ ((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<409 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(409 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<409 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<410 + 1024 * 0,true> { int V __attribute__ ((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<410 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(410 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<410 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<411 + 1024 * 0,true> { int V __attribute__ ((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<411 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(411 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<411 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<412 + 1024 * 0,true> { int V __attribute__ ((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<412 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(412 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<412 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<413 + 1024 * 0,true> { int V __attribute__ ((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<413 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(413 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<413 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<414 + 1024 * 0,true> { int V __attribute__ ((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<414 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(414 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<414 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<415 + 1024 * 0,true> { int V __attribute__ ((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<415 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(415 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<415 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<416 + 1024 * 0,true> { int V __attribute__ ((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<416 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(416 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<416 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<417 + 1024 * 0,true> { int V __attribute__ ((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<417 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(417 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<417 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<418 + 1024 * 0,true> { int V __attribute__ ((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<418 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(418 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<418 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<419 + 1024 * 0,true> { int V __attribute__ ((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<419 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(419 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<419 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<420 + 1024 * 0,true> { int V __attribute__ ((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<420 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(420 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<420 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<421 + 1024 * 0,true> { int V __attribute__ ((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<421 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(421 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<421 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<422 + 1024 * 0,true> { int V __attribute__ ((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<422 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(422 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<422 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<423 + 1024 * 0,true> { int V __attribute__ ((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<423 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(423 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<423 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<424 + 1024 * 0,true> { int V __attribute__ ((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<424 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(424 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<424 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<425 + 1024 * 0,true> { int V __attribute__ ((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<425 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(425 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<425 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<426 + 1024 * 0,true> { int V __attribute__ ((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<426 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(426 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<426 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<427 + 1024 * 0,true> { int V __attribute__ ((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<427 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(427 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<427 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<428 + 1024 * 0,true> { int V __attribute__ ((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<428 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(428 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<428 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<429 + 1024 * 0,true> { int V __attribute__ ((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<429 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(429 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<429 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<430 + 1024 * 0,true> { int V __attribute__ ((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<430 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(430 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<430 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<431 + 1024 * 0,true> { int V __attribute__ ((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<431 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(431 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<431 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<432 + 1024 * 0,true> { int V __attribute__ ((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<432 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(432 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<432 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<433 + 1024 * 0,true> { int V __attribute__ ((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<433 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(433 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<433 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<434 + 1024 * 0,true> { int V __attribute__ ((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<434 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(434 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<434 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<435 + 1024 * 0,true> { int V __attribute__ ((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<435 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(435 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<435 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<436 + 1024 * 0,true> { int V __attribute__ ((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<436 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(436 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<436 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<437 + 1024 * 0,true> { int V __attribute__ ((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<437 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(437 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<437 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<438 + 1024 * 0,true> { int V __attribute__ ((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<438 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(438 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<438 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<439 + 1024 * 0,true> { int V __attribute__ ((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<439 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(439 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<439 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<440 + 1024 * 0,true> { int V __attribute__ ((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<440 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(440 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<440 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<441 + 1024 * 0,true> { int V __attribute__ ((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<441 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(441 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<441 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<442 + 1024 * 0,true> { int V __attribute__ ((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<442 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(442 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<442 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<443 + 1024 * 0,true> { int V __attribute__ ((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<443 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(443 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<443 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<444 + 1024 * 0,true> { int V __attribute__ ((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<444 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(444 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<444 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<445 + 1024 * 0,true> { int V __attribute__ ((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<445 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(445 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<445 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<446 + 1024 * 0,true> { int V __attribute__ ((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<446 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(446 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<446 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<447 + 1024 * 0,true> { int V __attribute__ ((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<447 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(447 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<447 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<448 + 1024 * 0,true> { int V __attribute__ ((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<448 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(448 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<448 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<449 + 1024 * 0,true> { int V __attribute__ ((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<449 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(449 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<449 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<450 + 1024 * 0,true> { int V __attribute__ ((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<450 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(450 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<450 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<451 + 1024 * 0,true> { int V __attribute__ ((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<451 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(451 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<451 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<452 + 1024 * 0,true> { int V __attribute__ ((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<452 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(452 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<452 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<453 + 1024 * 0,true> { int V __attribute__ ((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<453 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(453 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<453 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<454 + 1024 * 0,true> { int V __attribute__ ((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<454 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(454 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<454 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<455 + 1024 * 0,true> { int V __attribute__ ((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<455 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(455 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<455 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<456 + 1024 * 0,true> { int V __attribute__ ((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<456 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(456 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<456 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<457 + 1024 * 0,true> { int V __attribute__ ((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<457 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(457 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<457 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<458 + 1024 * 0,true> { int V __attribute__ ((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<458 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(458 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<458 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<459 + 1024 * 0,true> { int V __attribute__ ((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<459 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(459 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<459 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<460 + 1024 * 0,true> { int V __attribute__ ((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<460 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(460 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<460 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<461 + 1024 * 0,true> { int V __attribute__ ((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<461 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(461 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<461 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<462 + 1024 * 0,true> { int V __attribute__ ((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<462 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(462 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<462 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<463 + 1024 * 0,true> { int V __attribute__ ((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<463 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(463 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<463 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<464 + 1024 * 0,true> { int V __attribute__ ((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<464 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(464 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<464 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<465 + 1024 * 0,true> { int V __attribute__ ((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<465 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(465 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<465 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<466 + 1024 * 0,true> { int V __attribute__ ((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<466 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(466 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<466 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<467 + 1024 * 0,true> { int V __attribute__ ((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<467 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(467 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<467 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<468 + 1024 * 0,true> { int V __attribute__ ((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<468 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(468 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<468 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<469 + 1024 * 0,true> { int V __attribute__ ((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<469 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(469 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<469 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<470 + 1024 * 0,true> { int V __attribute__ ((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<470 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(470 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<470 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<471 + 1024 * 0,true> { int V __attribute__ ((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<471 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(471 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<471 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<472 + 1024 * 0,true> { int V __attribute__ ((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<472 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(472 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<472 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<473 + 1024 * 0,true> { int V __attribute__ ((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<473 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(473 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<473 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<474 + 1024 * 0,true> { int V __attribute__ ((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<474 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(474 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<474 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<475 + 1024 * 0,true> { int V __attribute__ ((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<475 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(475 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<475 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<476 + 1024 * 0,true> { int V __attribute__ ((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<476 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(476 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<476 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<477 + 1024 * 0,true> { int V __attribute__ ((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<477 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(477 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<477 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<478 + 1024 * 0,true> { int V __attribute__ ((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<478 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(478 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<478 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<479 + 1024 * 0,true> { int V __attribute__ ((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<479 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(479 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<479 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<480 + 1024 * 0,true> { int V __attribute__ ((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<480 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(480 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<480 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<481 + 1024 * 0,true> { int V __attribute__ ((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<481 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(481 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<481 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<482 + 1024 * 0,true> { int V __attribute__ ((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<482 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(482 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<482 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<483 + 1024 * 0,true> { int V __attribute__ ((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<483 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(483 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<483 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<484 + 1024 * 0,true> { int V __attribute__ ((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<484 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(484 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<484 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<485 + 1024 * 0,true> { int V __attribute__ ((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<485 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(485 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<485 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<486 + 1024 * 0,true> { int V __attribute__ ((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<486 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(486 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<486 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<487 + 1024 * 0,true> { int V __attribute__ ((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<487 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(487 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<487 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<488 + 1024 * 0,true> { int V __attribute__ ((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<488 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(488 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<488 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<489 + 1024 * 0,true> { int V __attribute__ ((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<489 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(489 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<489 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<490 + 1024 * 0,true> { int V __attribute__ ((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<490 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(490 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<490 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<491 + 1024 * 0,true> { int V __attribute__ ((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<491 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(491 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<491 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<492 + 1024 * 0,true> { int V __attribute__ ((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<492 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(492 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<492 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<493 + 1024 * 0,true> { int V __attribute__ ((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<493 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(493 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<493 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<494 + 1024 * 0,true> { int V __attribute__ ((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<494 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(494 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<494 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<495 + 1024 * 0,true> { int V __attribute__ ((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<495 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(495 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<495 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<496 + 1024 * 0,true> { int V __attribute__ ((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<496 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(496 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<496 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<497 + 1024 * 0,true> { int V __attribute__ ((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<497 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(497 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<497 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<498 + 1024 * 0,true> { int V __attribute__ ((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<498 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(498 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<498 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<499 + 1024 * 0,true> { int V __attribute__ ((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<499 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(499 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<499 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<500 + 1024 * 0,true> { int V __attribute__ ((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<500 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(500 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<500 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<501 + 1024 * 0,true> { int V __attribute__ ((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<501 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(501 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<501 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<502 + 1024 * 0,true> { int V __attribute__ ((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<502 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(502 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<502 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<503 + 1024 * 0,true> { int V __attribute__ ((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<503 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(503 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<503 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<504 + 1024 * 0,true> { int V __attribute__ ((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<504 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(504 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<504 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<505 + 1024 * 0,true> { int V __attribute__ ((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<505 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(505 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<505 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<506 + 1024 * 0,true> { int V __attribute__ ((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<506 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(506 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<506 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<507 + 1024 * 0,true> { int V __attribute__ ((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<507 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(507 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<507 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<508 + 1024 * 0,true> { int V __attribute__ ((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<508 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(508 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<508 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<509 + 1024 * 0,true> { int V __attribute__ ((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<509 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(509 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<509 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<510 + 1024 * 0,true> { int V __attribute__ ((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<510 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(510 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<510 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<511 + 1024 * 0,true> { int V __attribute__ ((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<511 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(511 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<511 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<512 + 1024 * 0,true> { int V __attribute__ ((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<512 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(512 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<512 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<513 + 1024 * 0,true> { int V __attribute__ ((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<513 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(513 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<513 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<514 + 1024 * 0,true> { int V __attribute__ ((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<514 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(514 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<514 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<515 + 1024 * 0,true> { int V __attribute__ ((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<515 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(515 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<515 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<516 + 1024 * 0,true> { int V __attribute__ ((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<516 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(516 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<516 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<517 + 1024 * 0,true> { int V __attribute__ ((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<517 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(517 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<517 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<518 + 1024 * 0,true> { int V __attribute__ ((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<518 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(518 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<518 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<519 + 1024 * 0,true> { int V __attribute__ ((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<519 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(519 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<519 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<520 + 1024 * 0,true> { int V __attribute__ ((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<520 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(520 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<520 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<521 + 1024 * 0,true> { int V __attribute__ ((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<521 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(521 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<521 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<522 + 1024 * 0,true> { int V __attribute__ ((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<522 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(522 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<522 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<523 + 1024 * 0,true> { int V __attribute__ ((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<523 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(523 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<523 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<524 + 1024 * 0,true> { int V __attribute__ ((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<524 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(524 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<524 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<525 + 1024 * 0,true> { int V __attribute__ ((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<525 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(525 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<525 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<526 + 1024 * 0,true> { int V __attribute__ ((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<526 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(526 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<526 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<527 + 1024 * 0,true> { int V __attribute__ ((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<527 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(527 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<527 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<528 + 1024 * 0,true> { int V __attribute__ ((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<528 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(528 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<528 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<529 + 1024 * 0,true> { int V __attribute__ ((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<529 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(529 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<529 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<530 + 1024 * 0,true> { int V __attribute__ ((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<530 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(530 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<530 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<531 + 1024 * 0,true> { int V __attribute__ ((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<531 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(531 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<531 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<532 + 1024 * 0,true> { int V __attribute__ ((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<532 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(532 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<532 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<533 + 1024 * 0,true> { int V __attribute__ ((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<533 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(533 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<533 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<534 + 1024 * 0,true> { int V __attribute__ ((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<534 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(534 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<534 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<535 + 1024 * 0,true> { int V __attribute__ ((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<535 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(535 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<535 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<536 + 1024 * 0,true> { int V __attribute__ ((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<536 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(536 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<536 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<537 + 1024 * 0,true> { int V __attribute__ ((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<537 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(537 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<537 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<538 + 1024 * 0,true> { int V __attribute__ ((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<538 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(538 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<538 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<539 + 1024 * 0,true> { int V __attribute__ ((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<539 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(539 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<539 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<540 + 1024 * 0,true> { int V __attribute__ ((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<540 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(540 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<540 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<541 + 1024 * 0,true> { int V __attribute__ ((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<541 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(541 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<541 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<542 + 1024 * 0,true> { int V __attribute__ ((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<542 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(542 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<542 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<543 + 1024 * 0,true> { int V __attribute__ ((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<543 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(543 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<543 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<544 + 1024 * 0,true> { int V __attribute__ ((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<544 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(544 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<544 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<545 + 1024 * 0,true> { int V __attribute__ ((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<545 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(545 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<545 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<546 + 1024 * 0,true> { int V __attribute__ ((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<546 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(546 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<546 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<547 + 1024 * 0,true> { int V __attribute__ ((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<547 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(547 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<547 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<548 + 1024 * 0,true> { int V __attribute__ ((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<548 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(548 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<548 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<549 + 1024 * 0,true> { int V __attribute__ ((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<549 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(549 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<549 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<550 + 1024 * 0,true> { int V __attribute__ ((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<550 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(550 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<550 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<551 + 1024 * 0,true> { int V __attribute__ ((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<551 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(551 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<551 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<552 + 1024 * 0,true> { int V __attribute__ ((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<552 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(552 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<552 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<553 + 1024 * 0,true> { int V __attribute__ ((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<553 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(553 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<553 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<554 + 1024 * 0,true> { int V __attribute__ ((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<554 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(554 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<554 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<555 + 1024 * 0,true> { int V __attribute__ ((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<555 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(555 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<555 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<556 + 1024 * 0,true> { int V __attribute__ ((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<556 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(556 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<556 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<557 + 1024 * 0,true> { int V __attribute__ ((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<557 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(557 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<557 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<558 + 1024 * 0,true> { int V __attribute__ ((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<558 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(558 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<558 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<559 + 1024 * 0,true> { int V __attribute__ ((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<559 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(559 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<559 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<560 + 1024 * 0,true> { int V __attribute__ ((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<560 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(560 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<560 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<561 + 1024 * 0,true> { int V __attribute__ ((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<561 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(561 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<561 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<562 + 1024 * 0,true> { int V __attribute__ ((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<562 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(562 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<562 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<563 + 1024 * 0,true> { int V __attribute__ ((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<563 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(563 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<563 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<564 + 1024 * 0,true> { int V __attribute__ ((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<564 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(564 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<564 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<565 + 1024 * 0,true> { int V __attribute__ ((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<565 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(565 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<565 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<566 + 1024 * 0,true> { int V __attribute__ ((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<566 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(566 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<566 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<567 + 1024 * 0,true> { int V __attribute__ ((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<567 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(567 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<567 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<568 + 1024 * 0,true> { int V __attribute__ ((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<568 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(568 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<568 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<569 + 1024 * 0,true> { int V __attribute__ ((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<569 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(569 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<569 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<570 + 1024 * 0,true> { int V __attribute__ ((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<570 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(570 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<570 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<571 + 1024 * 0,true> { int V __attribute__ ((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<571 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(571 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<571 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<572 + 1024 * 0,true> { int V __attribute__ ((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<572 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(572 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<572 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<573 + 1024 * 0,true> { int V __attribute__ ((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<573 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(573 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<573 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<574 + 1024 * 0,true> { int V __attribute__ ((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<574 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(574 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<574 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<575 + 1024 * 0,true> { int V __attribute__ ((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<575 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(575 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<575 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<576 + 1024 * 0,true> { int V __attribute__ ((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<576 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(576 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<576 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<577 + 1024 * 0,true> { int V __attribute__ ((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<577 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(577 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<577 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<578 + 1024 * 0,true> { int V __attribute__ ((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<578 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(578 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<578 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<579 + 1024 * 0,true> { int V __attribute__ ((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<579 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(579 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<579 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<580 + 1024 * 0,true> { int V __attribute__ ((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<580 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(580 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<580 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<581 + 1024 * 0,true> { int V __attribute__ ((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<581 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(581 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<581 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<582 + 1024 * 0,true> { int V __attribute__ ((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<582 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(582 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<582 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<583 + 1024 * 0,true> { int V __attribute__ ((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<583 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(583 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<583 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<584 + 1024 * 0,true> { int V __attribute__ ((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<584 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(584 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<584 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<585 + 1024 * 0,true> { int V __attribute__ ((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<585 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(585 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<585 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<586 + 1024 * 0,true> { int V __attribute__ ((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<586 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(586 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<586 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<587 + 1024 * 0,true> { int V __attribute__ ((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<587 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(587 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<587 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<588 + 1024 * 0,true> { int V __attribute__ ((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<588 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(588 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<588 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<589 + 1024 * 0,true> { int V __attribute__ ((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<589 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(589 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<589 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<590 + 1024 * 0,true> { int V __attribute__ ((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<590 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(590 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<590 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<591 + 1024 * 0,true> { int V __attribute__ ((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<591 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(591 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<591 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<592 + 1024 * 0,true> { int V __attribute__ ((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<592 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(592 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<592 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<593 + 1024 * 0,true> { int V __attribute__ ((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<593 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(593 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<593 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<594 + 1024 * 0,true> { int V __attribute__ ((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<594 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(594 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<594 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<595 + 1024 * 0,true> { int V __attribute__ ((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<595 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(595 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<595 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<596 + 1024 * 0,true> { int V __attribute__ ((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<596 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(596 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<596 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<597 + 1024 * 0,true> { int V __attribute__ ((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<597 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(597 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<597 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<598 + 1024 * 0,true> { int V __attribute__ ((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<598 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(598 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<598 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<599 + 1024 * 0,true> { int V __attribute__ ((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<599 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(599 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<599 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<600 + 1024 * 0,true> { int V __attribute__ ((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<600 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(600 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<600 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<601 + 1024 * 0,true> { int V __attribute__ ((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<601 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(601 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<601 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<602 + 1024 * 0,true> { int V __attribute__ ((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<602 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(602 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<602 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<603 + 1024 * 0,true> { int V __attribute__ ((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<603 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(603 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<603 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<604 + 1024 * 0,true> { int V __attribute__ ((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<604 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(604 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<604 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<605 + 1024 * 0,true> { int V __attribute__ ((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<605 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(605 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<605 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<606 + 1024 * 0,true> { int V __attribute__ ((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<606 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(606 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<606 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<607 + 1024 * 0,true> { int V __attribute__ ((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<607 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(607 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<607 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<608 + 1024 * 0,true> { int V __attribute__ ((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<608 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(608 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<608 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<609 + 1024 * 0,true> { int V __attribute__ ((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<609 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(609 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<609 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<610 + 1024 * 0,true> { int V __attribute__ ((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<610 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(610 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<610 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<611 + 1024 * 0,true> { int V __attribute__ ((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<611 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(611 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<611 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<612 + 1024 * 0,true> { int V __attribute__ ((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<612 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(612 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<612 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<613 + 1024 * 0,true> { int V __attribute__ ((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<613 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(613 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<613 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<614 + 1024 * 0,true> { int V __attribute__ ((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<614 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(614 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<614 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<615 + 1024 * 0,true> { int V __attribute__ ((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<615 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(615 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<615 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<616 + 1024 * 0,true> { int V __attribute__ ((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<616 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(616 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<616 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<617 + 1024 * 0,true> { int V __attribute__ ((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<617 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(617 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<617 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<618 + 1024 * 0,true> { int V __attribute__ ((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<618 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(618 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<618 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<619 + 1024 * 0,true> { int V __attribute__ ((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<619 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(619 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<619 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<620 + 1024 * 0,true> { int V __attribute__ ((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<620 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(620 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<620 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<621 + 1024 * 0,true> { int V __attribute__ ((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<621 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(621 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<621 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<622 + 1024 * 0,true> { int V __attribute__ ((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<622 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(622 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<622 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<623 + 1024 * 0,true> { int V __attribute__ ((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<623 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(623 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<623 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<624 + 1024 * 0,true> { int V __attribute__ ((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<624 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(624 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<624 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<625 + 1024 * 0,true> { int V __attribute__ ((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<625 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(625 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<625 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<626 + 1024 * 0,true> { int V __attribute__ ((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<626 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(626 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<626 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<627 + 1024 * 0,true> { int V __attribute__ ((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<627 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(627 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<627 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<628 + 1024 * 0,true> { int V __attribute__ ((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<628 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(628 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<628 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<629 + 1024 * 0,true> { int V __attribute__ ((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<629 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(629 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<629 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<630 + 1024 * 0,true> { int V __attribute__ ((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<630 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(630 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<630 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<631 + 1024 * 0,true> { int V __attribute__ ((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<631 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(631 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<631 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<632 + 1024 * 0,true> { int V __attribute__ ((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<632 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(632 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<632 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<633 + 1024 * 0,true> { int V __attribute__ ((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<633 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(633 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<633 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<634 + 1024 * 0,true> { int V __attribute__ ((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<634 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(634 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<634 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<635 + 1024 * 0,true> { int V __attribute__ ((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<635 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(635 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<635 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<636 + 1024 * 0,true> { int V __attribute__ ((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<636 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(636 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<636 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<637 + 1024 * 0,true> { int V __attribute__ ((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<637 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(637 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<637 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<638 + 1024 * 0,true> { int V __attribute__ ((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<638 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(638 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<638 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<639 + 1024 * 0,true> { int V __attribute__ ((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<639 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(639 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<639 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<640 + 1024 * 0,true> { int V __attribute__ ((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<640 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(640 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<640 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<641 + 1024 * 0,true> { int V __attribute__ ((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<641 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(641 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<641 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<642 + 1024 * 0,true> { int V __attribute__ ((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<642 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(642 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<642 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<643 + 1024 * 0,true> { int V __attribute__ ((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<643 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(643 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<643 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<644 + 1024 * 0,true> { int V __attribute__ ((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<644 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(644 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<644 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<645 + 1024 * 0,true> { int V __attribute__ ((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<645 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(645 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<645 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<646 + 1024 * 0,true> { int V __attribute__ ((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<646 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(646 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<646 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<647 + 1024 * 0,true> { int V __attribute__ ((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<647 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(647 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<647 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<648 + 1024 * 0,true> { int V __attribute__ ((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<648 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(648 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<648 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<649 + 1024 * 0,true> { int V __attribute__ ((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<649 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(649 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<649 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<650 + 1024 * 0,true> { int V __attribute__ ((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<650 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(650 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<650 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<651 + 1024 * 0,true> { int V __attribute__ ((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<651 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(651 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<651 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<652 + 1024 * 0,true> { int V __attribute__ ((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<652 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(652 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<652 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<653 + 1024 * 0,true> { int V __attribute__ ((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<653 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(653 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<653 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<654 + 1024 * 0,true> { int V __attribute__ ((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<654 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(654 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<654 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<655 + 1024 * 0,true> { int V __attribute__ ((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<655 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(655 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<655 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<656 + 1024 * 0,true> { int V __attribute__ ((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<656 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(656 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<656 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<657 + 1024 * 0,true> { int V __attribute__ ((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<657 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(657 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<657 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<658 + 1024 * 0,true> { int V __attribute__ ((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<658 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(658 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<658 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<659 + 1024 * 0,true> { int V __attribute__ ((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<659 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(659 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<659 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<660 + 1024 * 0,true> { int V __attribute__ ((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<660 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(660 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<660 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<661 + 1024 * 0,true> { int V __attribute__ ((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<661 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(661 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<661 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<662 + 1024 * 0,true> { int V __attribute__ ((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<662 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(662 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<662 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<663 + 1024 * 0,true> { int V __attribute__ ((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<663 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(663 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<663 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<664 + 1024 * 0,true> { int V __attribute__ ((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<664 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(664 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<664 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<665 + 1024 * 0,true> { int V __attribute__ ((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<665 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(665 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<665 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<666 + 1024 * 0,true> { int V __attribute__ ((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<666 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(666 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<666 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<667 + 1024 * 0,true> { int V __attribute__ ((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<667 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(667 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<667 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<668 + 1024 * 0,true> { int V __attribute__ ((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<668 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(668 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<668 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<669 + 1024 * 0,true> { int V __attribute__ ((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<669 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(669 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<669 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<670 + 1024 * 0,true> { int V __attribute__ ((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<670 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(670 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<670 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<671 + 1024 * 0,true> { int V __attribute__ ((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<671 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(671 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<671 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<672 + 1024 * 0,true> { int V __attribute__ ((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<672 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(672 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<672 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<673 + 1024 * 0,true> { int V __attribute__ ((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<673 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(673 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<673 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<674 + 1024 * 0,true> { int V __attribute__ ((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<674 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(674 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<674 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<675 + 1024 * 0,true> { int V __attribute__ ((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<675 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(675 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<675 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<676 + 1024 * 0,true> { int V __attribute__ ((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<676 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(676 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<676 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<677 + 1024 * 0,true> { int V __attribute__ ((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<677 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(677 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<677 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<678 + 1024 * 0,true> { int V __attribute__ ((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<678 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(678 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<678 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<679 + 1024 * 0,true> { int V __attribute__ ((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<679 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(679 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<679 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<680 + 1024 * 0,true> { int V __attribute__ ((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<680 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(680 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<680 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<681 + 1024 * 0,true> { int V __attribute__ ((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<681 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(681 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<681 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<682 + 1024 * 0,true> { int V __attribute__ ((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<682 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(682 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<682 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<683 + 1024 * 0,true> { int V __attribute__ ((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<683 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(683 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<683 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<684 + 1024 * 0,true> { int V __attribute__ ((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<684 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(684 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<684 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<685 + 1024 * 0,true> { int V __attribute__ ((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<685 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(685 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<685 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<686 + 1024 * 0,true> { int V __attribute__ ((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<686 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(686 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<686 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<687 + 1024 * 0,true> { int V __attribute__ ((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<687 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(687 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<687 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<688 + 1024 * 0,true> { int V __attribute__ ((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<688 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(688 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<688 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<689 + 1024 * 0,true> { int V __attribute__ ((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<689 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(689 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<689 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<690 + 1024 * 0,true> { int V __attribute__ ((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<690 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(690 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<690 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<691 + 1024 * 0,true> { int V __attribute__ ((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<691 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(691 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<691 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<692 + 1024 * 0,true> { int V __attribute__ ((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<692 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(692 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<692 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<693 + 1024 * 0,true> { int V __attribute__ ((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<693 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(693 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<693 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<694 + 1024 * 0,true> { int V __attribute__ ((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<694 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(694 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<694 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<695 + 1024 * 0,true> { int V __attribute__ ((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<695 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(695 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<695 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<696 + 1024 * 0,true> { int V __attribute__ ((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<696 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(696 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<696 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<697 + 1024 * 0,true> { int V __attribute__ ((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<697 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(697 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<697 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<698 + 1024 * 0,true> { int V __attribute__ ((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<698 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(698 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<698 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<699 + 1024 * 0,true> { int V __attribute__ ((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<699 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(699 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<699 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<700 + 1024 * 0,true> { int V __attribute__ ((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<700 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(700 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<700 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<701 + 1024 * 0,true> { int V __attribute__ ((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<701 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(701 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<701 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<702 + 1024 * 0,true> { int V __attribute__ ((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<702 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(702 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<702 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<703 + 1024 * 0,true> { int V __attribute__ ((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<703 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(703 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<703 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<704 + 1024 * 0,true> { int V __attribute__ ((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<704 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(704 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<704 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<705 + 1024 * 0,true> { int V __attribute__ ((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<705 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(705 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<705 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<706 + 1024 * 0,true> { int V __attribute__ ((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<706 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(706 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<706 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<707 + 1024 * 0,true> { int V __attribute__ ((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<707 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(707 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<707 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<708 + 1024 * 0,true> { int V __attribute__ ((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<708 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(708 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<708 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<709 + 1024 * 0,true> { int V __attribute__ ((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<709 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(709 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<709 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<710 + 1024 * 0,true> { int V __attribute__ ((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<710 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(710 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<710 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<711 + 1024 * 0,true> { int V __attribute__ ((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<711 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(711 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<711 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<712 + 1024 * 0,true> { int V __attribute__ ((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<712 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(712 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<712 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<713 + 1024 * 0,true> { int V __attribute__ ((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<713 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(713 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<713 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<714 + 1024 * 0,true> { int V __attribute__ ((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<714 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(714 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<714 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<715 + 1024 * 0,true> { int V __attribute__ ((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<715 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(715 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<715 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<716 + 1024 * 0,true> { int V __attribute__ ((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<716 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(716 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<716 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<717 + 1024 * 0,true> { int V __attribute__ ((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<717 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(717 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<717 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<718 + 1024 * 0,true> { int V __attribute__ ((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<718 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(718 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<718 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<719 + 1024 * 0,true> { int V __attribute__ ((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<719 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(719 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<719 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<720 + 1024 * 0,true> { int V __attribute__ ((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<720 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(720 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<720 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<721 + 1024 * 0,true> { int V __attribute__ ((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<721 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(721 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<721 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<722 + 1024 * 0,true> { int V __attribute__ ((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<722 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(722 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<722 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<723 + 1024 * 0,true> { int V __attribute__ ((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<723 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(723 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<723 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<724 + 1024 * 0,true> { int V __attribute__ ((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<724 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(724 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<724 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<725 + 1024 * 0,true> { int V __attribute__ ((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<725 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(725 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<725 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<726 + 1024 * 0,true> { int V __attribute__ ((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<726 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(726 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<726 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<727 + 1024 * 0,true> { int V __attribute__ ((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<727 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(727 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<727 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<728 + 1024 * 0,true> { int V __attribute__ ((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<728 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(728 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<728 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<729 + 1024 * 0,true> { int V __attribute__ ((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<729 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(729 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<729 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<730 + 1024 * 0,true> { int V __attribute__ ((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<730 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(730 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<730 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<731 + 1024 * 0,true> { int V __attribute__ ((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<731 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(731 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<731 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<732 + 1024 * 0,true> { int V __attribute__ ((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<732 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(732 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<732 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<733 + 1024 * 0,true> { int V __attribute__ ((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<733 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(733 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<733 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<734 + 1024 * 0,true> { int V __attribute__ ((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<734 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(734 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<734 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<735 + 1024 * 0,true> { int V __attribute__ ((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<735 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(735 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<735 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<736 + 1024 * 0,true> { int V __attribute__ ((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<736 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(736 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<736 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<737 + 1024 * 0,true> { int V __attribute__ ((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<737 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(737 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<737 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<738 + 1024 * 0,true> { int V __attribute__ ((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<738 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(738 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<738 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<739 + 1024 * 0,true> { int V __attribute__ ((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<739 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(739 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<739 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<740 + 1024 * 0,true> { int V __attribute__ ((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<740 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(740 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<740 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<741 + 1024 * 0,true> { int V __attribute__ ((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<741 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(741 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<741 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<742 + 1024 * 0,true> { int V __attribute__ ((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<742 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(742 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<742 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<743 + 1024 * 0,true> { int V __attribute__ ((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<743 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(743 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<743 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<744 + 1024 * 0,true> { int V __attribute__ ((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<744 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(744 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<744 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<745 + 1024 * 0,true> { int V __attribute__ ((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<745 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(745 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<745 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<746 + 1024 * 0,true> { int V __attribute__ ((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<746 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(746 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<746 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<747 + 1024 * 0,true> { int V __attribute__ ((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<747 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(747 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<747 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<748 + 1024 * 0,true> { int V __attribute__ ((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<748 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(748 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<748 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<749 + 1024 * 0,true> { int V __attribute__ ((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<749 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(749 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<749 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<750 + 1024 * 0,true> { int V __attribute__ ((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<750 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(750 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<750 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<751 + 1024 * 0,true> { int V __attribute__ ((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<751 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(751 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<751 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<752 + 1024 * 0,true> { int V __attribute__ ((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<752 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(752 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<752 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<753 + 1024 * 0,true> { int V __attribute__ ((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<753 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(753 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<753 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<754 + 1024 * 0,true> { int V __attribute__ ((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<754 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(754 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<754 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<755 + 1024 * 0,true> { int V __attribute__ ((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<755 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(755 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<755 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<756 + 1024 * 0,true> { int V __attribute__ ((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<756 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(756 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<756 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<757 + 1024 * 0,true> { int V __attribute__ ((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<757 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(757 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<757 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<758 + 1024 * 0,true> { int V __attribute__ ((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<758 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(758 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<758 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<759 + 1024 * 0,true> { int V __attribute__ ((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<759 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(759 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<759 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<760 + 1024 * 0,true> { int V __attribute__ ((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<760 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(760 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<760 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<761 + 1024 * 0,true> { int V __attribute__ ((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<761 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(761 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<761 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<762 + 1024 * 0,true> { int V __attribute__ ((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<762 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(762 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<762 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<763 + 1024 * 0,true> { int V __attribute__ ((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<763 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(763 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<763 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<764 + 1024 * 0,true> { int V __attribute__ ((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<764 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(764 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<764 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<765 + 1024 * 0,true> { int V __attribute__ ((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<765 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(765 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<765 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<766 + 1024 * 0,true> { int V __attribute__ ((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<766 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(766 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<766 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<767 + 1024 * 0,true> { int V __attribute__ ((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<767 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(767 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<767 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<768 + 1024 * 0,true> { int V __attribute__ ((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<768 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(768 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<768 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<769 + 1024 * 0,true> { int V __attribute__ ((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<769 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(769 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<769 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<770 + 1024 * 0,true> { int V __attribute__ ((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<770 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(770 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<770 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<771 + 1024 * 0,true> { int V __attribute__ ((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<771 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(771 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<771 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<772 + 1024 * 0,true> { int V __attribute__ ((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<772 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(772 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<772 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<773 + 1024 * 0,true> { int V __attribute__ ((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<773 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(773 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<773 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<774 + 1024 * 0,true> { int V __attribute__ ((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<774 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(774 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<774 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<775 + 1024 * 0,true> { int V __attribute__ ((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<775 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(775 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<775 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<776 + 1024 * 0,true> { int V __attribute__ ((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<776 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(776 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<776 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<777 + 1024 * 0,true> { int V __attribute__ ((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<777 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(777 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<777 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<778 + 1024 * 0,true> { int V __attribute__ ((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<778 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(778 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<778 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<779 + 1024 * 0,true> { int V __attribute__ ((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<779 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(779 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<779 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<780 + 1024 * 0,true> { int V __attribute__ ((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<780 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(780 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<780 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<781 + 1024 * 0,true> { int V __attribute__ ((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<781 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(781 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<781 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<782 + 1024 * 0,true> { int V __attribute__ ((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<782 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(782 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<782 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<783 + 1024 * 0,true> { int V __attribute__ ((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<783 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(783 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<783 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<784 + 1024 * 0,true> { int V __attribute__ ((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<784 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(784 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<784 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<785 + 1024 * 0,true> { int V __attribute__ ((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<785 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(785 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<785 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<786 + 1024 * 0,true> { int V __attribute__ ((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<786 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(786 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<786 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<787 + 1024 * 0,true> { int V __attribute__ ((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<787 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(787 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<787 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<788 + 1024 * 0,true> { int V __attribute__ ((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<788 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(788 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<788 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<789 + 1024 * 0,true> { int V __attribute__ ((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<789 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(789 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<789 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<790 + 1024 * 0,true> { int V __attribute__ ((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<790 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(790 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<790 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<791 + 1024 * 0,true> { int V __attribute__ ((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<791 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(791 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<791 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<792 + 1024 * 0,true> { int V __attribute__ ((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<792 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(792 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<792 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<793 + 1024 * 0,true> { int V __attribute__ ((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<793 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(793 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<793 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<794 + 1024 * 0,true> { int V __attribute__ ((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<794 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(794 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<794 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<795 + 1024 * 0,true> { int V __attribute__ ((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<795 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(795 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<795 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<796 + 1024 * 0,true> { int V __attribute__ ((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<796 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(796 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<796 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<797 + 1024 * 0,true> { int V __attribute__ ((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<797 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(797 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<797 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<798 + 1024 * 0,true> { int V __attribute__ ((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<798 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(798 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<798 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<799 + 1024 * 0,true> { int V __attribute__ ((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<799 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(799 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<799 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<800 + 1024 * 0,true> { int V __attribute__ ((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<800 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(800 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<800 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<801 + 1024 * 0,true> { int V __attribute__ ((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<801 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(801 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<801 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<802 + 1024 * 0,true> { int V __attribute__ ((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<802 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(802 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<802 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<803 + 1024 * 0,true> { int V __attribute__ ((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<803 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(803 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<803 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<804 + 1024 * 0,true> { int V __attribute__ ((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<804 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(804 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<804 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<805 + 1024 * 0,true> { int V __attribute__ ((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<805 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(805 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<805 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<806 + 1024 * 0,true> { int V __attribute__ ((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<806 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(806 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<806 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<807 + 1024 * 0,true> { int V __attribute__ ((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<807 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(807 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<807 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<808 + 1024 * 0,true> { int V __attribute__ ((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<808 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(808 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<808 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<809 + 1024 * 0,true> { int V __attribute__ ((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<809 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(809 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<809 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<810 + 1024 * 0,true> { int V __attribute__ ((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<810 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(810 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<810 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<811 + 1024 * 0,true> { int V __attribute__ ((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<811 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(811 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<811 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<812 + 1024 * 0,true> { int V __attribute__ ((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<812 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(812 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<812 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<813 + 1024 * 0,true> { int V __attribute__ ((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<813 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(813 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<813 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<814 + 1024 * 0,true> { int V __attribute__ ((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<814 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(814 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<814 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<815 + 1024 * 0,true> { int V __attribute__ ((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<815 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(815 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<815 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<816 + 1024 * 0,true> { int V __attribute__ ((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<816 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(816 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<816 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<817 + 1024 * 0,true> { int V __attribute__ ((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<817 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(817 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<817 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<818 + 1024 * 0,true> { int V __attribute__ ((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<818 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(818 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<818 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<819 + 1024 * 0,true> { int V __attribute__ ((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<819 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(819 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<819 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<820 + 1024 * 0,true> { int V __attribute__ ((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<820 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(820 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<820 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<821 + 1024 * 0,true> { int V __attribute__ ((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<821 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(821 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<821 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<822 + 1024 * 0,true> { int V __attribute__ ((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<822 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(822 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<822 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<823 + 1024 * 0,true> { int V __attribute__ ((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<823 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(823 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<823 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<824 + 1024 * 0,true> { int V __attribute__ ((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<824 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(824 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<824 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<825 + 1024 * 0,true> { int V __attribute__ ((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<825 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(825 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<825 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<826 + 1024 * 0,true> { int V __attribute__ ((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<826 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(826 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<826 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<827 + 1024 * 0,true> { int V __attribute__ ((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<827 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(827 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<827 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<828 + 1024 * 0,true> { int V __attribute__ ((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<828 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(828 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<828 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<829 + 1024 * 0,true> { int V __attribute__ ((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<829 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(829 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<829 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<830 + 1024 * 0,true> { int V __attribute__ ((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<830 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(830 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<830 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<831 + 1024 * 0,true> { int V __attribute__ ((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<831 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(831 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<831 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<832 + 1024 * 0,true> { int V __attribute__ ((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<832 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(832 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<832 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<833 + 1024 * 0,true> { int V __attribute__ ((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<833 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(833 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<833 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<834 + 1024 * 0,true> { int V __attribute__ ((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<834 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(834 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<834 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<835 + 1024 * 0,true> { int V __attribute__ ((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<835 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(835 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<835 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<836 + 1024 * 0,true> { int V __attribute__ ((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<836 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(836 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<836 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<837 + 1024 * 0,true> { int V __attribute__ ((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<837 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(837 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<837 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<838 + 1024 * 0,true> { int V __attribute__ ((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<838 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(838 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<838 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<839 + 1024 * 0,true> { int V __attribute__ ((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<839 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(839 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<839 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<840 + 1024 * 0,true> { int V __attribute__ ((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<840 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(840 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<840 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<841 + 1024 * 0,true> { int V __attribute__ ((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<841 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(841 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<841 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<842 + 1024 * 0,true> { int V __attribute__ ((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<842 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(842 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<842 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<843 + 1024 * 0,true> { int V __attribute__ ((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<843 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(843 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<843 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<844 + 1024 * 0,true> { int V __attribute__ ((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<844 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(844 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<844 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<845 + 1024 * 0,true> { int V __attribute__ ((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<845 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(845 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<845 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<846 + 1024 * 0,true> { int V __attribute__ ((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<846 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(846 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<846 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<847 + 1024 * 0,true> { int V __attribute__ ((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<847 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(847 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<847 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<848 + 1024 * 0,true> { int V __attribute__ ((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<848 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(848 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<848 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<849 + 1024 * 0,true> { int V __attribute__ ((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<849 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(849 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<849 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<850 + 1024 * 0,true> { int V __attribute__ ((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<850 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(850 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<850 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<851 + 1024 * 0,true> { int V __attribute__ ((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<851 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(851 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<851 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<852 + 1024 * 0,true> { int V __attribute__ ((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<852 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(852 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<852 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<853 + 1024 * 0,true> { int V __attribute__ ((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<853 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(853 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<853 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<854 + 1024 * 0,true> { int V __attribute__ ((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<854 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(854 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<854 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<855 + 1024 * 0,true> { int V __attribute__ ((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<855 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(855 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<855 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<856 + 1024 * 0,true> { int V __attribute__ ((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<856 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(856 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<856 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<857 + 1024 * 0,true> { int V __attribute__ ((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<857 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(857 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<857 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<858 + 1024 * 0,true> { int V __attribute__ ((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<858 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(858 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<858 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<859 + 1024 * 0,true> { int V __attribute__ ((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<859 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(859 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<859 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<860 + 1024 * 0,true> { int V __attribute__ ((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<860 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(860 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<860 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<861 + 1024 * 0,true> { int V __attribute__ ((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<861 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(861 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<861 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<862 + 1024 * 0,true> { int V __attribute__ ((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<862 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(862 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<862 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<863 + 1024 * 0,true> { int V __attribute__ ((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<863 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(863 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<863 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<864 + 1024 * 0,true> { int V __attribute__ ((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<864 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(864 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<864 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<865 + 1024 * 0,true> { int V __attribute__ ((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<865 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(865 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<865 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<866 + 1024 * 0,true> { int V __attribute__ ((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<866 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(866 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<866 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<867 + 1024 * 0,true> { int V __attribute__ ((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<867 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(867 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<867 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<868 + 1024 * 0,true> { int V __attribute__ ((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<868 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(868 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<868 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<869 + 1024 * 0,true> { int V __attribute__ ((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<869 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(869 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<869 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<870 + 1024 * 0,true> { int V __attribute__ ((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<870 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(870 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<870 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<871 + 1024 * 0,true> { int V __attribute__ ((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<871 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(871 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<871 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<872 + 1024 * 0,true> { int V __attribute__ ((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<872 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(872 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<872 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<873 + 1024 * 0,true> { int V __attribute__ ((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<873 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(873 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<873 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<874 + 1024 * 0,true> { int V __attribute__ ((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<874 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(874 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<874 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<875 + 1024 * 0,true> { int V __attribute__ ((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<875 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(875 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<875 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<876 + 1024 * 0,true> { int V __attribute__ ((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<876 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(876 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<876 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<877 + 1024 * 0,true> { int V __attribute__ ((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<877 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(877 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<877 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<878 + 1024 * 0,true> { int V __attribute__ ((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<878 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(878 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<878 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<879 + 1024 * 0,true> { int V __attribute__ ((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<879 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(879 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<879 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<880 + 1024 * 0,true> { int V __attribute__ ((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<880 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(880 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<880 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<881 + 1024 * 0,true> { int V __attribute__ ((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<881 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(881 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<881 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<882 + 1024 * 0,true> { int V __attribute__ ((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<882 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(882 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<882 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<883 + 1024 * 0,true> { int V __attribute__ ((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<883 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(883 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<883 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<884 + 1024 * 0,true> { int V __attribute__ ((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<884 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(884 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<884 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<885 + 1024 * 0,true> { int V __attribute__ ((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<885 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(885 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<885 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<886 + 1024 * 0,true> { int V __attribute__ ((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<886 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(886 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<886 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<887 + 1024 * 0,true> { int V __attribute__ ((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<887 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(887 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<887 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<888 + 1024 * 0,true> { int V __attribute__ ((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<888 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(888 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<888 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<889 + 1024 * 0,true> { int V __attribute__ ((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<889 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(889 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<889 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<890 + 1024 * 0,true> { int V __attribute__ ((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<890 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(890 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<890 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<891 + 1024 * 0,true> { int V __attribute__ ((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<891 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(891 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<891 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<892 + 1024 * 0,true> { int V __attribute__ ((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<892 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(892 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<892 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<893 + 1024 * 0,true> { int V __attribute__ ((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<893 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(893 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<893 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<894 + 1024 * 0,true> { int V __attribute__ ((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<894 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(894 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<894 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<895 + 1024 * 0,true> { int V __attribute__ ((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<895 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(895 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<895 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<896 + 1024 * 0,true> { int V __attribute__ ((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<896 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(896 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<896 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<897 + 1024 * 0,true> { int V __attribute__ ((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<897 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(897 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<897 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<898 + 1024 * 0,true> { int V __attribute__ ((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<898 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(898 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<898 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<899 + 1024 * 0,true> { int V __attribute__ ((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<899 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(899 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<899 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<900 + 1024 * 0,true> { int V __attribute__ ((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<900 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(900 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<900 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<901 + 1024 * 0,true> { int V __attribute__ ((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<901 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(901 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<901 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<902 + 1024 * 0,true> { int V __attribute__ ((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<902 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(902 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<902 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<903 + 1024 * 0,true> { int V __attribute__ ((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<903 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(903 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<903 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<904 + 1024 * 0,true> { int V __attribute__ ((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<904 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(904 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<904 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<905 + 1024 * 0,true> { int V __attribute__ ((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<905 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(905 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<905 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<906 + 1024 * 0,true> { int V __attribute__ ((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<906 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(906 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<906 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<907 + 1024 * 0,true> { int V __attribute__ ((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<907 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(907 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<907 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<908 + 1024 * 0,true> { int V __attribute__ ((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<908 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(908 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<908 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<909 + 1024 * 0,true> { int V __attribute__ ((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<909 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(909 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<909 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<910 + 1024 * 0,true> { int V __attribute__ ((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<910 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(910 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<910 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<911 + 1024 * 0,true> { int V __attribute__ ((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<911 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(911 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<911 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<912 + 1024 * 0,true> { int V __attribute__ ((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<912 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(912 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<912 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<913 + 1024 * 0,true> { int V __attribute__ ((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<913 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(913 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<913 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<914 + 1024 * 0,true> { int V __attribute__ ((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<914 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(914 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<914 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<915 + 1024 * 0,true> { int V __attribute__ ((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<915 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(915 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<915 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<916 + 1024 * 0,true> { int V __attribute__ ((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<916 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(916 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<916 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<917 + 1024 * 0,true> { int V __attribute__ ((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<917 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(917 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<917 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<918 + 1024 * 0,true> { int V __attribute__ ((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<918 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(918 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<918 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<919 + 1024 * 0,true> { int V __attribute__ ((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<919 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(919 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<919 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<920 + 1024 * 0,true> { int V __attribute__ ((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<920 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(920 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<920 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<921 + 1024 * 0,true> { int V __attribute__ ((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<921 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(921 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<921 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<922 + 1024 * 0,true> { int V __attribute__ ((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<922 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(922 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<922 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<923 + 1024 * 0,true> { int V __attribute__ ((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<923 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(923 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<923 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<924 + 1024 * 0,true> { int V __attribute__ ((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<924 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(924 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<924 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<925 + 1024 * 0,true> { int V __attribute__ ((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<925 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(925 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<925 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<926 + 1024 * 0,true> { int V __attribute__ ((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<926 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(926 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<926 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<927 + 1024 * 0,true> { int V __attribute__ ((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<927 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(927 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<927 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<928 + 1024 * 0,true> { int V __attribute__ ((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<928 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(928 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<928 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<929 + 1024 * 0,true> { int V __attribute__ ((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<929 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(929 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<929 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<930 + 1024 * 0,true> { int V __attribute__ ((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<930 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(930 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<930 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<931 + 1024 * 0,true> { int V __attribute__ ((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<931 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(931 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<931 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<932 + 1024 * 0,true> { int V __attribute__ ((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<932 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(932 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<932 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<933 + 1024 * 0,true> { int V __attribute__ ((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<933 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(933 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<933 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<934 + 1024 * 0,true> { int V __attribute__ ((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<934 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(934 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<934 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<935 + 1024 * 0,true> { int V __attribute__ ((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<935 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(935 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<935 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<936 + 1024 * 0,true> { int V __attribute__ ((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<936 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(936 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<936 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<937 + 1024 * 0,true> { int V __attribute__ ((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<937 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(937 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<937 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<938 + 1024 * 0,true> { int V __attribute__ ((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<938 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(938 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<938 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<939 + 1024 * 0,true> { int V __attribute__ ((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<939 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(939 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<939 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<940 + 1024 * 0,true> { int V __attribute__ ((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<940 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(940 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<940 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<941 + 1024 * 0,true> { int V __attribute__ ((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<941 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(941 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<941 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<942 + 1024 * 0,true> { int V __attribute__ ((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<942 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(942 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<942 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<943 + 1024 * 0,true> { int V __attribute__ ((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<943 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(943 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<943 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<944 + 1024 * 0,true> { int V __attribute__ ((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<944 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(944 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<944 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<945 + 1024 * 0,true> { int V __attribute__ ((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<945 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(945 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<945 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<946 + 1024 * 0,true> { int V __attribute__ ((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<946 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(946 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<946 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<947 + 1024 * 0,true> { int V __attribute__ ((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<947 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(947 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<947 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<948 + 1024 * 0,true> { int V __attribute__ ((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<948 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(948 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<948 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<949 + 1024 * 0,true> { int V __attribute__ ((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<949 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(949 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<949 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<950 + 1024 * 0,true> { int V __attribute__ ((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<950 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(950 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<950 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<951 + 1024 * 0,true> { int V __attribute__ ((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<951 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(951 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<951 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<952 + 1024 * 0,true> { int V __attribute__ ((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<952 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(952 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<952 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<953 + 1024 * 0,true> { int V __attribute__ ((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<953 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(953 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<953 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<954 + 1024 * 0,true> { int V __attribute__ ((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<954 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(954 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<954 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<955 + 1024 * 0,true> { int V __attribute__ ((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<955 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(955 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<955 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<956 + 1024 * 0,true> { int V __attribute__ ((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<956 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(956 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<956 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<957 + 1024 * 0,true> { int V __attribute__ ((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<957 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(957 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<957 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<958 + 1024 * 0,true> { int V __attribute__ ((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<958 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(958 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<958 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<959 + 1024 * 0,true> { int V __attribute__ ((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<959 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(959 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<959 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<960 + 1024 * 0,true> { int V __attribute__ ((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<960 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(960 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<960 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<961 + 1024 * 0,true> { int V __attribute__ ((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<961 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(961 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<961 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<962 + 1024 * 0,true> { int V __attribute__ ((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<962 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(962 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<962 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<963 + 1024 * 0,true> { int V __attribute__ ((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<963 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(963 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<963 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<964 + 1024 * 0,true> { int V __attribute__ ((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<964 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(964 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<964 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<965 + 1024 * 0,true> { int V __attribute__ ((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<965 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(965 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<965 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<966 + 1024 * 0,true> { int V __attribute__ ((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<966 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(966 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<966 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<967 + 1024 * 0,true> { int V __attribute__ ((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<967 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(967 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<967 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<968 + 1024 * 0,true> { int V __attribute__ ((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<968 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(968 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<968 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<969 + 1024 * 0,true> { int V __attribute__ ((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<969 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(969 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<969 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<970 + 1024 * 0,true> { int V __attribute__ ((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<970 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(970 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<970 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<971 + 1024 * 0,true> { int V __attribute__ ((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<971 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(971 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<971 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<972 + 1024 * 0,true> { int V __attribute__ ((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<972 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(972 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<972 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<973 + 1024 * 0,true> { int V __attribute__ ((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<973 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(973 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<973 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<974 + 1024 * 0,true> { int V __attribute__ ((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<974 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(974 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<974 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<975 + 1024 * 0,true> { int V __attribute__ ((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<975 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(975 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<975 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<976 + 1024 * 0,true> { int V __attribute__ ((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<976 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(976 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<976 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<977 + 1024 * 0,true> { int V __attribute__ ((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<977 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(977 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<977 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<978 + 1024 * 0,true> { int V __attribute__ ((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<978 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(978 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<978 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<979 + 1024 * 0,true> { int V __attribute__ ((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<979 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(979 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<979 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<980 + 1024 * 0,true> { int V __attribute__ ((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<980 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(980 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<980 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<981 + 1024 * 0,true> { int V __attribute__ ((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<981 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(981 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<981 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<982 + 1024 * 0,true> { int V __attribute__ ((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<982 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(982 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<982 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<983 + 1024 * 0,true> { int V __attribute__ ((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<983 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(983 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<983 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<984 + 1024 * 0,true> { int V __attribute__ ((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<984 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(984 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<984 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<985 + 1024 * 0,true> { int V __attribute__ ((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<985 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(985 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<985 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<986 + 1024 * 0,true> { int V __attribute__ ((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<986 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(986 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<986 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<987 + 1024 * 0,true> { int V __attribute__ ((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<987 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(987 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<987 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<988 + 1024 * 0,true> { int V __attribute__ ((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<988 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(988 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<988 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<989 + 1024 * 0,true> { int V __attribute__ ((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<989 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(989 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<989 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<990 + 1024 * 0,true> { int V __attribute__ ((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<990 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(990 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<990 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<991 + 1024 * 0,true> { int V __attribute__ ((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<991 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(991 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<991 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<992 + 1024 * 0,true> { int V __attribute__ ((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<992 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(992 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<992 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<993 + 1024 * 0,true> { int V __attribute__ ((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<993 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(993 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<993 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<994 + 1024 * 0,true> { int V __attribute__ ((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<994 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(994 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<994 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<995 + 1024 * 0,true> { int V __attribute__ ((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<995 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(995 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<995 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<996 + 1024 * 0,true> { int V __attribute__ ((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<996 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(996 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<996 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<997 + 1024 * 0,true> { int V __attribute__ ((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<997 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(997 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<997 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<998 + 1024 * 0,true> { int V __attribute__ ((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<998 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(998 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<998 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<999 + 1024 * 0,true> { int V __attribute__ ((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<999 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(999 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<999 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1000 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1000 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1000 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1000 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1001 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1001 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1001 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1001 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1002 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1002 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1002 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1002 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1003 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1003 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1003 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1003 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1004 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1004 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1004 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1004 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1005 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1005 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1005 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1005 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1006 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1006 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1006 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1006 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1007 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1007 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1007 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1007 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1008 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1008 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1008 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1008 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1009 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1009 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1009 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1009 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1010 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1010 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1010 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1010 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1011 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1011 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1011 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1011 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1012 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1012 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1012 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1012 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1013 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1013 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1013 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1013 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1014 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1014 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1014 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1014 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1015 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1015 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1015 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1015 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1016 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1016 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1016 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1016 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1017 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1017 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1017 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1017 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1018 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1018 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1018 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1018 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1019 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1019 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1019 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1019 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1020 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1020 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1020 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1020 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1021 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1021 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1021 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1021 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1022 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1022 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1022 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1022 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1023 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1023 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1023 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1023 + 1024 * 0 , false>() { }; };
template<> struct ssdm_int<1024 + 1024 * 0,true> { int V __attribute__ ((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0 ,true>() { }; }; template<> struct ssdm_int<1024 + 1024 * 0, false> { unsigned int V __attribute__ ((bitwidth(1024 + 1024 * 0))); inline __attribute__((always_inline)) ssdm_int<1024 + 1024 * 0 , false>() { }; };
# 185 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h" 2
# 603 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
enum BaseMode { SC_BIN=2, SC_OCT=8, SC_DEC=10, SC_HEX=16 };
# 646 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
/* autopilot_ssdm_bits.h */
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 * $Id$
 */
# 98 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Concatination ----------------*/
# 108 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Bit get/set ----------------*/
# 129 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Part get/set ----------------*/

/* GetRange: Notice that the order of the range indices comply with SystemC
 standards. */
# 143 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* SetRange: Notice that the order of the range indices comply with SystemC
 standards. */
# 156 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- Reduce operations ----------------*/
# 192 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
/* -- String-Integer conversions ----------------*/
# 358 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_ssdm_bits.h"
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 647 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h" 2


/* Forward declaration.*/
template<int _AP_W, bool _AP_S, bool _AP_C = (_AP_W <= 64)>
struct ap_int_base;
template<int _AP_W, bool _AP_S> struct ap_range_ref;
template<int _AP_W, bool _AP_S> struct ap_bit_ref;
template<int _AP_W> struct ap_uint;
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2> struct ap_concat_ref;

enum ap_q_mode {
    SC_RND, // rounding to plus infinity
    SC_RND_ZERO, // rounding to zero
    SC_RND_MIN_INF, // rounding to minus infinity
    SC_RND_INF, // rounding to infinity
    SC_RND_CONV, // convergent rounding
    SC_TRN, // truncation
    SC_TRN_ZERO // truncation to zero

};
enum ap_o_mode {
    SC_SAT, // saturation
    SC_SAT_ZERO, // saturation to zero
    SC_SAT_SYM, // symmetrical saturation
    SC_WRAP, // wrap-around (*)
    SC_WRAP_SM // sign magnitude wrap-around (*)
};
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct ap_fixed_base;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_range_ref;
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> struct af_bit_ref;



/* Concatination reference.
 ----------------------------------------------------------------
*/
template<int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
    enum { _AP_WR = _AP_W1+_AP_W2, };

    _AP_T1& mbv1;
    _AP_T2& mbv2;

    inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1,
                          _AP_W2, _AP_T2>& ref):
           mbv1(ref.mbv1), mbv2(ref.mbv2) {}

    inline __attribute__((always_inline)) ap_concat_ref( _AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) { }


    template <int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_int_base<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        ap_int_base<_AP_W1,false> Part1;
        Part1.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1+W_ref2-1); __Result__; });
        mbv1.set(Part1);
        ap_int_base<_AP_W2,false> Part2;
        Part2.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2-1); __Result__; });
        mbv2.set(Part2);
        return *this;
    }

    inline __attribute__((always_inline)) ap_concat_ref& operator = (unsigned long long val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    /*template<typename _AP_T3>
    INLINE ap_concat_ref& operator = ( const _AP_T3& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator=<_AP_W1+_AP_W2,false>(tmpVal);
    }*/
    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_concat_ref<_AP_W1,_AP_T1,_AP_W2,_AP_T2>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_bit_ref<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref& operator = (const ap_range_ref<_AP_W3, _AP_S3>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> tmpVal(val);
        return operator = (tmpVal);
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const af_range_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = ((const ap_int_base<_AP_W3, false>)(val));
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator = (val.to_ap_int_base());
    }

    template<int _AP_W3, int _AP_I3, bool _AP_S3,
             ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline)) ap_concat_ref& operator= (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3,
                                    _AP_Q3, _AP_O3, _AP_N3>& val) {
        return operator=((unsigned long long)(bool)(val));
    }
    inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false> () const {
        return get();
    }

    inline __attribute__((always_inline)) operator unsigned long long () const {
        return get().to_uint64();
    }



    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >
    operator, (const ap_range_ref<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_range_ref<_AP_W3, _AP_S3> >(*this,
                          const_cast<ap_range_ref<_AP_W3, _AP_S3>& >(a2));
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (ap_int_base<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (volatile ap_int_base<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                 _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                 const_cast<ap_int_base<_AP_W3, _AP_S3>& >(a2));
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (const ap_int_base<_AP_W3, _AP_S3>& a2) {
   ap_int_base<_AP_W3,_AP_S3> op(a2);
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_int_base<_AP_W3, _AP_S3>& >(op));
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
    operator, (const volatile ap_int_base<_AP_W3, _AP_S3>& a2) {
   ap_int_base<_AP_W3,_AP_S3> op(a2);
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           _AP_W3, ap_int_base<_AP_W3, _AP_S3> >(*this,
                           const_cast<ap_int_base<_AP_W3, _AP_S3>& >(op));
    }
    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
    operator, (const ap_bit_ref<_AP_W3, _AP_S3>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                           1, ap_bit_ref<_AP_W3, _AP_S3> >(*this,
                 const_cast<ap_bit_ref<_AP_W3, _AP_S3>& >(a2));
    }

    template<int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3+_AP_W4,
                         ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >
    operator, (const ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4>& a2) {
      return ap_concat_ref<_AP_WR, ap_concat_ref,
                  _AP_W3+_AP_W4, ap_concat_ref<_AP_W3,_AP_T3,_AP_W4,_AP_T4> >(
                 *this, const_cast<ap_concat_ref<_AP_W3,_AP_T3,
                 _AP_W4,_AP_T4>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, af_range_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_range_ref< _AP_W3, _AP_I3, _AP_S3, _AP_Q3,
                _AP_O3, _AP_N3>& >(a2));
    }

    template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3, ap_o_mode _AP_O3, int _AP_N3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
    operator, (const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
               _AP_O3, _AP_N3> &a2) {
        return ap_concat_ref<_AP_WR, ap_concat_ref, 1, af_bit_ref<_AP_W3,
                _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(*this,
                const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3,
                 _AP_O3, _AP_N3>& >(a2));
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator & (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() & a2;
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator | (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() | a2;
    }

    template<int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3>
    operator ^ (const ap_int_base<_AP_W3,_AP_S3>& a2) {
      return get() ^ a2;
    }
# 881 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 inline __attribute__((always_inline)) ap_int_base<_AP_WR,false> get() const {
        ap_int_base<_AP_WR,false> tmpVal(0);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        tmpVal.V = ({ typeof(tmpVal.V) __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof((ap_int_base<_AP_W2,false>(mbv2)).V) __Repl2__ = (ap_int_base<_AP_W2,false>(mbv2)).V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2-1); __Result__; });

        tmpVal.V = ({ typeof(tmpVal.V) __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof((ap_int_base<_AP_W1,false>(mbv1)).V) __Repl2__ = (ap_int_base<_AP_W1,false>(mbv1)).V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1+W_ref2-1); __Result__; });

        return tmpVal;
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        ap_int_base<_AP_W1+_AP_W2, false> vval(val);
        int W_ref1 = mbv1.length();
        int W_ref2 = mbv2.length();
        ap_int_base<_AP_W1,false> tmpVal1;
        tmpVal1.V = ({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1+W_ref2-1); __Result__; });
        mbv1.set(tmpVal1);
        ap_int_base<_AP_W2, false> tmpVal2;
        tmpVal2.V=({ typeof(vval.V) __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2-1); __Result__; });
        mbv2.set(tmpVal2);
    }

    inline __attribute__((always_inline)) int length() const {
      return mbv1.length() + mbv2.length();
    }
};
# 920 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
/* Range (slice) reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, bool _AP_S>
struct ap_range_ref {
    ap_int_base<_AP_W,_AP_S> &d_bv;
    int l_index;
    int h_index;

public:
    inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref):
      d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline __attribute__((always_inline)) ap_range_ref(ap_int_base<_AP_W,_AP_S>* bv, int h, int l) :
        d_bv(*bv), l_index(l), h_index(h) {
        /*AP_ASSERT(h >= l, "Range must be (High, Low)");*/
    }

    inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false> () const {
        ap_int_base<_AP_W,false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret;
    }

    inline __attribute__((always_inline)) operator unsigned long long () const {
        return to_uint64();
    }

    inline __attribute__((always_inline)) ap_range_ref& operator = (unsigned long long val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)val);
    }

    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_range_ref<_AP_W, _AP_S>& val) {
        return operator=((const ap_int_base<_AP_W, false>)val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_int_base());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_range_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                      ap_range_ref<_AP_W2,_AP_S2> >(*this,
                      const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (ap_int_base<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }

    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W,ap_int_base<_AP_W,_AP_S> >
    operator, (ap_int_base<_AP_W,_AP_S> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W,_AP_S> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (volatile ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this,
                 const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (const ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this,
              const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,_AP_W2,ap_int_base<_AP_W2,_AP_S2> >
    operator, (const volatile ap_int_base<_AP_W2,_AP_S2>& a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                       ap_int_base<_AP_W2,_AP_S2> >(*this,
                       const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W,ap_range_ref,1,ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2,_AP_S2> &a2) {
        return
          ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2+_AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2,_AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_range_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2,_AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop(*this);
        ap_int_base<_AP_W2, false> hop(op2);
        return lop == hop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return !(operator == (op2));
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop (*this);

        ap_int_base<_AP_W2, false> hop (op2);
        return lop < hop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop (*this);

        ap_int_base<_AP_W2, false> hop (op2);
        return lop <= hop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
       return !(operator <= (op2));
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
       return !(operator < (op2));
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    }

    inline __attribute__((always_inline)) int length() const {
      return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
    }

    inline __attribute__((always_inline)) int to_int() const {
        return (int)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return (unsigned)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) long to_long() const {
        return (long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned long to_ulong() const {
        return (unsigned long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return (ap_slong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return (ap_ulong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) bool and_reduce() const {
        bool ret = true;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i) {
            _ssdm_Unroll(0,0,0, "");
            ret &= (bool)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); __Result__; }));
        }
        return ret;
    }
    inline __attribute__((always_inline)) bool or_reduce() const {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i) {
            _ssdm_Unroll(0,0,0, "");
            ret |= (bool)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); __Result__; }));
        }
        return ret;
    }
    inline __attribute__((always_inline)) bool xor_reduce() const {
        bool ret = false;
        bool reverse = l_index > h_index;
        unsigned low = reverse ? h_index : l_index;
        unsigned high = reverse ? l_index : h_index;
        for (unsigned i = low; i != high; ++i) {
            _ssdm_Unroll(0,0,0, "");
            ret ^= (bool)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); __Result__; }));
        }
        return ret;
    }
};


/* Bit reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, bool _AP_S>
struct ap_bit_ref {
    ap_int_base<_AP_W, _AP_S>& d_bv;
    int d_index;

public:
    inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref):
            d_bv(ref.d_bv), d_index(ref.d_index) {}

    inline __attribute__((always_inline)) ap_bit_ref(ap_int_base<_AP_W,_AP_S>* bv, int index=0) :
        d_bv(*bv), d_index(index) { }
    inline __attribute__((always_inline)) operator bool () const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }
    inline __attribute__((always_inline)) bool to_bool() const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }

    inline __attribute__((always_inline)) ap_bit_ref& operator = ( unsigned long long val ) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = ( const ap_int_base<_AP_W2,_AP_S2> &val ) {
        return operator =((unsigned long long)(val.V != 0));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2> &val ) {
        return operator =(val.operator ap_int_base<_AP_W2, false>());
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref& operator = (const ap_bit_ref<_AP_W2,_AP_S2>& val) {
        return operator =((unsigned long long) (bool) val);
    }

    inline __attribute__((always_inline)) ap_bit_ref& operator = (const ap_bit_ref<_AP_W,_AP_S>& val) {
        return operator =((unsigned long long) (bool) val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }


    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (volatile ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2>
                  >(*this, const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) {
  ap_int_base<_AP_W2,_AP_S2> op(a2);
        return ap_concat_ref<1,ap_bit_ref,_AP_W2,ap_int_base<_AP_W2,
               _AP_S2> >(*this, const_cast<ap_int_base<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >
    operator, (const volatile ap_int_base<_AP_W2, _AP_S2>& a2) {
  ap_int_base<_AP_W2,_AP_S2> op(a2);
        return ap_concat_ref<1,ap_bit_ref,_AP_W2, ap_int_base<_AP_W2,_AP_S2>
                 >(*this, const_cast< ap_int_base<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,_AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return
            ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2,
                    _AP_S2> >(*this, const_cast<ap_range_ref<_AP_W2, _AP_S2> &>(a2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2,_AP_S2> >(*this,
                 const_cast<ap_bit_ref<_AP_W2,_AP_S2>& >(a2));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> >
    operator, (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &a2) {
        return ap_concat_ref<1,ap_bit_ref,_AP_W2+_AP_W3,ap_concat_ref<_AP_W2,
                  _AP_T2,_AP_W3,_AP_T3> >(*this,
                  const_cast<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3> &>(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() == op.get();
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        return get() != op.get();
    }

    inline __attribute__((always_inline)) bool get() const {
         return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }

    inline __attribute__((always_inline)) bool get() {
         return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        operator = (val);
    }

    inline __attribute__((always_inline)) bool operator ~() const {
        bool bit = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
        return bit ? false : true;
    }

    inline __attribute__((always_inline)) int length() const { return 1; }
};

template <int _AP_N, bool _AP_S> struct retval;

template <int _AP_N>
struct retval<_AP_N, true> {
    typedef ap_slong Type;
};
template <int _AP_N>
struct retval<_AP_N, false> {
    typedef ap_ulong Type;
};

template<> struct retval<1, true> {
    typedef signed char Type;
};
template<> struct retval<1, false> {
    typedef unsigned char Type;
};
template<> struct retval<2, true> {
    typedef short Type;
};
template<> struct retval<2, false> {
    typedef unsigned short Type;
};
template<> struct retval<3, true> {
    typedef int Type;
};
template<> struct retval<3, false> {
    typedef unsigned int Type;
};
template<> struct retval<4, true> {
    typedef int Type;
};
template<> struct retval<4, false> {
    typedef unsigned int Type;
};

/* ----------------------------------------------------------------
 ap_int_base: AutoPilot integer/Arbitrary precision integer.
 ----------------------------------------------------------------
*/

template<int _AP_W, bool _AP_S>
struct ap_int_base <_AP_W, _AP_S, true>: public ssdm_int<_AP_W,_AP_S> {

public:
    typedef ssdm_int<_AP_W, _AP_S> Base;

    typedef typename retval< (_AP_W + 7)/8, _AP_S>::Type RetType;

    static const int width = _AP_W;



    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };

        typedef ap_int_base<mult_w, mult_s> mult;
        typedef ap_int_base<plus_w, plus_s> plus;
        typedef ap_int_base<minus_w, minus_s> minus;
        typedef ap_int_base<logic_w, logic_s> logic;
        typedef ap_int_base<div_w, div_s> div;
        typedef ap_int_base<mod_w, mod_s> mod;
        typedef ap_int_base<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };

    /* Constructors.
     ----------------------------------------------------------------
   */
   inline __attribute__((always_inline)) ap_int_base() {
/*
   #ifdef __SC_COMPATIBLE__
       Base::V = 0;
   #endif
*/
   }

    //INLINE ap_int_base(const ap_int_base& op) { Base::V = op.V; }
    //INLINE ap_int_base(const volatile ap_int_base& op) { Base::V = op.V; }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }

 template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }

    /* For C++ basic data types.*/




    inline __attribute__((always_inline)) explicit ap_int_base(bool op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(signed char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_slong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_ulong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(half op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(float op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(double op) { Base::V = op; }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op) {
      Base::V = op.to_ap_int_base().V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator ap_int_base<_AP_W2, false>().V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator bool();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& ref) {
        const ap_int_base<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>::_AP_WR,false> tmp = ref.get();
        Base::V = tmp.V;
    }

    /* This constructor is not usable yet, because the second parameter of 
     __builtin_bit_from_string(...)
     is required to be a constant C string.
    */
    inline __attribute__((always_inline)) ap_int_base(const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10,
         _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
    }

    inline __attribute__((always_inline)) ap_int_base(const char* str, signed char radix) {_ssdm_SpecConstant(&width);
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix,
             _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = (val.operator ap_int_base<_AP_W2, false> ()).V;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = val.operator bool ();
    }

    inline __attribute__((always_inline)) ap_int_base read() volatile {
                                                    ;
        ap_int_base ret;
        ret.V = Base::V;
        return ret;
    }
    inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
                                                   ;
        Base::V = op2.V;
    }

    /* Another form of "write".*/

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }

    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }

    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }
# 1567 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator = (const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str),
                 10, _AP_W, _AP_S, SC_TRN, SC_WRAP, 0,true);
        Base::V = Result;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& set(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix,
                           _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
        return *this;
    }







inline __attribute__((always_inline)) ap_int_base& operator = (signed char op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned char op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (short op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned short op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (int op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned int op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (ap_slong op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (ap_ulong op) { Base::V = op; return *this; }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (bool) op2;
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
        return *this;
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& op2) {
      Base::V = op2.get().V;
      return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = op.to_ap_int_base().V;
        return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = (bool) op;
        return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
        return *this;
    }

    inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }


    /* Explicit conversions to C interger types.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool to_bool() const {return (bool)(Base::V);}
    inline __attribute__((always_inline)) unsigned char to_uchar() const {return (unsigned char)(Base::V);}
    inline __attribute__((always_inline)) signed char to_char() const {return (signed char)(Base::V);}
    inline __attribute__((always_inline)) unsigned short to_ushort() const {return (unsigned short)(Base::V);}
    inline __attribute__((always_inline)) short to_short() const {return (short)(Base::V);}
    inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
    inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
    inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
    inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
    inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
    inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 1686 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 inline __attribute__((always_inline)) int length() const { return _AP_W; }
    inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }

    /*INLINE operator ap_ulong () { return (ap_ulong)(Base::V); }*/

    /*Reverse the contents of ap_int_base instance. I.e. LSB becomes MSB and vise versa*/
    inline __attribute__((always_inline)) ap_int_base& reverse () {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
        return *this;
    }

    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool iszero () const {
        return Base::V == 0 ;
    }

    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool is_zero () const {
        return Base::V == 0 ;
    }

    /* x < 0 */
    inline __attribute__((always_inline)) bool sign () const {
        if (_AP_S && ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }))
            return true;
        else
            return false;
    }

    /* x[i] = 0 */
    inline __attribute__((always_inline)) void clear(int i) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    /* x[i] = !x[i]*/
    inline __attribute__((always_inline)) void invert(int i) {
                                                                ;
        bool val = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
        if (val) Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
        else Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }


    inline __attribute__((always_inline)) bool test (int i) const {
                                                                ;
        return ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }

    //Set the ith bit into 1
    inline __attribute__((always_inline)) void set (int i) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //Set the ith bit into v
    inline __attribute__((always_inline)) void set (int i, bool v) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the left
    inline __attribute__((always_inline)) void lrotate(int n) {
                                                                   ;
         typeof(Base::V) l_p = Base::V << n;
         typeof(Base::V) r_p = Base::V >> (_AP_W - n);
         Base::V = l_p | r_p;
    }

    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the right 
    inline __attribute__((always_inline)) void rrotate(int n) {
                                                                   ;
         typeof(Base::V) l_p = Base::V << (_AP_W - n);
         typeof(Base::V) r_p = Base::V >> n;
         Base::V = l_p | r_p;
    }

    //Set the ith bit into v 
    inline __attribute__((always_inline)) void set_bit (int i, bool v) {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //Get the value of ith bit
    inline __attribute__((always_inline)) bool get_bit (int i) const {
        return (bool)({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }

    //complements every bit 
    inline __attribute__((always_inline)) void b_not() {
       Base::V = ~Base::V;
    }

    // Count the number of zeros from the most significant bit 
    // to the first one bit. Note this is only for ap_fixed_base whose 
    // _AP_W <= 64, otherwise will incur assertion.
    inline __attribute__((always_inline)) int countLeadingZeros() {
        if (_AP_W <= 32) {
            ap_int_base<32, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctz(t.V);
        } else if (_AP_W <= 64) {
            ap_int_base<64, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctzll(t.V);
        } else {
            enum { __N = (_AP_W+63)/64 };
            int NZeros = 0;
            int i = 0;
            bool hitNonZero = false;
            for (i=0; i<__N-1; ++i) {
                ap_int_base<64, false> t;
                t.range(0, 63) = this->range(_AP_W - i*64 - 64, _AP_W - i*64 - 1);
                NZeros += hitNonZero?0:__builtin_clzll(t.V);
                hitNonZero |= (t.to_uint64() != 0);
            }
            if (!hitNonZero) {
                ap_int_base<64, false> t(-1ULL);
                t.range(63-(_AP_W-1)%64, 63) = this->range(0, (_AP_W-1)%64);
                NZeros += __builtin_clzll(t.V);
            }
            return NZeros;
        }
    }
# 1820 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 /* Arithmetic assign.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V *= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator += ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V += op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V -= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V /= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V %= op2.V; return *this; }

    /* Bitwise assign: and, or, xor.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V &= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V |= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V ^= op2.V; return *this; }


    /* Prefix increment, decrement.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base& operator ++() {
        operator+=((ap_int_base<1,false>) 1);
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator --() {
        operator-=((ap_int_base<1,false>) 1);
        return *this;
    }

    /* Postfix increment, decrement
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) const ap_int_base operator ++(int) {
        ap_int_base t = *this;
        operator+=((ap_int_base<1,false>) 1);
        return t;
    }
    inline __attribute__((always_inline)) const ap_int_base operator --(int) {
        ap_int_base t = *this;
        operator-=((ap_int_base<1,false>) 1);
        return t;
    }

    /* Unary arithmetic.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base operator +() const {
        return *this;
    }
    /* Not (!)
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool operator ! () const {
        return Base::V == 0;
    }

    inline __attribute__((always_inline)) ap_int_base<((64) < (_AP_W + 1) ? (64) : (_AP_W + 1)), true>
                      operator -() const {
        return ((ap_int_base<1,false>) 0) - *this;
    }

    /* Shift (result constrained by left operand).
     ----------------------------------------------------------------
    */

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,true> &op2 ) const {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator >> (sh);
        } else
            return operator << (sh);
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r ;
        r.V = Base::V << op2.to_uint();
        return r;
    }


    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,true> &op2 ) const {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator << (sh);
        }
        return operator >> (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r;
        r.V = Base::V >> op2.to_uint();
        return r;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this << (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this >> (op2.operator ap_int_base<_AP_W2, false>());
    }


    /* Shift assign
     ----------------------------------------------------------------
    */
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,true> &op2 ) {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator >>= (sh);
        } else
            return operator <<= (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V <<= op2.to_uint();
        return *this;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,true> &op2 ) {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator <<= (sh);
        }
        return operator >>= (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V >>= op2.to_uint();
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this <<= (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this >>= (op2.operator ap_int_base<_AP_W2, false>());
    }

    /* Comparisons.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V == op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return !(Base::V == op2.V);
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V < op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V >= op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V > op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V <= op2.V;
    }


    /* Bit and Part Select
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }
# 2044 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (int index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_int_base<_AP_W2,_AP_S2> &index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }

    inline __attribute__((always_inline)) bool operator [] (int index) const {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator [] (const ap_int_base<_AP_W2,_AP_S2>& index) const {
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this),
                                   index.to_int());
        return br.to_bool();
    }

     inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (int index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (const ap_int_base<_AP_W2,_AP_S2> &index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }

    inline __attribute__((always_inline)) bool bit (int index) const {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool bit (const ap_int_base<_AP_W2,_AP_S2>& index) const {
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }
# 2107 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(const ap_int_base<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                                                      const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(ap_int_base<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                     const_cast< ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(*this,
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this), const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                     const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this ^ a2.get();
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        Base::V = val.V;
    }

    /* Reduce operations.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool and_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }

    inline __attribute__((always_inline)) bool and_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }

    /* Output as a string.
     ----------------------------------------------------------------
     */
     void to_string(char* str, int len, BaseMode mode, bool sign = false) const {
        for (int i = 0; i <= len; ++i) str[i] = '\0';
        if (mode == SC_BIN) {
            int size = ((_AP_W) < (len) ? (_AP_W) : (len));
            for (int bit = size; bit > 0; --bit) {
                if (({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), bit-1, bit-1); (bool)(__Result__ & 1); })) str[size-bit] = '1';
                else str[size-bit] = '0';
            }
        } /*else if (mode == AP_HEX) {
            typeof(Base::V) tmpV = Base::V;
            int idx = 0;
            int size = AP_MIN((_AP_W+3)/4, len);
            while (idx < size) {
                char hexb = tmpV & 0xF;
                if (hexb > 9) hexb = hexb - 10 + 'a';
                else hexb += '0';
                str[size-1-idx] = hexb;
                tmpV >> 4;
                idx ++;
            }
            } */ else if (mode == SC_OCT || mode == SC_DEC) {
                                                   ;
        } else {
                                                 ;
        }
    }

    inline __attribute__((always_inline)) char* to_string(BaseMode mode, bool sign=false) const {
          return 0;
    }

    inline __attribute__((always_inline)) char* to_string(signed char mode, bool sign=false) const {
          return to_string(BaseMode(mode), sign);
    }
};
template<int _AP_W, bool _AP_S>
struct ap_int_base<_AP_W, _AP_S, false> : public ssdm_int<_AP_W,_AP_S> {

public:
    typedef ssdm_int<_AP_W, _AP_S> Base;
    typedef typename retval<8, _AP_S>::Type RetType;
    static const int width = _AP_W;


    template<int _AP_W2, bool _AP_S2>
    struct RType {
        enum {
            mult_w = _AP_W+_AP_W2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,
            div_w = _AP_W+_AP_S2,
            div_s = _AP_S||_AP_S2,
            mod_w = ((_AP_W) < (_AP_W2+(!_AP_S2&&_AP_S)) ? (_AP_W) : (_AP_W2+(!_AP_S2&&_AP_S))),
            mod_s = _AP_S,
            logic_w = ((_AP_W+(_AP_S2&&!_AP_S)) > (_AP_W2+(_AP_S&&!_AP_S2)) ? (_AP_W+(_AP_S2&&!_AP_S)) : (_AP_W2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };

        typedef ap_int_base<mult_w, mult_s> mult;
        typedef ap_int_base<plus_w, plus_s> plus;
        typedef ap_int_base<minus_w, minus_s> minus;
        typedef ap_int_base<logic_w, logic_s> logic;
        typedef ap_int_base<div_w, div_s> div;
        typedef ap_int_base<mod_w, mod_s> mod;
        typedef ap_int_base<_AP_W, _AP_S> arg1;
        typedef bool reduce;
    };

    /* Constructors.
     ----------------------------------------------------------------
   */
   inline __attribute__((always_inline)) ap_int_base() {
/*
   #ifdef __SC_COMPATIBLE__
       Base::V = 0;
   #endif
*/
   }

    //INLINE ap_int_base(const ap_int_base& op) { Base::V = op.V; }
    //INLINE ap_int_base(const volatile ap_int_base& op) { Base::V = op.V; }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }

 template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2,_AP_S2> &op) { Base::V = op.V; }

    /* For C++ basic data types.*/




    inline __attribute__((always_inline)) explicit ap_int_base(bool op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(signed char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned char op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned short op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned int op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(unsigned long op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_slong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(ap_ulong op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(half op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(float op) { Base::V = op; }
    inline __attribute__((always_inline)) explicit ap_int_base(double op) { Base::V = op; }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op) {
      Base::V = op.to_ap_int_base().V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator ap_int_base<_AP_W2, false>().V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2,_AP_S2>& ref) {
        Base::V = ref.operator bool();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& ref) {
        const ap_int_base<ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>::_AP_WR,false> tmp = ref.get();
        Base::V = tmp.V;
    }

    /* This constructor is not usable yet, because the second parameter of 
     __builtin_bit_from_string(...)
     is required to be a constant C string.
    */
    inline __attribute__((always_inline)) ap_int_base(const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10,
                    _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
    }

    inline __attribute__((always_inline)) ap_int_base(const char* str, signed char radix) {_ssdm_SpecConstant(&width);
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix,
                    _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = (val.operator ap_int_base<_AP_W2, false> ()).V;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
         ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                       _AP_Q2, _AP_O2, _AP_N2> &val) {
        Base::V = val.operator bool ();
    }

    inline __attribute__((always_inline)) ap_int_base read() volatile {
                                                    ;
        ap_int_base ret;
        ret.V = Base::V;
        return ret;
    }
    inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
                                                   ;
        Base::V = op2.V;
    }

    /* Another form of "write".*/

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }

    inline __attribute__((always_inline)) void operator = (const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) volatile {
        Base::V = op2.V;
    }

    inline __attribute__((always_inline)) void operator = (const ap_int_base<_AP_W, _AP_S>& op2) volatile {
        Base::V = op2.V;
    }
# 2509 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W2,_AP_S2>& op2) {
        Base::V = op2.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& operator = (const volatile ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_int_base<_AP_W,_AP_S>& op2) {
        Base::V = op2.V;
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator = (const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), 10,
                   _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
        return *this;
    }

    inline __attribute__((always_inline)) ap_int_base& set(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str), radix,
                  _AP_W, _AP_S, SC_TRN, SC_WRAP, 0, true);
        Base::V = Result;
        return *this;
    }







inline __attribute__((always_inline)) ap_int_base& operator = (char op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned char op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (short op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned short op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (int op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (unsigned int op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (ap_slong op) { Base::V = op; return *this; }
inline __attribute__((always_inline)) ap_int_base& operator = (ap_ulong op) { Base::V = op; return *this; }


    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (bool) op2;
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
        return *this;
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_concat_ref<_AP_W2,_AP_T2,_AP_W3,_AP_T3>& op2) {
      Base::V = op2.get().V;
      return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = op.to_ap_int_base().V;
        return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = (bool) op;
        return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int_base& operator = (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
        return *this;
    }

    inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }


    /* Explicit conversions to C interger types.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool to_bool() const {return (bool)(Base::V);}
    inline __attribute__((always_inline)) bool to_uchar() const {return (unsigned char)(Base::V);}
    inline __attribute__((always_inline)) bool to_char() const {return (char)(Base::V);}
    inline __attribute__((always_inline)) bool to_ushort() const {return (unsigned short)(Base::V);}
    inline __attribute__((always_inline)) bool to_short() const {return (short)(Base::V);}
    inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
    inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
    inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
    inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
    inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
    inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 2628 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 inline __attribute__((always_inline)) int length() const { return _AP_W; }
    inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }

    /*INLINE operator ap_ulong () { return (ap_ulong)(Base::V); }*/

    /*Reverse the contents of ap_int_base instance. I.e. LSB becomes MSB and vise versa*/
    inline __attribute__((always_inline)) ap_int_base& reverse () {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
        return *this;
    }

    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool iszero () const {
        return Base::V == 0 ;
    }

    /*Return true if the value of ap_int_base instance is zero*/
    inline __attribute__((always_inline)) bool is_zero () const {
        return Base::V == 0 ;
    }

    /* x < 0 */
    inline __attribute__((always_inline)) bool sign () const {
        if (_AP_S && ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }))
            return true;
        else
            return false;
    }

    /* x[i] = 0 */
    inline __attribute__((always_inline)) void clear(int i) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    /* x[i] = !x[i]*/
    inline __attribute__((always_inline)) void invert(int i) {
                                                                ;
        bool val = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
        if (val) Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
        else Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }


    inline __attribute__((always_inline)) bool test (int i) const {
                                                                ;
        return ({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }

    //Set the ith bit into 1
    inline __attribute__((always_inline)) void set (int i) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //Set the ith bit into v
    inline __attribute__((always_inline)) void set (int i, bool v) {
                                                                ;
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the left
    inline __attribute__((always_inline)) void lrotate(int n) {
                                                                   ;
         typeof(Base::V) l_p = Base::V << n;
         typeof(Base::V) r_p = Base::V >> (_AP_W - n);
         Base::V = l_p | r_p;
    }

    //This is used for sc_lv and sc_bv, which is implemented by sc_uint 
    //Rotate an ap_int_base object n places to the right 
    inline __attribute__((always_inline)) void rrotate(int n) {
                                                                   ;
         typeof(Base::V) l_p = Base::V << (_AP_W - n);
         typeof(Base::V) r_p = Base::V >> n;
         Base::V = l_p | r_p;
    }

    //Set the ith bit into v 
    inline __attribute__((always_inline)) void set_bit (int i, bool v) {
        Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    }

    //Get the value of ith bit
    inline __attribute__((always_inline)) bool get_bit (int i) const {
        return (bool)({ typeof(const_cast<ap_int_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_int_base*>(this)->V) __Val2__ = const_cast<ap_int_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), i, i); (bool)(__Result__ & 1); });
    }

    //complements every bit 
    inline __attribute__((always_inline)) void b_not() {
       Base::V = ~Base::V;
    }

    // Count the number of zeros from the most significant bit 
    // to the first one bit. Note this is only for ap_fixed_base whose 
    // _AP_W <= 64, otherwise will incur assertion.
    inline __attribute__((always_inline)) int countLeadingZeros() {
        if (_AP_W <= 32) {
            ap_int_base<32, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctz(t.V);
        } else if (_AP_W <= 64) {
            ap_int_base<64, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctzll(t.V);
        } else {
            enum { __N = (_AP_W+63)/64 };
            int NZeros = 0;
            unsigned i = 0;
            bool hitNonZero = false;
            for (i=0; i<__N-1; ++i) {
                ap_int_base<64, false> t;
                t.range(0, 63) = this->range(_AP_W - i*64 - 64, _AP_W - i*64 - 1);
                NZeros += hitNonZero?0:__builtin_clzll(t.V);
                hitNonZero |= (t.to_uint64() != 0);
            }
            if (!hitNonZero) {
                ap_int_base<64, false> t(-1ULL);
                t.range(63-(_AP_W-1)%64, 63) = this->range(0, (_AP_W-1)%64);
                NZeros += __builtin_clzll(t.V);
            }
            return NZeros;
        }
    }
# 2762 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 /* Arithmetic assign.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V *= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator += ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V += op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V -= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V /= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V %= op2.V; return *this; }

    /* Bitwise assign: and, or, xor.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V &= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V |= op2.V; return *this; }
    template<int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^= ( const ap_int_base<_AP_W2,_AP_S2> &op2) { ; Base::V ^= op2.V; return *this; }


    /* Prefix increment, decrement.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base& operator ++() {
        operator+=((ap_int_base<1,false>) 1);
        return *this;
    }
    inline __attribute__((always_inline)) ap_int_base& operator --() {
        operator-=((ap_int_base<1,false>) 1);
        return *this;
    }

    /* Postfix increment, decrement
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) const ap_int_base operator ++(int) {
        ap_int_base t = *this;
        operator+=((ap_int_base<1,false>) 1);
        return t;
    }
    inline __attribute__((always_inline)) const ap_int_base operator --(int) {
        ap_int_base t = *this;
        operator-=((ap_int_base<1,false>) 1);
        return t;
    }

    /* Unary arithmetic.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base operator +() const{
        return *this;
    }

    inline __attribute__((always_inline)) typename RType<1,false>::minus operator -() const {
        return ((ap_int_base<1,false>) 0) - *this;
    }

    /* Not (!)
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool operator ! () const {
        return Base::V == 0;
    }

    /* Bitwise (arithmetic) unary: complement
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_int_base<_AP_W+!_AP_S, true> operator ~() const {
        ap_int_base<_AP_W+!_AP_S, true> r;
        r.V = ~Base::V;
        return r;
    }

    /* Shift (result constrained by left operand).
     ----------------------------------------------------------------
    */
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,true> &op2 ) const {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator >> (sh);
        } else
            return operator << (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r ;
        r.V = Base::V << op2.to_uint();
        return r;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,true> &op2 ) const {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator << (sh);
        }
        return operator >> (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_int_base<_AP_W2,false> &op2 ) const {
        ap_int_base r;
        r.V = Base::V >> op2.to_uint();
        return r;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator << ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this << (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base operator >> ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) const {
        return *this >> (op2.operator ap_int_base<_AP_W2, false>());
    }

    /* Shift assign
     ----------------------------------------------------------------
    */
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,true> &op2 ) {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            return operator >>= (sh);
        } else
            return operator <<= (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V <<= op2.to_uint();
        return *this;
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,true> &op2 ) {
        bool isNeg = op2[_AP_W2 - 1];
        ap_int_base<_AP_W2, false> sh = op2;
        if (isNeg) {
            sh = -op2;
            operator <<= (sh);
        }
        return operator >>= (sh);
    }
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_int_base<_AP_W2,false> &op2 ) {
        Base::V >>= op2.to_uint();
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator <<= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this <<= (op2.operator ap_int_base<_AP_W2, false>());
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int_base& operator >>= ( const ap_range_ref<_AP_W2,_AP_S2>& op2 ) {
        return *this >>= (op2.operator ap_int_base<_AP_W2, false>());
    }

    /* Comparisons.
     ----------------------------------------------------------------
    */
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V == op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return !(Base::V == op2.V);
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V < op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V >= op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V > op2.V;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2,_AP_S2> &op2) const {
        return Base::V <= op2.V;
    }


    /* Bit and Part Select
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    range (int Hi, int Lo) const {
                                                                           ;
        return ap_range_ref<_AP_W,_AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
    }

    inline __attribute__((always_inline)) ap_range_ref<_AP_W,_AP_S>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }
# 2991 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (int index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> operator [] (const ap_int_base<_AP_W2,_AP_S2> &index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }

    inline __attribute__((always_inline)) bool operator [] (int index) const {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator [] (const ap_int_base<_AP_W2,_AP_S2>& index) const {
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this),
                                   index.to_int());
        return br.to_bool();
    }

     inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (int index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index );
        return bvh;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_bit_ref<_AP_W,_AP_S> bit (const ap_int_base<_AP_W2,_AP_S2> &index) {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> bvh( this, index.to_int() );
        return bvh;
    }

    inline __attribute__((always_inline)) bool bit (int index) const {
                                                                           ;
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br(const_cast<ap_int_base*>(this), index);
        return br.to_bool();
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool bit (const ap_int_base<_AP_W2,_AP_S2>& index) const {
                                                                     ;
        ap_bit_ref<_AP_W,_AP_S> br = bit(index);
        return br.to_bool();
    }
# 3054 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(const ap_int_base<_AP_W2,_AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                                                      const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W,ap_int_base,_AP_W2,ap_int_base<_AP_W2,_AP_S2> > concat(ap_int_base<_AP_W2,_AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,_AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                                                     const_cast< ap_range_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (ap_range_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                      ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(*this,
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (const ap_int_base<_AP_W2, _AP_S2>& a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                             const_cast<ap_int_base<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this), const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(a2));
    }

    template <int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (ap_bit_ref<_AP_W2, _AP_S2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2,
                   _AP_S2> >(*this, a2);
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                     const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(a2));
    }

    template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3, ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2+_AP_W3,
                     ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, _AP_W2, af_range_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) const {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(const_cast<ap_int_base<_AP_W, _AP_S>& >(*this),
                const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& >(a2));
    }

    template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline))
    ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &a2) {
        return ap_concat_ref<_AP_W, ap_int_base, 1, af_bit_ref<_AP_W2,
                _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator & (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this & a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator | (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this | a2.get();
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int_base<((_AP_W2+_AP_W3) > (_AP_W) ? (_AP_W2+_AP_W3) : (_AP_W)), _AP_S>
    operator ^ (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
      return *this ^ a2.get();
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        Base::V = val.V;
    }

    /* Reduce operations.
     ----------------------------------------------------------------
    */
    inline __attribute__((always_inline)) bool and_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }

    inline __attribute__((always_inline)) bool and_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nand_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool or_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool nor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }));
    }
    inline __attribute__((always_inline)) bool xor_reduce() const {
        return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); });
    }
    inline __attribute__((always_inline)) bool xnor_reduce() const {
        return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
    }

    /* Output as a string.
     ----------------------------------------------------------------
     */
     void to_string(char* str, int len, BaseMode mode, bool sign = false) const {
        for (int i = 0; i <= len; ++i) str[i] = '\0';
        if (mode == SC_BIN) {
            int size = ((_AP_W) < (len) ? (_AP_W) : (len));
            for (int bit = size; bit > 0; --bit) {
                if (({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), bit-1, bit-1); (bool)(__Result__ & 1); })) str[size-bit] = '1';
                else str[size-bit] = '0';
            }
        } /*else if (mode == AP_HEX) {
            typeof(Base::V) tmpV = Base::V;
            int idx = 0;
            int size = AP_MIN((_AP_W+3)/4, len);
            while (idx < size) {
                char hexb = tmpV & 0xF;
                if (hexb > 9) hexb = hexb - 10 + 'a';
                else hexb += '0';
                str[size-1-idx] = hexb;
                tmpV >> 4;
                idx ++;
            }
            } */ else if (mode == SC_OCT || mode == SC_DEC) {
                                                   ;
        } else {
                                                 ;
        }
    }

    inline __attribute__((always_inline)) char* to_string(BaseMode mode, bool sign=false) const {
          return 0;
    }

    inline __attribute__((always_inline)) char* to_string(signed char mode, bool sign=false) const {
          return to_string(BaseMode(mode), sign);
    }
};





/* Output streaming.
 ----------------------------------------------------------------
*/


template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream &os, const ap_int_base<_AP_W,_AP_S> &x) {
    //os << x.to_string(AP_DEC);
    return os;
}

/* Input streaming.
......................................................
*/
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::istream& operator >> (std::istream& in, ap_int_base<_AP_W,_AP_S> &op) {





    return in;
}

template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream &os, const ap_range_ref<_AP_W,_AP_S> &x) {
    //os << x.to_string(AP_DEC);
    return os;
}

/* Input streaming.
......................................................
*/
template<int _AP_W, bool _AP_S>
inline __attribute__((always_inline)) std::istream& operator >> (std::istream& in, ap_range_ref<_AP_W,_AP_S> &op) {





    return in;
}



    /*Binary Arithmetic. 
     ----------------------------------------------------------------
    */
# 3368 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
 template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mult operator * (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mult lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mult rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mult r ; r.V = lhs.V * rhs.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::plus operator + (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::plus lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::plus rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::plus r ; r.V = lhs.V + rhs.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::minus operator - (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::minus lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::minus rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::minus r ; r.V = lhs.V - rhs.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::div r ; r.V = op.V / op2.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::mod r ; r.V = op.V % op2.V; return r; }

    /* Bitwise and, or, xor.
     ----------------------------------------------------------------
    */
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic operator & (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V & rhs.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic operator | (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V | rhs.V; return r; }
    template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic operator ^ (const ap_int_base<_AP_W,_AP_S> &op, const ap_int_base<_AP_W2,_AP_S2> &op2) { ; typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2,_AP_S2>::logic r ; r.V = lhs.V ^ rhs.V; return r; }


//FIXME

//char a[100];
//char* ptr = a;
//ap_int<2> n = 3;
//char* ptr2 = ptr + n*2;
//avoid ambiguous errors
# 3403 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator + (PTR_TYPE* i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator + (const ap_int_base<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return op2 + i_op; }
template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator - (PTR_TYPE* i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; } template<typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator - (const ap_int_base<_AP_W,_AP_S> &op, PTR_TYPE* i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return op2 - i_op; }

//float OP ap_int
//when ap_int<wa>'s width > 64, then trunc ap_int<w> to ap_int<64>
# 3428 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator * (half i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator * (const ap_int_base<_AP_W,_AP_S> &op, half i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator / (half i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator / (const ap_int_base<_AP_W,_AP_S> &op, half i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator + (half i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator + (const ap_int_base<_AP_W,_AP_S> &op, half i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator - (half i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator - (const ap_int_base<_AP_W,_AP_S> &op, half i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator * (float i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator * (const ap_int_base<_AP_W,_AP_S> &op, float i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator / (float i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator / (const ap_int_base<_AP_W,_AP_S> &op, float i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator + (float i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator + (const ap_int_base<_AP_W,_AP_S> &op, float i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator - (float i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator - (const ap_int_base<_AP_W,_AP_S> &op, float i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator * (double i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator * (const ap_int_base<_AP_W,_AP_S> &op, double i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op * op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator / (double i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator / (const ap_int_base<_AP_W,_AP_S> &op, double i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op / op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator + (double i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator + (const ap_int_base<_AP_W,_AP_S> &op, double i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op + op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator - (double i_op, const ap_int_base<_AP_W,_AP_S> &op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator - (const ap_int_base<_AP_W,_AP_S> &op, double i_op) { typename ap_int_base<_AP_W,_AP_S>::RetType op2 = op; return i_op - op2; }

/* Operators mixing Integers with AP_Int
 ----------------------------------------------------------------
*/
// partially specialize template argument _AP_C in order that:
// for _AP_W > 64, we will explicitly convert operand with native data type
// into corresponding ap_private
// for _AP_W <= 64, we will implicitly convert operand with ap_private into
// (unsigned) long long
# 3462 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mult operator * (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op * ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::plus operator + (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op + ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::minus operator - (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op - ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::div operator / (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op / ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mod operator % (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op % ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator & (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op & ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator | (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op | ap_int_base<1,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ (bool i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<1,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, bool i_op) { return op ^ ap_int_base<1,false>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op * ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op + ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op - ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op / ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op % ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op & ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op | ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ (char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, char i_op) { return op ^ ap_int_base<8,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op * ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op + ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op - ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op / ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op % ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op & ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op | ap_int_base<8,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ (signed char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, signed char i_op) { return op ^ ap_int_base<8,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mult operator * (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op * ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::plus operator + (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op + ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::minus operator - (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op - ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::div operator / (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op / ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mod operator % (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op % ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator & (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op & ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator | (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op | ap_int_base<8,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ (unsigned char i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<8,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char i_op) { return op ^ ap_int_base<8,false>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mult operator * (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op * ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::plus operator + (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op + ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::minus operator - (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op - ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::div operator / (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op / ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mod operator % (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op % ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator & (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op & ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator | (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op | ap_int_base<16,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ (short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, short i_op) { return op ^ ap_int_base<16,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mult operator * (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op * ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::plus operator + (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op + ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::minus operator - (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op - ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::div operator / (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op / ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mod operator % (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op % ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator & (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op & ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator | (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op | ap_int_base<16,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ (unsigned short i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<16,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short i_op) { return op ^ ap_int_base<16,false>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mult operator * (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op * ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::plus operator + (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op + ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::minus operator - (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op - ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::div operator / (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op / ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mod operator % (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op % ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator & (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op & ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator | (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op | ap_int_base<32,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ (int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, int i_op) { return op ^ ap_int_base<32,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mult operator * (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op * ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::plus operator + (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op + ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::minus operator - (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op - ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::div operator / (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op / ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mod operator % (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op % ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator & (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op & ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator | (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op | ap_int_base<32,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ (unsigned int i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<32,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int i_op) { return op ^ ap_int_base<32,false>(i_op); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mult operator * (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op * ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::plus operator + (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op + ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::minus operator - (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op - ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::div operator / (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op / ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mod operator % (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op % ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator & (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op & ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator | (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op | ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ (long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, long i_op) { return op ^ ap_int_base<64,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mult operator * (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op * ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::plus operator + (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op + ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::minus operator - (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op - ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::div operator / (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op / ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mod operator % (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op % ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator & (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op & ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator | (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op | ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ (unsigned long i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long i_op) { return op ^ ap_int_base<64,false>(i_op); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mult operator * (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op * ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::plus operator + (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op + ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::minus operator - (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op - ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::div operator / (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op / ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mod operator % (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op % ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator & (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op & ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator | (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op | ap_int_base<64,true>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ (ap_slong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,true>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong i_op) { return op ^ ap_int_base<64,true>(i_op); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mult operator * (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) * (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mult operator * ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op * ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::plus operator + (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) + (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::plus operator + ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op + ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::minus operator - (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) - (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::minus operator - ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op - ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::div operator / (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) / (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::div operator / ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op / ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mod operator % (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) % (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::mod operator % ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op % ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator & (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) & (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator & ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op & ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator | (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) | (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator | ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op | ap_int_base<64,false>(i_op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ (ap_ulong i_op, const ap_int_base<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(i_op) ^ (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,_AP_S>::template RType<64,false>::logic operator ^ ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong i_op) { return op ^ ap_int_base<64,false>(i_op); }
# 3498 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( bool i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<1,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator <= (ap_int_base<1,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator <= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( signed char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator <= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned char i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<8,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <= (ap_int_base<8,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator <= (ap_int_base<16,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned short i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<16,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <= (ap_int_base<16,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator <= (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned int i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<32,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <= (ap_int_base<32,false>(op2)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator <= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned long i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <= (ap_int_base<64,false>(op2)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_slong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,true>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator == (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator != (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator > (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator >= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator < (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_ulong i_op, const ap_int_base<_AP_W,_AP_S, false> &op) { return ap_int_base<64,false>(i_op).operator <= (op); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <= (ap_int_base<64,false>(op2)); }
# 3534 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator += (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator -= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator *= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator /= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator %= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator >>= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator <<= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator &= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator |= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, bool op2) { return op.operator ^= (ap_int_base<1,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator += (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator -= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator *= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator /= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator %= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator >>= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator <<= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator &= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator |= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, char op2) { return op.operator ^= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator += (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator -= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator *= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator /= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator %= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator >>= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator <<= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator &= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator |= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, signed char op2) { return op.operator ^= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator += (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator -= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator *= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator /= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator %= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator >>= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator <<= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator &= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator |= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned char op2) { return op.operator ^= (ap_int_base<8,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator += (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator -= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator *= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator /= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator %= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator >>= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator <<= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator &= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator |= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, short op2) { return op.operator ^= (ap_int_base<16,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator += (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator -= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator *= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator /= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator %= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator >>= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator <<= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator &= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator |= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned short op2) { return op.operator ^= (ap_int_base<16,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator += (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator -= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator *= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator /= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator %= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator >>= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator <<= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator &= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator |= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, int op2) { return op.operator ^= (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator += (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator -= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator *= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator /= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator %= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator >>= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator <<= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator &= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator |= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned int op2) { return op.operator ^= (ap_int_base<32,false>(op2)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator += (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator -= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator *= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator /= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator %= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator >>= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator <<= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator &= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator |= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, long op2) { return op.operator ^= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator += (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator -= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator *= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator /= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator %= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator >>= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator <<= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator &= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator |= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, unsigned long op2) { return op.operator ^= (ap_int_base<64,false>(op2)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator += (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator -= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator *= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator /= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator %= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator >>= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator <<= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator &= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator |= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, ap_slong op2) { return op.operator ^= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator += ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator += (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator -= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator -= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator *= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator *= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator /= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator /= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator %= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator %= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator >>= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator >>= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator <<= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator <<= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator &= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator &= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator |= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator |= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W,_AP_S> &operator ^= ( ap_int_base<_AP_W,_AP_S> &op, ap_ulong op2) { return op.operator ^= (ap_int_base<64,false>(op2)); }
# 3574 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }

template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }




template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator << (const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S> operator >> (const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; if (false) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 3628 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator += ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator += ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator -= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator -= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator *= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator *= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator /= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator /= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator %= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator %= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator >>= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator >>= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator <<= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator <<= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator &= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator &= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator |= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator |= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator ^= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_int_base<_AP_W2, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1,_AP_S1>& operator ^= ( ap_range_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator == (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator != (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator > (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator >= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator < (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (op2.operator ap_int_base<_AP_W2, false>()); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1,false>(op1).operator <= (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (op2.operator ap_int_base<_AP_W2, false>()); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::plus operator + ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 + (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::minus operator - ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 - (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mult operator * ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 * (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::div operator / ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 / (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::mod operator % ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 % (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator >> ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 >> (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::arg1 operator << ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 << (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator & ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 & (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator | ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 | (ap_int_base<_AP_W2, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_range_ref<_AP_W1,_AP_S1>& op1, const ap_int_base<_AP_W2,_AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ (op2); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<_AP_W2,_AP_S2>::logic operator ^ ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_range_ref<_AP_W2,_AP_S2>& op2) { return op1 ^ (ap_int_base<_AP_W2, false>(op2)); }
# 3684 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator += ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator += (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator += ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator += (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator -= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator -= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator -= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator -= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator *= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator *= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator *= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator *= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator /= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator /= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator /= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator /= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator %= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator %= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator %= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator %= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator >>= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >>= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator >>= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator >>= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator <<= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <<= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator <<= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator <<= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator &= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator &= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator &= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator &= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator |= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator |= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator |= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator |= (op2); op1 = tmp; return op1; }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1,_AP_S1>& operator ^= ( ap_int_base<_AP_W1,_AP_S1>& op1, ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator ^= (ap_int_base<1, false>(op2)); } template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1,_AP_S1>& operator ^= ( ap_bit_ref<_AP_W1,_AP_S1>& op1, ap_int_base<_AP_W2,_AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.operator ^= (op2); op1 = tmp; return op1; }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator == (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator != (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator > (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator >= (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator < (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1.operator <= (ap_int_base<1, false>(op2)); }

template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::plus operator + ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 + (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::minus operator - ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 - (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::mult operator * ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 * (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::div operator / ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 / (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::mod operator % ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 % (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator >> ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 >> (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::arg1 operator << ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 << (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator & ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 & (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator | ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 | (ap_int_base<1, false>(op2)); }
template<int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1,_AP_S1>::template RType<1,false>::logic operator ^ ( const ap_int_base<_AP_W1,_AP_S1>& op1, const ap_bit_ref<_AP_W2,_AP_S2>& op2) { return op1 ^ (ap_int_base<1, false>(op2)); }
# 3731 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
// Make the line shorter than 5000 chars






template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<1,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,(-127 -1) != 0>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<8,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<16,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<16,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<32,false>(op2)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,false>(op2)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 > (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator > ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 < (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator < ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 >= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 <= (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <= ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator <= (ap_int_base<64,false>(op2)); }

// Make the line shorter than 5000 chars




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( bool op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, bool op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<1,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,(-127 -1) != 0>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( signed char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, signed char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned char op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<8,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<16,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned short op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<16,false>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned int op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<32,false>(op2)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, unsigned long op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,false>(op2)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_slong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,true>(op2)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 == (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator == ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( const ap_bit_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const ap_bit_ref<_AP_W,_AP_S> &op) { return op2 != (bool(op)); } template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator != ( const ap_concat_ref<_AP_W,_AP_T, _AP_W1, _AP_T1> &op, ap_ulong op2) { return (ap_int_base<_AP_W + _AP_W1, false>(op)).operator != (ap_int_base<64,false>(op2)); }
# 3798 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::plus operator + ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::minus operator - ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::mult operator * ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::div operator / ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::mod operator % ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::plus operator + ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::minus operator - ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::mult operator * ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::div operator / ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::mod operator % ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::plus operator + ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::minus operator - ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mult operator * ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::div operator / ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::mod operator % ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::plus operator + ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::minus operator - ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::mult operator * ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::div operator / ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::mod operator % ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::plus operator + ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::minus operator - ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::mult operator * ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::div operator / ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::mod operator % ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::plus operator + ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::minus operator - ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::mult operator * ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::div operator / ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::mod operator % ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::plus operator + ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::minus operator - ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mult operator * ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::div operator / ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::mod operator % ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::plus operator + ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::minus operator - ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mult operator * ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::div operator / ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::mod operator % ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) % (ap_int_base<_AP_W, false>(op)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::plus operator + ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::minus operator - ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mult operator * ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::div operator / ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mod operator % ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::plus operator + ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::minus operator - ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mult operator * ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::div operator / ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mod operator % ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) % (ap_int_base<_AP_W, false>(op)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::plus operator + ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::minus operator - ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mult operator * ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::div operator / ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::mod operator % ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) % (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::plus operator + ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) + (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::plus operator + ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) + (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::minus operator - ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) - (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::minus operator - ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) - (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mult operator * ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) * (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mult operator * ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) * (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::div operator / ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) / (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::div operator / ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) / (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::mod operator % ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) % (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::mod operator % ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) % (ap_int_base<_AP_W, false>(op)); }
# 3823 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::arg1 operator >> ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::arg1 operator << ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator & ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator | ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<1,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<1,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<1,false>::template RType<_AP_W,false>::logic operator ^ ( bool op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<1,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::arg1 operator >> ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::arg1 operator << ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::logic operator & ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::logic operator | ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,(-127 -1) != 0>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, char op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<8,(-127 -1) != 0>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,(-127 -1) != 0>::template RType<_AP_W,false>::logic operator ^ ( char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,(-127 -1) != 0>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator >> ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::arg1 operator << ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator & ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator | ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<8,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,true>::template RType<_AP_W,false>::logic operator ^ ( signed char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,true>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator & ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator | ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<8,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<8,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<8,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned char op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<8,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::arg1 operator >> ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::arg1 operator << ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator & ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator | ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, short op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<16,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,true>::template RType<_AP_W,false>::logic operator ^ ( short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,true>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator & ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator | ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<16,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<16,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<16,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned short op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<16,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator >> ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::arg1 operator << ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator & ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator | ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, int op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<32,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,true>::template RType<_AP_W,false>::logic operator ^ ( int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,true>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator & ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator | ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<32,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<32,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<32,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned int op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<32,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator >> ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator << ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator & ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator | ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, long op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator ^ ( long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator >> ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator << ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator & ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator | ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator ^ ( unsigned long op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator >> ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::arg1 operator << ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator & ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator | ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,true>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<64,true>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,true>::template RType<_AP_W,false>::logic operator ^ ( ap_slong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,true>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator >> ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) >> (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator >> ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) >> (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::arg1 operator << ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) << (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::arg1 operator << ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) << (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator & ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) & (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator & ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) & (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator | ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) | (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator | ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) | (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W,false>::template RType<64,false>::logic operator ^ ( const ap_range_ref<_AP_W,_AP_S> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)) ^ (ap_int_base<64,false>(op2)); } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<64,false>::template RType<_AP_W,false>::logic operator ^ ( ap_ulong op2, const ap_range_ref<_AP_W,_AP_S> &op) { return ap_int_base<64,false>(op2) ^ (ap_int_base<_AP_W, false>(op)); }
# 3848 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator + (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) + (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator - (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) - (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator * (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) * (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator / (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) / (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator % (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) % (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >> (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) >> (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator << (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) << (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator & (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) & (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator | (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) | (ap_int_base<_AP_W2, false>(rhs)); }
template<int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^ (const ap_range_ref<_AP_W,_AP_S> &lhs, const ap_range_ref<_AP_W2,_AP_S2> &rhs) { return ap_int_base<_AP_W, false>(lhs) ^ (ap_int_base<_AP_W2, false>(rhs)); }

//************************************************************************
//  Implement
//      ap_private<M+N> = ap_concat_ref<M> OP ap_concat_ref<N>
//  for operators  +, -, *, /, %, >>, <<, &, |, ^
//  Without these operators the operands are converted to int64 and
//  larger results lose informations (higher order bits).
//
//                       operand OP
//                      /          |
//              left-concat         right-concat
//                /     |            /         |
//         <LW1,LT1>  <LW2,LT2>   <RW1,RT1>    <RW2,RT2>
//
//      _AP_LW1, _AP_LT1 (width and type of left-concat's left side)
//      _AP_LW2, _AP_LT2 (width and type of left-concat's right side)
//  Similarly for RHS of operand OP: _AP_RW1, AP_RW2, _AP_RT1, _AP_RT2
//
//  In Verilog 2001 result of concatenation is always unsigned even
//  when both sides are signed.
//************************************************************************
# 3893 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::plus operator + (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::minus operator - (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::mult operator * (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::div operator / (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::mod operator % (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::arg1 operator >> (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::arg1 operator << (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator & (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator | (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template<int _AP_LW1,typename _AP_LT1,int _AP_LW2,typename _AP_LT2, int _AP_RW1,typename _AP_RT1,int _AP_RW2,typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1+_AP_LW2,false>::template RType<_AP_RW1+_AP_RW2,false>::logic operator ^ (const ap_concat_ref<_AP_LW1,_AP_LT1,_AP_LW2,_AP_LT2>& lhs, const ap_concat_ref<_AP_RW1,_AP_RT1,_AP_RW2,_AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }


//************************************************************************
# 4048 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (bool op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false > operator, (bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false > operator, (bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 1, false > operator, (bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 1, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 1, false> operator, (bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-127 -1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (char op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if ((-127 -1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, (-127 -1) != 0> val(op2); ap_int_base<8 + _AP_W + _AP_W2, (-127 -1) != 0> ret(op1); if ((-127 -1) != 0) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, (-127 -1) != 0> val(op1); ap_int_base<8 + _AP_W + _AP_W2, (-127 -1) != 0> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if ((-127 -1) != 0) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, (-127 -1) != 0> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, (-127 -1) != 0> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (signed char op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (unsigned char op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false > operator, (unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false > operator, (unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 8, false > operator, (unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 8, false> operator, (unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (short op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); ret <<= 16; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<16 + 1, false > operator, (short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<16 + _AP_W + _AP_W2, true> val(op2); ap_int_base<16 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 16, false > operator, (short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<16 + _AP_W + _AP_W2, true> val(op1); ap_int_base<16 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<16 + 1, true> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 16, false> operator, (short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (unsigned short op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 16; ret >>= 16; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); ret <<= 16; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<16 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<16 + 1, false > operator, (unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 16, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<16 + _AP_W + _AP_W2, false> val(op2); ap_int_base<16 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 16; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 16, false > operator, (unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<16 + _AP_W + _AP_W2, false> val(op1); ap_int_base<16 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<16 + _AP_W, false> val(op2); ap_int_base<16 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 16; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 16, false > operator, (unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16 + _AP_W, false> val(op1); ap_int_base<16 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 16, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<16 + 1, false> val(op2); val[16] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 16, false> operator, (unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<16 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (int op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); ret <<= 32; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<32 + 1, false > operator, (int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<32 + _AP_W + _AP_W2, true> val(op2); ap_int_base<32 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 32, false > operator, (int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32 + _AP_W + _AP_W2, true> val(op1); ap_int_base<32 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<32 + 1, true> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 32, false> operator, (int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (unsigned int op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 32; ret >>= 32; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); ret <<= 32; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<32 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<32 + 1, false > operator, (unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 32, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<32 + _AP_W + _AP_W2, false> val(op2); ap_int_base<32 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 32; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 32, false > operator, (unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<32 + _AP_W + _AP_W2, false> val(op1); ap_int_base<32 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<32 + _AP_W, false> val(op2); ap_int_base<32 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 32; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 32, false > operator, (unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32 + _AP_W, false> val(op1); ap_int_base<32 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 32, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<32 + 1, false> val(op2); val[32] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 32, false> operator, (unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<32 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }

template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (long op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<64 + _AP_W + _AP_W2, true> val(op2); ap_int_base<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64 + _AP_W + _AP_W2, true> val(op1); ap_int_base<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (unsigned long op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<64 + _AP_W + _AP_W2, false> val(op2); ap_int_base<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64 + _AP_W + _AP_W2, false> val(op1); ap_int_base<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }




template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_slong op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<64 + _AP_W + _AP_W2, true> val(op2); ap_int_base<64 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64 + _AP_W + _AP_W2, true> val(op1); ap_int_base<64 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<64 + 1, true> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret;} template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_ulong op1, const ap_int_base<_AP_W, _AP_S>& op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 64; ret >>= 64; } ret |= val << _AP_W; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); ret <<= 64; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<64 + 1, false > operator, (ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<64 + _AP_W + _AP_W2, false> val(op2); ap_int_base<64 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 64; ret |= val; return ret; }template<int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 64, false > operator, (ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<64 + _AP_W + _AP_W2, false> val(op1); ap_int_base<64 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; }template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<64 + _AP_W, false> val(op2); ap_int_base<64 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 64; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< _AP_W + 64, false > operator, (ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + _AP_W, false> val(op1); ap_int_base<64 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<64 + 1, false> val(op2); val[64] = op1; return val; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N > inline __attribute__((always_inline)) ap_int_base< 1 + 64, false> operator, (ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<64 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 4074 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int_syn.h"
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator << (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) << ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }
template<int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W+_AP_W1> operator >> (const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ((ap_uint<_AP_W+_AP_W1>)lhs.get()) >> ((int)rhs); }





// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 62 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h" 1
// -*- c++ -*-

/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 */
# 62 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
/// ap_fixed_base
// -----------------------------------------------------------------------------
//#include <math.h>
# 81 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
//enum ap_q_mode { SC_TRN, SC_RND, SC_TRN_ZERO, SC_RND_ZERO, 
//                 SC_RND_INF, SC_RND_MIN_INF, SC_RND_CONV };

//enum ap_o_mode { SC_WRAP, SC_SAT, SC_SAT_ZERO, SC_SAT_SYM,SC_WRAP_SM };

/// Forward declaration.
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed_base;

template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct af_bit_ref {
    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& d_bv;
    int d_index;

public:
    inline __attribute__((always_inline)) af_bit_ref(const af_bit_ref<_AP_W,_AP_I,_AP_S,
              _AP_Q,_AP_O,_AP_N>&ref):
              d_bv(ref.d_bv), d_index(ref.d_index) {}

    inline __attribute__((always_inline)) af_bit_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>* bv, int index = 0) :
        d_bv(*bv), d_index(index) {}
    inline __attribute__((always_inline)) operator bool () const { return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); }); }

    inline __attribute__((always_inline)) af_bit_ref& operator = (unsigned long long val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
        return *this;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        return operator =(val.to_uint64());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_bit_ref& operator = (const af_bit_ref<_AP_W2,_AP_I2,
                                  _AP_S2,_AP_Q2,_AP_O2,_AP_N2>& val) {
        return operator =((unsigned long long) (bool) val);
    }

    inline __attribute__((always_inline)) af_bit_ref& operator = (const af_bit_ref<_AP_W,_AP_I,
                                  _AP_S,_AP_Q,_AP_O,_AP_N>& val) {
        return operator =((unsigned long long) (bool) val);
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = ( const ap_bit_ref<_AP_W2, _AP_S2> &val) {
        return operator =((unsigned long long) (bool) val);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref& operator = ( const ap_range_ref<_AP_W2,_AP_S2>& val) {
        return operator =((const ap_int_base<_AP_W2, false>) val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_bit_ref& operator= (const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((const ap_int_base<_AP_W2, false>)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) af_bit_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
               ap_int_base<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, 1,
                 ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2,
                  ap_range_ref<_AP_W2, _AP_S2> >(*this,
                  const_cast< ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> op) {
        return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& > (op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<1, af_bit_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator == (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() == op.get();
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator != (const af_bit_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        return get() != op.get();
    }

    inline __attribute__((always_inline)) bool get() const {
        return ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
    }

    inline __attribute__((always_inline)) bool operator ~ () const {
        bool bit = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), d_index, d_index); (bool)(__Result__ & 1); });
        return bit ? false : true;
    }

    inline __attribute__((always_inline)) int length() const {
        return 1;
    }

};
/* Range (slice) reference.
 ----------------------------------------------------------------
*/
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
struct af_range_ref {
    ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& d_bv;
    int l_index;
    int h_index;

public:
    inline __attribute__((always_inline)) af_range_ref(const af_range_ref<_AP_W,_AP_I,_AP_S,
           _AP_Q,_AP_O, _AP_N>&ref):
           d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

    inline __attribute__((always_inline)) af_range_ref(ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>* bv
                        , int h, int l) :
        d_bv(*bv), l_index(l), h_index(h) {
    }

    inline __attribute__((always_inline)) operator ap_int_base<_AP_W,false> () const {
        ap_int_base<_AP_W, false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret;
    }

    inline __attribute__((always_inline)) operator unsigned long long () const {
        ap_int_base<_AP_W, false> ret;
        ret.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
        return ret.to_uint64();
    }







inline __attribute__((always_inline)) af_range_ref& operator = (const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const long long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
inline __attribute__((always_inline)) af_range_ref& operator = (const unsigned long long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator = (const ap_int_base<_AP_W2,_AP_S2>& val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }

    inline __attribute__((always_inline)) af_range_ref& operator = (const char* val) {
        ap_int_base<_AP_W, false> loc(val);
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
        return *this;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const af_range_ref<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        ap_int_base<_AP_W2, false> tmp(val);
        return operator=(tmp);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_fixed_base<_AP_W2,
                          _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=(val.to_ap_int_base());
    }

    inline __attribute__((always_inline)) af_range_ref& operator= (const af_range_ref<_AP_W,
                          _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& val) {
        ap_int_base<_AP_W, false> tmp(val);
        return operator=(tmp);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_range_ref<_AP_W2, _AP_S2>& val) {
        return operator=((ap_int_base<_AP_W2, false>)val);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                    _AP_Q2, _AP_O2, _AP_N2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_bit_ref<_AP_W2, _AP_S2>& val) {
        return operator=((unsigned long long)(bool)(val));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) af_range_ref& operator= (const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
        return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator == (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop (*this);
        ap_int_base<_AP_W2, false> rop (op2);
        return lop == rop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator != (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return !(operator == (op2));
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator < (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop(*this);
        ap_int_base<_AP_W2, false> rop(op2);
        return lop < rop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator <= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        ap_int_base<_AP_W, false> lop(*this);
        ap_int_base<_AP_W2, false> rop(op2);
        return lop <= rop;
    }
    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator > (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return !(operator <= (op2));
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) bool operator >= (const ap_range_ref<_AP_W2, _AP_S2>& op2) {
        return !(operator < (op2));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator == (const af_range_ref<_AP_W2, _AP_I2,
                              _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_int_base<_AP_W, false> lop (*this);
        ap_int_base<_AP_W2, false> rop (op2);
        return lop == rop;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator != (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
       return !(operator == (op2));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator < (const af_range_ref<_AP_W2, _AP_I2,
                            _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_int_base<_AP_W, false> lop (*this);
        ap_int_base<_AP_W2, false> rop (op2);
        return lop < rop;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator <= (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        ap_int_base<_AP_W, false> lop( *this);
        ap_int_base<_AP_W2, false> rop (op2);
        return lop <= rop;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator > (const af_range_ref<_AP_W2, _AP_I2,
                               _AP_S2,_AP_Q2, _AP_O2, _AP_N2>& op2) {
        return !(operator <= (op2));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) bool operator >= (const af_range_ref<_AP_W2, _AP_I2,
                             _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
        return !(operator < (op2));
    }

    template <int _AP_W3>
    inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
        d_bv.V = ({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
    operator, (ap_int_base<_AP_W2, _AP_S2>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_int_base<_AP_W2, _AP_S2> >(*this, op);
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
    operator, (const ap_bit_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, 1,
               ap_bit_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_bit_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, int _AP_S2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
    operator, (const ap_range_ref<_AP_W2, _AP_S2> &op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
               ap_range_ref<_AP_W2, _AP_S2> >(*this,
               const_cast<ap_range_ref<_AP_W2, _AP_S2>& >(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                        ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
    operator, (const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                 ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                 const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
             af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                       _AP_O2, _AP_N2>& >(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
    operator, (const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
               _AP_O2, _AP_N2> &op) {
       return ap_concat_ref<_AP_W, af_range_ref, 1,
             af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
             const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
             _AP_O2, _AP_N2>& >(op));
    }


    inline __attribute__((always_inline)) int length() const {
      return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
    }

    inline __attribute__((always_inline)) int to_int() const {
        return (int)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return (unsigned)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) long to_long() const {
        return (long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) unsigned long to_ulong() const {
        return (unsigned long)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return (ap_slong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return (ap_ulong)(({ typeof(d_bv.V) __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
    }
};

// -----------------------------------------------------------------------------
/// ap_fixed_base: AutoPilot fixed point.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S=true,
         ap_q_mode _AP_Q=SC_TRN, ap_o_mode _AP_O=SC_WRAP, int _AP_N=0>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {

public:
    typedef ssdm_int<_AP_W, _AP_S> Base;

    static const int width = _AP_W;
    static const int iwidth = _AP_I;
    static const ap_q_mode qmode = _AP_Q;
    static const ap_o_mode omode = _AP_O;

    /*__attribute__((weak))*/ void overflow_adjust(bool underflow, bool overflow,bool lD, bool sign) {

_ssdm_InlineSelf(0, "");


        if (!underflow && !overflow) return;
        if (_AP_O==SC_WRAP) {
            if (_AP_N == 0)
                return;
            if (_AP_S) {
                //signed SC_WRAP 
                //n_bits == 1
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
                if (_AP_N > 1) {
                //n_bits > 1
                    ap_int_base<_AP_W, false> mask(-1);
                    if (sign) mask.V = 0;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });

                }
            } else {
                //unsigned SC_WRAP 
                ap_int_base<_AP_W, false> mask(-1);
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });

            }
        } else if (_AP_O==SC_SAT_ZERO) {
              Base::V = 0;
        }
        else if (_AP_O == SC_WRAP_SM && _AP_S) {
            bool Ro = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); });
            if (_AP_N == 0) {
                if (lD != Ro) {
                    Base::V = ~Base::V;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
                }
            } else {
                if (_AP_N == 1 && sign != Ro) {
                   Base::V = ~Base::V;
                } else if (_AP_N > 1) {
                    bool lNo = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_N, _AP_W - _AP_N); (bool)(__Result__ & 1); });
                    if (lNo == sign)
                        Base::V = ~Base::V;
                    ap_int_base<_AP_W, false> mask(-1);
                    if (sign) mask.V = 0;
                    Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });

                }
                Base::V = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });

            }
        } else {
            if (_AP_S) {
                if (overflow) {
                    Base::V = 1;
                    Base::V <<= _AP_W - 1;
                    Base::V = ~Base::V;
                } else if (underflow) {
                    Base::V = 1;
                    Base::V <<= _AP_W - 1;
                    if (_AP_O==SC_SAT_SYM)
                        Base::V |= 1;
                }
            }
            else {
                if (overflow)
                    Base::V = ~(ap_int_base<_AP_W,false>(0).V);
                else if (underflow)
                    Base::V = 0;
            }
        }
    }

    /*__attribute__((weak))*/ bool quantization_adjust(bool qb, bool r, bool s) {

_ssdm_InlineSelf(0, "");

        bool carry=(bool)({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); });
        if (_AP_Q==SC_TRN)
            return false;
        if (_AP_Q==SC_RND_ZERO)
            qb &= s || r;
        else if (_AP_Q==SC_RND_MIN_INF)
            qb &= r;
        else if (_AP_Q==SC_RND_INF)
            qb &= !s || r;
        else if (_AP_Q==SC_RND_CONV)
            qb &= ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 0); (bool)(__Result__ & 1); }) || r;
        else if (_AP_Q==SC_TRN_ZERO)
            qb = s && ( qb || r );
        Base::V += qb;
        //return qb;
        return carry&&(!(bool)({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); }));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2>
    struct RType {
        enum {
            _AP_F=_AP_W-_AP_I,
            F2=_AP_W2-_AP_I2,
            mult_w = _AP_W+_AP_W2,
            mult_i = _AP_I+_AP_I2,
            mult_s = _AP_S||_AP_S2,
            plus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            plus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            plus_s = _AP_S||_AP_S2,
            minus_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            minus_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+1,
            minus_s = true,

            div_w = _AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)) + _AP_S2,



            div_i = _AP_I + _AP_W2 -_AP_I2 + _AP_S2,
            div_s = _AP_S||_AP_S2,
            logic_w = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2)))+((_AP_F) > (F2) ? (_AP_F) : (F2)),
            logic_i = ((_AP_I+(_AP_S2&&!_AP_S)) > (_AP_I2+(_AP_S&&!_AP_S2)) ? (_AP_I+(_AP_S2&&!_AP_S)) : (_AP_I2+(_AP_S&&!_AP_S2))),
            logic_s = _AP_S||_AP_S2
        };

        typedef ap_fixed_base<mult_w, mult_i, mult_s> mult;
        typedef ap_fixed_base<plus_w, plus_i, plus_s> plus;
        typedef ap_fixed_base<minus_w, minus_i, minus_s> minus;
        typedef ap_fixed_base<logic_w, logic_i, logic_s> logic;
        typedef ap_fixed_base<div_w, div_i, div_s> div;
        typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1;
    };

    /// Constructors.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base() {
                                                                                          ;
/*
    #ifdef __SC_COMPATIBLE__
        Base::V = 0;
    #endif
*/
    }
    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    /*__attribute__((weak))*/ ap_fixed_base (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2> &op) {

_ssdm_InlineSelf(0, "");

        enum { N2=_AP_W2, _AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2,
               QUAN_INC = F2>_AP_F && !(_AP_Q==SC_TRN || (_AP_Q==SC_TRN_ZERO && !_AP_S2)) };
        bool carry = false;



        // handle quantization
        unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
        bool signbit = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W2-1, _AP_W2-1); (bool)(__Result__ & 1); });

        bool isneg = signbit && _AP_S2;
        if (F2 == _AP_F)
            Base::V = op.V;
        else if (F2 > _AP_F) {
            if (sh_amt < _AP_W2)
                Base::V = op.V >> sh_amt;
            else {
                static int AllOnesInt = -1;
                if (isneg) Base::V = AllOnesInt;
                else Base::V = 0;
            }
            if (_AP_Q!=SC_TRN && !(_AP_Q==SC_TRN_ZERO && !_AP_S2)) {
                bool qbit = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), F2-_AP_F-1, F2-_AP_F-1); (bool)(__Result__ & 1); });

                bool qb = (F2-_AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;

                bool r = (F2 > _AP_F+1) ?
                         ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, F2-_AP_F-2<_AP_W2?F2-_AP_F-2:_AP_W2-1); __Result__; })!=0 : false;


                carry = quantization_adjust(qb, r, _AP_S2 && signbit);
            }
        }
        else { // no quantization
            Base::V = op.V;
            if (sh_amt < _AP_W)
                Base::V = Base::V << sh_amt;
            else
                Base::V = 0;
        }

        // handle overflow/underflow
        if ((_AP_O != SC_WRAP || _AP_N != 0) && ((!_AP_S && _AP_S2) ||
             _AP_I-_AP_S < _AP_I2-_AP_S2+(QUAN_INC ||
              (_AP_S2 && _AP_O==SC_SAT_SYM)))) { // saturation
            bool deleted_zeros = _AP_S2?true:!carry,
                 deleted_ones = true;
            bool neg_src = isneg;
            bool lD = false;

            bool newsignbit = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W-1, _AP_W-1); (bool)(__Result__ & 1); });
            int pos1 = F2 - _AP_F + _AP_W;
            int pos2 = F2 - _AP_F + _AP_W + 1;
            if (pos1 < _AP_W2 && pos1 >= 0)
                lD = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*>(&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, pos1); (bool)(__Result__ & 1); });



            if(pos1 < _AP_W2)
            {
                bool Range1_all_ones = true;
                bool Range1_all_zeros = true;
                bool Range2_all_ones = true;
                ap_int_base<_AP_W2,false> Range1(0);
                ap_int_base<_AP_W2,false> Range2(0);
                ap_int_base<_AP_W2,false> all_ones(-1);

                if (pos2 < _AP_W2 && pos2 >= 0) {
                    Range2.V = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2-1); __Result__; });


                    Range2_all_ones = Range2 == (all_ones >> pos2);
                } else if (pos2 < 0)
                    Range2_all_ones = false;

                if (pos1 >= 0 && pos2 < _AP_W2) {
                    Range1.V = ({ typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Result__ = 0; typeof((const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V)) __Val2__ = (const_cast<ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>*> (&op)->V); __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2-1); __Result__; });



                    Range1_all_ones = Range1 == (all_ones >> pos1);
                    Range1_all_zeros = !Range1.V ;
                } else if (pos2 == _AP_W2) {
                    Range1_all_ones = lD;
                    Range1_all_zeros = !lD;
                } else if (pos1 < 0) {
                    Range1_all_zeros = !op.V;
                    Range1_all_ones = false;
                }


                deleted_zeros = deleted_zeros && (carry ? Range1_all_ones: Range1_all_zeros);
                deleted_ones = carry ? Range2_all_ones &&
                               (pos1 < 0 || !lD): Range1_all_ones;
                neg_src = isneg && !(carry&&Range1_all_ones);
            } else
                neg_src = isneg && newsignbit;
            bool neg_trg = _AP_S && newsignbit;
            bool overflow = (neg_trg || !deleted_zeros) && !isneg;
            bool underflow = (!neg_trg || !deleted_ones) && neg_src;
            if ((_AP_O == SC_SAT_SYM) && _AP_S2 && _AP_S)
                underflow |= neg_src && (_AP_W > 1 ?
                  ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0 : true);

            overflow_adjust(underflow, overflow, lD, neg_src);
        }
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
        *this = const_cast<ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base (const ap_int_base<_AP_W2,_AP_S2>& op) {
                                                                                          ;
        ap_fixed_base<_AP_W2,_AP_W2,_AP_S2> f_op;
        f_op.V = op.V;
        *this = f_op;
    }

    inline __attribute__((always_inline)) ap_fixed_base( bool b ) { *this = (ap_fixed_base<1, 1, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( char b ) { *this = (ap_fixed_base<8, 8, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed char b ) { *this = (ap_fixed_base<8, 8, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned char b ) { *this = (ap_fixed_base<8, 8, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed short b ) { *this = (ap_fixed_base<16, 16, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned short b ) { *this = (ap_fixed_base<16, 16, false>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( signed int b ) { *this = (ap_fixed_base<32, 32, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned int b ) { *this = (ap_fixed_base<32, 32, false>) b; }

    inline __attribute__((always_inline)) ap_fixed_base( signed long b ) { *this = (ap_fixed_base<64, 64, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( unsigned long b ) { *this = (ap_fixed_base<64, 64, false>) b; }




    inline __attribute__((always_inline)) ap_fixed_base( ap_slong b ) { *this = (ap_fixed_base<64, 64, true>) b; }
    inline __attribute__((always_inline)) ap_fixed_base( ap_ulong b ) { *this = (ap_fixed_base<64, 64, false>) b; }
   inline __attribute__((always_inline)) ap_fixed_base(const char* str) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str),
         10, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N, true);
        Base::V = Result;
    }

    inline __attribute__((always_inline)) ap_fixed_base(const char* str, signed char radix) {
        typeof(Base::V) Result;
        _ssdm_string2bits((void*)(&Result), (const char*)(str),
            radix, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N, true);
        Base::V = Result;
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
        *this = ((bool)op);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
        *this = (ap_int_base<_AP_W2, false>(op));
    }

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_fixed_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
        *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));

    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
         *this = (bool(op));
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
        *this = (ap_int_base<_AP_W2, false>(op));
    }

    // helper function.
    inline __attribute__((always_inline)) unsigned long long doubleToRawBits(double pf) const {
        union {
            unsigned long long __L;
            double __D;
        } LD;
        LD.__D = pf;
        return LD.__L;
    }
    inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) const {
        union {
            unsigned int __L;
            float __D;
        } LD;
        LD.__D = pf;
        return LD.__L;
    }
    inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) const {
        union {
            unsigned short __L;
            half __D;
        } LD;
        LD.__D = pf;
        return LD.__L;
    }

    inline __attribute__((always_inline)) double rawBitsToDouble(unsigned long long pi) const {
        union {
            unsigned long long __L;
            double __D;
        } LD;
        LD.__L = pi;
        return LD.__D;
    }

    inline __attribute__((always_inline)) float rawBitsToFloat (unsigned int pi) const {
        union {
            unsigned int __L;
            float __D;
        } LD;
        LD.__L = pi;
        return LD.__D;
    }

    inline __attribute__((always_inline)) half rawBitsToHalf (unsigned short pi) const {
        union {
            unsigned short __L;
            half __D;
        } LD;
        LD.__L = pi;
        return LD.__D;
    }

    /*__attribute__((weak))*/ ap_fixed_base(double d) {

_ssdm_InlineSelf(0, "");

        ap_int_base<64,false> ireg;
        ireg.V = doubleToRawBits(d);
        bool isneg = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 63, 63); (bool)(__Result__ & 1); });

        ap_int_base<11 + 1, true> exp;
        ap_int_base<11, false> exp_tmp;
        exp_tmp.V = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 -1); __Result__; });

        exp = exp_tmp - ((1<<(11 -1))-1);
        ap_int_base<52 + 2, true> man;
        man.V = ({ typeof(ireg.V) __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });
        //do not support NaN

                                                    ;
        man.V = ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
        if(isneg) man = -man;
        if ( (ireg.V & 0x7fffffffffffffffLL)==0 ) {
            Base::V = 0;
        } else {
            int _AP_W2=52 +2, _AP_I2=exp.V+2, _AP_F=_AP_W-_AP_I, F2=_AP_W2-_AP_I2;
            bool _AP_S2 = true,
                 QUAN_INC = F2>_AP_F && !(_AP_Q==SC_TRN || (_AP_Q==SC_TRN_ZERO && !_AP_S2));
            bool carry = false;
            // handle quantization
            unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
            if (F2 == _AP_F)
                Base::V = man.V;
            else if (F2 > _AP_F) {
                if (sh_amt < 52 + 2)
                   Base::V = man.V >> sh_amt;
                else {
                   static int AllOnesInt = -1;
                   if (isneg) Base::V = AllOnesInt;
                   else Base::V = 0;
                }
                if ((_AP_Q != SC_TRN) && !((_AP_Q == SC_TRN_ZERO) && !_AP_S2)) {

                    bool qb = (F2-_AP_F > _AP_W2) ?
                        isneg : (bool) ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), F2 - _AP_F - 1, F2 - _AP_F - 1); (bool)(__Result__ & 1); });
                    bool r = (F2 > _AP_F + 1) ? ({ typeof(man.V) __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2): (_AP_W2 - 1)); __Result__; }) !=

                             0 : false;
                    carry = quantization_adjust(qb, r, isneg);
                }
            }
            else { // no quantization 
                Base::V = man.V;
                if (sh_amt < _AP_W)
                    Base::V = Base::V << sh_amt;
                else
                    Base::V = 0;
            }
            // handle overflow/underflow
            if ((_AP_O != SC_WRAP || _AP_N != 0) && ((!_AP_S && _AP_S2)
                || _AP_I - _AP_S < _AP_I2 - _AP_S2 + (QUAN_INC ||
                (_AP_S2 && (_AP_O == SC_SAT_SYM)))) ) { // saturation
                bool deleted_zeros = _AP_S2?true:!carry,
                     deleted_ones = true;
                bool neg_src = isneg;
                bool lD = false;
                int pos1 =F2 - _AP_F + _AP_W;
                int pos2 =F2 - _AP_F + _AP_W + 1;
                bool newsignbit = ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); });
                if (pos1 < _AP_W2 && pos1 >= 0)
                  //lD = _ssdm_op_get_bit(man.V, pos1);
                  lD = (man.V >> pos1) & 1;
                if (pos1 < _AP_W2 ) {
                    bool Range1_all_ones = true;
                    bool Range1_all_zeros = true;
                    bool Range2_all_ones = true;
                    ap_int_base<52 +2,false> Range2;
                    ap_int_base<52 +2,false> all_ones(-1);

                    if (pos2 >= 0 && pos2 < _AP_W2) {
                        //Range2.V = _ssdm_op_get_range(man.V, 
                        //                        pos2, _AP_W2 - 1);
                        Range2.V = man.V;
                        Range2.V >>= pos2;
                        Range2_all_ones = Range2 == (all_ones >> pos2);
                    } else if (pos2 < 0)
                        Range2_all_ones = false;
                    if (pos1 >= 0 && pos2 < _AP_W2) {
                        Range1_all_ones = Range2_all_ones && lD;
                        Range1_all_zeros = !Range2.V && !lD;
                    } else if (pos2 == _AP_W2) {
                        Range1_all_ones = lD;
                        Range1_all_zeros = !lD;
                    } else if (pos1 < 0) {
                        Range1_all_zeros = !man.V;
                        Range1_all_ones = false;
                    }

                    deleted_zeros = deleted_zeros && (carry ? Range1_all_ones: Range1_all_zeros);
                    deleted_ones = carry ? Range2_all_ones &&
                                   ( pos1 < 0 || !lD): Range1_all_ones;
                    neg_src=isneg && !(carry&&Range1_all_ones);
                } else
                    neg_src = isneg && newsignbit;
                bool neg_trg = _AP_S && newsignbit;
                bool overflow = (neg_trg || !deleted_zeros) && !isneg;
                bool underflow =(!neg_trg || !deleted_ones) && neg_src;
                if ((_AP_O == SC_SAT_SYM) && _AP_S2 && _AP_S)
                   underflow |= neg_src && (_AP_W > 1 ?
                     ({ typeof(Base::V) __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0 : true);
                overflow_adjust(underflow, overflow, lD, neg_src);
            }
        }
    }

    inline __attribute__((always_inline)) ap_fixed_base(float d) {
        *this = ap_fixed_base(double(d));
    }

    inline __attribute__((always_inline)) ap_fixed_base(half d) {_ssdm_SpecConstant(&omode);_ssdm_SpecConstant(&qmode);_ssdm_SpecConstant(&iwidth);_ssdm_SpecConstant(&width);
        *this = ap_fixed_base(double(d));
    }

    inline __attribute__((always_inline)) ap_fixed_base& operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op)
    {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_fixed_base& operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op)
    {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) void operator=(const ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op) volatile
    {
        Base::V = op.V;
    }

    inline __attribute__((always_inline)) void operator=(const volatile ap_fixed_base<_AP_W, _AP_I, _AP_S,
                                        _AP_Q, _AP_O, _AP_N>& op) volatile
    {
        Base::V = op.V;
    }

    // Set this ap_fixed_base with a bits string. That means the ssdm_int::V
    // inside this ap_fixed_base is assigned by bv.
    // Note the input parameter should be a fixed-point formatted bit string.
    inline __attribute__((always_inline)) ap_fixed_base& setBits(unsigned long long bv) {
      Base::V = bv;
      return *this;
    }
    // Return a ap_fixed_base object whose ssdm_int::V is assigned by bv.
    // Note the input parameter should be a fixed-point formatted bit string.
    static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(unsigned long long bv) {
      ap_fixed_base Tmp;
      Tmp.V = bv;
      return Tmp;
    }

    // Explicit conversion functions to ap_int_base that captures 
    // all integer bits (bits are truncated)
    inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S>
    to_ap_int_base(bool Cnative = true) const {
        //return ap_int_base<AP_MAX(_AP_I,1),_AP_S>(_AP_I > 1 ? 
        // _ssdm_op_get_range(const_cast<ap_fixed_base*>(this)->Base::V,_AP_W-_AP_I,_AP_W-1) : 0);
        ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)),_AP_S> ret(0);
        if(_AP_I > 0 && _AP_I <= _AP_W)
            ret.V = ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });


        else if (_AP_I > _AP_W)
        {
            ret.V = ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });

            unsigned int shift = _AP_I - _AP_W;
            ret.V <<= shift;
        }
        if (Cnative) {
            //Follow C native data type, conversion from double to int
            if (_AP_S && ({ typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast< ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast< ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); })

                && (_AP_I < _AP_W) && (({ typeof(const_cast<ap_fixed_base*>(this)->Base::V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->Base::V) __Val2__ = const_cast<ap_fixed_base*>(this)->Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I >= 0 ? _AP_W - _AP_I - 1: _AP_W - 1); __Result__; }) != 0))


                ret.V += 1;
        } else {
        //Follow OSCI library, conversion from sc_fixed to sc_int
        }
        return ret;
    };

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) operator ap_int_base<_AP_W2,_AP_S2> () const {
        return (ap_int_base<_AP_W2,_AP_S2>)to_ap_int_base();
    }

    // Explicit conversion function to C built-in integral type.
    inline __attribute__((always_inline)) int to_int() const {
        return to_ap_int_base().to_int();
    }
    inline __attribute__((always_inline)) unsigned to_uint() const {
        return to_ap_int_base().to_uint();
    }
    inline __attribute__((always_inline)) ap_slong to_int64() const {
        return to_ap_int_base().to_int64();
    }
    inline __attribute__((always_inline)) ap_ulong to_uint64() const {
        return to_ap_int_base().to_uint64();
    }
    /*__attribute__((weak))*/ double to_double() const {

_ssdm_InlineSelf(0, "");

        if (_AP_W - _AP_I > 0 && _AP_W <= 64) {
            if (!Base::V)
                return 0;
            double dp = Base::V;
            ap_int_base<64,true> res;
            res.V = doubleToRawBits(dp);
            ap_int_base<11, true> exp;
            exp.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 62); __Result__; });
            exp -= _AP_W - _AP_I;
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp.V) __Repl2__ = exp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 62); __Result__; });
            dp = rawBitsToDouble(res.to_int64());
            return dp;
        } else if (_AP_I - _AP_W >= 0 && _AP_I <= 64) {
            ap_int_base<((1) > (_AP_I) ? (1) : (_AP_I)), _AP_S> temp;
            temp.V = Base::V;
            temp <<= _AP_I - _AP_W;
            double dp = temp.V;
            return dp;
        } else {
            if (!Base::V)
                return 0;
            ap_int_base<64,true> res;
            res.V = 0;
            bool isneg = _AP_S ? ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }) : false;

            ap_int_base<_AP_W+_AP_S,_AP_S> tmp;
            tmp.V = Base::V;
            if (isneg) tmp.V = -Base::V;

            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(isneg) __Repl2__ = !!isneg; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63, 63); __Result__; });
            int j = _AP_W+_AP_S-1-tmp.countLeadingZeros();

            int exp = _AP_I-(_AP_W-j);
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp + ((1<<(11 -1))-1)) __Repl2__ = exp + ((1<<(11 -1))-1); __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 62); __Result__; });
            if (j == 0)
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(0) __Repl2__ = 0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 52 - 1); __Result__; });
            else {
                ap_int_base<52,false> man;
                man.V = ({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), j > 52 ? j - 52 : 0, j - 1); __Result__; });

                man.V <<= 52 > j ? 52 -j : 0;
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(man.V) __Repl2__ = man.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 52 - 1); __Result__; });
            }
            double dp = rawBitsToDouble(res.to_int64());
            return dp;
        }

    }

    /*__attribute__((weak))*/ float to_float() const {

_ssdm_InlineSelf(0, "");

        if (_AP_W - _AP_I > 0 && _AP_W <= 64) {
            if (!Base::V)
                return 0;
            float dp = Base::V;
            ap_int_base<32,true> res;
            res.V = floatToRawBits(dp);
            ap_int_base<8, true> exp;
            exp.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, 30); __Result__; });
            exp -= _AP_W - _AP_I;
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp.V) __Repl2__ = exp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 30); __Result__; });
            dp = rawBitsToFloat(res.to_int());
            return dp;
        } else if (_AP_I - _AP_W >= 0 && _AP_I <= 64) {
            ap_int_base<((1) > (_AP_I) ? (1) : (_AP_I)), _AP_S> temp;
            temp.V = Base::V;
            temp <<= _AP_I - _AP_W;
            float dp = temp.V;
            return dp;
        } else {
            if (!Base::V)
                return 0;
            ap_int_base<32,true> res;
            res.V = 0;
            bool isneg = _AP_S ? ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }) : false;

            ap_int_base<_AP_W+_AP_S,_AP_S> tmp;
            tmp.V = Base::V;
            if (isneg) tmp.V = -Base::V;
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(isneg) __Repl2__ = !!isneg; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 31, 31); __Result__; });
            int j = _AP_W+_AP_S-1-tmp.countLeadingZeros();

            int exp = _AP_I-(_AP_W-j);
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp + ((1<<(8 -1))-1)) __Repl2__ = exp + ((1<<(8 -1))-1); __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 30); __Result__; });
            if (j == 0)
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(0) __Repl2__ = 0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 23 - 1); __Result__; });
            else {
                ap_int_base<23,false> man;
                man.V = ({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), j > 23 ? j - 23 : 0, j - 1); __Result__; });

                man.V <<= 23 > j ? 23 -j: 0;
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(man.V) __Repl2__ = man.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 23 - 1); __Result__; });
            }
            return rawBitsToFloat(res.to_int());
        }
    }
    inline __attribute__((always_inline)) half to_half() const {

_ssdm_InlineSelf(0, "");

        if (_AP_W - _AP_I > 0 && _AP_W <= 64) {
            if (!Base::V)
                return 0;
            half dp = Base::V;
            ap_int_base<16,true> res;
            res.V = halfToRawBits(dp);
            ap_int_base<5, true> exp;
            exp.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 10, 14); __Result__; });
            exp -= _AP_W - _AP_I;
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp.V) __Repl2__ = exp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 14); __Result__; });
            dp = rawBitsToHalf(res.to_int());
            return dp;
        } else if (_AP_I - _AP_W >= 0 && _AP_I <= 64) {
            ap_int_base<((1) > (_AP_I) ? (1) : (_AP_I)), _AP_S> temp;
            temp.V = Base::V;
            temp <<= _AP_I - _AP_W;
            half dp = temp.V;
            return dp;
        } else {
            if (!Base::V)
                return 0;
            ap_int_base<16,true> res;
            res.V = 0;
            bool isneg = _AP_S ? ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }) : false;

            ap_int_base<_AP_W+_AP_S,_AP_S> tmp;
            tmp.V = Base::V;
            if (isneg) tmp.V = -Base::V;
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(isneg) __Repl2__ = !!isneg; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 31, 31); __Result__; });
            int j = _AP_W+_AP_S-1-tmp.countLeadingZeros();

            int exp = _AP_I-(_AP_W-j);
            res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(exp + ((1<<(5 -1))-1)) __Repl2__ = exp + ((1<<(5 -1))-1); __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 14); __Result__; });
            if (j == 0)
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(0) __Repl2__ = 0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 10 - 1); __Result__; });
            else {
                ap_int_base<10,false> man;
                man.V = ({ typeof(tmp.V) __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), j > 10 ? j - 10 : 0, j - 1); __Result__; });

                man.V <<= 10 > j ? 10 -j: 0;
                res.V = ({ typeof(res.V) __Result__ = 0; typeof(res.V) __Val2__ = res.V; typeof(man.V) __Repl2__ = man.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, 10 - 1); __Result__; });
            }
            return rawBitsToHalf(res.to_int());
        }
    }

    inline __attribute__((always_inline)) operator double () const {
        return to_double();
    }

    inline __attribute__((always_inline)) operator float () const {
        return to_float();
    }
    inline __attribute__((always_inline)) operator half () const {
        return to_half();
    }
    inline __attribute__((always_inline)) operator char () const {
        return (char) to_int();
    }

    inline __attribute__((always_inline)) operator signed char () const {
        return (signed char) to_int();
    }

    inline __attribute__((always_inline)) operator unsigned char () const {
        return (unsigned char) to_uint();
    }

    inline __attribute__((always_inline)) operator short () const {
        return (short) to_int();
    }

    inline __attribute__((always_inline)) operator unsigned short () const {
        return (unsigned short) to_uint();
    }


    inline __attribute__((always_inline)) operator int () const {
        return to_int();
    }

    inline __attribute__((always_inline)) operator unsigned int () const {
        return to_uint();
    }


    inline __attribute__((always_inline)) operator long () const {
        return (long)to_int64();
    }

    inline __attribute__((always_inline)) operator unsigned long () const {
        return (unsigned long) to_uint64();
    }
# 1322 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 inline __attribute__((always_inline)) operator unsigned long long () const {
        return to_uint64();
    }

    inline __attribute__((always_inline)) operator long long () const {
        return to_int64();
    }

    inline __attribute__((always_inline)) int length() const { return _AP_W; };
    // Count the number of zeros from the most significant bit 
    // to the first one bit. Note this is only for ap_fixed_base whose 
    // _AP_W <= 64, otherwise will incur assertion.
    inline __attribute__((always_inline)) int countLeadingZeros() {
        if (_AP_W <= 32) {
            ap_int_base<32, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctz(t.V);
        } else if (_AP_W <= 64) {
            ap_int_base<64, false> t(-1ULL);
            t.range(_AP_W-1, 0) = this->range(0, _AP_W-1);
            return __builtin_ctzll(t.V);
        } else {
            enum { __N = (_AP_W+63)/64 };
            int NZeros = 0;
            unsigned i = 0;
            bool hitNonZero = false;
            for (i=0; i<__N-1; ++i) {
                ap_int_base<64, false> t;
                t.range(0, 63) = this->range(_AP_W - i*64 - 64, _AP_W - i*64 - 1);
                NZeros += hitNonZero?0:__builtin_clzll(t.V);
                hitNonZero |= (t != 0);
            }
            if (!hitNonZero) {
                ap_int_base<64, false> t(-1ULL);
                t.range(63-(_AP_W-1)%64, 63) = this->range(0, (_AP_W-1)%64);
                NZeros += __builtin_clzll(t.V);
            }
            return NZeros;
        }
    }

    // Arithmetic : Binary
    // -------------------------------------------------------------------------
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::mult
    operator *(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::mult r;
        ap_int_base<_AP_W+_AP_W2,_AP_S> OP1;
        OP1.V = Base::V;
        ap_int_base<_AP_W+_AP_W2,_AP_S2> OP2;
        OP2.V = op2.V ;
        r.V = OP1.V * OP2.V;
        return r;
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::div
    operator /(const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const {
        typename RType<_AP_W2,_AP_I2,_AP_S2>::div r;

        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),
                      _AP_I, _AP_S> t(*this);




        r.V = t.V / op2.V;
        //r = double(to_double() / op2.to_double());
        return r;
    }
# 1406 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::plus operator + (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::plus r, lhs(*this), rhs(op2); ; r.V = lhs.V + rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::minus operator - (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::minus r, lhs(*this), rhs(op2); ; r.V = lhs.V - rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator & (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V & rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator | (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V | rhs.V; return r; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2,_AP_I2,_AP_S2>::logic operator ^ (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { ; enum { _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 }; ; typename RType<_AP_W2,_AP_I2,_AP_S2>::logic r, lhs(*this), rhs(op2); ; r.V = lhs.V ^ rhs.V; return r; }


    // Arithmetic : assign
    // -------------------------------------------------------------------------
# 1424 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator += (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator + (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator - (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator * (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator / (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator & (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator | (op2); return *this; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2,_AP_N2>& op2) { ; *this = operator ^ (op2); return *this; }


    // Prefix increment, decrement.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base& operator ++() {
        operator+=(ap_fixed_base<_AP_W-_AP_I+1,1,false>(1));
        return *this;
    }
    inline __attribute__((always_inline)) ap_fixed_base& operator --() {
        operator-=(ap_fixed_base<_AP_W-_AP_I+1,1,false>(1));
        return *this;
    }

    // Postfix increment, decrement
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) const ap_fixed_base
    operator ++(int) {
        ap_fixed_base t(*this);
        operator++();
        return t;
    }
    inline __attribute__((always_inline)) const ap_fixed_base
    operator --(int) {
        ap_fixed_base t(*this);
        operator--();
        return t;
    }

    // Unary arithmetic.
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base operator +() {
        return *this;
    }

    inline __attribute__((always_inline)) ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator -() const {
        ap_fixed_base<_AP_W + 1, _AP_I + 1, true> ret(*this);
        ret.V = - ret.V;
        return ret;
    }

    inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O,_AP_N> getNeg() {
        ap_fixed_base<_AP_W,_AP_I,true,_AP_Q,_AP_O,_AP_N> Tmp(*this);
        Tmp.V = -Tmp.V;
        return Tmp;
    }

    // Not (!)
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) bool operator !() const {
        return Base::V == 0;
    }

    // Bitwise complement
    // -------------------------------------------------------------------------
    inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator ~() const {
        ap_fixed_base<_AP_W, _AP_I, _AP_S> ret;
        ret.V=~Base::V;
        return ret;
    }

    // Shift
    // -------------------------------------------------------------------------
     template<int _AP_SHIFT>
     inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift () const {
         ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
         r.V = Base::V;
         return r;
     }

     template<int _AP_SHIFT>
     inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift () const {
         ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
         r.V = Base::V;
         return r;
     }

     /*__attribute__((weak))*/ ap_fixed_base
     operator << (int sh) const {

_ssdm_InlineSelf(0, "");

        ap_fixed_base r;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V >> sh;
        else r.V = Base::V << sh;
# 1555 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return r;

    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_int_base<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator << (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base
    operator << (unsigned int sh) const {

_ssdm_InlineSelf(0, "");

        ap_fixed_base r;
        r.V = Base::V << sh;
# 1600 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return r;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_int_base<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator << (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base
    operator >> (int sh) const {

_ssdm_InlineSelf(0, "");

        ap_fixed_base r;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
        if (isNeg) r.V = Base::V << sh;
        else r.V = Base::V >> sh;
# 1658 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return r;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_int_base<_AP_W2,true>& op2) const {
        int sh = op2.to_int();
        return operator >> (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base
    operator >> (unsigned sh) const {

_ssdm_InlineSelf(0, "");

        ap_fixed_base r;
        r.V = Base::V >> sh;
# 1690 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return r;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_int_base<_AP_W2,false>& op2) const {
        unsigned int sh = op2.to_uint();
        return operator >> (sh);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator >> (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator >> (op2.to_ap_int_base());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base
    operator << (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator << (op2.to_ap_int_base());
    }



    // Shift assign
    // -------------------------------------------------------------------------
    /*__attribute__((weak))*/ ap_fixed_base&
    operator <<= (int sh) {

_ssdm_InlineSelf(0, "");

        if (sh == 0) return *this;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
# 1759 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 if (isNeg) Base::V >>= sh;
        else Base::V <<= sh;
# 1773 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return *this;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_int_base<_AP_W2,true>& op2) {
        int sh = op2.to_int();
        return operator <<= (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base&
    operator <<= (unsigned int sh) {

_ssdm_InlineSelf(0, "");
# 1808 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 Base::V <<= sh;
# 1820 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return *this;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_int_base<_AP_W2,false>& op2) {
        unsigned int sh = op2.to_uint();
        return operator <<= (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base&
    operator >>= (int sh) {

_ssdm_InlineSelf(0, "");

        if (sh == 0) return *this;
        bool isNeg = sh & 0x80000000;
        sh = isNeg ? -sh : sh;
# 1868 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 if (isNeg) Base::V <<= sh;
        else Base::V >>= sh;
# 1882 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 return *this;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_int_base<_AP_W2,true>& op2) {
        int sh = op2.to_int();
        return operator >>= (sh);
    }

    /*__attribute__((weak))*/ ap_fixed_base&
    operator >>= (unsigned int sh) {

_ssdm_InlineSelf(0, "");
# 1912 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 Base::V >>= sh;




        return *this;
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_int_base<_AP_W2,false>& op2) {
        unsigned int sh = op2.to_uint();
        return operator >>= (sh);
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator >>= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator >>= (op2.to_ap_int_base());
    }

    template<int _AP_W2, int _AP_I2, bool _AP_S2,
             ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed_base&
    operator <<= (const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                 _AP_N2>& op2) {
        return operator <<= (op2.to_ap_int_base());
    }

    // Comparisons.
    // -------------------------------------------------------------------------
# 1959 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
 template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator == (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V == op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator != (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V != op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator > (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V > op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V >= op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator < (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V < op2.V; return false; }
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <= (const ap_fixed_base<_AP_W2,_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>& op2) const { const int _AP_F = _AP_W-_AP_I, F2 = _AP_W2-_AP_I2 ; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2+_AP_F-F2) > (1) ? (_AP_W2+_AP_F-F2) : (1)),_AP_I2,_AP_S2,_AP_Q2,_AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W+F2-_AP_F+1) > (1) ? (_AP_W+F2-_AP_F+1) : (1)),_AP_I+1,_AP_S,_AP_Q,_AP_O, _AP_N>(*this).V <= op2.V; return false; }






    inline __attribute__((always_inline)) bool operator == (double d) const { return to_double() == d; }
    inline __attribute__((always_inline)) bool operator != (double d) const { return to_double() != d; }
    inline __attribute__((always_inline)) bool operator > (double d) const { return to_double() > d; }
    inline __attribute__((always_inline)) bool operator >= (double d) const { return to_double() >= d; }
    inline __attribute__((always_inline)) bool operator < (double d) const { return to_double() < d; }
    inline __attribute__((always_inline)) bool operator <= (double d) const { return to_double() <= d; }

    // Bit and Slice Select
    inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> operator[] (unsigned index) {
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index);
    }

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> operator [] (const ap_int_base<_AP_W2,_AP_S2>& index) {
                                                                           ;
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int());
    }

    inline __attribute__((always_inline)) bool operator [] (unsigned index) const {
                                                                     ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index, index); (bool)(__Result__ & 1); });
    }

    inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> bit(unsigned index) {
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index);
    }


    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> bit (const ap_int_base<_AP_W2,_AP_S2>& index) {
                                                                           ;
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int());
    }

    inline __attribute__((always_inline)) bool bit (unsigned index) const {
                                                                     ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index, index); (bool)(__Result__ & 1); });
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> get_bit (const ap_int_base<_AP_W2, true>& index) {
                                                                                       ;
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index.to_int() + _AP_W - _AP_I);
    }

    inline __attribute__((always_inline)) bool get_bit (int index) const {
                                                                     ;
                                                                              ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index + _AP_W - _AP_I, index + _AP_W - _AP_I); (bool)(__Result__ & 1); });
    }

    inline __attribute__((always_inline)) af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N> get_bit (int index) {
                                                                                       ;
                                                                     ;
        return af_bit_ref<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>(this, index + _AP_W - _AP_I);
    }

    template<int _AP_W2>
    inline __attribute__((always_inline)) bool get_bit (const ap_int_base<_AP_W2, true>& index) const {
                                                                     ;
                                                                              ;
        return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), index.to_int() + _AP_W - _AP_I, index.to_int() + _AP_W - _AP_I); (bool)(__Result__ & 1); });
    }


    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) {
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) {
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range(int Hi, int Lo) const {
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
          const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    range(const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
          const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
                                                                           ;
        return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(const_cast<
               ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>*>(this),
               Hi, Lo);
    }

    template<int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
    inline __attribute__((always_inline)) af_range_ref<_AP_W,_AP_I,_AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (const ap_int_base<_AP_W2, _AP_S2> &HiIdx,
                 const ap_int_base<_AP_W3, _AP_S3> &LoIdx) const {
        int Hi = HiIdx.to_int();
        int Lo = LoIdx.to_int();
        return this->range(Hi, Lo);
    }

    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    operator () (int Hi, int Lo) const {
        return this->range(Hi, Lo);
    }

    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() {
        return this->range(_AP_W - 1, 0);
    }

    inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>
    range() const {
        return this->range(_AP_W - 1, 0);
    }

    inline __attribute__((always_inline)) bool is_zero () const {
        return Base::V == 0;
    }

    inline __attribute__((always_inline)) bool is_neg () const {
        if (_AP_S && ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Result__ = 0; typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, _AP_W - 1); (bool)(__Result__ & 1); }))
           return true;
        return false;
    }

    inline __attribute__((always_inline)) int wl () const {
        return _AP_W;
    }

    inline __attribute__((always_inline)) int iwl () const {
        return _AP_I;
    }

    inline __attribute__((always_inline)) ap_q_mode q_mode () const {
        return _AP_Q;
    }

    inline __attribute__((always_inline)) ap_o_mode o_mode () const {
        return _AP_O;
    }

    inline __attribute__((always_inline)) int n_bits () const {
        return _AP_N;
    }

    inline __attribute__((always_inline)) char* to_string(BaseMode mode) {
          return 0;
    }

    inline __attribute__((always_inline)) char* to_string(signed char mode) {
          return to_string(BaseMode(mode));
    }
};

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_not(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
    ret.V = ~ op.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_and(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V & op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_or(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V | op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) void b_xor(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
            const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
    ret.V = op1.V ^ op2.V;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N, int _AP_W2, int _AP_I2,
         bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void neg(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    ap_fixed_base<_AP_W2+!_AP_S2, _AP_I2+!_AP_S2, true, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = - op.V;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N, int _AP_W2, int _AP_I2,
         bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void lshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_W2 - _AP_I2 + ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)), _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    Tmp.V = op.V;
    Tmp.V <<= i;
    ret = Tmp;
}

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
         int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
         ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void rshift(ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
            const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
            int i) {
    ap_fixed_base<_AP_I2 + ((_AP_W - _AP_I) > (_AP_W2 - _AP_I2) ? (_AP_W - _AP_I) : (_AP_W2 - _AP_I2)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> Tmp;
    const int val = _AP_W - _AP_I - (_AP_W2 - _AP_I2);
    Tmp.V = op.V;
    if (val > 0) Tmp.V <<= val;
    Tmp.V >>= i;
    ret = Tmp;
}
# 2232 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
template<> inline __attribute__((always_inline)) ap_fixed_base<1,1,true,SC_TRN,SC_WRAP>::ap_fixed_base(bool i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<1,1,false,SC_TRN,SC_WRAP>::ap_fixed_base(bool i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned char i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<8,8,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned char i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed short i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed short i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned short i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<16,16,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned short i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(signed int i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(signed int i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned int i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<32,32,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned int i_op) { Base::V = i_op; }

template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(long i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(long i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned long i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(unsigned long i_op) { Base::V = i_op; }




template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(ap_slong i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(ap_slong i_op) { Base::V = i_op; }
template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,true,SC_TRN,SC_WRAP>::ap_fixed_base(ap_ulong i_op) { Base::V = i_op; } template<> inline __attribute__((always_inline)) ap_fixed_base<64,64,false,SC_TRN,SC_WRAP>::ap_fixed_base(ap_ulong i_op) { Base::V = i_op; }


/// Output streamimg.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) std::ostream&
operator << (std::ostream& os, const ap_fixed_base<_AP_W,_AP_I,
             _AP_S,_AP_Q,_AP_O, _AP_N>& x) {
    // os << x.to_double();
    return os;
}

/// Input streamimg.
// -----------------------------------------------------------------------------
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) std::istream&
operator >> (std::istream& in, ap_fixed_base<_AP_W,_AP_I,
             _AP_S,_AP_Q,_AP_O, _AP_N>& x) {





    return in;
}



/// Operators mixing Integers with ap_fixed_base
// -----------------------------------------------------------------------------
# 2350 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator + (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::plus operator + ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator - (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::minus operator - ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator * (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::mult operator * ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator / (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::div operator / ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >> (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator << (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator & (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator & ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator | (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator | ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator ^ (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<1,1,false>::logic operator ^ ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator == (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator != (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator > (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator < (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<1,1,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator += (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator >>= (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, bool i_op) { return op.operator <<= (ap_int_base<1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |= (ap_fixed_base<1,1,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^= (ap_fixed_base<1,1,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator >>= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, char i_op) { return op.operator <<= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator + (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::plus operator + ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator - (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::minus operator - ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator * (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::mult operator * ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator / (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::div operator / ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >> (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator << (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator & (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator & ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator | (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator | ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator ^ (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,true>::logic operator ^ ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator == (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator != (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator > (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator < (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator += (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator >>= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed char i_op) { return op.operator <<= (ap_int_base<8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |= (ap_fixed_base<8,8,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^= (ap_fixed_base<8,8,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator + (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::plus operator + ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator - (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::minus operator - ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator * (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::mult operator * ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator / (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::div operator / ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >> (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator << (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator & (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator & ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator | (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator | ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^ (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<8,8,false>::logic operator ^ ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator == (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator != (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator > (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator < (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<8,8,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator += (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>= (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<= (ap_int_base<8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |= (ap_fixed_base<8,8,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^= (ap_fixed_base<8,8,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator + (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::plus operator + ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator - (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::minus operator - ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator * (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::mult operator * ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator / (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::div operator / ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >> (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator << (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator & (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator & ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator | (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator | ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator ^ (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,true>::logic operator ^ ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator == (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator != (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator > (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator < (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator <= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator += (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator -= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator *= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator /= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator >>= (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, signed short i_op) { return op.operator <<= (ap_int_base<16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator &= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator |= (ap_fixed_base<16,16,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, signed short i_op) { return op.operator ^= (ap_fixed_base<16,16,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator + (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::plus operator + ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator - (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::minus operator - ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator * (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::mult operator * ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator / (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::div operator / ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >> (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator << (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator & (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator & ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator | (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator | ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^ (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<16,16,false>::logic operator ^ ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator == (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator != (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator > (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator < (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<16,16,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator += (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>= (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<= (ap_int_base<16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |= (ap_fixed_base<16,16,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^= (ap_fixed_base<16,16,false>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator + (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::plus operator + ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator - (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::minus operator - ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator * (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::mult operator * ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator / (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::div operator / ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >> (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator << (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator & (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator & ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator | (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator | ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator ^ (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,true>::logic operator ^ ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator == (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator != (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator > (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator < (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator += (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator >>= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, int i_op) { return op.operator <<= (ap_int_base<32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |= (ap_fixed_base<32,32,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^= (ap_fixed_base<32,32,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator + (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::plus operator + ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator - (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::minus operator - ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator * (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::mult operator * ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator / (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::div operator / ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >> (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator << (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator & (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator & ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator | (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator | ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^ (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<32,32,false>::logic operator ^ ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator == (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator != (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator > (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator < (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<32,32,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator += (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<= (ap_int_base<32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |= (ap_fixed_base<32,32,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^= (ap_fixed_base<32,32,false>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >> (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator << (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator >>= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, long i_op) { return op.operator <<= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >> (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator << (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator + (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::plus operator + ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator - (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::minus operator - ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator * (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::mult operator * ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator / (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::div operator / ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >> (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator << (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator & (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator & ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator | (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator | ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^ (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,true>::logic operator ^ ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator == (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator != (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator > (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator < (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,true>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator += (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<= (ap_int_base<64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |= (ap_fixed_base<64,64,true>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^= (ap_fixed_base<64,64,true>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator + (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::plus operator + ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator - (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::minus operator - ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator * (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::mult operator * ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator / (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::div operator / ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator >> ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >> (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::arg1 operator << ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator << (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator & (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator & ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator | (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator | ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^ (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W,_AP_I,_AP_S>::template RType<64,64,false>::logic operator ^ ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator == (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator == (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator != (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator != (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator > (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator > (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator >= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator < (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator < (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<64,64,false>(i_op).operator <= (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator += (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator >>= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& operator <<= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<= (ap_int_base<64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |= (ap_fixed_base<64,64,false>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^= (ap_fixed_base<64,64,false>(i_op)); }
# 2400 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::plus operator + ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator + (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::plus operator + ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator + (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::minus operator - ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator - (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::minus operator - ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator - (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::mult operator * ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator * (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::mult operator * ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator * (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::div operator / ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator / (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::div operator / ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator / (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator & ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator & (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator & ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator & (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator | ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator | (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator | ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator | (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>::template RType<_AP_W,_AP_I,_AP_S>::logic operator ^ ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator ^ (op); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType<_AP_W2,_AP_W2,_AP_S2>::logic operator ^ ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator ^ (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator == ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator == (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator != ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator != (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator > ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator > (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator >= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator >= (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator < ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator < (op); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator <= ( ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op) { return ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op).operator <= (op); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator += ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator += (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator += ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator += (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator -= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator -= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator -= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator -= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator *= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator *= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator *= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator *= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator /= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator /= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator /= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator /= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator &= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator &= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator &= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator &= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator |= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator |= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator |= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator |= (op.to_ap_int_base()); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& operator ^= ( ap_fixed_base<_AP_W, _AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op, const ap_int_base<_AP_W2,_AP_S2>& i_op) { return op.operator ^= (ap_fixed_base<_AP_W2,_AP_W2,_AP_S2>(i_op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2,_AP_S2>& operator ^= ( ap_int_base<_AP_W2,_AP_S2>& i_op, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op) { return i_op.operator ^= (op.to_ap_int_base()); }

// Relational Operators with double
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator == ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator == (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator != ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator != (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
        ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator > ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator < (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator >= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O, _AP_N>& op2) {
  return op2.operator <= (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
        ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator < ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator > (op1);
}
template<int _AP_W, int _AP_I, bool _AP_S,
         ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((always_inline)) bool operator <= ( double op1, const ap_fixed_base<_AP_W,_AP_I,_AP_S,_AP_Q,_AP_O,_AP_N>& op2) {
  return op2.operator >= (op1);
}
# 2485 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<1,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<1,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, bool op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, signed char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<8,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<8,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned char op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<16,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<16,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned short op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned int op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }

template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<32,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<32,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, unsigned long op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }




template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,true>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,true>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_slong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator > (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) > op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator > ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 > (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator < (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) < op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator < ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 < (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) >= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 >= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) <= op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <= ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 <= (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator == (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) == op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator == ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 == (bool(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (ap_int_base<_AP_W, false>(op)).operator != (ap_int_base<64,false>(op2)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return ap_int_base<64,false>(op2).operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, ap_ulong op2) { return (bool(op)) != op2; } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator != ( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2 != (bool(op)); }
# 2525 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed_syn.h"
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator > (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator > ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator > (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator < (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator < ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator < (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator >= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >= ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator >= (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator <= (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <= ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator <= (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator == (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator == ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator == (ap_int_base<1,false>(op)); }
template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const af_range_ref<_AP_W,_AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S> &op2) { return (ap_int_base<_AP_W, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != (const ap_int_base<_AP_W2, _AP_S2> &op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_int_base<_AP_W, false>(op)); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op, const ap_int_base<_AP_W2, _AP_S2> &op2) { return (ap_int_base<1, false>(op)).operator != (op2); } template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator != ( const ap_int_base<_AP_W2, _AP_S2> &op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op) { return op2.operator != (ap_int_base<1,false>(op)); }







// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_int.h" 2
//Forward declaration
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_fixed;
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q,
         ap_o_mode _AP_O, int _AP_N> struct ap_ufixed;
template<int _AP_W> struct ap_int;
template<int _AP_W> struct ap_uint;

//AP_INT
//--------------------------------------------------------
template<int _AP_W>
struct ap_int: ap_int_base<_AP_W, true> {
    typedef ap_int_base<_AP_W, true> Base;
    //Constructor
    inline __attribute__((always_inline)) ap_int(): Base() {}
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const ap_int<_AP_W2> &op) {Base::V = op.V;}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_int<_AP_W2> &op) {Base::V = op.V;}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const ap_uint<_AP_W2> &op) { Base::V = op.V;}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_uint<_AP_W2> &op) { Base::V = op.V;}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}


    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op){ Base::V = op.V; }

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_int(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}



    inline __attribute__((always_inline)) ap_int(bool val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(signed char val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned char val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(short val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned short val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(int val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned int val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(unsigned long long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(long long val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(half val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(float val) {Base::V = val; }
    inline __attribute__((always_inline)) ap_int(double val) {Base::V = val; }

     inline __attribute__((always_inline)) ap_int(const char* str):Base(str) {}
     inline __attribute__((always_inline)) ap_int(const char* str, signed char radix):Base(str, radix) {}
     //Assignment
     //Assignment
     //Another form of "write"
     inline __attribute__((always_inline)) void operator = (const ap_int<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }

     inline __attribute__((always_inline)) void operator = (const volatile ap_int<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }

     inline __attribute__((always_inline)) ap_int& operator = (const volatile ap_int<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }

     inline __attribute__((always_inline)) ap_int& operator = (const ap_int<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
};

//AP_UINT
//---------------------------------------------------------------
template<int _AP_W>
struct ap_uint: ap_int_base<_AP_W, false> {
    typedef ap_int_base<_AP_W, false> Base;
    //Constructor
    inline __attribute__((always_inline)) ap_uint(): Base() {}
    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const ap_uint<_AP_W2> &op) { Base::V = op.V; }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const ap_int<_AP_W2> &op) { Base::V = op.V;}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_uint<_AP_W2> &op) { Base::V = op.V; }

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_int<_AP_W2> &op) { Base::V = op.V;}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref):Base(ref) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref):Base(ref) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
        :Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op){ Base::V = op.V;}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2,
                  _AP_N2>& op):Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_uint(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}



    inline __attribute__((always_inline)) ap_uint(bool val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(signed char val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned char val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(short val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned short val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(int val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned int val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(unsigned long long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(long long val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(half val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(float val) { Base::V = val; }
    inline __attribute__((always_inline)) ap_uint(double val) { Base::V = val; }

    inline __attribute__((always_inline)) ap_uint(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_uint(const char* str, signed char radix):Base(str, radix) {}
     //Assignment
     //Another form of "write"
     inline __attribute__((always_inline)) void operator = (const ap_uint<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }

     inline __attribute__((always_inline)) void operator = (const volatile ap_uint<_AP_W>& op2) volatile {
         Base::V = op2.V;
     }

     inline __attribute__((always_inline)) ap_uint& operator = (const volatile ap_uint<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }

     inline __attribute__((always_inline)) ap_uint& operator = (const ap_uint<_AP_W>& op2) {
         Base::V = op2.V;
         return *this;
     }
};


//AP_FIXED
//---------------------------------------------------------------------  
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = SC_TRN,
         ap_o_mode _AP_O = SC_WRAP, int _AP_N = 0>
struct ap_fixed: ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
    typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;
     //Constructor
    inline __attribute__((always_inline)) ap_fixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                    _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                          true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const ap_int<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const ap_uint<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2,
                    _AP_O2, _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                          true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                    _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                   false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_int<_AP_W2>& op):
                    Base(ap_int_base<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_fixed(const volatile ap_uint<_AP_W2>& op):
                   Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_fixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op): Base(op) {}



    inline __attribute__((always_inline)) ap_fixed(bool v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(signed char v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned char v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(short v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned short v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(int v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned int v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(unsigned long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(half v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(float v):Base(v) {}
    inline __attribute__((always_inline)) ap_fixed(double v):Base(v) {}

    inline __attribute__((always_inline)) ap_fixed(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_fixed(const char* str, signed char radix):Base(str, radix) {}

    //Assignment
    inline __attribute__((always_inline)) ap_fixed& operator = (const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                        _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_fixed& operator = (const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) void operator = (const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                        _AP_N>& op) volatile {
        Base::V = op.V;
    }

    inline __attribute__((always_inline)) void operator = (const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = op.V;
    }



};
//AP_UFIXED
//-------------------------------------------------------------------
template<int _AP_W, int _AP_I, ap_q_mode _AP_Q = SC_TRN,
         ap_o_mode _AP_O = SC_WRAP, int _AP_N = 0>
struct ap_ufixed: ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
    typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;
     //Constructor
    inline __attribute__((always_inline)) ap_ufixed():Base() {}

    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                      _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                     _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_int<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_uint<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                      _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     true, _AP_Q2, _AP_O2, _AP_N2>(op)) {}


    template<int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2,
                     _AP_N2>& op): Base(ap_fixed_base<_AP_W2, _AP_I2,
                     false, _AP_Q2, _AP_O2, _AP_N2>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_int<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, true>(op)) {}

    template<int _AP_W2>
    inline __attribute__((always_inline)) ap_ufixed(const volatile ap_uint<_AP_W2>& op):
                     Base(ap_int_base<_AP_W2, false>(op)) {}
    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2,
                      _AP_Q2, _AP_O2, _AP_N2>& op):Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op):
                   Base(op) {}

    template<int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
    inline __attribute__((always_inline)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op):
                   Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
             ap_o_mode _AP_O2, int _AP_N2>
    inline __attribute__((always_inline)) ap_ufixed(const af_range_ref<_AP_W2, _AP_I2, _AP_S2,
                    _AP_Q2, _AP_O2, _AP_N2>& op): Base(op) {}

    template<int _AP_W2, bool _AP_S2>
    inline __attribute__((always_inline)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op): Base(op) {}



    inline __attribute__((always_inline)) ap_ufixed(bool v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(signed char v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned char v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(short v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned short v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(int v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned int v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(unsigned long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(long long v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(half v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(float v):Base(v) {}
    inline __attribute__((always_inline)) ap_ufixed(double v):Base(v) {}

    inline __attribute__((always_inline)) ap_ufixed(const char* str):Base(str) {}
    inline __attribute__((always_inline)) ap_ufixed(const char* str, signed char radix):Base(str, radix) {}

    //Assignment
    inline __attribute__((always_inline)) ap_ufixed& operator = (const ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) ap_ufixed& operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) {
        Base::V = op.V;
        return *this;
    }

    inline __attribute__((always_inline)) void operator = (const ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = op.V;
    }

    inline __attribute__((always_inline)) void operator = (const volatile ap_ufixed<_AP_W, _AP_I,
                      _AP_Q, _AP_O, _AP_N>& op) volatile {
        Base::V = op.V;
    }

};





// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 87 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_axi_sdata.h" 2

template<int D,int U,int TI,int TD>
  struct ap_axis{
    ap_int<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };

template<int D,int U,int TI,int TD>
  struct ap_axiu{
    ap_uint<D> data;
    ap_uint<(D+7)/8> keep;
    ap_uint<(D+7)/8> strb;
    ap_uint<U> user;
    ap_uint<1> last;
    ap_uint<TI> id;
    ap_uint<TD> dest;
  };

//typedef ap_axis<int D, int U, int TI, int TD> ap_axis_unsigned<int D, int U, int TI, int TD>;




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/





# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdint.h" 1 3
/*===---- stdint.h - Standard header for sized integer types --------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/




/* If we're hosted, fall back to the system's stdint.h, which might have
 * additional definitions.
 */




# 1 "/usr/include/stdint.h" 1 3 4
/* Copyright (C) 1997,1998,1999,2000,2001,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99: 7.18 Integer types <stdint.h>
 */








# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 29 "/usr/include/stdint.h" 2 3 4

/* Exact integral types.  */

/* Signed.  */

/* There is some amount of overlap with <sys/types.h> as known by inet code */


typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;






/* Unsigned.  */
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;






/* Small types.  */

/* Signed.  */
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;





/* Unsigned.  */
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;






/* Fast types.  */

/* Signed.  */
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;







/* Unsigned.  */
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 117 "/usr/include/stdint.h" 3 4
/* Types for `void *' pointers.  */





typedef unsigned long int uintptr_t;
# 133 "/usr/include/stdint.h" 3 4
/* Largest integral types.  */

typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 145 "/usr/include/stdint.h" 3 4
/* The ISO C99 standard specifies that in C++ implementations these
   macros should only be defined if explicitly requested.  */
# 285 "/usr/include/stdint.h" 3 4
/* The ISO C99 standard specifies that in C++ implementations these
   should only be defined if explicitly requested.  */
# 34 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stdint.h" 2 3
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
// 2006, 2007, 2008, 2009, 2010
// Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cstdlib
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdlib.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 20.4.6  C library
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
# 65 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */





/* Get size_t, wchar_t and NULL from <stddef.h>.  */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {





/* XPG requires a few symbols from <sys/wait.h> being defined.  */


# 1 "/usr/include/bits/waitflags.h" 1 3 4
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992,1996,1997,2000,2004,2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Bits in the third argument to `waitpid'.  */



/* Bits in the fourth argument to `waitid'.  */
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */


/* If WIFSIGNALED(STATUS), the terminating signal.  */


/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */


/* Nonzero if STATUS indicates normal termination.  */


/* Nonzero if STATUS indicates termination by a signal.  */



/* Nonzero if STATUS indicates the child is stopped.  */


/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */




/* Nonzero if STATUS indicates the child dumped core.  */


/* Macros for constructing status values.  */
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7; /* Terminating signal.  */
 unsigned int __w_coredump:1; /* Set if dumped core.  */
 unsigned int __w_retcode:8; /* Return code if exited normally.  */
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
 unsigned int __w_stopsig:8; /* Stopping signal.  */
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4



/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */
# 58 "/usr/include/stdlib.h" 3 4
/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */
# 84 "/usr/include/stdlib.h" 3 4
/* Define the macros <sys/wait.h> also would define this way.  */
# 97 "/usr/include/stdlib.h" 3 4
/* Returned by `div'.  */
typedef struct
  {
    int quot; /* Quotient.  */
    int rem; /* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */

typedef struct
  {
    long int quot; /* Quotient.  */
    long int rem; /* Remainder.  */
  } ldiv_t;






/* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot; /* Quotient.  */
    long long int rem; /* Remainder.  */
  } lldiv_t;





/* The largest number rand will return (same as INT_MAX).  */



/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */




/* Maximum length of a multibyte character in the current locale.  */

extern size_t __ctype_get_mb_cur_max (void) throw () /* Ignore */;



/* Convert a string to a floating-point number.  */
extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) /* Ignore */;
/* Convert a string to an integer.  */
extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) /* Ignore */;
/* Convert a string to a long integer.  */
extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Convert a string to a long long integer.  */
__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Convert a string to a floating-point number.  */
extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Convert a string to a long integer.  */
extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;



/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another problem is
   the implementation of the internationalization handling in the
   ISO C++ standard library.  To support this another set of
   the functions using locale data exist which take an additional
   argument.

   Attention: even though several *_l interfaces are part of POSIX:2008,
   these are not.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */


/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) /* Ignore */;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) /* Ignore */;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) /* Ignore */;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) /* Ignore */;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) /* Ignore */;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) /* Ignore */;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) /* Ignore */;
# 308 "/usr/include/stdlib.h" 3 4
/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n) throw () /* Ignore */;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) /* Ignore */;






# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */






extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 71 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 148 "/usr/include/sys/types.h" 2 3 4


/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


/* These size-specific names are used by some of the inet code.  */
# 187 "/usr/include/sys/types.h" 3 4
/* For GCC 2.7 and later, we can use specific type-size attributes.  */
# 201 "/usr/include/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */





/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */


/* It also defines `fd_set' and the FD_* macros for `select'.  */


# 1 "/usr/include/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2003, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */






/* Get definition of needed basic types.  */


/* Get __FD_* definitions.  */


# 1 "/usr/include/bits/select.h" 1 3 4
/* Copyright (C) 1997,1998,1999,2001,2008,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */







# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4

/* Get __sigset_t.  */


# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */


typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;




/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;


/* Get definition of timer specification structures.  */






# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 73 "/usr/include/bits/time.h" 3 4
/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec; /* Seconds.  */
    __suseconds_t tv_usec; /* Microseconds.  */
  };
# 47 "/usr/include/sys/select.h" 2 3 4







/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define these macros.  */



/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */




/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */

    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */



/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */




/* Access macros for `fd_set'.  */






extern "C" {

/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);


/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4

/* BSD defines these symbols, so we follow.  */


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996, 1997, 1999, 2003, 2004, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* If the compiler does not know long long it is out of luck.  We are
   not going to hack weird hacks to support the dev_t representation
   they need.  */

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();
# 64 "/usr/include/sys/sysmacros.h" 3 4
/* Access the functions with their traditional names.  */
# 224 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;



/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t; /* Type to count number of disk blocks.  */



typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */



typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
# 263 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t; /* Type to count number of disk blocks. */
typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */



/* Now add the thread types.  */




}
# 321 "/usr/include/stdlib.h" 2 3 4

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) throw ();

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) throw ();

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));



/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr; /* Front pointer.  */
    int32_t *rptr; /* Rear pointer.  */
    int32_t *state; /* Array of state values.  */
    int rand_type; /* Type of random number generator.  */
    int rand_deg; /* Degree of random number generator.  */
    int rand_sep; /* Distance between front and rear.  */
    int32_t *end_ptr; /* Pointer behind state table.  */
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) throw ();
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) throw ();



/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) throw ();




/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));

/* Seed random number generator.  */
extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));


/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3]; /* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c; /* Additive const. in congruential formula.  */
    unsigned short int __init; /* Flag for initializing.  */
    unsigned long long int __a; /* Factor in congruential formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
# 470 "/usr/include/stdlib.h" 3 4
/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) /* Ignore */;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) /* Ignore */;





/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) throw ();



/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) throw ();





# 1 "/usr/include/alloca.h" 1 3 4
/* Copyright (C) 1992, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */
# 26 "/usr/include/alloca.h" 3 4
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/clang/bin/../lib/clang/3.1/include/stddef.h" 3 4
/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {

/* Remove any previous definitions.  */


/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4




/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) /* Ignore */;



/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;



/* Abort execution and generate a core-dump.  */
extern void abort (void) throw () __attribute__ ((__noreturn__));


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));


// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Register a function to be called when `quick_exit' is called.  */

extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));







/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));



/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) throw () __attribute__ ((__noreturn__));


// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));





/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));



/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));

/* Remove the variable NAME from the environment.  */
extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) throw ();





/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique file name.  */
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) /* Ignore */;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) /* Ignore */;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;



/* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */

extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) /* Ignore */;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) /* Ignore */;


/* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) /* Ignore */;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) /* Ignore */;





/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (__const char *__command) /* Ignore */;




/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;



/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () /* Ignore */;



/* Shorthand for type of comparison functions.  */


typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);



/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) /* Ignore */;

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));



/* Return the absolute value of X.  */
extern int abs (int __x) throw () __attribute__ ((__const__)) /* Ignore */;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) /* Ignore */;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) /* Ignore */;




/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) /* Ignore */;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) /* Ignore */;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) /* Ignore */;






/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) /* Ignore */;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) /* Ignore */;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) /* Ignore */;



/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) /* Ignore */;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) /* Ignore */;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) /* Ignore */;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (__const char *__s, size_t __n) throw () /* Ignore */;
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () /* Ignore */;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) throw () /* Ignore */;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();




/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) /* Ignore */;




/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) /* Ignore */;




/* Setup DES tables according KEY.  */
extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));



/* X/Open pseudo terminal handling.  */


/* Return a master pseudo-terminal handle.  */
extern int posix_openpt (int __oflag) /* Ignore */;



/* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  */

/* Chown the slave to the calling user.  */
extern int grantpt (int __fd) throw ();

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
extern int unlockpt (int __fd) throw ();

/* Return the pathname of the pseudo terminal slave assoicated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  */
extern char *ptsname (int __fd) throw () /* Ignore */;



/* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  */
extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));

/* Open a master pseudo terminal and return its file descriptor.  */
extern int getpt (void);



/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));



/* Define some macros helping to catch buffer overflows.  */
# 964 "/usr/include/stdlib.h" 3 4
}
# 66 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 2 3

// Get rid of those macros defined in <stdlib.h> in lieu of real functions.
# 97 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


} // namespace
# 157 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 192 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/cstdlib" 3
 using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


} // namespace __gnu_cxx

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
} // namespace std
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 37 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h" 2

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 1 3
// The template and inlines for the numeric_limits classes. -*- C++ -*-

// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
// 2008, 2009, 2010  Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/limits
 *  This is a Standard C++ Library header.
 */

// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>

//
// ISO 14882:1998
// 18.2.1
//
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3



//
// The numeric_limits<> traits document implementation-defined aspects
// of fundamental arithmetic data types (integers and floating points).
// From Standard C++ point of view, there are 14 such types:
//   * integers
//         bool							(1)
//         char, signed char, unsigned char, wchar_t            (4)
//         short, unsigned short				(2)
//         int, unsigned					(2)
//         long, unsigned long					(2)
//
//   * floating points
//         float						(1)
//         double						(1)
//         long double						(1)
//
// GNU C++ understands (where supported by the host C-library)
//   * integer
//         long long, unsigned long long			(2)
//
// which brings us to 16 fundamental arithmetic data types in GNU C++.
//
//
// Since a numeric_limits<> is a bit tricky to get right, we rely on
// an interface composed of macros which should be defined in config/os
// or config/cpu when they differ from the generic (read arbitrary)
// definitions given here.
//

// These values can be overridden in the target configuration file.
// The default values are appropriate for many 32-bit targets.

// GCC only intrinsically supports modulo integral types.  The only remaining
// integral exceptional values is division by zero.  Only targets that do not
// signal division by zero in some "hard to ignore" way should use false.




// float
//

// Default values.  Should be overridden in configuration files if necessary.
# 98 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
// double

// Default values.  Should be overridden in configuration files if necessary.
# 112 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
// long double

// Default values.  Should be overridden in configuration files if necessary.
# 126 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
// You should not need to define any macros below this point.
# 140 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
// The fraction 643/2136 approximates log10(2) to 7 significant digits.






namespace std __attribute__ ((__visibility__ ("default")))
{


  /**
   *  @brief Describes the rounding style for floating-point types.
   *
   *  This is used in the std::numeric_limits class.
  */
  enum float_round_style
  {
    round_indeterminate = -1, /// Intermediate.
    round_toward_zero = 0, /// To zero.
    round_to_nearest = 1, /// To the nearest representable value.
    round_toward_infinity = 2, /// To infinity.
    round_toward_neg_infinity = 3 /// To negative infinity.
  };

  /**
   *  @brief Describes the denormalization for floating-point types.
   *
   *  These values represent the presence or absence of a variable number
   *  of exponent bits.  This type is used in the std::numeric_limits class.
  */
  enum float_denorm_style
  {
    /// Indeterminate at compile time whether denormalized values are allowed.
    denorm_indeterminate = -1,
    /// The type does not allow denormalized values.
    denorm_absent = 0,
    /// The type allows denormalized values.
    denorm_present = 1
  };

  /**
   *  @brief Part of std::numeric_limits.
   *
   *  The @c static @c const members are usable as integral constant
   *  expressions.
   *
   *  @note This is a separate class for purposes of efficiency; you
   *        should only access these members as part of an instantiation
   *        of the std::numeric_limits class.
  */
  struct __numeric_limits_base
  {
    /** This will be true for all fundamental types (which have
	specializations), and false for everything else.  */
    static const bool is_specialized = false;

    /** The number of @c radix digits that be represented without change:  for
	integer types, the number of non-sign bits in the mantissa; for
	floating types, the number of @c radix digits in the mantissa.  */
    static const int digits = 0;

    /** The number of base 10 digits that can be represented without change. */
    static const int digits10 = 0;







    /** True if the type is signed.  */
    static const bool is_signed = false;

    /** True if the type is integer.
     *  Is this supposed to be <em>if the type is integral?</em>  */
    static const bool is_integer = false;

    /** True if the type uses an exact representation. <em>All integer types are
	exact, but not all exact types are integer.  For example, rational and
	fixed-exponent representations are exact but not integer.</em>
	[18.2.1.2]/15  */
    static const bool is_exact = false;

    /** For integer types, specifies the base of the representation.  For
	floating types, specifies the base of the exponent representation.  */
    static const int radix = 0;

    /** The minimum negative integer such that @c radix raised to the power of
	(one less than that integer) is a normalized floating point number.  */
    static const int min_exponent = 0;

    /** The minimum negative integer such that 10 raised to that power is in
	the range of normalized floating point numbers.  */
    static const int min_exponent10 = 0;

    /** The maximum positive integer such that @c radix raised to the power of
	(one less than that integer) is a representable finite floating point
	number.  */
    static const int max_exponent = 0;

    /** The maximum positive integer such that 10 raised to that power is in
	the range of representable finite floating point numbers.  */
    static const int max_exponent10 = 0;

    /** True if the type has a representation for positive infinity.  */
    static const bool has_infinity = false;

    /** True if the type has a representation for a quiet (non-signaling)
	<em>Not a Number</em>.  */
    static const bool has_quiet_NaN = false;

    /** True if the type has a representation for a signaling
	<em>Not a Number</em>.  */
    static const bool has_signaling_NaN = false;

    /** See std::float_denorm_style for more information.  */
    static const float_denorm_style has_denorm = denorm_absent;

    /** <em>True if loss of accuracy is detected as a denormalization loss,
	rather than as an inexact result.</em> [18.2.1.2]/42  */
    static const bool has_denorm_loss = false;

    /** True if-and-only-if the type adheres to the IEC 559 standard, also
	known as IEEE 754.  (Only makes sense for floating point types.)  */
    static const bool is_iec559 = false;

    /** <em>True if the set of values representable by the type is
	finite.  All built-in types are bounded, this member would be
	false for arbitrary precision types.</em> [18.2.1.2]/54  */
    static const bool is_bounded = false;

    /** True if the type is @e modulo, that is, if it is possible to add two
	positive numbers and have a result that wraps around to a third number
	that is less.  Typically false for floating types, true for unsigned
	integers, and true for signed integers.  */
    static const bool is_modulo = false;

    /** True if trapping is implemented for this type.  */
    static const bool traps = false;

    /** True if tininess is detected before rounding.  (see IEC 559)  */
    static const bool tinyness_before = false;

    /** See std::float_round_style for more information.  This is only
	meaningful for floating types; integer types will all be
	round_toward_zero.  */
    static const float_round_style round_style =
          round_toward_zero;
  };

  /**
   *  @brief Properties of fundamental types.
   *
   *  This class allows a program to obtain information about the
   *  representation of a fundamental type on a given platform.  For
   *  non-fundamental types, the functions will return 0 and the data
   *  members will all be @c false.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS:  DRs 201 and 184 (hi Gaby!) are
   *  noted, but not incorporated in this documented (yet).
  */
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      /** The minimum finite value, or for floating types with
	  denormalization, the minimum positive normalized value.  */
      static _Tp
      min() throw() { return static_cast<_Tp>(0); }

      /** The maximum finite value.  */
      static _Tp
      max() throw() { return static_cast<_Tp>(0); }
# 321 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
 /** The @e machine @e epsilon:  the difference between 1 and the least
	  value greater than 1 that is representable.  */
      static _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }

      /** The maximum rounding error measurement (see LIA-1).  */
      static _Tp
      round_error() throw() { return static_cast<_Tp>(0); }

      /** The representation of positive infinity, if @c has_infinity.  */
      static _Tp
      infinity() throw() { return static_cast<_Tp>(0); }

      /** The representation of a quiet <em>Not a Number</em>,
	  if @c has_quiet_NaN. */
      static _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }

      /** The representation of a signaling <em>Not a Number</em>, if
	  @c has_signaling_NaN. */
      static _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }

      /** The minimum positive denormalized value.  For types where
	  @c has_denorm is false, this is the minimum positive normalized
	  value.  */
      static _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };
# 365 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
 // Now there follow 16 explicit specializations.  Yes, 16.  Make sure
  // you get the count right. (18 in c++0x mode)

  /// numeric_limits<bool> specialization.
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      // It is not clear what it means for a boolean type to trap.
      // This is a DR on the LWG issue list.  Here, I use integer
      // promotion semantics.
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<char> specialization.
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<signed char> specialization.
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw() { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned char> specialization.
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<wchar_t> specialization.
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
# 850 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/lnx64/tools/gcc/lib/gcc/x86_64-unknown-linux-gnu/4.6.3/../../../../include/c++/4.6.3/limits" 3
 /// numeric_limits<short> specialization.
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned short> specialization.
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<int> specialization.
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned int> specialization.
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<long> specialization.
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long> specialization.
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<long long> specialization.
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw() { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long long> specialization.
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<float> specialization.
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435e-38F; }

      static float
      max() throw() { return 3.40282347e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209290e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf (); }

      static float
      quiet_NaN() throw() { return __builtin_nanf (""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf (""); }

      static float
      denorm_min() throw() { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };





  /// numeric_limits<double> specialization.
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return 2.2250738585072014e-308; }

      static double
      max() throw() { return 1.7976931348623157e+308; }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return 2.2204460492503131e-16; }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan (""); }

      static double
      signaling_NaN() throw() { return __builtin_nans (""); }

      static double
      denorm_min() throw() { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };





  /// numeric_limits<long double> specialization.
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall (); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl (""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl (""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






} // namespace
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h" 2

/*
*******************************************************************************
* HLS utilities
* -----------------------
*
* General utilities usable by all functions. Mainly contains classes to
* generate static values from recursive class declarations.
*
* pow2
* sqrtf - C declaration
* to_float
* set_to_one
* set_to_max
*
* fp_struct<float>
* fp_struct<double>
* fp_struct<half>
* dumpDouble
*
* Power - B^N
* BitWidth = calculate minimum # of bits to store given integer value
* LowerTri - converts the coordinates of a lower triangular matrix into a
*            sequential index
* LowerTriDim
*
* Table
*
*******************************************************************************
*/

namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1; //One of the definitions is: Machine epsilon is defined as the smallest number that, when added
                    //to one, yields a result different from one
          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W, int I>
    ap_ufixed<W,I> abs(ap_ufixed<W,I> x) {
        return x;
    }

    template <int W, int I>
    ap_ufixed<W,I> abs(ap_fixed<W,I> x) {
        ap_ufixed<W,I> xw = x;
        ap_ufixed<W,I> xn = -x;
        return (x < 0) ? xn: xw;
    }

    template <int W>
    ap_uint<W> abs(ap_uint<W> x) {
        return x;
    }
    template <int W>
    ap_uint<W> abs(ap_int<W> x) {
        ap_int<W+1> xw = x;
        return (x < 0) ? -xw: xw;
    }
    /*static
    float abs(float x) {
        return fabsf(x);
    }
    static
    double abs(double x) {
        return fabs(x);
    }*/
    static
    int abs(int x) {
        return std::abs(x);
    }
    static
    long int abs(long int x) {
        return std::abs(x);
    }
}

static
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<class T>
T reg(T in)
{
    //#ifndef NO_FORCING
_ssdm_InlineSelf(2, "");
_ssdm_op_SpecInterface(0, "ap_none", 1, 1, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
    //#endif
    return in;
}

/*
*------------------------------------------------------------------------------
* References C square root function for single precision square root.
* Maps to FPU sqrt core
*------------------------------------------------------------------------------
*/
// extern "C" float sqrtf(float);

/*
*------------------------------------------------------------------------------
* Converts data to float type
*------------------------------------------------------------------------------
*/
static
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}


/*
*------------------------------------------------------------------------------
* Overloaded function to set variable to a 1. See fixed point case below.
*------------------------------------------------------------------------------
*/
template<class _T>
void set_to_one(_T &a)
{
    a = 1.0f;
}

/*
* Set the input variable a to 1.
* We approximate 1 by setting the maximum value in the fractional bits.
*/
template<int _W, int _I>
void set_to_one(ap_fixed<_W,_I> &a)
{
    ap_int<_W> tmp_sat = pow((double)2,(double)(_W-_I))-1; //SATURATION_LIMIT_17_BIT;
    a.range() = tmp_sat;
}

/*template<int W, int I, int EW>
void set_to_one(fp<W,I,EW> &a)
{
    a.mant = 1.0;
    a.exp = 0;
    a.flags = REG;
}
*/
template<int _W, int _I>
void set_to_max(ap_fixed<_W,_I> &a)
{
    ap_int<_W> tmp_sat = pow((double)2,(double)_W)-1;
    a.range() = tmp_sat;
}


/*
*------------------------------------------------------------------------------
* Single-precision floating point union to convert between 32-bit int and float
*------------------------------------------------------------------------------
*/

template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {

        //def __SYNTHESIS__
        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {_ssdm_SpecConstant(&BITS);_ssdm_SpecConstant(&SIG_BITS);_ssdm_SpecConstant(&EXP_BITS);_ssdm_SpecConstant(&EXP_BIAS);_ssdm_SpecConstant(&EXP_INFNAN);
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {

        //def __SYNTHESIS__
        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1; // The implicit '1' in IEEE format.
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<float> &s)
{
# 411 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
 return os;
}

static
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 447 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
}


/*
*------------------------------------------------------------------------------
* Double-precision floating point union to convert between 64-bit int and double
*------------------------------------------------------------------------------
*/
union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {_ssdm_SpecConstant(&BITS);_ssdm_SpecConstant(&SIG_BITS);_ssdm_SpecConstant(&EXP_BITS);_ssdm_SpecConstant(&EXP_BIAS);_ssdm_SpecConstant(&EXP_INFNAN);
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1; // The implicit '1' in IEEE format.
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<double> &s)
{





    return os;
}

static
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 599 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
}

/*
*------------------------------------------------------------------------------
* Half-precision floating point union to convert between 16-bit int and half
*------------------------------------------------------------------------------
*/



union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1; // The implicit '1' in IEEE format.
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};

static
std::ostream &operator << (std::ostream &os, const fp_struct<half> &s)
{





    return os;
}

static
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 758 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
}



/*
*------------------------------------------------------------------------------
* Raise a value to a certain power (B^N).
*
* This class is necessary in template arguments due to its static const nature
* and the fact that it performs the power operation as part of the recursive
* class declaration. A standard recursive power function would not return
* a static const value.
*
*------------------------------------------------------------------------------
*/
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;

public :
inline __attribute__((always_inline)) Power() { _ssdm_SpecConstant(&Value); }
# 778 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;

public :
inline __attribute__((always_inline)) Power< _Base, 0 >() { _ssdm_SpecConstant(&Value); }
# 785 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

/*
*------------------------------------------------------------------------------
* Calculate the minimum # of bits to store the given integer value.
* UnsignedBitWidth<2>::Value == 3
* UnsignedBitWidth<3>::Value == 3
* UnsignedBitWidth<4>::Value == 4
*------------------------------------------------------------------------------
*/
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;

public :
inline __attribute__((always_inline)) BitWidth() { _ssdm_SpecConstant(&Value); }
# 800 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;

public :
inline __attribute__((always_inline)) BitWidth<_Num, 0>() { _ssdm_SpecConstant(&Value); }
# 807 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

/*
*------------------------------------------------------------------------------
* Calculate the minimum # of bits to store the given unsigned integer value.
* UnsignedBitWidth<2>::Value == 2
* UnsignedBitWidth<3>::Value == 2
* UnsignedBitWidth<4>::Value == 3
*------------------------------------------------------------------------------
*/
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;

public :
inline __attribute__((always_inline)) UnsignedBitWidth() { _ssdm_SpecConstant(&Value); }
# 822 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 0;

public :
inline __attribute__((always_inline)) UnsignedBitWidth<_Num, 0>() { _ssdm_SpecConstant(&Value); }
# 829 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

/*
*------------------------------------------------------------------------------
* return num of bits of a specific type
*
* This class returns the bitwidth result of a specific type
*------------------------------------------------------------------------------
*/
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);

public :
inline __attribute__((always_inline)) Type_BitWidth() { _ssdm_SpecConstant(&Value); }
# 843 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;

public :
inline __attribute__((always_inline)) Type_BitWidth< ap_uint<W> >() { _ssdm_SpecConstant(&Value); }
# 850 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;

public :
inline __attribute__((always_inline)) Type_BitWidth< ap_int<W> >() { _ssdm_SpecConstant(&Value); }
# 857 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;

public :
inline __attribute__((always_inline)) Type_BitWidth< ap_ufixed<W, I> >() { _ssdm_SpecConstant(&Value); }
# 864 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;

public :
inline __attribute__((always_inline)) Type_BitWidth< ap_fixed<W, I> >() { _ssdm_SpecConstant(&Value); }
# 871 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

/*
*------------------------------------------------------------------------------
* Lower triangular matrix index lookup function
*
* LowerTriDim<N> where N is square matrix dimension
* RowLookup[i]: returns row given sequential index i
* ColLookup[i]: returns row given sequential index i
* SizeLookup[i]: returns maximum index size
*
* Indexes are incremented as follows:
*
* 0
* 1 2
* 3 4 5
* 6 7 8 9
* ...
*
*------------------------------------------------------------------------------
*/

template < unsigned int _DIM, unsigned int _I=_DIM>
class LowerTri : public LowerTri<_DIM, _I-1>
{
public:
    static const int dummy;
    static const unsigned int Size = _I + LowerTri<_DIM,_I-1>::Size;

public :
inline __attribute__((always_inline)) LowerTri() { _ssdm_SpecConstant(&dummy); _ssdm_SpecConstant(&Size); }
# 899 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < unsigned int _DIM>
class LowerTri<_DIM, 0>
{
public:
    static const int dummy;
    static const unsigned int Size = 0;

public :
inline __attribute__((always_inline)) LowerTri<_DIM, 0>() { _ssdm_SpecConstant(&dummy); _ssdm_SpecConstant(&Size); }
# 907 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <int _MAX, int _I>
class LowerTriApply
{
public:
    static int rowApply() {
        int max = _MAX;
        int i = _I;
        int index = 0;
        int row[max];
        int dim = (int)(sqrtf(0.25+2*max)-0.5);
        for(int ii=0; ii<dim; ii++) {
            for(int jj=0; jj<ii+1; jj++) {
                row[index] = ii;
                index++;
            }
        }
        return row[i];
    }

    static int colApply() {
        int max = _MAX;
        int i = _I;
        int index = 0;
        int col[max];
        int dim = (int)(sqrtf(0.25+2*max)-0.5);
        for(int ii=0; ii<dim; ii++) {
            for(int jj=0; jj<ii+1; jj++) {
                col[index] = jj;
                index++;
            }
        }
        return col[i];
    }

    static int sizeApply() {
        int max = _MAX;
        int i = _I;
        int size[max];
        size[0] = 0;
        for(int ii=1; ii<max; ii++) {
            size[ii] = size[ii-1]+ii;
            if(i == ii) { return size[i]; }
        }
        return size[i];
    }
};

template < int _DIM, int _Num=LowerTri<_DIM>::Size, int _I=_Num-1>
class LowerTriDim : public LowerTriDim<_DIM,_Num,_I-1>
{
public:
    static const int dummy;
    static const int dummy2;
    static const int dummy3;

public :
inline __attribute__((always_inline)) LowerTriDim() { _ssdm_SpecConstant(&dummy); _ssdm_SpecConstant(&dummy2); _ssdm_SpecConstant(&dummy3); }
# 963 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < int _DIM, int _Num>
class LowerTriDim<_DIM, _Num, 0>
{
public:
    static const int dummy;
    static const int dummy2;
    static const int dummy3;
    static int RowLookup[_Num];
    static int ColLookup[_Num];
    static int SizeLookup[_DIM];

public :
inline __attribute__((always_inline)) LowerTriDim<_DIM, _Num, 0>() { _ssdm_SpecConstant(&dummy); _ssdm_SpecConstant(&dummy2); _ssdm_SpecConstant(&dummy3); }
# 975 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy =
    LowerTriDim<_DIM,_Num,0>::RowLookup[_I] = LowerTriApply<_Num,_I>::rowApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy =
    LowerTriDim<_DIM,_Num,0>::RowLookup[0] = LowerTriApply<_Num,0>::rowApply()
            + 0*LowerTriDim<_DIM,_Num,_Num>::dummy2;


template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy2 =
    LowerTriDim<_DIM,_Num,0>::ColLookup[_I] = LowerTriApply<_Num,_I>::colApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy2;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy2 =
    LowerTriDim<_DIM,_Num,0>::ColLookup[0] = LowerTriApply<_Num,0>::colApply()
            + 0*LowerTriDim<_DIM,_Num,_Num>::dummy3;

template < int _DIM, int _Num, int _I>
const int LowerTriDim<_DIM, _Num, _I>::dummy3 =
    LowerTriDim<_DIM,_Num,0>::SizeLookup[_I] = LowerTriApply<_Num,_I>::sizeApply()
            + 0*LowerTriDim<_DIM,_Num,_I-1>::dummy3;

template < int _DIM, int _Num>
const int LowerTriDim<_DIM, _Num, 0>::dummy3 =
    LowerTriDim<_DIM,_Num,0>::SizeLookup[0] = LowerTriApply<_Num,0>::sizeApply();

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::RowLookup[_Num];

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::ColLookup[_Num];

template<int _DIM, int _Num>
int LowerTriDim<_DIM, _Num, 0>::SizeLookup[_DIM];

/*
*******************************************************************************
* Table class
*
* T: table data type
* N: Depth of table entries
*
* public:
* 	dummy			Table data type
*		array[N]	Table array
*******************************************************************************
*/

template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;


public :
inline __attribute__((always_inline)) Table() { _ssdm_SpecConstant(&dummy); _ssdm_SpecConstant(&size); }
# 1037 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];

public :
inline __attribute__((always_inline)) Table<_T, _Num, 0>() { _ssdm_SpecConstant(&dummy); }
# 1045 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

/*
* Declares the templatized and static Table dummy variable
*
* Assign the global static const Table::dummy variable to the
* associated Table entry by invoking T::apply, assigning it to array[I]
* and adding smaller templates of Table::dummy to it, thereby recursively
* assigning the smaller templates for Tables..
*/

template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);

/*
* Declares the templatized and static Table array
*/
template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];

// Some standard junk... this is in the new standard and in boost,
// but for a few definitions it's not worth the dependency
template <class T>
struct is_fptype { static const bool value = false;
public :
inline __attribute__((always_inline)) is_fptype() { _ssdm_SpecConstant(&value); }
# 1073 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_fptype<float> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_fptype<float>() { _ssdm_SpecConstant(&value); }
# 1074 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_fptype<double> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_fptype<double>() { _ssdm_SpecConstant(&value); }
# 1075 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false;
public :
inline __attribute__((always_inline)) is_integraltype() { _ssdm_SpecConstant(&value); }
# 1079 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<int> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<int>() { _ssdm_SpecConstant(&value); }
# 1080 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<unsigned int> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<unsigned int>() { _ssdm_SpecConstant(&value); }
# 1081 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<char> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<char>() { _ssdm_SpecConstant(&value); }
# 1082 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<signed char> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<signed char>() { _ssdm_SpecConstant(&value); }
# 1083 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<unsigned char> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<unsigned char>() { _ssdm_SpecConstant(&value); }
# 1084 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<short> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<short>() { _ssdm_SpecConstant(&value); }
# 1085 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<unsigned short> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<unsigned short>() { _ssdm_SpecConstant(&value); }
# 1086 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<long> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<long>() { _ssdm_SpecConstant(&value); }
# 1087 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<unsigned long> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<unsigned long>() { _ssdm_SpecConstant(&value); }
# 1088 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<long long> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<long long>() { _ssdm_SpecConstant(&value); }
# 1089 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <> struct is_integraltype<unsigned long long> { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<unsigned long long>() { _ssdm_SpecConstant(&value); }
# 1090 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<ap_int<W> >() { _ssdm_SpecConstant(&value); }
# 1091 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true;
public :
inline __attribute__((always_inline)) is_integraltype<ap_uint<W> >() { _ssdm_SpecConstant(&value); }
# 1092 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template <class T>
struct is_fixedtype { static const bool value = false;
public :
inline __attribute__((always_inline)) is_fixedtype() { _ssdm_SpecConstant(&value); }
# 1095 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true;
public :
inline __attribute__((always_inline)) is_fixedtype<ap_fixed<W,I,Q,O> >() { _ssdm_SpecConstant(&value); }
# 1096 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true;
public :
inline __attribute__((always_inline)) is_fixedtype<ap_ufixed<W,I,Q,O> >() { _ssdm_SpecConstant(&value); }
# 1097 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template<bool B, class T = void>
struct enable_if {};

template<class T>
struct enable_if<true, T> { typedef T type; };

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value;
public :
inline __attribute__((always_inline)) enable_or() { _ssdm_SpecConstant(&value); }
# 1106 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value;
public :
inline __attribute__((always_inline)) enable_and() { _ssdm_SpecConstant(&value); }
# 1109 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

template<typename T, T _v>
struct integral_constant
{
    static const T value = _v;
    typedef T value_type;
    typedef integral_constant<T,_v> type;
    operator value_type() { return value; }

public :
inline __attribute__((always_inline)) integral_constant() { _ssdm_SpecConstant(&value); }
# 1118 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_utils.h"
};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template<typename T1, typename T2>
struct is_same;

template<typename T1, typename T2>
struct is_same : public false_type { };

template<typename T1>
struct is_same<T1,T1> : public true_type { };

template<typename T>
struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };

template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };



//End standard junk





// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h" 2
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
# 45 "/usr/include/assert.h" 3 4
/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
# 66 "/usr/include/assert.h" 3 4
extern "C" {

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 100 "/usr/include/assert.h" 3 4
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h" 2

namespace hls {

template<int W, typename T>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, T& val) {
_ssdm_InlineSelf(0, "");
    ((start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 48, __PRETTY_FUNCTION__));
    val = (T)pix(start+w-1, start);
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, float& val) {
_ssdm_InlineSelf(0, "");
    ((w == 32 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 55, __PRETTY_FUNCTION__));
    fp_struct<float> temp((ap_uint<32>)pix(start+w-1, start));
    val = temp.to_float();
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, double& val) {
_ssdm_InlineSelf(0, "");
    ((w == 64 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 63, __PRETTY_FUNCTION__));
    fp_struct<double> temp((ap_uint<64>)pix(start+w-1, start));
    val = temp.to_double();
}

template<int W, typename T>
void AXIGetBitFields(ap_axiu<W,1,1,1> axi, int start, int w, T& val) {
_ssdm_InlineSelf(0, "");
    AXIGetBitFields(axi.data, start, w, val);
}

template<int W, typename T>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, T val) {
_ssdm_InlineSelf(0, "");
    ((start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 77, __PRETTY_FUNCTION__));
    pix(start+w-1, start) = val;
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, float val) {
_ssdm_InlineSelf(0, "");
    ((w == 32 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 32 && start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 84, __PRETTY_FUNCTION__));
    fp_struct<float> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, double val) {
_ssdm_InlineSelf(0, "");
    ((w == 64 && start >= 0 && start+w <= W) ? static_cast<void> (0) : __assert_fail ("w == 64 && start >= 0 && start+w <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_axi_io.h", 92, __PRETTY_FUNCTION__));
    fp_struct<double> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W, typename T>
void AXISetBitFields(ap_axiu<W,1,1,1>& axi, int start, int w, T val) {
_ssdm_InlineSelf(0, "");
    AXISetBitFields(axi.data, start, w, val);
}

} // namespace hls



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 49 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2008-2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/


/**
 * @file hls_math.h
 * This file contains math.h related functions such as sin, cos, sqrt, ln, etc.
 */
# 45 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h"
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
# 45 "/usr/include/assert.h" 3 4
/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
# 66 "/usr/include/assert.h" 3 4
extern "C" {

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 100 "/usr/include/assert.h" 3 4
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_defines.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file x_hls_defines.h
 */






/*
*******************************************************************************
*
* Contains global defines, macos, and structs.
*
*******************************************************************************
*/
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_defines.h"
/*
* May be used to specify all intantiated ap_fixed to have different options.
* Currently unused.
*/
# 96 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_defines.h"
/*
* Macros
*/



/*
* Floating point data structure (with unsigned mantissa)
*/
template<int M, int E>
struct float_struct {
    ap_uint<M> mant; // 23
    ap_uint<E> exp; // 8
    ap_uint<1> sign;
};

/*
* Floating point data structure (with signed mantissa)
*/
template<int M, int E>
struct float_struct2 {
    ap_int<M> mant; // 24
    ap_uint<E> exp; // 8
};





// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 49 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_traits.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2008-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_traits.h" 2




namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
// 	typedef T1 ADD_T;
// 	typedef T1 SAT_T;
// 	typedef T1 MULT_T;
// 	typedef T1 MADD_T;
// 	typedef T1 CMADD_T;
// 	typedef T1 CONJ_SQ_T;
// 	typedef T1 CONJ_SQ_2_T;
// 	typedef int INT_T;
//     typedef T1 INV_T;
//     typedef float_struct<24,8> FLOAT_STRUCT_T;

};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,SC_RND,SC_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(((I1) > (W1-I1) ? (I1) : (W1-I1))+1),(((I1) > (W1-I1) ? (I1) : (W1-I1))+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,SC_RND,SC_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(((I1) > (W1-I1) ? (I1) : (W1-I1))+1),(((I1) > (W1-I1) ? (I1) : (W1-I1))+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<((W1) > (W2+1) ? (W1) : (W2+1)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2+1) ? (W1) : (W2+1)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<((W1+1) > (W2) ? (W1+1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1+1) > (W2) ? (W1+1) : (W2)) + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<((W1) > (W2) ? (W1) : (W2)) + 1> ADD_T;
 typedef ap_int<((W1) > (W2) ? (W1) : (W2)) + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};

// fixed_type<X>::T is the smallest ap_fixed/ap_ufixed type that can losslessly contain X
// e.g. X x;  fixed_type<X>::T y(x); is sensible;

    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T; // TODO placeholder
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T; // TODO placeholder
};

}




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_fpo.h" 1
/* -*- c -*-*/
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 *
 */








# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
# 45 "/usr/include/assert.h" 3 4
/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
# 66 "/usr/include/assert.h" 3 4
extern "C" {

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 100 "/usr/include/assert.h" 3 4
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# 60 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_fpo.h" 2
# 91 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_fpo.h"
//#define HLS_FPO_UNORDEREDF(a,b)
//#define HLS_FPO_UNORDERED(a,b)
# 105 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_fpo.h"
//#define HLS_FPO_CONDCODEF(a,b)
//#define HLS_FPO_CONDCODE(a,b)
# 661 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_fpo.h"
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 52 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

namespace hls
{

/**
 * The Xilinx math.h library implements standard math.h functions
 * optimized for FPGA implementation.
 *
 */



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_basic_math.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2008-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_basic_math.h
 * This file contains basic comparison-related functions.
 */
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_basic_math.h"
template <typename T>
int generic_signbit(T x) {
    fp_struct<T> s(x);
    return s.__signbit();
}
static int __signbit(float x)
{
    return generic_signbit(x);
}

static int __signbit(double x)
{
    return generic_signbit(x);
}

static int __signbit(half x)
{
    return generic_signbit(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type signbit(T x)
{
    return x < 0 ? 1 : 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type signbit(T x)
{
    return __signbit(x);
}

template <typename T>
T generic_nan(const char *tagp) {
    fp_struct<T> nan;
    nan.sig = -1; // all ones
    nan.exp = -1; // all ones
    nan.sign = 0;
    return nan.to_ieee();
}
static double nan(const char *tagp) {
    return generic_nan<double>(tagp);
}

static float nanf(const char *tagp) {
    return generic_nan<double>(tagp);
}

static half half_nan(const char *tagp) {
    return generic_nan<half>(tagp);
}


/**
 * Determines if given floating point number has a finite value.
 * i.e. normal, subnormal or zero, but not infinite or NAN
 *
 * @param x floating point vlaue.
 * @return nonzero value if arg has finite value, 0 otherwise.
 */
template <typename T>
int generic_isfinite(T x) {
    fp_struct<T> fs = x;
    int ret = (fs.exp == fp_struct<T>::EXP_INFNAN) ? 0 : 1;
    return ret;
}
static int __isfinite(float x)
{
    return generic_isfinite(x);
}

static int __isfinite(double x)
{
    return generic_isfinite(x);
}

static int __isfinite(half x)
{
    return generic_isfinite(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isfinite(T x)
{
    return 1;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isfinite(T x)
{
    return __isfinite(x);
}

/**
 * Determines if given floating point number is positive or negative infinity.
 *
 * @param x floating point vlaue.
 * @return nonzero value if arg is infinite, 0 otherwise.
 */
template <typename T>
int generic_isinf(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig == 0x0)) ? 1 : 0;
    return ret;
}
static int __isinf(float x)
{
    return generic_isinf(x);
}

static int __isinf(double x)
{
    return generic_isinf(x);
}

static int __isinf(half x)
{
    return generic_isinf(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isinf(T x)
{
    return 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isinf(T x)
{
    return __isinf(x);
}

/**
 * Determines if given floating point number is not-a-number (NaN)
 *
 * @param x floating point vlaue.
 * @return nonzero value if arg is not-a-number (NaN), 0 otherwise.
 */
template <typename T>
int generic_isnan(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig != 0x0)) ? 1 : 0;
    return ret;
}
static int __isnan(float x)
{
    return generic_isnan(x);
}

static int __isnan(double x)
{
    return generic_isnan(x);
}

static int __isnan(half x)
{
    return generic_isnan(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isnan(T x)
{
    return 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isnan(T x)
{
 return __isnan(x);
}

/**
 * Determines if given floating point number is normal
 * i.e. is neither zero, subnormal, infinite or NaN.
 *
 * @param x floating point vlaue.
 * @return nonzero value if arg is normal, 0 otherwise.
 */

template <typename T>
int generic_isnormal(T x) {
    fp_struct<T> fs = x;
    int ret = ((fs.exp != fp_struct<T>::EXP_INFNAN) && (fs.exp != 0x0)) ? 1 : 0;
    return ret;
}
static int __isnormal(float x)
{
    return generic_isnormal(x);
}

static int __isnormal(double x)
{
    return generic_isnormal(x);
}

static int __isnormal(half x)
{
    return generic_isnormal(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isnormal(T x)
{
    return x != 0 ? 1 : 0;
}

template <typename T>
typename enable_if<is_fptype<T>::value, int>::type isnormal(T x)
{
 return __isnormal(x);
}

/**
 * Categorizes floating point value into the following categories:
 * zero, subnormal, normal, infinite, NaN, or implementation-defined category.
 *
 * @param x floating point vlaue.
 * @return FP_INFINITE, FP_NAN, FP_NORMAL, FP_SUBNORMAL, FP_ZERO
 */
# 283 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_basic_math.h"
template <typename T>
int generic_fpclassify(T x) {
    fp_struct<T> fs = x;
    int ret;
    if(fs.exp == 0x0) {
        ret = (fs.sig == 0x0) ? FP_ZERO : FP_SUBNORMAL;
    } else if(fs.exp == fp_struct<T>::EXP_INFNAN) {
        ret = (fs.sig == 0x0) ? FP_INFINITE : FP_NAN;
    } else {
        ret = FP_NORMAL;
    }
    return ret;
}
static int __fpclassifyf(float x)
{
    return generic_fpclassify(x);
}

static int __fpclassify(double x)
{
    return generic_fpclassify(x);
}

static int __fpclassify(half x)
{
    return generic_fpclassify(x);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type fpclassify(T x)
{
    return x !=0 ? FP_NORMAL : FP_ZERO;
}

static int fpclassify(float x)
{
    return __fpclassifyf(x);
}

static int fpclassify(double x)
{
    return __fpclassify(x);
}

static int fpclassify(half x)
{
    return __fpclassify(x);
}

static
double copysign(double x, double y)
{
    fp_struct<double> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}

static
float copysignf(float x, float y)
{
    fp_struct<float> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}
static
half half_copysign(half x, half y)
{
    fp_struct<half> xs(x), ys(y);
    xs.sign = ys.sign;
    return xs.to_ieee();
}


static
float copysign(float x, float y)
{
    return copysignf(x, y);
}
static
half copysign(half x, half y)
{
    return ::hls::half_copysign(x, y);
}



template <typename T>
T generic_fabs(T x)
{
    return copysign(x, (T)0);
}

template <typename T>
T generic_fma(T x, T y, T z)
{
    return x*y+z;
}


// opencl relational function
template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isequal(T x, T y)
{
    return x == y;
}

static int isequal(double x, double y)
{
    return ((x) == (y));
}

static int isequal(float x, float y)
{
    return ((x) == (y));
}

static int isequal(half x, half y)
{
    return x == y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isgreater(T x, T y)
{
    return x > y;
}

static int isgreater(double x, double y)
{
    return ((x) > (y));
}

static int isgreater(float x, float y)
{
    return ((x) > (y));
}

static int isgreater(half x, half y)
{
    return x > y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isgreaterequal(T x, T y)
{
    return x >= y;
}

static int isgreaterequal(double x, double y)
{
    return ((x) >= (y));
}

static int isgreaterequal(float x, float y)
{
    return ((x) >= (y));
}

static int isgreaterequal(half x, half y)
{
    return x >= y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type isless(T x, T y)
{
    return x < y;
}

static int isless(double x, double y)
{
    return ((x) < (y));
}

static int isless(float x, float y)
{
    return ((x) < (y));
}

static int isless(half x, half y)
{
    return x < y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type islessequal(T x, T y)
{
    return x <= y;
}

static int islessequal(double x, double y)
{
    return ((x) <= (y));
}

static int islessequal(float x, float y)
{
    return ((x) <= (y));
}

static int islessequal(half x, half y)
{
    return x <= y;
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type islessgreater(T x, T y)
{
    return (x < y) || (x > y);
}

static int islessgreater(double x, double y)
{
    return ((x) < (y)) || ((x) > (y));
}

static int islessgreater(float x, float y)
{
    return ((x) < (y)) || ((x) > (y));
}

static int islessgreater(half x, half y)
{
    return (x < y) || (x > y);
}

// opencl relational function
template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isnotequal(T x, T y)
{
    return x != y;
}

static int isnotequal(double x, double y)
{
    return ((x) != (y));
}

static int isnotequal(float x, float y)
{
    return ((x) != (y));
}

static int isnotequal(half x, half y)
{
    return x != y;
}

// opencl relational function
template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isordered(T x, T y)
{
    return (((!__isnan(x))&&(!__isnan(y))) ? 1 : 0); // &&(in0==in0)&&(in1==in1));
}

template <typename T>
typename enable_if<is_arithmetic<T>::value, int>::type isunordered(T x, T y)
{
    return (( __isnan(x) || __isnan(y) ) ? 1 : 0);
}

/**
 * fmax returns the maximum of two arguments. 
 * If both arguments are 0/ -0, fmax always returns the 2nd argument
 * If both argumetns are nan, fmax always returns the 1st argument but casted
 * to be of type QNaN meaning bit 23 is a 1.
 * If only one argument is nan, fmax always returns the other argument.
 */
template <typename T>
T generic_fmax(T x, T y)
{
 fp_struct<T> x_fp(x);
 fp_struct<T> y_fp(y);
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
 T res;
 if(x_fp.exp == 0 && x_fp.sig == 0 && y_fp.exp == 0 && y_fp.sig == 0) { // 0, -0: always return 2nd arg
  res = y;
 } else if(__isnan(x)) { // 1st arg: nan
  if(__isnan(y)) { // 1st and 2nd arg: nan, cast to QNaN and choose 1st arg
   x_fp.sig[fp_struct<T>::SIG_BITS-1] = 1;
   res = x_fp.to_ieee();
  } else { // 1st arg: nan, 2nd: ~nan
   res = y;
  }
 } else if(__isnan(y)) { // 2nd arg: nan, 1st arg: ~nan
  res = x;
 } else {
  //res = (x > y) ? x : y;
        bool ymaggreater = x_fp.to_int() < y_fp.to_int();
        if(y_fp.sign && x_fp.sign) ymaggreater = !ymaggreater;
        res = ymaggreater ? y : x;
 }
 return res;
}

/**
 * fmax returns the maximum of two arguments.
 * If both arguments are 0/ -0, fmax always returns the 2nd argument
 * If both argumetns are nan, fmax always returns the 1st argument but casted
 * to be of type QNaN meaning bit 23 is a 1.
 * If only one argument is nan, fmax always returns the other argument.
 */
template<typename T>
T generic_fmin(T x, T y)
{
 fp_struct<T> x_fp(x);
 fp_struct<T> y_fp(y);
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
 T res;
 if(x_fp.exp == 0 && x_fp.sig == 0 && y_fp.exp == 0 && y_fp.sig == 0) { // 0, -0: always return 2nd arg
  res = y;
 } else if(__isnan(x)) { // 1st arg: nan
  if(__isnan(y)) { // 1st and 2nd arg: nan, cast to QNaN and choose 1st arg
   x_fp.sig[fp_struct<T>::SIG_BITS-1] = 1;
   res = x_fp.to_ieee();
  } else { // 1st arg: nan, 2nd: ~nan
   res = y;
  }
 } else if(__isnan(y)) { // 2nd arg: nan, 1st arg: ~nan
  res = x;
 } else {
  //res = (x < y) ? x : y;
        bool ymaggreater = x_fp.to_int() < y_fp.to_int();
        if(y_fp.sign && x_fp.sign) ymaggreater = !ymaggreater;
        res = ymaggreater ? x : y;
    }
 return res;
}

template<typename T>
T generic_fdim(T x, T y)
{
 T res = 0;
 if (__isnan(x)) res = x;
 else if (__isnan(y)) res = y;
 else if (x>y) res = x-y;
 return res;
}

template<typename T>
T generic_maxmag(T x, T y)
{
        if (generic_fabs(y)>generic_fabs(x)) return y;
        else return x;
}

template<typename T>
T generic_minmag(T x, T y)
{
        if (generic_fabs(y)<generic_fabs(x)) return y;
        else return x;
}


// opencl relational function
template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type any(typename enable_if<is_integraltype<T>::value, T>::type x)
{
    return (x < 0);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, int>::type all(typename enable_if<is_integraltype<T>::value, T>::type x)
{
    return (x < 0);
}

template <typename T>
typename enable_if<is_integraltype<T>::value, T>::type bitselect(T x, T y, T z)
{
    T r = (z & y) | (~z & x);
    return r;
}

template <typename T>
typename enable_if<is_fptype<T>::value, T>::type bitselect(T x, T y, T z)
{
    fp_struct<T> fp_x(x);
    fp_struct<T> fp_y(y);
    fp_struct<T> fp_z(z);
    ap_uint<Type_BitWidth<T>::Value> r;
    r = (fp_z.data() & fp_y.data()) | (~fp_z.data() & fp_x.data());
    fp_struct<T> fp_r(r);
    return fp_r.to_ieee();
}

// in opencl_1.x doc, type of z is i/ugentype
template <typename T>
typename enable_if<is_arithmetic<T>::value, T>::type select(T x, T y, bool z)
{
    T r = z ? y : x;
    return r;
}

template <typename T>
T generic_frexp (T x, int* exp) {
    // The maximum exponent possible for type T.
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
    fp_struct<T> xs = x;
    bool zero = (xs.exp == 0x0);
    bool nan = (xs.exp == max_exponent);
    *exp = (zero || nan) ? 0 : xs.expv()+1;
    if(zero) {
        // zero or subnormal
        return (T)0.0;
    } else if(nan) {
        // nan or infinity, return input.
        return x;
    } else {
        xs.exp = fp_struct<T>::EXP_BIAS-1;
        return xs.to_ieee();
    }
}

template <typename T>
T generic_ldexp (T x, int exp) {
    // The maximum exponent possible for type T.
    ap_uint<fp_struct<T>::EXP_BITS> max_exponent = -1;
    fp_struct<T> xs = x;
    exp += xs.exp;
    bool ininf = (xs.exp == max_exponent);
    bool zero = (xs.exp == 0) || (exp <= 0);
    bool inf = ininf || (exp >= max_exponent);
    if(__isnan(x)) {
        return x;
    } else if(zero && !ininf) {
        return ::hls::copysign((T)0.0,x);
    } else if(inf) {
        // infinity, return input.
        xs.sig = 0x0;
        xs.exp = max_exponent;
    } else {
        xs.exp = exp;
    }
    return xs.to_ieee();
}

template <typename T>
int generic_ilogb (T x) {
    fp_struct<T> xs(x);
    if ( xs.exp == 0 ) {
        if ( xs.sig == 0 ) return (-2147483647 - 1);
        else return (-2147483647 - 1);
//        unsigned int wf = fp_struct<T>::SIG_BITS;
//        unsigned int zeros;
//        #pragma unroll
//        for ( zeros = 0; zeros < wf; zeros++ )
//            if ( xs.sig[wf-zeros-1] ) break;
//        int ret = -127 - zeros;
//        return ret;
    }
    if ( xs.exp == fp_struct<T>::EXP_INFNAN ) {
        if ( xs.sig == 0 ) return 2147483647;
        else return (-2147483647 - 1);
    }
    return xs.expv();
}
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

static double fabs (double x) {
    return generic_fabs<double>(x);
}
static float fabs (float x) {
    return generic_fabs<float>(x);
}
static half fabs (half x) {
    return generic_fabs<half>(x);
}
static float fabsf (float x) {
    return generic_fabs<float>(x);
}
static half half_fabs (half x) {
    return generic_fabs<half>(x);
}

// defined in hls/utils/x_hls_utils.h
static double abs (double x) {
    return generic_fabs<double>(x);
}
static float abs (float x) {
    return generic_fabs<float>(x);
}
static half abs (half x) {
    return generic_fabs<half>(x);
}
static float absf (float x) {
    return generic_fabs<float>(x);
}
static half half_abs (half x) {
    return generic_fabs<half>(x);
}

static double fma (double x, double y, double z) {
    return generic_fma<double>(x,y,z);
}
static float fma (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half fma (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}
static float fmaf (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half half_fma (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}

static double mad (double x, double y, double z) {
    return generic_fma<double>(x,y,z);
}
static float mad (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half mad (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}
static float madf (float x, float y, float z) {
    return generic_fma<float>(x,y,z);
}
static half half_mad (half x, half y, half z) {
    return generic_fma<half>(x,y,z);
}

static double frexp (double x, int* exp) {
    return generic_frexp<double>(x, exp);
}
static float frexp (float x, int* exp) {
    return generic_frexp<float>(x, exp);
}
static half frexp (half x, int* exp) {
    return generic_frexp<half>(x, exp);
}
static float frexpf (float x, int* exp) {
    return generic_frexp<float>(x, exp);
}
static half half_frexp (half x, int* exp) {
    return generic_frexp<half>(x, exp);
}

static double ldexp (double x, int exp) {
    return generic_ldexp<double>(x, exp);
}
static float ldexp (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half ldexp (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}
static float ldexpf (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_ldexp (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}

static double scalbn (double x, int exp) {
    return generic_ldexp<double>(x, exp);
}
static float scalbn (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half scalbn (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}
static float scalbnf (float x, int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_scalbn (half x, int exp) {
    return generic_ldexp<half>(x, exp);
}

static double scalbln (double x, long int exp) {
    return generic_ldexp<double>(x, exp);
}
static float scalbln (float x, long int exp) {
    return generic_ldexp<float>(x, exp);
}
static half scalbln (half x, long int exp) {
    return generic_ldexp<half>(x, exp);
}
static float scalblnf (float x, long int exp) {
    return generic_ldexp<float>(x, exp);
}
static half half_scalbln (half x, long int exp) {
    return generic_ldexp<half>(x, exp);
}

static int ilogb (double x) {
    return generic_ilogb<double>(x);
}
static int ilogb (float x) {
    return generic_ilogb<float>(x);
}
static int ilogb (half x) {
    return generic_ilogb<half>(x);
}
static int ilogbf (float x) {
    return generic_ilogb<float>(x);
}
static int half_ilogb (half x) {
    return generic_ilogb<half>(x);
}

static double fmax(double x, double y) {
    return generic_fmax<double>(x,y);
}
static float fmax(float x, float y) {
    return generic_fmax(x,y);
}
static half fmax(half x, half y) {
    return generic_fmax<half>(x,y);
}
static float fmaxf(float x, float y) {
    return generic_fmax<float>(x,y);
}
static half half_fmax(half x, half y) {
    return generic_fmax<half>(x,y);
}

static double fmin(double x, double y) {
    return generic_fmin<double>(x,y);
}
static float fmin(float x, float y) {
    return generic_fmin(x,y);
}
static half fmin(half x, half y) {
    return generic_fmin<half>(x,y);
}
static float fminf(float x, float y) {
    return generic_fmin<float>(x,y);
}
static half half_fmin(half x, half y) {
    return generic_fmin<half>(x,y);
}

static double fdim(double x, double y) {
    return generic_fdim<double>(x,y);
}
static float fdim(float x, float y) {
    return generic_fdim(x,y);
}
static half fdim(half x, half y) {
    return generic_fdim<half>(x,y);
}
static float fdimf(float x, float y) {
    return generic_fdim<float>(x,y);
}
static half half_fdim(half x, half y) {
    return generic_fdim<half>(x,y);
}

static double maxmag(double x, double y) {
    return generic_maxmag<double>(x,y);
}
static float maxmag(float x, float y) {
    return generic_maxmag(x,y);
}
static half maxmag(half x, half y) {
    return generic_maxmag<half>(x,y);
}
static float maxmagf(float x, float y) {
    return generic_maxmag<float>(x,y);
}
static half half_maxmag(half x, half y) {
    return generic_maxmag<half>(x,y);
}

static double minmag(double x, double y) {
    return generic_minmag<double>(x,y);
}
static float minmag(float x, float y) {
    return generic_minmag(x,y);
}
static half minmag(half x, half y) {
    return generic_minmag<half>(x,y);
}
static float minmagf(float x, float y) {
    return generic_minmag<float>(x,y);
}
static half half_minmag(half x, half y) {
    return generic_minmag<half>(x,y);
}




# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_normalize.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_normalize.h
 */




/* @{ */

/**
 * This function returns the number of 'redundant sign bits' in a
 * signed number.  This is equivalent to the gcc __builtin_clrsb(),
 * but synthesizable.
 *
 * @param value The input
 */
template <int W, int I, ap_q_mode Q, ap_o_mode O>
unsigned int clrsb(ap_fixed<W,I,Q,O> value) {
    ap_uint<W> x = value(W-1,0);
    if(value[W-1]) {
        x = ~x;
    }
    x = x << 1 | 0x1;
    (((int)x.countLeadingZeros() <= W) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_normalize.h", 55, __PRETTY_FUNCTION__));
    (((int)x.countLeadingZeros() >= 0) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_normalize.h", 56, __PRETTY_FUNCTION__));
    return x.countLeadingZeros();
}

/**
 * This function returns the number of 'redundant sign bits' in a
 * signed number.  This is equivalent to the gcc __builtin_clrsb(),
 * but synthesizable.
 *
 * @param value The input
 */
template <int W>
unsigned int clrsb(ap_int<W> value) {
    ap_uint<W> x = value(W-1,0);
    if(value[W-1]) {
        x = ~x;
    }
    x = x << 1 | 0x1;
    (((int)x.countLeadingZeros() <= W) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() <= W", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_normalize.h", 74, __PRETTY_FUNCTION__));
    (((int)x.countLeadingZeros() >= 0) ? static_cast<void> (0) : __assert_fail ("(int)x.countLeadingZeros() >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_normalize.h", 75, __PRETTY_FUNCTION__));
    return x.countLeadingZeros();
}

/**
 * This function returns the number of 'redundant sign bits' in a
 * signed number.  This is equivalent to the gcc __builtin_clrsb(),
 * but synthesizable.
 *
 * @param value The input
 */
static
unsigned int clrsb(int value)
{
_ssdm_InlineSelf(0, "");
    return clrsb(ap_int<32>(value));
}

template<int Z, int W, int I>
unsigned int clz(ap_ufixed<W,I> x)
{
    ap_uint<Z+1> t;
    t(Z,1) = x(x.wl()-1,x.wl()-Z);
    t[0] = 1;

    return t.countLeadingZeros();
}

static
unsigned int clz(int value) {
    ap_int<32> x = value;
    return x.countLeadingZeros();
}

template <int W>
unsigned int clz(ap_int<W> value) {
    return value.countLeadingZeros();
}

template <int W>
unsigned int clz(ap_uint<W> value) {
    return value.countLeadingZeros();
}


/**
 * This function returns the number of 'redundant sign bits' in a
 * signed number.  This is equivalent to the gcc __builtin_clrsb(),
 * but synthesizable.  The result of left-shifting the input by the
 * result will be a Q31 format number in [-1,-0.5) or (0.5, 1).
 *
 * @param x The input
 */
static
unsigned int find_normalization(int x)
{
    return clrsb(x);
}

/**
 * This function returns the number of 'redundant sign bits' in a
 * signed number.  This is equivalent to the gcc __builtin_clrsb(),
 * but synthesizable.    The result of left-shifting the input by the
 * result will be a Q15 format number in [-1,-0.5) or (0.5, 1).
 *
 * @param x The input
 */
static
unsigned int find_normalization(short x)
{
    // Set the low order bits to the opposite of the sign bit to
    // ensure that the case of zero results in a shift of 15.
    int bits;
    if(x < 0) {
        bits = 0;
    } else {
        bits = 0xFFFF;
    }
    return clrsb(((int)x) << 16 | bits);
}




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 291 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_round.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2008-2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_round.h
 * This file contains rounding related functions such as round, trunc, floor, ceil.
 */

template <typename T>
void init_mask_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {_ssdm_SpecArrayDimSize(mask_table,fp_struct<T>::BITS);
    // Note that this is a little wierd since we are shifted by BIAS, so
    // mask_table[i] = mask(exp-BIAS+1);
    const typename fp_struct<T>::inttype t = (1LL << fp_struct<T>::SIG_BITS)-1;
    for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = t >> (i+1);
    }
    mask_table[fp_struct<T>::BITS-2] = t; // Special case for round()
    mask_table[fp_struct<T>::BITS-1] = t; // mask(fp_struct<double>::EXP_BIAS), stuffed into index N-1.
}

template <typename T>
void init_one_half_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {_ssdm_SpecArrayDimSize(mask_table,fp_struct<T>::BITS);
    // Note that this is a little wierd since we are shifted by BIAS, so
    // mask_table[i] = mask(exp-BIAS+1);
    const typename fp_struct<T>::inttype t = 1LL << (fp_struct<T>::SIG_BITS-1);
    for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = t >> (i+1);
    }
    mask_table[fp_struct<T>::BITS-2] = t << 1; // Special case for round()
    mask_table[fp_struct<T>::BITS-1] = t; // one_half(fp_struct<double>::EXP_BIAS), stuffed into index N-1.
}

template <typename T>
void init_one_half_minus_one_table(typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS]) {_ssdm_SpecArrayDimSize(mask_table,fp_struct<T>::BITS);
    // Note that this is a little wierd since we are shifted by BIAS, so
    // mask_table[i] = mask(exp-BIAS+1);
    const typename fp_struct<T>::inttype t = (1LL << (fp_struct<T>::SIG_BITS-1));
    for(unsigned int i = 0; i < fp_struct<T>::SIG_BITS-1; i++) {
        mask_table[i] = (t >> (i+1))-1;
    }
    for(unsigned int i = fp_struct<T>::SIG_BITS-1; i < fp_struct<T>::BITS-2; i++) {
        mask_table[i] = 0;
    }
    mask_table[fp_struct<T>::BITS-2] = (t << 1)-1; // Special case for round()
    mask_table[fp_struct<T>::BITS-1] = t-1; // one_half(fp_struct<double>::EXP_BIAS), stuffed into index N-1.
}

template <typename T>
T generic_floor(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);
    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        if(xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) { // negative and not zero
            return T(-1.0);
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else if((xs.exp > fp_struct<T>::EXP_BIAS + fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];

        // Deal with negative numbers
        if(xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double floor(double x)
{
    return generic_floor<double>(x);
}

static
float floorf(float x)
{
    return generic_floor<float>(x);
}

static
half half_floor(half x)
{
    return generic_floor<half>(x);
}


static
float floor(float x)
{
    return floorf(x);
}
static
half floor(half x)
{
    return generic_floor<half>(x);
}


template <typename T>
T generic_ceil(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        if(!xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) { // positive and not zero
            return T(1.0);
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else if(xs.exp > (fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value> index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];

        // Deal with positive numbers
        if(!xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double ceil(double x)
{
    return generic_ceil<double>(x);
}

static
float ceilf(float x)
{
    return generic_ceil<float>(x);
}

static
half half_ceil(half x)
{
    return generic_ceil<half>(x);
}

static
float ceil(float x)
{
    return ceilf(x);
}
static
half ceil(half x)
{
    return generic_ceil<half>(x);
}



template <typename T>
T generic_trunc(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp > fp_struct<T>::EXP_BIAS + fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double trunc(double x)
{
    return generic_trunc<double>(x);
}

static
float truncf(float x)
{
    return generic_trunc<float>(x);
}

static
half half_trunc(half x)
{
    return generic_trunc<half>(x);
}


static
float trunc(float x)
{
    return truncf(x);
}
static
half trunc(half x)
{
    return generic_trunc<half>(x);
}


// For round, we deal with three cases, the first is for small numbers <0.5, which get rounded to 0.0.
// The second case if for large numbers where nothing happens.  The third deals with the 'normal' case
// where we add one half and then drop the fractional bits.  There are two things to observe:
// 1) When we add one half, we sometimes roll over and increment the exponent, by one.  The exponent
// integer bits of the resulting number is correct, but the fractional bits aren't.  This is OK, since
// we drop the fractional bits.
// 2) The 'missing case' of [0.5, 1.0) is handled in the third case, where adding one
// to the exponent (making it zero) and then dropping all of the fractional bits, resulting in 1.0f.
// As a result there is an extra 'dummy' entry in the tables for round, that is not used for the other
// operators.
template <typename T>
T generic_round(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    typename fp_struct<T>::inttype one_half_table[fp_struct<T>::BITS];
    init_one_half_table<T>(one_half_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS - 1) {
        // Then we have a number less than 0.5
        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        typename fp_struct<T>::inttype one_half;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        one_half = one_half_table[index];

        xs = typename fp_struct<T>::data_type(xs.data() + one_half);

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double round(double x)
{
    return generic_round<double>(x);
}


static
float roundf(float x)
{
    return generic_round<float>(x);
}

static
half half_round(half x)
{
    return generic_round<half>(x);
}


static
float round(float x)
{
    return roundf(x);
}
static
half round(half x)
{
    return generic_round<half>(x);
}


// For round, we deal with three cases, the first is for small numbers <=0.5, which get rounded to 0.0.
// The second case if for large numbers where nothing happens.  The third deals with the 'normal' case
// where we add one half and then drop the fractional bits.  There are two things to observe:
// 1) When we add one half, we sometimes roll over and increment the exponent, by one.  The exponent
// integer bits of the resulting number is correct, but the fractional bits aren't.  This is OK, since
// we drop the fractional bits.
// 2) The 'missing case' of (0.5, 1.0) is handled in the third case, where adding one
// to the exponent (making it zero) and then dropping all of the fractional bits, resulting in 1.0f.
// As a result there is an extra 'dummy' entry in the tables for round, that is not used for the other
// operators.
// rint differs from round() in that we have to round ties to nearest even, rather than always
// rounding to +-infinity.  This is done by picking off the bit corresponding to the ones place and
// adding it in.
template <typename T>
T generic_rint(T x)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    typename fp_struct<T>::inttype one_half_minus_one_table[fp_struct<T>::BITS];
    init_one_half_minus_one_table<T>(one_half_minus_one_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS - 1 || (xs.exp == (fp_struct<T>::EXP_BIAS-1) && xs.sig == 0)) {
        // Then we have a number less than or equal to 0.5
        return ::hls::copysign((T)0.0, x);
    } else if((xs.exp >= fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        return x;
    } else {
        typename fp_struct<T>::inttype mask;
        typename fp_struct<T>::inttype one_half;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];
        one_half = one_half_minus_one_table[index];

        int index_table[fp_struct<T>::BITS];
        for(unsigned int i = 0; i < fp_struct<T>::BITS-2; i++) {
            index_table[i] = int(fp_struct<T>::SIG_BITS - 1 - i);
        }
        index_table[fp_struct<T>::BITS-2] = int(fp_struct<T>::SIG_BITS)-2;//(t << 1)-1; // Special case for round()
        // This index is actually the LSB of the exponent.  There are
        // only two numbers where this matters: one is 1.5, which has
        // an exponent equal to EXP_BIAS.  Since this is always odd,
        // we happen to pick the correct value which is the implicit 1
        // in the mantissa.
        index_table[fp_struct<T>::BITS-1] = int(fp_struct<T>::SIG_BITS);

        if(xs.data()[index_table[index]]) one_half += 1; // Only round up if the next higher bit is odd.
# 389 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_round.h"
 xs = typename fp_struct<T>::data_type(xs.data() + one_half);

        xs.sig = xs.sig & (~mask);
        return xs.to_ieee();
    }
}

static
double rint(double x)
{
    return generic_rint<double>(x);
}


static
float rintf(float x)
{
    return generic_rint<float>(x);
}

static
half half_rint(half x)
{
    return generic_rint<half>(x);
}

static
double nearbyint(double x)
{
    return generic_rint<double>(x);
}


static
float nearbyintf(float x)
{
    return generic_rint<float>(x);
}

static
half half_nearbyint(half x)
{
    return generic_rint<half>(x);
}

template <typename T, ap_q_mode ROUNDING, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false, typename enable_if<std::numeric_limits<T>::is_signed, bool>::type = true) {
    fp_struct<FP> xs(x);
    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> mantissa = xs.mantissa();

    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> smantissa = mantissa << xs.expv();

    ap_ufixed<1 , 8 * sizeof(T) , SC_TRN, SC_SAT> overflow_bits = smantissa;
    ap_ufixed<8 * sizeof(T)-1, 8 * sizeof(T)-1, ROUNDING> val = smantissa;

    bool overflow;
    if(fp_struct<FP>::SIG_BITS + 8 * sizeof(T) >= (fp_struct<FP>::EXP_INFNAN - fp_struct<FP>::EXP_BIAS)) {
        // Basically, this means that the exponent width of T will not result in a shift past the width of
        // smantissa.  The only way to overflow without overflow_bits being set is to have an infinity.
        // Basically for half precision
        overflow = (xs.exp == fp_struct<FP>::EXP_INFNAN) || (overflow_bits != 0);
    } else {
        // Basically, this means that the exponent width of T will result in a shift past the width of
        // smantissa.
        overflow = xs.expv() >= (signed)(fp_struct<FP>::SIG_BITS + 8 * sizeof(T)) || (overflow_bits != 0);
    }

    ap_int<8*sizeof(T)> minval = 0;
    minval[8*sizeof(T)-1] = 1;
    ap_int<8*sizeof(T)> maxval = -1;
    maxval[8*sizeof(T)-1] = 0;
    if(overflow && detect_overflow)
        return xs.__signbit() ? minval : maxval;
# 472 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_round.h"
 ap_fixed<8 * sizeof(T),8 * sizeof(T)> result = val;
    if(xs.__signbit()) result = -val;
    // std::cout << std::hex << "result = " << result.to_string(16) << std::dec << "\n";
    return result;
}

template <typename T, ap_q_mode ROUNDING, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false, typename enable_if<!std::numeric_limits<T>::is_signed, bool>::type = true) {
    fp_struct<FP> xs(x);
    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> mantissa = xs.mantissa();

    ap_ufixed<1+2*fp_struct<FP>::SIG_BITS + 8 * sizeof(T),
                  fp_struct<FP>::SIG_BITS + 8 * sizeof(T)> smantissa = mantissa << xs.expv();

    ap_ufixed<1 , 8 * sizeof(T)+1, SC_TRN, SC_SAT> overflow_bits = smantissa;
    ap_ufixed<8 * sizeof(T) , 8 * sizeof(T) , ROUNDING> val = smantissa;


    bool overflow;
    if(fp_struct<FP>::SIG_BITS + 8 * sizeof(T) >= (fp_struct<FP>::EXP_INFNAN - fp_struct<FP>::EXP_BIAS)) {
        // Basically, this means that the exponent width of T will not result in a shift past the width of
        // smantissa.  The only way to overflow without overflow_bits being set is to have an infinity.
        // Basically for half precision
        overflow = (xs.exp == fp_struct<FP>::EXP_INFNAN) || (overflow_bits != 0);
    } else {
        // Basically, this means that the exponent width of T will result in a shift past the width of
        // smantissa.
        overflow = xs.expv() >= (signed)(fp_struct<FP>::SIG_BITS + 8 * sizeof(T)) || (overflow_bits != 0);
    }

    ap_uint<8*sizeof(T)> minval = 0;
    ap_uint<8*sizeof(T)> maxval = -1;
    if((overflow || xs.__signbit()) && detect_overflow)
        return xs.__signbit() ? minval : maxval;
# 515 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_round.h"
 ap_fixed<8 * sizeof(T),8 * sizeof(T)> result = val;
    // std::cout << std::hex << "result = " << result.to_string(16) << std::dec << "\n";
    return result;
}


template <typename T, typename FP>
T cast_IEEE754(FP x, bool detect_overflow = false) {
    return cast_IEEE754<T, SC_TRN_ZERO>(x, detect_overflow);
}


// lrint* functions use the current rounding mode.
// Currently HLS provides no way to modify the rounding mode.
static
long int lrint(double x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_CONV>(x, true);
}

static
long long int llrint(double x) {
    return cast_IEEE754<long long int, SC_RND_CONV>(x, true);
}

static
long int lrintf(float x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_CONV>(x, true);
}

static
long long int llrintf(float x) {
    return cast_IEEE754<long long int, SC_RND_CONV>(x, true);
}

static
long int half_lrint(half x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_CONV>(x, true);
}

static
long long int half_llrint(half x) {
    return cast_IEEE754<long long int, SC_RND_CONV>(x, true);
}

static
long int lround(double x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_INF>(x, true);
}

static
long long int llround(double x) {
    return cast_IEEE754<long long int, SC_RND_INF>(x, true);
}

static
long int lroundf(float x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_INF>(x, true);
}

static
long long int llroundf(float x) {
    return cast_IEEE754<long long int, SC_RND_INF>(x, true);
}

static
long int half_lround(half x) {
    // Note: long int may be 32 or 64 bits.
    return cast_IEEE754<long int, SC_RND_INF>(x, true);
}

static
long long int half_llround(half x) {
    return cast_IEEE754<long long int, SC_RND_INF>(x, true);
}

template <typename T>
T generic_modf(T x, T *intpart)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    if(xs.exp < fp_struct<T>::EXP_BIAS) {
        *intpart = ::hls::copysign((T)0.0, x);
        return x;
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        *intpart = x;
        if(::hls::__isnan(x)) {
            fp_struct<T> nan;
            nan.sig = -1; // all ones
            nan.exp = -1; // all ones
            nan.sign = 0;
            return nan.to_ieee();
        } else {
            return ::hls::copysign((T)0.0, x);
        }
    } else {
        typename fp_struct<T>::inttype mask;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];

        // normalize the fractional part
        fp_struct<T> xf;
        xf.sig = xs.sig & mask;

        int zeros = xf.sig.countLeadingZeros();
        // If the significand is exactly zero, then we need to return a floating point zero
        // Otherwise compute the new exponent from the old one.
        xf.exp = (xf.sig == 0) ? 0 : (unsigned short)(xs.exp-zeros-1);
        // Normalize the significand, shifting off the zeros and the leading 1.
        xf.sig = (xf.sig << 1) << zeros;
        xf.sign = xs.sign;

        // mask the integer part
        xs.sig = xs.sig & (~mask);
        *intpart = xs.to_ieee();

        return xf.to_ieee();
    }
}

static
double modf(double x, double *intpart)
{
    return generic_modf<double>(x, intpart);
}

static
float modff(float x, float *intpart)
{
    return generic_modf<float>(x, intpart);
}

static
half half_modf(half x, half *intpart)
{
    return generic_modf<half>(x, intpart);
}


static
float modf(float x, float *intpart)
{
    return modff(x, intpart);
}
static
half modf(half x, half *intpart)
{
    return generic_modf<half>(x, intpart);
}


template <typename T>
T generic_fract(T x, T *intpart)
{
    typename fp_struct<T>::inttype mask_table[fp_struct<T>::BITS];
    init_mask_table<T>(mask_table);
    fp_struct<T> xs(x);

    // The number that is slightly less than 1. (e.g. for float: 0x1.fffffep-1f);
    fp_struct<T> special_case;
    special_case.sign = 0;
    special_case.exp = fp_struct<T>::EXP_BIAS-1;
    special_case.sig = -1;

    if(xs.exp < fp_struct<T>::EXP_BIAS) { // fp_struct<float>::EXP_BIAS is biased zero
        if(xs.__signbit() && !(xs.sig == 0 && xs.exp == 0)) { // negative and not zero
            *intpart = (T)-1.0f;
            T f = (T)1.0 + x;
            fp_struct<T> xf(f);
            bool is_one = (xf.exp == fp_struct<T>::EXP_BIAS) && xf.sig == 0;
            if(is_one) {
                return special_case.to_ieee();
            } else {
                return xf.to_ieee();
            }
        } else {
            *intpart = ::hls::copysign((T)0.0, x);
            return x;
        }
    } else if(xs.exp == fp_struct<T>::EXP_INFNAN) { // Infinity or nan
        *intpart = x;
 if (xs.sig == 0)
     return ::hls::copysign((T)0.0, x);
        return x;
    } else if((xs.exp > fp_struct<T>::EXP_BIAS+fp_struct<T>::SIG_BITS)) {
        // In this special case, we know there are no fractional bits.
        *intpart = x;
        return ::hls::copysign((T)0.0, x);
    } else {
        typename fp_struct<T>::inttype mask;
        // Find the mask.  These are 1's where there are fractional bits.
        // Note that the other bits should be zero, because of the special cases above.
        ap_uint<UnsignedBitWidth<fp_struct<T>::BITS>::Value > index = xs.exp(UnsignedBitWidth<fp_struct<T>::BITS>::Value-1,0);
        mask = mask_table[index];

        // normalize the fractional part
        fp_struct<T> xf;
        if(xs.__signbit())
            xf.sig = -xs.sig;
        else
            xf.sig = xs.sig;
        xf.sig = xf.sig & mask; // essentially 1.0f - xs.to_ieee()

        int zeros = xf.sig.countLeadingZeros();;
        // If the significand is exactly zero, then we need to return a floating point zero
        // Otherwise compute the new exponent from the old one.
        xf.exp = (xf.sig == 0) ? 0 : (unsigned short)(xs.exp-zeros-1);
        // Normalize the significand, shifting off the zeros and the leading 1.
        xf.sig = (xf.sig << 1) << zeros;
        xf.sign = 0;

        // Deal with negative numbers
        if(xs.__signbit()) {
            xs = typename fp_struct<T>::data_type(xs.data() + mask);
        }

        // mask the integer part
        xs.sig = xs.sig & (~mask);
        *intpart = xs.to_ieee();

        return xf.to_ieee();
    }
}
static
double fract(double x, double *intpart)
{
    return generic_fract<double>(x, intpart);
}

static
float fractf(float x, float *intpart)
{
    return generic_fract<float>(x, intpart);
}
static
half half_fract(half x, half *intpart)
{
    return generic_fract<half>(x, intpart);
}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 292 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_log.h
 *
 * Natural log implementation using range reduction + Taylor series
 * see: de Dinechin, "A flexible floating-point logarithm for reconfigurable computers"
 */
namespace log_reduce {



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_tables.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_tables.h" 2
namespace {

template <typename T, int p, int alpha, int size> class log_lut_table {};

// =============================================== iter1 tables for log() ==========================
// offset by ln513-ln512

// total length = 1 + 5 (we) + 35 (MaxPrecision) = 41 for half
template <> class log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",//ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//ln513-ln484
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",//ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//ln513-ln484
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",//A0
"0x0.01000015555888891AD1C98C9E9Bp0",//A1,ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//A2,ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//A3,ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//A4,ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//A5,ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//A6,ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//A7,ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//A8,ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//A9,ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//A10,ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//A11,ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//A12,ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//A13,ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//A14,ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//A15,ln513-ln484
};

// =============================================== iter2 tables for log() ==========================
// offset by ln16385-ln16384

// total length = 1 + 5 (we) + 36 (MaxPrecision) = 41 for half
template <> class log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// =============================================== iter3 tables for log() ==========================
// offset by ln(2^24+1)-ln(2^24)

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {
//A0-64,ln(262144.015625)-ln(262144.015625-i)
"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {
//A0-64,ln(262144.015625)-ln(262144.015625-i)
"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};

// =============================================== iter4 table for log() ==========================
// offset by ln(8388608.00048828125)-ln8388608

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>::array [64] = {
//A0-64,ln(8388608.00048828125)-ln(8388608.00048828125-i)
"0x0",
"0x0.000002000001FF8002A9AACEA8ABp0",
"0x0.000004000007FF00155155D54557p0",
"0x0.000006000011FE8047F701A3CA09p0",
"0x0.00000800001FFE00AA9AAF2A2ACAp0",
"0x0.00000A000031FD814D3C5FB85BACp0",
"0x0.00000C000047FD023FDC14FE50CFp0",
"0x0.00000E000061FC839279D10BFE61p0",
"0x0.00001000007FFC055515965158A0p0",
"0x0.0000120000A1FB8797AF679E53E2p0",
"0x0.0000140000C7FB0A6A474822E493p0",
"0x0.0000160000F1FA8DDCDD3B6EFF3Cp0",
"0x0.00001800011FFA11FF7145729881p0",
"0x0.00001A000151F996E2036A7DA52Ap0",
"0x0.00001C000187F91C9493AF401A22p0",
"0x0.00001E0001C1F8A3272218C9EC79p0",
"0x0.0000200001FFF82AA9AEAC8B116Dp0",
"0x0.000022000241F7B32C3970537E65p0",
"0x0.000024000287F73CBEC26A5328FAp0",
"0x0.0000260002D1F6C77149A11A06F8p0",
"0x0.00002800031FF65353CF1B980E61p0",
"0x0.00002A000371F5E07652E11D3570p0",
"0x0.00002C0003C7F56EE8D4F959729Ap0",
"0x0.00002E000421F4FEBB556C5CBC97p0",
"0x0.00003000047FF48FFDD442970A5Dp0",
"0x0.0000320004E1F422C05184D8532Ap0",
"0x0.000034000547F3B712CD3C508E82p0",
"0x0.0000360005B1F34D0547728FB434p0",
"0x0.00003800061FF2E4A7C03185BC5Fp0",
"0x0.00003A000691F27E0A3783829F71p0",
"0x0.00003C000707F2193CAD7336562Dp0",
"0x0.00003E000781F1B64F220BB0D9ADp0",
"0x0.0000400007FFF155519558622364p0",
"0x0.000042000881F0F65407651A2D24p0",
"0x0.000044000907F09966783E08F11Cp0",
"0x0.000046000991F03E98E7EFBE69E0p0",
"0x0.000048000A1FEFE5FB56872A926Bp0",
"0x0.00004A000AB1EF8F9DC4119D661Ep0",
"0x0.00004C000B47EF3B90309CC6E0CAp0",
"0x0.00004E000BE1EEE9E29C36B6FEAAp0",
"0x0.000050000C7FEE9AA506EDDDBC70p0",
"0x0.000052000D21EE4DE770D10B1740p0",
"0x0.000054000DC7EE03B9D9EF6F0CB6p0",
"0x0.000056000E71EDBC2C4258999AEAp0",
"0x0.000058000F1FED774EAA1C7AC072p0",
"0x0.00005A000FD1ED3531114B627C64p0",
"0x0.00005C001087ECF5E377F600CE5Cp0",
"0x0.00005E001141ECB975DE2D65B67Bp0",
"0x0.0000600011FFEC7FF8440301356Dp0",
"0x0.0000620012C1EC497AA988A34C6Ap0",
"0x0.000064001387EC160D0ED07BFD3Cp0",
"0x0.000066001451EBE5BF73ED1B4A3Dp0",
"0x0.00006800151FEBB8A1D8F1713660p0",
"0x0.00006A0015F1EB8EC43DF0CDC52Fp0",
"0x0.00006C0016C7EB6836A2FEE0FAD1p0",
"0x0.00006E0017A1EB4509082FBADC0Cp0",
"0x0.00007000187FEB254B6D97CB6E48p0",
"0x0.000072001961EB090DD34BE2B790p0",
"0x0.000074001A47EAF060396130BE9Bp0",
"0x0.000076001B31EADB529FED458AC7p0",
"0x0.000078001C1FEAC9F50706112422p0",
"0x0.00007A001D11EABC576EC1E3936Cp0",
"0x0.00007C001E07EAB289D7376CE216p0",
"0x0.00007E001F01EAAC9C407DBD1A4Bp0",
};

// =============================================== iter5 table for log() ==========================
// offset by ln(268435456.0000152587890625)-ln268435456

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>::array [64] = {
//A0-64,ln(268435456.0000152587890625)-ln(268435456.0000152587890625-i)
"0x0",
"0x0.000000100000007FFF0005554555p0",
"0x0.00000020000001FFFE002AAA6AAEp0",
"0x0.000000300000047FFD008FFF7014p0",
"0x0.00000040000007FFFC0155545595p0",
"0x0.0000005000000C7FFB029AA91B47p0",
"0x0.00000060000011FFFA047FFDC144p0",
"0x0.000000700000187FF907255247AEp0",
"0x0.0000008000001FFFF80AAAA6AEABp0",
"0x0.000000900000287FF70F2FFAF668p0",
"0x0.000000A0000031FFF614D54F1F19p0",
"0x0.000000B000003C7FF51BBAA328F7p0",
"0x0.000000C0000047FFF423FFF71440p0",
"0x0.000000D00000547FF32DC54AE13Ap0",
"0x0.000000E0000061FFF2392A9E902Fp0",
"0x0.000000F00000707FF1464FF22171p0",
"0x0.0000010000007FFFF05555459556p0",
"0x0.000001100000907FEF665A98EC3Bp0",
"0x0.000001200000A1FFEE797FEC2685p0",
"0x0.000001300000B47FED8EE53F449Ap0",
"0x0.000001400000C7FFECA6AA9246EBp0",
"0x0.000001500000DC7FEBC0EFE52DEDp0",
"0x0.000001600000F1FFEADDD537FA1Ap0",
"0x0.000001700001087FE9FD7A8AABF4p0",
"0x0.0000018000011FFFE91FFFDD4401p0",
"0x0.000001900001387FE845852FC2CEp0",
"0x0.000001A0000151FFE76E2A8228F0p0",
"0x0.000001B000016C7FE69A0FD476FDp0",
"0x0.000001C0000187FFE5C95526AD96p0",
"0x0.000001D00001A47FE4FC1A78CD60p0",
"0x0.000001E00001C1FFE4327FCAD705p0",
"0x0.000001F00001E07FE36CA51CCB37p0",
"0x0.000002000001FFFFE2AAAA6EAAACp0",
"0x0.000002100002207FE1ECAFC07621p0",
"0x0.00000220000241FFE132D5122E5Ap0",
"0x0.000002300002647FE07D3A63D420p0",
"0x0.00000240000287FFDFCBFFB56841p0",
"0x0.000002500002AC7FDF1F4506EB93p0",
"0x0.000002600002D1FFDE772A585EF0p0",
"0x0.000002700002F87FDDD3CFA9C339p0",
"0x0.0000028000031FFFDD3554FB1956p0",
"0x0.000002900003487FDC9BDA4C6234p0",
"0x0.000002A0000371FFDC077F9D9EC5p0",
"0x0.000002B000039C7FDB7864EED003p0",
"0x0.000002C00003C7FFDAEEAA3FF6ECp0",
"0x0.000002D00003F47FDA6A6F911485p0",
"0x0.000002E0000421FFD9EBD4E229DAp0",
"0x0.000002F00004507FD972FA3337FCp0",
"0x0.0000030000047FFFD8FFFF844001p0",
"0x0.000003100004B07FD89304D54307p0",
"0x0.000003200004E1FFD82C2A264230p0",
"0x0.000003300005147FD7CB8F773EA5p0",
"0x0.00000340000547FFD77154C83996p0",
"0x0.0000035000057C7FD71D9A193438p0",
"0x0.000003600005B1FFD6D07F6A2FC5p0",
"0x0.000003700005E87FD68A24BB2D7Ep0",
"0x0.0000038000061FFFD64AAA0C2EABp0",
"0x0.000003900006587FD6122F5D3499p0",
"0x0.000003A0000691FFD5E0D4AE409Ap0",
"0x0.000003B00006CC7FD5B6B9FF5408p0",
"0x0.000003C0000707FFD593FF507041p0",
"0x0.000003D00007447FD578C4A196AAp0",
"0x0.000003E0000781FFD56529F2C8AFp0",
"0x0.000003F00007C07FD5594F4407C1p0",
};

// =============================================== iter6 table for log() ==========================
// offset by ln(8589934592.000000476837158203125)-ln8589934592

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>::array [64] = {
//A0-64,ln(8589934592.000000476837158203125)-ln(8589934592.000000476837158203125-i)
"0x0",
"0x0.00000000800000001FFFFE000AAAp0",
"0x0.00000001000000007FFFFC005555p0",
"0x0.00000001800000011FFFFA011FFFp0",
"0x0.0000000200000001FFFFF802AAAAp0",
"0x0.00000002800000031FFFF6053555p0",
"0x0.00000003000000047FFFF408FFFFp0",
"0x0.00000003800000061FFFF20E4AAAp0",
"0x0.0000000400000007FFFFF0155555p0",
"0x0.000000048000000A1FFFEE1E5FFFp0",
"0x0.000000050000000C7FFFEC29AAAAp0",
"0x0.000000058000000F1FFFEA377554p0",
"0x0.0000000600000011FFFFE847FFFFp0",
"0x0.00000006800000151FFFE65B8AAAp0",
"0x0.00000007000000187FFFE4725554p0",
"0x0.000000078000001C1FFFE28C9FFFp0",
"0x0.000000080000001FFFFFE0AAAAA9p0",
"0x0.00000008800000241FFFDECCB554p0",
"0x0.00000009000000287FFFDCF2FFFEp0",
"0x0.000000098000002D1FFFDB1DCAA9p0",
"0x0.0000000A00000031FFFFD94D5553p0",
"0x0.0000000A800000371FFFD781DFFEp0",
"0x0.0000000B0000003C7FFFD5BBAAA8p0",
"0x0.0000000B800000421FFFD3FAF553p0",
"0x0.0000000C00000047FFFFD23FFFFDp0",
"0x0.0000000C8000004E1FFFD08B0AA8p0",
"0x0.0000000D000000547FFFCEDC5552p0",
"0x0.0000000D8000005B1FFFCD341FFDp0",
"0x0.0000000E00000061FFFFCB92AAA7p0",
"0x0.0000000E800000691FFFC9F83552p0",
"0x0.0000000F000000707FFFC864FFFCp0",
"0x0.0000000F800000781FFFC6D94AA7p0",
"0x0.000000100000007FFFFFC5555551p0",
"0x0.00000010800000881FFFC3D95FFCp0",
"0x0.00000011000000907FFFC265AAA6p0",
"0x0.00000011800000991FFFC0FA7550p0",
"0x0.00000012000000A1FFFFBF97FFFBp0",
"0x0.00000012800000AB1FFFBE3E8AA5p0",
"0x0.00000013000000B47FFFBCEE5550p0",
"0x0.00000013800000BE1FFFBBA79FFAp0",
"0x0.00000014000000C7FFFFBA6AAAA5p0",
"0x0.00000014800000D21FFFB937B54Fp0",
"0x0.00000015000000DC7FFFB80EFFF9p0",
"0x0.00000015800000E71FFFB6F0CAA4p0",
"0x0.00000016000000F1FFFFB5DD554Ep0",
"0x0.00000016800000FD1FFFB4D4DFF9p0",
"0x0.00000017000001087FFFB3D7AAA3p0",
"0x0.00000017800001141FFFB2E5F54Dp0",
"0x0.000000180000011FFFFFB1FFFFF8p0",
"0x0.000000188000012C1FFFB1260AA2p0",
"0x0.00000019000001387FFFB058554Dp0",
"0x0.00000019800001451FFFAF971FF7p0",
"0x0.0000001A00000151FFFFAEE2AAA1p0",
"0x0.0000001A8000015F1FFFAE3B354Cp0",
"0x0.0000001B0000016C7FFFADA0FFF6p0",
"0x0.0000001B8000017A1FFFAD144AA1p0",
"0x0.0000001C00000187FFFFAC95554Bp0",
"0x0.0000001C800001961FFFAC245FF5p0",
"0x0.0000001D000001A47FFFABC1AAA0p0",
"0x0.0000001D800001B31FFFAB6D754Ap0",
"0x0.0000001E000001C1FFFFAB27FFF5p0",
"0x0.0000001E800001D11FFFAAF18A9Fp0",
"0x0.0000001F000001E07FFFAACA5549p0",
"0x0.0000001F800001F01FFFAAB29FF4p0",
};

// =============================================== iter7 table for pow() ==========================
// offset by ln(274877906944.00000001490116119384765625)-ln274877906944

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>::array [64] = {
//A0-64,ln(274877906944.00000001490116119384765625)-ln(274877906944.00000001490116119384765625-i)
"0x0",
"0x0.00000000040000000007FFFFFC00p0",
"0x0.0000000008000000001FFFFFF800p0",
"0x0.000000000C0000000047FFFFF402p0",
"0x0.0000000010000000007FFFFFF005p0",
"0x0.000000001400000000C7FFFFEC0Ap0",
"0x0.0000000018000000011FFFFFE811p0",
"0x0.000000001C0000000187FFFFE41Cp0",
"0x0.000000002000000001FFFFFFE02Ap0",
"0x0.00000000240000000287FFFFDC3Cp0",
"0x0.0000000028000000031FFFFFD853p0",
"0x0.000000002C00000003C7FFFFD46Ep0",
"0x0.0000000030000000047FFFFFD08Fp0",
"0x0.00000000340000000547FFFFCCB7p0",
"0x0.0000000038000000061FFFFFC8E4p0",
"0x0.000000003C0000000707FFFFC519p0",
"0x0.000000004000000007FFFFFFC155p0",
"0x0.00000000440000000907FFFFBD99p0",
"0x0.00000000480000000A1FFFFFB9E5p0",
"0x0.000000004C0000000B47FFFFB63Bp0",
"0x0.00000000500000000C7FFFFFB29Ap0",
"0x0.00000000540000000DC7FFFFAF03p0",
"0x0.00000000580000000F1FFFFFAB77p0",
"0x0.000000005C0000001087FFFFA7F5p0",
"0x0.000000006000000011FFFFFFA47Fp0",
"0x0.00000000640000001387FFFFA116p0",
"0x0.0000000068000000151FFFFF9DB8p0",
"0x0.000000006C00000016C7FFFF9A68p0",
"0x0.0000000070000000187FFFFF9725p0",
"0x0.00000000740000001A47FFFF93F0p0",
"0x0.00000000780000001C1FFFFF90C9p0",
"0x0.000000007C0000001E07FFFF8DB2p0",
"0x0.00000000800000001FFFFFFF8AAAp0",
"0x0.00000000840000002207FFFF87B2p0",
"0x0.0000000088000000241FFFFF84CBp0",
"0x0.000000008C0000002647FFFF81F4p0",
"0x0.0000000090000000287FFFFF7F2Fp0",
"0x0.00000000940000002AC7FFFF7C7Dp0",
"0x0.00000000980000002D1FFFFF79DCp0",
"0x0.000000009C0000002F87FFFF774Fp0",
"0x0.00000000A000000031FFFFFF74D5p0",
"0x0.00000000A40000003487FFFF726Fp0",
"0x0.00000000A8000000371FFFFF701Dp0",
"0x0.00000000AC00000039C7FFFF6DE1p0",
"0x0.00000000B00000003C7FFFFF6BBAp0",
"0x0.00000000B40000003F47FFFF69A9p0",
"0x0.00000000B8000000421FFFFF67AFp0",
"0x0.00000000BC0000004507FFFF65CBp0",
"0x0.00000000C000000047FFFFFF63FFp0",
"0x0.00000000C40000004B07FFFF624Cp0",
"0x0.00000000C80000004E1FFFFF60B0p0",
"0x0.00000000CC0000005147FFFF5F2Ep0",
"0x0.00000000D0000000547FFFFF5DC5p0",
"0x0.00000000D400000057C7FFFF5C76p0",
"0x0.00000000D80000005B1FFFFF5B41p0",
"0x0.00000000DC0000005E87FFFF5A28p0",
"0x0.00000000E000000061FFFFFF592Ap0",
"0x0.00000000E40000006587FFFF5848p0",
"0x0.00000000E8000000691FFFFF5783p0",
"0x0.00000000EC0000006CC7FFFF56DAp0",
"0x0.00000000F0000000707FFFFF564Fp0",
"0x0.00000000F40000007447FFFF55E3p0",
"0x0.00000000F8000000781FFFFF5594p0",
"0x0.00000000FC0000007C07FFFF5565p0",
};

// =============================================== iter0 tables for log() ==========================

template <typename T, typename T2, int p, int alpha, int size> class log0_lut_table {};

// L0 = ln(1/[1/~Y0])
// [1/~Y0] = upper_int(32/~Y0)/32
// 1/[1/~Y0] = 32/upper_int(32/~Y0)
// ~Y0 = 1.0xxxxx or 0.11xxxxx
//
// 		||   1/[1/~Y0]	||	L0	
// =============||==============||==============
//    0/1/2	||	1	||   ln32-ln32	
// 	3/4	||    32/31	||   ln32-ln31	
// 	5/6	||    32/30	||   ln32-ln30	
//    7/8/9	||    32/29	||   ln32-ln29	
//    10/11	||    32/28	||   ln32-ln28	
//    12/13/14	||    32/27	||   ln32-ln27	
//    15/16/17	||    32/26	||   ln32-ln26	
//  18/19/20/21	||    32/25	||   ln32-ln25	
//  22/23/24/25	||    32/24	||   ln32-ln24	
//  26/27/28/29	||    32/23	||   ln32-ln23	
//    30/31	||    32/22	||   ln32-ln22	
// -------------||--------------||--------------
//    32/33	||    32/43	||   ln32-ln43	
//    34/35	||    32/42	||   ln32-ln42	
//    36/37/38	||    32/41	||   ln32-ln41	
//    39/40/41	||    32/40	||   ln32-ln40	
//    42/43	||    32/39	||   ln32-ln39	
//    44/45/46	||    32/38	||   ln32-ln38	
//    47/48/49	||    32/37	||   ln32-ln37	
//  50/51/52/53	||    32/36	||   ln32-ln36	
//    54/55/56	||    32/35	||   ln32-ln35	
//  57/58/59/60	||    32/34	||   ln32-ln34	
//    61/62/63	||    32/33	||   ln32-ln33	
// =============================================

// offset by ln513-ln512
// offset by ln16385-ln16384
// offset by ln(262144.015625)-ln262144
// offset by ln(8388608.00048828125)-ln8388608
// offset by ln(268435456.0000152587890625)-ln268435456
// offset by ln(8589934592.000000476837158203125)-ln8589934592
// offset by ln(274877906944.00000001490116119384765625)-ln274877906944

// total length = 1 + 5 (we) + 35 (MaxPrecision) = 41 for half
// offset by -ln513+ln512-ln16385+ln16384
template <> class log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64> { public:
log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>();
static const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<34, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>::array [64] = {
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"0x0.079CCEC24p0",
"0x0.079CCEC24p0",
"0x0.1001B8B2Fp0",
"0x0.1001B8B2Fp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.21AB3D01Ap0",
"0x0.21AB3D01Ap0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5F6808ECBp0",
"0x0.5F6808ECBp0",
"-0x0.4C276AEE2p0",
"-0x0.4C276AEE2p0",
"-0x0.462152B15p0",
"-0x0.462152B15p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.3328953C8p0",
"-0x0.3328953C8p0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
// offset by -ln513+ln512-ln16385+ln16384-ln(262144.015625)+ln262144
template <> class log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64> { public:
log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>();
static const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<58, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>::array [64] = {
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"0x0.079CCDC24CE109p0",
"0x0.079CCDC24CE109p0",
"0x0.1001B7B2F778EDp0",
"0x0.1001B7B2F778EDp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.21AB3C01A907DFp0",
"0x0.21AB3C01A907DFp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5F6807ECB99357p0",
"0x0.5F6807ECB99357p0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.462153B1555950p0",
"-0x0.462153B1555950p0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.3328963C8F6E81p0",
"-0x0.3328963C8F6E81p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
// offset by -ln513+ln512-ln16385+ln16384-ln(262144.015625)+ln262144-ln(8388608.00048828125)+ln8388608-ln(268435456.0000152587890625)+ln268435456-ln(8589934592.000000476837158203125)+ln8589934592-ln(274877906944.00000001490116119384765625)+ln274877906944
template <> class log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64> { public:
log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>();
static const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<102, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>::array [64] = {
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5F6807EC798353076AE126693CACp0",
"0x0.5F6807EC798353076AE126693CACp0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
};

// =============================================== log inverse tables for log() ==========================
// [1/~Y0] = upper_int(32/~Y0)/32
// ~Y0 = 1.0xxxxx or 0.11xxxxx
//
//              ||   [1/~Y0]  
// =============||==============
//    0/1/2     ||      1       
//      3/4     ||    31/32     
//      5/6     ||    30/32     
//    7/8/9     ||    29/32     
//    10/11     ||    28/32     
//    12/13/14  ||    27/32     
//    15/16/17  ||    26/32     
//  18/19/20/21 ||    25/32     
//  22/23/24/25 ||    24/32     
//  26/27/28/29 ||    23/32     
//    30/31     ||    22/32     
// -------------||--------------
//    32/33     ||    43/32     
//    34/35     ||    42/32     
//    36/37/38  ||    41/32     
//    39/40/41  ||    40/32     
//    42/43     ||    39/32     
//    44/45/46  ||    38/32     
//    47/48/49  ||    37/32     
//  50/51/52/53 ||    36/32     
//    54/55/56  ||    35/32     
//  57/58/59/60 ||    34/32     
//    61/62/63  ||    33/32     
// =============================
template <int p, int alpha, int size> class log_inverse_lut_table {};
template <> class log_inverse_lut_table<0,5,64> { public:
log_inverse_lut_table<0,5,64>();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> log_inverse_lut_table<0,5,64>::array [64] = {
"0x1",
"0x1",
"0x1",
"0x0.F8p0",
"0x0.F8p0",
"0x0.F0p0",
"0x0.F0p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E0p0",
"0x0.E0p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B0p0",
"0x0.B0p0",
"0x1.58p0",
"0x1.58p0",
"0x1.50p0",
"0x1.50p0",
"0x1.48p0",
"0x1.48p0",
"0x1.48p0",
"0x1.40p0",
"0x1.40p0",
"0x1.40p0",
"0x1.38p0",
"0x1.38p0",
"0x1.30p0",
"0x1.30p0",
"0x1.30p0",
"0x1.28p0",
"0x1.28p0",
"0x1.28p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.18p0",
"0x1.18p0",
"0x1.18p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.08p0",
"0x1.08p0",
"0x1.08p0",
};

}
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h" 2

template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{
    //#pragma HLS inline self off
    const int T1size = 1 << alpha; // The size of the first table


    //#pragma HLS RESOURCE variable=log_lut core=ROM_1P_LUTRAM

    ap_ufixed<alpha, -p> a = zN; // Extract alpha MSBs from z1.
    ap_ufixed<size-alpha, -p-alpha> b = zN; // Extract the LSBs from z1.
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN; // Extend z1 for shift
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1; // Stage dependent?
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}

//   i  0  1  2  3   4   5   6   7   8
// =====================================
//  pi  0  4  7  12  17  22  27  32  37
const int p0 = 0; // We start with zero zeroed bits
const int alpha0 = 5; // 1+alpha0 = number of bits considered by stage 0.
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2); // The number of bits zeroed in y1.
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template<typename T>
class log_traits {};

template <> class log_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = 15;
    const static int org_wf = fp_struct<half>::SIG_BITS; // 10

    const static int gbits = 0;
    const static int MaxPrecision = p3+wf+1+gbits; // 35
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE; // < 41, 6 >

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p3, -p3> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;
        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};
template <> class log_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = 31;
    const static int org_wf = fp_struct<float>::SIG_BITS; // 23

    const static int gbits = 0;
    const static int MaxPrecision = p4+wf+1+gbits; // 56
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE; // < 65, 9 >

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p4, -p4> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;
        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }

public :
inline __attribute__((always_inline)) log_traits<float>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&org_wf); _ssdm_SpecConstant(&gbits); _ssdm_SpecConstant(&MaxPrecision); _ssdm_SpecConstant(&w1); _ssdm_SpecConstant(&w2); _ssdm_SpecConstant(&w3); _ssdm_SpecConstant(&w4); }
# 145 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"
};

template <> class log_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = 52;
    const static int org_wf = fp_struct<double>::SIG_BITS; // 52

    const static int gbits = 0;
    const static int MaxPrecision = p8+wf+1+gbits; // 109
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we> LOG_TYPE; // < 121, 12>

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p8, -p8> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }

public :
inline __attribute__((always_inline)) log_traits<double>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&org_wf); _ssdm_SpecConstant(&gbits); _ssdm_SpecConstant(&MaxPrecision); _ssdm_SpecConstant(&w1); _ssdm_SpecConstant(&w2); _ssdm_SpecConstant(&w3); _ssdm_SpecConstant(&w4); _ssdm_SpecConstant(&w5); _ssdm_SpecConstant(&w6); _ssdm_SpecConstant(&w7); _ssdm_SpecConstant(&w8); }
# 194 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"
};

template<typename T>
T log_generic(T base)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> bs(base);
        const static int we = log_traits<T>::we;
_ssdm_SpecConstant(&we);
# 202 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"

        const static int wf = log_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 203 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"

        const static int org_wf = log_traits<T>::org_wf;
_ssdm_SpecConstant(&org_wf);
# 204 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();

// 	x	|    NaN / <0	|	+/-0	|	+inf	|	normal	
// =============================================================================
// 	log(x)	|	NaN	|	-inf	|	+inf	|		
// 
    bool x_is_0 = 0;
    bool x_is_NaN = 0;
    bool x_is_neg = 0; // not strongly correct, including -0 and -inf
    bool x_is_inf = 0;


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;
    if (bs.sign[0]==1) x_is_neg = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if ( x_is_0 ) {
        // out = -inf
        out.sign[0] = 1;
        //out.sig = 0;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( x_is_NaN | x_is_neg ) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( x_is_inf ) {
        // out = +inf
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }


        const static int bypass_threshold = wf/2;
_ssdm_SpecConstant(&bypass_threshold);
# 254 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"

        const static int MaxPrecision = log_traits<T>::MaxPrecision;
_ssdm_SpecConstant(&MaxPrecision);
# 255 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"

        typedef typename log_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;
 LOG_TYPE log_base;

    // storing exp and frac of base using int b_exp and ap_ufixed<1+wf+1,1> b_frac
    //int b_exp = bs.expv();
    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
# 281 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h"
 int FirstBit = nbs.sig[org_wf-1];

    // Y is prenormalized, between 0.75 and 1.5
    b_frac[b_frac.wl()-b_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));

    // the first two bits of b_frac can only be 01 or 10
    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }

    //const ap_ufixed<wf+we+2, 0> LOG2 = 0.69314718055994530941723212145818;
    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0); // The size of the first table




        //ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-1, b_frac.wl()-(1+alpha0));
 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];

        // The first bits of y1 are always a 1, followed by p1 zeros, but
        // it gets dropped later
        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;
        // p_next = p1;

        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_log_.h", 317, __PRETTY_FUNCTION__)); // Check that the first stage zeros out p1 bits.

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1; // Extract a1+b1 from y1.

    ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
        zk = log_traits<T>::range_reduction(z1,log_sum);

    ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);
    //sum = zk*2/(zk+2);

    log_base = Elog2 + log_sum + sum;




// let's output the result
 out.sign[0] = log_base[log_base.wl()-1];
 if (log_base[log_base.wl()-1]) {
     log_base = - log_base;
 }

 int r_exp = 0;
 int pone;
#pragma unroll
 for (pone = we-1; pone > -MaxPrecision+1; pone--) {
     if ( log_base[pone+MaxPrecision] == 1 ) {
  r_exp = pone;
  break;
     }
 }

 if ( r_exp != pone ) {
     // out = 0
     out.sign[0] = 0;
     //out.sig = 0;
     out.exp = 0;
     return out.to_ieee();
 }

        ap_fixed<1 + MaxPrecision+org_wf, 1> delta = 0;
        delta[delta.wl()-1] = log_base[log_base.wl()-1];
        delta[delta.wl()-2] = 1;
        ap_fixed<1 + we + MaxPrecision+org_wf, 1 + we> log_base_l = log_base + (delta >> (org_wf-r_exp));

 if ( log_base_l[r_exp+1+MaxPrecision+org_wf] == 1 ) {
     r_exp++;
 }

        out.exp = fp_struct<T>::EXP_BIAS+r_exp;
 out.sig(org_wf-1,0) = log_base_l ( r_exp+MaxPrecision+org_wf-1 , r_exp+MaxPrecision );
 return out.to_ieee();

}

static half log(half base)
{
 return log_generic(base);
}
static float log(float base)
{
 return log_generic(base);
}
static double log(double base)
{
 return log_generic(base);
}

static float logf(float base)
{
 return log_generic(base);
}

static half half_log(half base)
{
 return log_generic(base);
}


static half log2(half base)
{
        return log_generic(base) * static_cast<half>(1.4426950408889634073599246810019);
}
static float log2(float base)
{
        return ((log_generic(base)) * (1.4426950408889634073599246810019f));
}
static double log2(double base)
{
        return ((log_generic(base)) * (1.4426950408889634073599246810019));
}

static float log2f(float base)
{
        return ((log_generic(base)) * (1.4426950408889634073599246810019f));
}

static half half_log2(half base)
{
        return log_generic(base) * static_cast<half>(1.4426950408889634073599246810019);
}


static half log10(half base)
{
        return log_generic(base) * static_cast<half>(0.43429448190325182765112891891661);
}
static float log10(float base)
{
        return ((log_generic(base)) * (0.43429448190325182765112891891661f));
}
static double log10(double base)
{
        return ((log_generic(base)) * (0.43429448190325182765112891891661));
}

static float log10f(float base)
{
        return ((log_generic(base)) * (0.43429448190325182765112891891661f));
}

static half half_log10(half base)
{
        return log_generic(base) * static_cast<half>(0.43429448190325182765112891891661);
}


static half logb(half base)
{
        return log_generic(fabs(base)) * static_cast<half>(1.4426950408889634073599246810019);
}
static float logb(float base)
{
        return ((log_generic(fabs(base))) * (1.4426950408889634073599246810019f));
}
static double logb(double base)
{
        return ((log_generic(fabs(base))) * (1.4426950408889634073599246810019));
}

static float logbf(float base)
{
        return ((log_generic(fabs(base))) * (1.4426950408889634073599246810019f));
}

static half half_logb(half base)
{
        return log_generic(fabs(base)) * static_cast<half>(1.4426950408889634073599246810019);
}


static double log1p(double x)
{
        fp_struct<double> xs(x);
 if ( xs.exp == 0 ) return 0;
 if ( xs.sign[0] & ::hls::__isinf(x) ) {
  xs.sig = -1;
  return xs.to_ieee();
 }
 if ( xs.exp == 2047 ) return x;
 ap_uint<2> xexp_h;
 xexp_h(1,0) = xs.exp(10,9);
 if ( xexp_h == 0 ) return x;
 fp_struct<double> ys;
 ys.sign[0] = 0;
 ap_uint<12> yexp = xs.exp;
 yexp <<= 1;
 ap_uint<2> yexp_h;
 yexp_h(1,0) = yexp(11,10);
 yexp_h--;
 yexp(11,10) = yexp_h(1,0);
 ys.exp(10,0) = yexp(10,0);
 ap_ufixed<53,1> xsig;
 xsig[52] = 1;
 xsig(51,0) = xs.sig(51,0);
 ap_ufixed<106,2> ysig = xsig*xsig;
 if ( ysig[105] ) {
  ys.exp++;
  ysig >>= 1;
 }
 ys.sig(51,0) = ysig(103,52);
 if ( xs.exp <= 998 ) return x-ys.to_ieee();
 double xd1p = x + 1;
 return log_generic(xd1p)-((xd1p-1)-x)/xd1p;
}
static float log1p(float x)
{
 fp_struct<float> xs(x);
 if ( xs.exp == 0 ) return 0;
        if ( xs.sign[0] & ::hls::__isinf(x) ) {
                xs.sig = -1;
                return xs.to_ieee();
        }
 if ( xs.exp == 255 ) return x;
 float xf1p = x + 1;
 return log_generic(xf1p)-((xf1p-1)-x)/xf1p;
}
static half log1p(half x)
{
        fp_struct<half> xs(x);
        if ( xs.exp == 0 ) return 0;
 if ( xs.sign[0] == 1 && xs.exp == 15 && xs.sig == 0 ) {
  xs.exp = 31;
  return xs.to_ieee();
 }
        if ( xs.sign[0] & ::hls::__isinf(x) ) {
                xs.sig = -1;
                return xs.to_ieee();
        }
        if ( xs.exp == 31 ) return x;
 float xf1p = x + 1;
        return log_generic(xf1p)-((xf1p-1)-x)/xf1p;
}

}
# 293 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
//#include "hls/hls_log.h"


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_pow.h
 *
 * see: de Dinechin, "Floating-Point Exponentiation Units for Reconfigurable Computing"
 */
namespace pow_reduce {



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow_tables.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow_tables.h" 2
namespace {

template <typename T, int p, int alpha, int size> class log_lut_table {};

// =============================================== iter1 tables for pow() ==========================
// offset by ln513-ln512

// total length = 1 + 5 (we) + 35 (MaxPrecision) = 41 for half
template <> class log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",//ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//ln513-ln484
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",
"0x0.01000015555888891AD1C98C9E9Bp0",//ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//ln513-ln484
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>::array [16] = {
"0x0",//A0
"0x0.01000015555888891AD1C98C9E9Bp0",//A1,ln513-ln511
"0x0.0201012BEC32F8DAC34409DEFA0Cp0",//A2,ln513-ln509
"0x0.03030549D3B2A18BB8123EEF5D29p0",//A3,ln513-ln507
"0x0.04060E7B3F982465E5AE80179F4Ap0",//A4,ln513-ln505
"0x0.050A1ED2A137CD8B76C303145D04p0",//A5,ln513-ln503
"0x0.060F3868C0EF391853C966BD7471p0",//A6,ln513-ln501
"0x0.07155D5CD81D53619307B8308EB9p0",//A7,ln513-ln499
"0x0.0798D4C5ABD6FFFD026D938E80B4p0",//A8,ln513-ln498
"0x0.08A08ECF9A4E65D1EE3C74FFAA7Fp0",//A9,ln513-ln496
"0x0.09A959A26D3862E752AF15528C0Fp0",//A10,ln513-ln494
"0x0.0AB33774BD9E386027BF3B81173Fp0",//A11,ln513-ln492
"0x0.0BBE2A841109EFBA651B04210A41p0",//A12,ln513-ln490
"0x0.0CCA3514F685E5346E87B075E077p0",//A13,ln513-ln488
"0x0.0DD759732434C1A6FD3C142C43A9p0",//A14,ln513-ln486
"0x0.0EE599F19585A95D50A830135E93p0",//A15,ln513-ln484
};

// =============================================== iter2 tables for pow() ==========================
// offset by ln16385-ln16384

// total length = 1 + 5 (we) + 36 (MaxPrecision) = 41 for half
template <> class log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>::array [64] = {
//A0-64,ln(16385)-ln(16385-i*2)
"0x0",
"0x0.00080000002AAAAAAC444444568Dp0",
"0x0.001000400255695618901E2C05A4p0",
"0x0.001800C00A809C09C56F97B3C271p0",
"0x0.002001801CAD02DF35DB04005A1Fp0",
"0x0.002802803CDBBE0DF2F7C6412B45p0",
"0x0.003003C06F0E4DF791B9F9D5213Cp0",
"0x0.00380540B7469333BA6755ED5901p0",
"0x0.004007011986CE9C31FBA6FC586Ep0",
"0x0.0048090199D1A158E56F385486F9p0",
"0x0.00500B423C2A0CEBF6DF886C6226p0",
"0x0.00580DC30493733DCC9AA252B7FEp0",
"0x0.00601083F71196A9220D76F10705p0",
"0x0.0068138517A89A071A9590CDFD16p0",
"0x0.007016C66A5D00BB56367D15ED95p0",
"0x0.00781A47F333AEC0083344C2FB6Fp0",
"0x0.00801E09B631E8B20F8C50D29C47p0",
"0x0.0088220BB75D53DD1162148A0824p0",
"0x0.0090264DFABBF647953CD8DF1BF1p0",
"0x0.00982AD0845436BF233A042F2D08p0",
"0x0.00A02F93582CDCE4641F398148E4p0",
"0x0.00A834967A4D11374353AAA55E38p0",
"0x0.00B039D9EEBC5D2312BFF895D363p0",
"0x0.00B83F5DB982AB0AB094FD951A6Ap0",
"0x0.00C04521DEA84654AEF9DC94E38Bp0",
"0x0.00C84B266235DB777DA1B188A58Dp0",
"0x0.00D0516B4834780595493E594E09p0",
"0x0.00D857F094AD8AB9A51CF0440BFBp0",
"0x0.00E05EB64BAAE382C20799824C39p0",
"0x0.00E865BC7136B39097EA3B2D2973p0",
"0x0.00F06D03095B8D5F9CBD3B62C0DFp0",
"0x0.00F8748A182464C5459B63C810E2p0",
"0x0.01007C51A19C8EFC3DB704964091p0",
"0x0.01088459A9CFC2B09F3998766D52p0",
"0x0.01108CA234CA180C2E0E45835F83p0",
"0x0.0118952B469808C2949797DCCFB1p0",
"0x0.01209DF4E346701DA250D24C33B5p0",
"0x0.0128A6FF0EE28B098C5B318F5DD1p0",
"0x0.0130B049CD79F8212FF77EF19006p0",
"0x0.0138B9D5231AB7BA56EC4EF002C1p0",
"0x0.0140C3A113D32BF1FDD948BB4048p0",
"0x0.0148CDADA3B218B89C77D37B1D99p0",
"0x0.0150D7FAD6C6A3DE6FC9864F85D9p0",
"0x0.0158E288B120551FC634B81CBF00p0",
"0x0.0160ED5736CF16314D8F8C46452Dp0",
"0x0.0168F8666BE332CC6319D98FD5D4p0",
"0x0.017103B6546D58BB65664870C50Ep0",
"0x0.01790F46F47E97E60833063A3D60p0",
"0x0.01811B185028625DAA326A8595B7p0",
"0x0.0189272A6B7C8C69ACC3EC7479BCp0",
"0x0.0191337D4A8D4C93CD9DC561365Bp0",
"0x0.01994010F16D3BB482679EB21716p0",
"0x0.01A14CE5642F54FF5646A89760DEp0",
"0x0.01A959FAA6E6F60F495B77901C41p0",
"0x0.01B16750BDA7DEF3323206A68B38p0",
"0x0.01B974E7AC86323A21243C69D661p0",
"0x0.01C182BF779674FFC5AF50BF325Ep0",
"0x0.01C990D822ED8EF8D5BC71B977FDp0",
"0x0.01D19F31B2A0CA7F76DD05BAE904p0",
"0x0.01D9ADCC2AC5D49FA97AE939A011p0",
"0x0.01E1BCA78F72BD23B5FD0693F386p0",
"0x0.01E9CBC3E4BDF6A09BE0A676E288p0",
"0x0.01F1DB212EBE568282C7D76D771Ep0",
"0x0.01F9EABF718B15192D7D4B44E20Ep0",
};

// =============================================== iter3 tables for pow() ==========================
// offset by ln(2^24+1)-ln(2^24)

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
template <> class log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {
//A0-64,ln(262144.015625)-ln(262144.015625-i)
"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>::array [64] = {
//A0-64,ln(262144.015625)-ln(262144.015625-i)
"0x0",
"0x0.0000400007C0014595916D212A04p0",
"0x0.000080001F800A6B2E8B0BB48467p0",
"0x0.0000C00047402370D3D4E31644A3p0",
"0x0.000100007F0054569457068AB036p0",
"0x0.00014000C6C0A51C84F99B3E2F48p0",
"0x0.000180011E811DC2C0A4DE4566C5p0",
"0x0.0001C0018641C64968412A9D5A08p0",
"0x0.00020001FE02A6B0A2B6FF2B93F7p0",
"0x0.0002400285C3C6F89CEF04BE57ACp0",
"0x0.000280031D852F2189D2140CD892p0",
"0x0.0002C003C546E72BA2493BB77A0Dp0",
"0x0.000300047D08F717253DC648169Cp0",
"0x0.0003400544CB66E4579940324E7Fp0",
"0x0.000380061C8E3E9384457DD3DDDAp0",
"0x0.0003C00704518624FC2CA174FA5Cp0",
"0x0.00040007FC15459916392148B864p0",
"0x0.0004400903D984F02F55CD6D77A8p0",
"0x0.0004800A1B9E4C2AAA6DD5ED575Cp0",
"0x0.0004C00B4363A348F06CD0BEB1DCp0",
"0x0.0005000C7B29924B703EBFC49FCFp0",
"0x0.0005400DC2F021329ED016CF82D9p0",
"0x0.0005800F1AB757FEF70DC19D97BFp0",
"0x0.0005C010827F3EB0F9E529DB9013p0",
"0x0.00060011FA47DD492E443D253362p0",
"0x0.0006401382113BC82119730607E1p0",
"0x0.0006801519DB622E6553D2FA029Bp0",
"0x0.0006C016C1A6587C93E2FA6E3F1Dp0",
"0x0.00070018797226B34BB722C1BEACp0",
"0x0.0007401A413ED4D331C127462EF1p0",
"0x0.0007801C190C6ADCF0F28B40B830p0",
"0x0.0007C01E00DAF0D13A3D7FEAD2F8p0",
"0x0.0008001FF8AA6EB0C494EA73255Ap0",
"0x0.00084022007AEC7C4CEC69FE67A2p0",
"0x0.00088024184C723496385DA85089p0",
"0x0.0008C026401F07DA696DEA8488F3p0",
"0x0.0009002877F2B56E9583019FA728p0",
"0x0.0009402ABFC782F1EF6E66003190p0",
"0x0.0009802D179D78655227B2A7A8EFp0",
"0x0.0009C02F7F749DC99EA760939A2Ap0",
"0x0.000A0031F74CFB1FBBE6CCBEB780p0",
"0x0.000A40347F26986896E03E21F954p0",
"0x0.000A803717017DA5228EEBB5C66Cp0",
"0x0.000AC039BEDDB2D657EF027323B8p0",
"0x0.000B003C76BB3FFD35FDAB54EB9Dp0",
"0x0.000B403F3E9A2D1AC1B911590CBAp0",
"0x0.000B8042167A823006206781D039p0",
"0x0.000BC044FE5C473E1433EED72797p0",
"0x0.000C0047F63F844602F4FC6801F7p0",
"0x0.000C404AFE244148EF65FF4BA8F1p0",
"0x0.000C804E160A8647FC8A86A324E9p0",
"0x0.000CC0513DF25B445367479AA8E3p0",
"0x0.000D005475DBC83F2302236B05D9p0",
"0x0.000D4057BDC6D539A0622D5B2596p0",
"0x0.000D805B15B38A35068FB0C18D15p0",
"0x0.000DC05E7DA1EF3296943705E65Dp0",
"0x0.000E0061F5920C33977A8DA291E1p0",
"0x0.000E40657D83E939564ECC263F67p0",
"0x0.000E806915778E45261E5A358E67p0",
"0x0.000EC06CBD6D03585FF7F58CB5FDp0",
"0x0.000F00707564507462EBB801344Ap0",
"0x0.000F40743D5D7D9A940B1D838568p0",
"0x0.000F8078155892CC5E690A20E1D3p0",
"0x0.000FC07BFD55980B3319D0050465p0",
};

// =============================================== iter4 table for pow() ==========================
// offset by ln(8388608.00048828125)-ln8388608

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>::array [64] = {
//A0-64,ln(8388608.00048828125)-ln(8388608.00048828125-i)
"0x0",
"0x0.000002000001FF8002A9AACEA8ABp0",
"0x0.000004000007FF00155155D54557p0",
"0x0.000006000011FE8047F701A3CA09p0",
"0x0.00000800001FFE00AA9AAF2A2ACAp0",
"0x0.00000A000031FD814D3C5FB85BACp0",
"0x0.00000C000047FD023FDC14FE50CFp0",
"0x0.00000E000061FC839279D10BFE61p0",
"0x0.00001000007FFC055515965158A0p0",
"0x0.0000120000A1FB8797AF679E53E2p0",
"0x0.0000140000C7FB0A6A474822E493p0",
"0x0.0000160000F1FA8DDCDD3B6EFF3Cp0",
"0x0.00001800011FFA11FF7145729881p0",
"0x0.00001A000151F996E2036A7DA52Ap0",
"0x0.00001C000187F91C9493AF401A22p0",
"0x0.00001E0001C1F8A3272218C9EC79p0",
"0x0.0000200001FFF82AA9AEAC8B116Dp0",
"0x0.000022000241F7B32C3970537E65p0",
"0x0.000024000287F73CBEC26A5328FAp0",
"0x0.0000260002D1F6C77149A11A06F8p0",
"0x0.00002800031FF65353CF1B980E61p0",
"0x0.00002A000371F5E07652E11D3570p0",
"0x0.00002C0003C7F56EE8D4F959729Ap0",
"0x0.00002E000421F4FEBB556C5CBC97p0",
"0x0.00003000047FF48FFDD442970A5Dp0",
"0x0.0000320004E1F422C05184D8532Ap0",
"0x0.000034000547F3B712CD3C508E82p0",
"0x0.0000360005B1F34D0547728FB434p0",
"0x0.00003800061FF2E4A7C03185BC5Fp0",
"0x0.00003A000691F27E0A3783829F71p0",
"0x0.00003C000707F2193CAD7336562Dp0",
"0x0.00003E000781F1B64F220BB0D9ADp0",
"0x0.0000400007FFF155519558622364p0",
"0x0.000042000881F0F65407651A2D24p0",
"0x0.000044000907F09966783E08F11Cp0",
"0x0.000046000991F03E98E7EFBE69E0p0",
"0x0.000048000A1FEFE5FB56872A926Bp0",
"0x0.00004A000AB1EF8F9DC4119D661Ep0",
"0x0.00004C000B47EF3B90309CC6E0CAp0",
"0x0.00004E000BE1EEE9E29C36B6FEAAp0",
"0x0.000050000C7FEE9AA506EDDDBC70p0",
"0x0.000052000D21EE4DE770D10B1740p0",
"0x0.000054000DC7EE03B9D9EF6F0CB6p0",
"0x0.000056000E71EDBC2C4258999AEAp0",
"0x0.000058000F1FED774EAA1C7AC072p0",
"0x0.00005A000FD1ED3531114B627C64p0",
"0x0.00005C001087ECF5E377F600CE5Cp0",
"0x0.00005E001141ECB975DE2D65B67Bp0",
"0x0.0000600011FFEC7FF8440301356Dp0",
"0x0.0000620012C1EC497AA988A34C6Ap0",
"0x0.000064001387EC160D0ED07BFD3Cp0",
"0x0.000066001451EBE5BF73ED1B4A3Dp0",
"0x0.00006800151FEBB8A1D8F1713660p0",
"0x0.00006A0015F1EB8EC43DF0CDC52Fp0",
"0x0.00006C0016C7EB6836A2FEE0FAD1p0",
"0x0.00006E0017A1EB4509082FBADC0Cp0",
"0x0.00007000187FEB254B6D97CB6E48p0",
"0x0.000072001961EB090DD34BE2B790p0",
"0x0.000074001A47EAF060396130BE9Bp0",
"0x0.000076001B31EADB529FED458AC7p0",
"0x0.000078001C1FEAC9F50706112422p0",
"0x0.00007A001D11EABC576EC1E3936Cp0",
"0x0.00007C001E07EAB289D7376CE216p0",
"0x0.00007E001F01EAAC9C407DBD1A4Bp0",
};

// =============================================== iter5 table for pow() ==========================
// offset by ln(268435456.0000152587890625)-ln268435456

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>::array [64] = {
//A0-64,ln(268435456.0000152587890625)-ln(268435456.0000152587890625-i)
"0x0",
"0x0.000000100000007FFF0005554555p0",
"0x0.00000020000001FFFE002AAA6AAEp0",
"0x0.000000300000047FFD008FFF7014p0",
"0x0.00000040000007FFFC0155545595p0",
"0x0.0000005000000C7FFB029AA91B47p0",
"0x0.00000060000011FFFA047FFDC144p0",
"0x0.000000700000187FF907255247AEp0",
"0x0.0000008000001FFFF80AAAA6AEABp0",
"0x0.000000900000287FF70F2FFAF668p0",
"0x0.000000A0000031FFF614D54F1F19p0",
"0x0.000000B000003C7FF51BBAA328F7p0",
"0x0.000000C0000047FFF423FFF71440p0",
"0x0.000000D00000547FF32DC54AE13Ap0",
"0x0.000000E0000061FFF2392A9E902Fp0",
"0x0.000000F00000707FF1464FF22171p0",
"0x0.0000010000007FFFF05555459556p0",
"0x0.000001100000907FEF665A98EC3Bp0",
"0x0.000001200000A1FFEE797FEC2685p0",
"0x0.000001300000B47FED8EE53F449Ap0",
"0x0.000001400000C7FFECA6AA9246EBp0",
"0x0.000001500000DC7FEBC0EFE52DEDp0",
"0x0.000001600000F1FFEADDD537FA1Ap0",
"0x0.000001700001087FE9FD7A8AABF4p0",
"0x0.0000018000011FFFE91FFFDD4401p0",
"0x0.000001900001387FE845852FC2CEp0",
"0x0.000001A0000151FFE76E2A8228F0p0",
"0x0.000001B000016C7FE69A0FD476FDp0",
"0x0.000001C0000187FFE5C95526AD96p0",
"0x0.000001D00001A47FE4FC1A78CD60p0",
"0x0.000001E00001C1FFE4327FCAD705p0",
"0x0.000001F00001E07FE36CA51CCB37p0",
"0x0.000002000001FFFFE2AAAA6EAAACp0",
"0x0.000002100002207FE1ECAFC07621p0",
"0x0.00000220000241FFE132D5122E5Ap0",
"0x0.000002300002647FE07D3A63D420p0",
"0x0.00000240000287FFDFCBFFB56841p0",
"0x0.000002500002AC7FDF1F4506EB93p0",
"0x0.000002600002D1FFDE772A585EF0p0",
"0x0.000002700002F87FDDD3CFA9C339p0",
"0x0.0000028000031FFFDD3554FB1956p0",
"0x0.000002900003487FDC9BDA4C6234p0",
"0x0.000002A0000371FFDC077F9D9EC5p0",
"0x0.000002B000039C7FDB7864EED003p0",
"0x0.000002C00003C7FFDAEEAA3FF6ECp0",
"0x0.000002D00003F47FDA6A6F911485p0",
"0x0.000002E0000421FFD9EBD4E229DAp0",
"0x0.000002F00004507FD972FA3337FCp0",
"0x0.0000030000047FFFD8FFFF844001p0",
"0x0.000003100004B07FD89304D54307p0",
"0x0.000003200004E1FFD82C2A264230p0",
"0x0.000003300005147FD7CB8F773EA5p0",
"0x0.00000340000547FFD77154C83996p0",
"0x0.0000035000057C7FD71D9A193438p0",
"0x0.000003600005B1FFD6D07F6A2FC5p0",
"0x0.000003700005E87FD68A24BB2D7Ep0",
"0x0.0000038000061FFFD64AAA0C2EABp0",
"0x0.000003900006587FD6122F5D3499p0",
"0x0.000003A0000691FFD5E0D4AE409Ap0",
"0x0.000003B00006CC7FD5B6B9FF5408p0",
"0x0.000003C0000707FFD593FF507041p0",
"0x0.000003D00007447FD578C4A196AAp0",
"0x0.000003E0000781FFD56529F2C8AFp0",
"0x0.000003F00007C07FD5594F4407C1p0",
};

// =============================================== iter6 table for pow() ==========================
// offset by ln(8589934592.000000476837158203125)-ln8589934592

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>::array [64] = {
//A0-64,ln(8589934592.000000476837158203125)-ln(8589934592.000000476837158203125-i)
"0x0",
"0x0.00000000800000001FFFFE000AAAp0",
"0x0.00000001000000007FFFFC005555p0",
"0x0.00000001800000011FFFFA011FFFp0",
"0x0.0000000200000001FFFFF802AAAAp0",
"0x0.00000002800000031FFFF6053555p0",
"0x0.00000003000000047FFFF408FFFFp0",
"0x0.00000003800000061FFFF20E4AAAp0",
"0x0.0000000400000007FFFFF0155555p0",
"0x0.000000048000000A1FFFEE1E5FFFp0",
"0x0.000000050000000C7FFFEC29AAAAp0",
"0x0.000000058000000F1FFFEA377554p0",
"0x0.0000000600000011FFFFE847FFFFp0",
"0x0.00000006800000151FFFE65B8AAAp0",
"0x0.00000007000000187FFFE4725554p0",
"0x0.000000078000001C1FFFE28C9FFFp0",
"0x0.000000080000001FFFFFE0AAAAA9p0",
"0x0.00000008800000241FFFDECCB554p0",
"0x0.00000009000000287FFFDCF2FFFEp0",
"0x0.000000098000002D1FFFDB1DCAA9p0",
"0x0.0000000A00000031FFFFD94D5553p0",
"0x0.0000000A800000371FFFD781DFFEp0",
"0x0.0000000B0000003C7FFFD5BBAAA8p0",
"0x0.0000000B800000421FFFD3FAF553p0",
"0x0.0000000C00000047FFFFD23FFFFDp0",
"0x0.0000000C8000004E1FFFD08B0AA8p0",
"0x0.0000000D000000547FFFCEDC5552p0",
"0x0.0000000D8000005B1FFFCD341FFDp0",
"0x0.0000000E00000061FFFFCB92AAA7p0",
"0x0.0000000E800000691FFFC9F83552p0",
"0x0.0000000F000000707FFFC864FFFCp0",
"0x0.0000000F800000781FFFC6D94AA7p0",
"0x0.000000100000007FFFFFC5555551p0",
"0x0.00000010800000881FFFC3D95FFCp0",
"0x0.00000011000000907FFFC265AAA6p0",
"0x0.00000011800000991FFFC0FA7550p0",
"0x0.00000012000000A1FFFFBF97FFFBp0",
"0x0.00000012800000AB1FFFBE3E8AA5p0",
"0x0.00000013000000B47FFFBCEE5550p0",
"0x0.00000013800000BE1FFFBBA79FFAp0",
"0x0.00000014000000C7FFFFBA6AAAA5p0",
"0x0.00000014800000D21FFFB937B54Fp0",
"0x0.00000015000000DC7FFFB80EFFF9p0",
"0x0.00000015800000E71FFFB6F0CAA4p0",
"0x0.00000016000000F1FFFFB5DD554Ep0",
"0x0.00000016800000FD1FFFB4D4DFF9p0",
"0x0.00000017000001087FFFB3D7AAA3p0",
"0x0.00000017800001141FFFB2E5F54Dp0",
"0x0.000000180000011FFFFFB1FFFFF8p0",
"0x0.000000188000012C1FFFB1260AA2p0",
"0x0.00000019000001387FFFB058554Dp0",
"0x0.00000019800001451FFFAF971FF7p0",
"0x0.0000001A00000151FFFFAEE2AAA1p0",
"0x0.0000001A8000015F1FFFAE3B354Cp0",
"0x0.0000001B0000016C7FFFADA0FFF6p0",
"0x0.0000001B8000017A1FFFAD144AA1p0",
"0x0.0000001C00000187FFFFAC95554Bp0",
"0x0.0000001C800001961FFFAC245FF5p0",
"0x0.0000001D000001A47FFFABC1AAA0p0",
"0x0.0000001D800001B31FFFAB6D754Ap0",
"0x0.0000001E000001C1FFFFAB27FFF5p0",
"0x0.0000001E800001D11FFFAAF18A9Fp0",
"0x0.0000001F000001E07FFFAACA5549p0",
"0x0.0000001F800001F01FFFAAB29FF4p0",
};

// =============================================== iter7 table for pow() ==========================
// offset by ln(274877906944.00000001490116119384765625)-ln274877906944

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
template <> class log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>::array [64] = {
//A0-64,ln(274877906944.00000001490116119384765625)-ln(274877906944.00000001490116119384765625-i)
"0x0",
"0x0.00000000040000000007FFFFFC00p0",
"0x0.0000000008000000001FFFFFF800p0",
"0x0.000000000C0000000047FFFFF402p0",
"0x0.0000000010000000007FFFFFF005p0",
"0x0.000000001400000000C7FFFFEC0Ap0",
"0x0.0000000018000000011FFFFFE811p0",
"0x0.000000001C0000000187FFFFE41Cp0",
"0x0.000000002000000001FFFFFFE02Ap0",
"0x0.00000000240000000287FFFFDC3Cp0",
"0x0.0000000028000000031FFFFFD853p0",
"0x0.000000002C00000003C7FFFFD46Ep0",
"0x0.0000000030000000047FFFFFD08Fp0",
"0x0.00000000340000000547FFFFCCB7p0",
"0x0.0000000038000000061FFFFFC8E4p0",
"0x0.000000003C0000000707FFFFC519p0",
"0x0.000000004000000007FFFFFFC155p0",
"0x0.00000000440000000907FFFFBD99p0",
"0x0.00000000480000000A1FFFFFB9E5p0",
"0x0.000000004C0000000B47FFFFB63Bp0",
"0x0.00000000500000000C7FFFFFB29Ap0",
"0x0.00000000540000000DC7FFFFAF03p0",
"0x0.00000000580000000F1FFFFFAB77p0",
"0x0.000000005C0000001087FFFFA7F5p0",
"0x0.000000006000000011FFFFFFA47Fp0",
"0x0.00000000640000001387FFFFA116p0",
"0x0.0000000068000000151FFFFF9DB8p0",
"0x0.000000006C00000016C7FFFF9A68p0",
"0x0.0000000070000000187FFFFF9725p0",
"0x0.00000000740000001A47FFFF93F0p0",
"0x0.00000000780000001C1FFFFF90C9p0",
"0x0.000000007C0000001E07FFFF8DB2p0",
"0x0.00000000800000001FFFFFFF8AAAp0",
"0x0.00000000840000002207FFFF87B2p0",
"0x0.0000000088000000241FFFFF84CBp0",
"0x0.000000008C0000002647FFFF81F4p0",
"0x0.0000000090000000287FFFFF7F2Fp0",
"0x0.00000000940000002AC7FFFF7C7Dp0",
"0x0.00000000980000002D1FFFFF79DCp0",
"0x0.000000009C0000002F87FFFF774Fp0",
"0x0.00000000A000000031FFFFFF74D5p0",
"0x0.00000000A40000003487FFFF726Fp0",
"0x0.00000000A8000000371FFFFF701Dp0",
"0x0.00000000AC00000039C7FFFF6DE1p0",
"0x0.00000000B00000003C7FFFFF6BBAp0",
"0x0.00000000B40000003F47FFFF69A9p0",
"0x0.00000000B8000000421FFFFF67AFp0",
"0x0.00000000BC0000004507FFFF65CBp0",
"0x0.00000000C000000047FFFFFF63FFp0",
"0x0.00000000C40000004B07FFFF624Cp0",
"0x0.00000000C80000004E1FFFFF60B0p0",
"0x0.00000000CC0000005147FFFF5F2Ep0",
"0x0.00000000D0000000547FFFFF5DC5p0",
"0x0.00000000D400000057C7FFFF5C76p0",
"0x0.00000000D80000005B1FFFFF5B41p0",
"0x0.00000000DC0000005E87FFFF5A28p0",
"0x0.00000000E000000061FFFFFF592Ap0",
"0x0.00000000E40000006587FFFF5848p0",
"0x0.00000000E8000000691FFFFF5783p0",
"0x0.00000000EC0000006CC7FFFF56DAp0",
"0x0.00000000F0000000707FFFFF564Fp0",
"0x0.00000000F40000007447FFFF55E3p0",
"0x0.00000000F8000000781FFFFF5594p0",
"0x0.00000000FC0000007C07FFFF5565p0",
};

// =============================================== iter0 tables for pow() ==========================

template <typename T, typename T2, int p, int alpha, int size> class log0_lut_table {};

// L0 = ln(1/[1/~Y0])
// [1/~Y0] = upper_int(32/~Y0)/32
// 1/[1/~Y0] = 32/upper_int(32/~Y0)
// ~Y0 = 1.0xxxxx or 0.11xxxxx
//
// 		||   1/[1/~Y0]	||	L0	
// =============||==============||==============
//    0/1/2	||	1	||   ln32-ln32	
// 	3/4	||    32/31	||   ln32-ln31	
// 	5/6	||    32/30	||   ln32-ln30	
//    7/8/9	||    32/29	||   ln32-ln29	
//    10/11	||    32/28	||   ln32-ln28	
//    12/13/14	||    32/27	||   ln32-ln27	
//    15/16/17	||    32/26	||   ln32-ln26	
//  18/19/20/21	||    32/25	||   ln32-ln25	
//  22/23/24/25	||    32/24	||   ln32-ln24	
//  26/27/28/29	||    32/23	||   ln32-ln23	
//    30/31	||    32/22	||   ln32-ln22	
// -------------||--------------||--------------
//    32/33	||    32/43	||   ln32-ln43	
//    34/35	||    32/42	||   ln32-ln42	
//    36/37/38	||    32/41	||   ln32-ln41	
//    39/40/41	||    32/40	||   ln32-ln40	
//    42/43	||    32/39	||   ln32-ln39	
//    44/45/46	||    32/38	||   ln32-ln38	
//    47/48/49	||    32/37	||   ln32-ln37	
//  50/51/52/53	||    32/36	||   ln32-ln36	
//    54/55/56	||    32/35	||   ln32-ln35	
//  57/58/59/60	||    32/34	||   ln32-ln34	
//    61/62/63	||    32/33	||   ln32-ln33	
// =============================================

// offset by ln513-ln512
// offset by ln16385-ln16384
// offset by ln(262144.015625)-ln262144
// offset by ln(8388608.00048828125)-ln8388608
// offset by ln(268435456.0000152587890625)-ln268435456
// offset by ln(8589934592.000000476837158203125)-ln8589934592
// offset by ln(274877906944.00000001490116119384765625)-ln274877906944

// total length = 1 + 5 (we) + 35 (MaxPrecision) = 41 for half
// offset by -ln513+ln512-ln16385+ln16384
template <> class log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64> { public:
log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>();
static const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<41, 6, (ap_q_mode)5, (ap_o_mode)3, 0>,half,0,5,64>::array [64] = {
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"-0x0.0083E002Ap0",
"0x0.079CCEC24p0",
"0x0.079CCEC24p0",
"0x0.1001B8B2Fp0",
"0x0.1001B8B2Fp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.18AF7E5ABp0",
"0x0.21AB3D01Ap0",
"0x0.21AB3D01Ap0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.2AFAA0D40p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.34A3FA766p0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.3EAE58D6Cp0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.4921A8422p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5406D81A3p0",
"0x0.5F6808ECBp0",
"0x0.5F6808ECBp0",
"-0x0.4C276AEE2p0",
"-0x0.4C276AEE2p0",
"-0x0.462152B15p0",
"-0x0.462152B15p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.3FF610DD6p0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.39A3CF91Dp0",
"-0x0.3328953C8p0",
"-0x0.3328953C8p0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.2C8240E3Fp0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.25AE85F2Ep0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1EAAE770Dp0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1774B28D8p0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.1008F862Ap0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
"-0x0.086486C64p0",
};

// total length = 1 + 8 (we) + 56 (MaxPrecision) = 65 for float
// offset by -ln513+ln512-ln16385+ln16384-ln(262144.015625)+ln262144
template <> class log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64> { public:
log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>();
static const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<65, 9, (ap_q_mode)5, (ap_o_mode)3, 0>,float,0,5,64>::array [64] = {
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"-0x0.0083E102A6C118p0",
"0x0.079CCDC24CE109p0",
"0x0.079CCDC24CE109p0",
"0x0.1001B7B2F778EDp0",
"0x0.1001B7B2F778EDp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.18AF7D5AB2886Fp0",
"0x0.21AB3C01A907DFp0",
"0x0.21AB3C01A907DFp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.2AFA9FD401BA4Bp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.34A3F9766EF2AEp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.3EAE57D6C0A5DAp0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.4921A7422CAD31p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5406D71A3BCE46p0",
"0x0.5F6807ECB99357p0",
"0x0.5F6807ECB99357p0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.4C276BEE2B35DBp0",
"-0x0.462153B1555950p0",
"-0x0.462153B1555950p0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.3FF611DD633D6Dp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.39A3D091DBF55Cp0",
"-0x0.3328963C8F6E81p0",
"-0x0.3328963C8F6E81p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.2C8241E3F5E8C0p0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.25AE86F2E6AB5Fp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1EAAE870D1B3FEp0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1774B38D8C2C64p0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.1008F962AF726Bp0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
"-0x0.086487C644CDD8p0",
};

// total length = 1 + 11 (we) + 109 (MaxPrecision) = 121 for double
// offset by -ln513+ln512-ln16385+ln16384-ln(262144.015625)+ln262144-ln(8388608.00048828125)+ln8388608-ln(268435456.0000152587890625)+ln268435456-ln(8589934592.000000476837158203125)+ln8589934592-ln(274877906944.00000001490116119384765625)+ln274877906944
template <> class log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64> { public:
log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>();
static const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0> log0_lut_table<ap_fixed<121, 12, (ap_q_mode)5, (ap_o_mode)3, 0>,double,0,5,64>::array [64] = {
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"-0x0.0083E102E6D11CB03115AE61D579p0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.079CCDC20CD10587DA888C8896CAp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.1001B7B2B768E9D872E7ED932DBDp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.18AF7D5A72786BFDEC48F58AF7ABp0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.21AB3C0168F7DB0C3600D5971043p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.2AFA9FD3C1AA4746D4102B972E92p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.34A3F9762EE2AA2E26BF40E9BAA1p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.3EAE57D68095D64B016D896A2F92p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.4921A741EC9D2D30BE982B792D30p0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5406D719FBBE42880F9CB54ADEBBp0",
"0x0.5F6807EC798353076AE126693CACp0",
"0x0.5F6807EC798353076AE126693CACp0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.4C276BEE6B45DF20E43A1875F5E6p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.462153B1956954BEA4350425F105p0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.3FF611DDA34D71CADBA286D0FF1Fp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.39A3D0921C0560087CC5EC47D4ECp0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.3328963CCF7E859CB37698D346A6p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.2C8241E435F8C44118D9C27017C1p0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.25AE86F326BB63483CCE9065C36Ep0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1EAAE87111C4029A1B9DAE43D417p0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1774B38DCC3C684C15AF684EEF2Fp0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.1008F962EF826FE0EF7A67194B13p0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
"-0x0.086487C684DDDCC36F54B353C49Cp0",
};

// =============================================== log inverse tables for pow() ==========================
// [1/~Y0] = upper_int(32/~Y0)/32
// ~Y0 = 1.0xxxxx or 0.11xxxxx
//
//              ||   [1/~Y0]  
// =============||==============
//    0/1/2     ||      1       
//      3/4     ||    31/32     
//      5/6     ||    30/32     
//    7/8/9     ||    29/32     
//    10/11     ||    28/32     
//    12/13/14  ||    27/32     
//    15/16/17  ||    26/32     
//  18/19/20/21 ||    25/32     
//  22/23/24/25 ||    24/32     
//  26/27/28/29 ||    23/32     
//    30/31     ||    22/32     
// -------------||--------------
//    32/33     ||    43/32     
//    34/35     ||    42/32     
//    36/37/38  ||    41/32     
//    39/40/41  ||    40/32     
//    42/43     ||    39/32     
//    44/45/46  ||    38/32     
//    47/48/49  ||    37/32     
//  50/51/52/53 ||    36/32     
//    54/55/56  ||    35/32     
//  57/58/59/60 ||    34/32     
//    61/62/63  ||    33/32     
// =============================
template <int p, int alpha, int size> class log_inverse_lut_table_pow {};
template <> class log_inverse_lut_table_pow<0,5,64> { public:
log_inverse_lut_table_pow<0,5,64>();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> log_inverse_lut_table_pow<0,5,64>::array [64] = {
"0x1",
"0x1",
"0x1",
"0x0.F8p0",
"0x0.F8p0",
"0x0.F0p0",
"0x0.F0p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E8p0",
"0x0.E0p0",
"0x0.E0p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D8p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.D0p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C8p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.C0p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B8p0",
"0x0.B0p0",
"0x0.B0p0",
"0x1.58p0",
"0x1.58p0",
"0x1.50p0",
"0x1.50p0",
"0x1.48p0",
"0x1.48p0",
"0x1.48p0",
"0x1.40p0",
"0x1.40p0",
"0x1.40p0",
"0x1.38p0",
"0x1.38p0",
"0x1.30p0",
"0x1.30p0",
"0x1.30p0",
"0x1.28p0",
"0x1.28p0",
"0x1.28p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.20p0",
"0x1.18p0",
"0x1.18p0",
"0x1.18p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.10p0",
"0x1.08p0",
"0x1.08p0",
"0x1.08p0",
};

// =============================================== exp_Z1 tables for pow() ==========================
template <typename T> class table_exp_Z1 {};

// w_Z1 = 9 for half
template <> class table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};

// w_Z1 = 9 for float
template <> class table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};

// w_Z1 = 8 for double
template <> class table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x1.000000000000000p0",
"0x1.0100802AB55777Dp0",
"0x1.0202015600445B0p0",
"0x1.0304848362076A0p0",
"0x1.04080AB55DE3917p0",
"0x1.050C94EF7A206DCp0",
"0x1.06122436410DD14p0",
"0x1.0718B98F42084EFp0",
"0x1.08205601127EC98p0",
"0x1.0928FA934EF9093p0",
"0x1.0A32A84E9C1F581p0",
"0x1.0B3D603CA7C3273p0",
"0x1.0C49236829E8BC2p0",
"0x1.0D55F2DCE5D1E96p0",
"0x1.0E63CFA7AB09D17p0",
"0x1.0F72BAD65671B69p0",
"0x1.1082B577D34ED7Dp0",
"0x1.1193C09C1C595C4p0",
"0x1.12A5DD543CCC4DDp0",
"0x1.13B90CB25176A4Cp0",
"0x1.14CD4FC989CD645p0",
"0x1.15E2A7AE28FECA6p0",
"0x1.16F91575870692Fp0",
"0x1.18109A3611C34FBp0",
"0x1.192937074E0CD68p0",
"0x1.1A42ED01D8CBC61p0",
"0x1.1B5DBD3F6812230p0",
"0x1.1C79A8DACC350DEp0",
"0x1.1D96B0EFF0E793Dp0",
"0x1.1EB4D69BDE569A3p0",
"0x1.1FD41AFCBA45E6Ep0",
"0x1.20F47F31C92E464p0",
"0x1.2216045B6F5CCF9p0",
"0x1.2338AB9B3213497p0",
"0x1.245C7613B8A9AF2p0",
"0x1.258164E8CDB0D82p0",
"0x1.26A7793F601642Bp0",
"0x1.27CEB43D844902Fp0",
"0x1.28F7170A755FD75p0",
"0x1.2A20A2CE964063Dp0",
"0x1.2B4B58B372C7950p0",
"0x1.2C7739E3C0F32BDp0",
"0x1.2DA4478B620C73Ep0",
"0x1.2ED282D763D424Dp0",
"0x1.3001ECF601AF700p0",
"0x1.31328716A5D63C2p0",
"0x1.32645269EA828F9p0",
"0x1.339750219B212A8p0",
"0x1.34CB8170B58352Dp0",
"0x1.3600E78B6B11D19p0",
"0x1.373783A7220124Fp0",
"0x1.386F56FA7686E62p0",
"0x1.39A862BD3C1065Fp0",
"0x1.3AE2A8287E7A804p0",
"0x1.3C1E2876834AA7Fp0",
"0x1.3D5AE4E2CAE92C8p0",
"0x1.3E98DEAA11DCBAAp0",
"0x1.3FD8170A520718Bp0",
"0x1.41188F42C3E320Fp0",
"0x1.425A4893DFC3F9Ep0",
"0x1.439D443F5F158EEp0",
"0x1.44E183883D9E498p0",
"0x1.462707B2BAC20DBp0",
"0x1.476DD2045AC678Dp0",
"0x1.48B5E3C3E818667p0",
"0x1.49FF3E397492BACp0",
"0x1.4B49E2AE5AC6746p0",
"0x1.4C95D26D3F44074p0",
"0x1.4DE30EC211E6013p0",
"0x1.4F3198FA0F1CF9Ep0",
"0x1.50817263C13CCF5p0",
"0x1.51D29C4F01CB308p0",
"0x1.5325180CFACF76Cp0",
"0x1.5478E6F02823D02p0",
"0x1.55CE0A4C58C7BB2p0",
"0x1.57248376B033D61p0",
"0x1.587C53C5A7AF027p0",
"0x1.59D57C910FA4DE7p0",
"0x1.5B2FFF3210FD957p0",
"0x1.5C8BDD032E7708Fp0",
"0x1.5DE9176045FF53Bp0",
"0x1.5F47AFA69210A75p0",
"0x1.60A7A734AB0E875p0",
"0x1.6208FF6A88A4614p0",
"0x1.636BB9A9832584Dp0",
"0x1.64CFD75454EE7BFp0",
"0x1.663559CF1BC7C5Ap0",
"0x1.679C427F5A49F39p0",
"0x1.690492CBF9432CFp0",
"0x1.6A6E4C1D491E179p0",
"0x1.6BD96FDD034A27Fp0",
"0x1.6D45FF764BA55B5p0",
"0x1.6EB3FC55B1E75B4p0",
"0x1.702367E9330E0DDp0",
"0x1.719443A03ACB928p0",
"0x1.730690EBA4F5ADFp0",
"0x1.747A513DBEF6A62p0",
"0x1.75EF860A493F8FBp0",
"0x1.776630C678BC0EDp0",
"0x1.78DE52E8F8478BBp0",
"0x1.7A57EDE9EA23DE3p0",
"0x1.7BD30342E9716FBp0",
"0x1.7D4F946F0BA8D6Ap0",
"0x1.7ECDA2EAE215EBFp0",
"0x1.804D30347B545CBp0",
"0x1.81CE3DCB64CDB88p0",
"0x1.8350CD30AC38FF6p0",
"0x1.84D4DFE6E11BAF5p0",
"0x1.865A7772164C541p0",
"0x1.87E19557E3769A2p0",
"0x1.896A3B1F66A0E69p0",
"0x1.8AF46A5145B3750p0",
"0x1.8C802477B000FDCp0",
"0x1.8E0D6B1E5FD0E54p0",
"0x1.8F9C3FD29BEAF6Bp0",
"0x1.912CA4233924AA7p0",
"0x1.92BE99A09BEFFB7p0",
"0x1.945221DCB9EBCBAp0",
"0x1.95E73E6B1B75D9Bp0",
"0x1.977DF0E0DD3E499p0",
"0x1.99163AD4B1DCC13p0",
"0x1.9AB01DDEE3671B6p0",
"0x1.9C4B9B995509B1Fp0",
"0x1.9DE8B59F84A1410p0",
"0x1.9F876D8E8C56650p0",
"0x1.A127C505243AB4Fp0",
"0x1.A2C9BDA3A3E77AAp0",
"0x1.A46D590C041E0A9p0",
"0x0.9B4597E37CB04FFp0",
"0x0.9BE12B381386EBAp0",
"0x0.9C7D5A6DE293099p0",
"0x0.9D1A262119177CBp0",
"0x0.9DB78EEE82D48C8p0",
"0x0.9E55957388A4C0Ep0",
"0x0.9EF43A4E311A4ACp0",
"0x0.9F937E1D211D0B1p0",
"0x0.A033617F9C89377p0",
"0x0.A0D3E51586CE9E3p0",
"0x0.A175097F63908A0p0",
"0x0.A216CF5E5746455p0",
"0x0.A2B9375427DC3EFp0",
"0x0.A35C42033D55D02p0",
"0x0.A3FFF00EA26FA4Ap0",
"0x0.A4A4421A0542C56p0",
"0x0.A54938C9B7E846Bp0",
"0x0.A5EED4C2B11D9A6p0",
"0x0.A69516AA8CE986Cp0",
"0x0.A73BFF278D41C26p0",
"0x0.A7E38EE09AB1365p0",
"0x0.A88BC67D44FEE6Bp0",
"0x0.A934A6A5C3D5825p0",
"0x0.A9DE3002F76B9AEp0",
"0x0.AA88633E692C84Ap0",
"0x0.AB3341024C61E05p0",
"0x0.ABDEC9F97EDDCE4p0",
"0x0.AC8AFECF89A5CC7p0",
"0x0.AD37E030A19E3F4p0",
"0x0.ADE56EC9A836A6Ep0",
"0x0.AE93AB482C16806p0",
"0x0.AF42965A69CAD4Cp0",
"0x0.AFF230AF4C74755p0",
"0x0.B0A27AF66E76E6Dp0",
"0x0.B15375E01A27FC3p0",
"0x0.B205221D4A8020Cp0",
"0x0.B2B7805FABCB532p0",
"0x0.B36A91599C5AD1Dp0",
"0x0.B41E55BE2D37798p0",
"0x0.B4D2CE4122D4D60p0",
"0x0.B587FB96F5C4E71p0",
"0x0.B63DDE74D36C98Bp0",
"0x0.B6F477909EB8F0Cp0",
"0x0.B7ABC7A0F0D4F20p0",
"0x0.B863CF5D19E0354p0",
"0x0.B91C8F7D21A6399p0",
"0x0.B9D608B9C8566BFp0",
"0x0.BA903BCC873CE7Ep0",
"0x0.BB4B296F917BF09p0",
"0x0.BC06D25DD4C6241p0",
"0x0.BCC33752FA19691p0",
"0x0.BD80590B667A97Fp0",
"0x0.BE3E38443BB1DFEp0",
"0x0.BEFCD5BB5907E8Dp0",
"0x0.BFBC322F5C03B26p0",
"0x0.C07C4E5FA129321p0",
"0x0.C13D2B0C44B8AF4p0",
"0x0.C1FEC8F6236EE00p0",
"0x0.C2C128DEDB45C57p0",
"0x0.C3844B88CC364A2p0",
"0x0.C44831B718FAA1Dp0",
"0x0.C50CDC2DA7D16C9p0",
"0x0.C5D24BB123419CAp0",
"0x0.C6988106FADF218p0",
"0x0.C75F7CF56410574p0",
"0x0.C82740435AD43C0p0",
"0x0.C8EFCBB8A2896C2p0",
"0x0.C9B9201DC6B5E5Bp0",
"0x0.CA833E3C1BCF93Ep0",
"0x0.CB4E26DDC005A3Ap0",
"0x0.CC19DACD9C0AA1Dp0",
"0x0.CCE65AD763DF644p0",
"0x0.CDB3A7C7979EBD5p0",
"0x0.CE81C26B8449FC9p0",
"0x0.CF50AB9144963B9p0",
"0x0.D0206407C1BA78Bp0",
"0x0.D0F0EC9EB43E807p0",
"0x0.D1C24626A4CAA61p0",
"0x0.D2947170ECF84C4p0",
"0x0.D3676F4FB8233EDp0",
"0x0.D43B4096043BDE0p0",
"0x0.D50FE617A29A1CBp0",
"0x0.D5E560A938D151Dp0",
"0x0.D6BBB1204184DDBp0",
"0x0.D792D8530D3DA53p0",
"0x0.D86AD718C34061Dp0",
"0x0.D943AE496264C99p0",
"0x0.DA1D5EBDC1ED8D8p0",
"0x0.DAF7E94F9261313p0",
"0x0.DBD34ED95E63BB6p0",
"0x0.DCAF90368B91406p0",
"0x0.DD8CAE435B59485p0",
"0x0.DE6AA9DCEBDB100p0",
"0x0.DF4983E138C2A7Bp0",
"0x0.E0293D2F1C26EE7p0",
"0x0.E109D6A64F686C6p0",
"0x0.E1EB51276C110C3p0",
"0x0.E2CDAD93ECB4B4Ep0",
"0x0.E3B0ECCE2DD2C3Fp0",
"0x0.E4950FB96EB86A9p0",
"0x0.E57A1739D263EC9p0",
"0x0.E66004346068C38p0",
"0x0.E746D78F05D4A68p0",
"0x0.E82E92309615774p0",
"0x0.E9173500CBE0159p0",
"0x0.EA00C0E84A181A3p0",
"0x0.EAEB36D09CB879Ap0",
"0x0.EBD697A439BD105p0",
"0x0.ECC2E44E820D18Cp0",
"0x0.EDB01DBBC2668C3p0",
"0x0.EE9E44D9344A6FEp0",
"0x0.EF8D5A94FEEA0E4p0",
"0x0.F07D5FDE38151E7p0",
"0x0.F16E55A4E528DA0p0",
"0x0.F2603CD9FC00028p0",
"0x0.F353166F63E3D78p0",
"0x0.F446E357F67DFD8p0",
"0x0.F53BA48780CB586p0",
"0x0.F6315AF2C40FD7Bp0",
"0x0.F728078F76CB38Cp0",
"0x0.F81FAB5445AEBC8p0",
"0x0.F9184738D493D4Fp0",
"0x0.FA11DC35BF73C89p0",
"0x0.FB0C6B449B604ECp0",
"0x0.FC07F55FF77D249p0",
"0x0.FD047B835DFA9C5p0",
"0x0.FE01FEAB551127Cp0",
"0x0.FF007FD55FFDDE3p0",
};

// =============================================== f_Z2 tables for pow() ==========================
// f_Z2 tables
template <typename T> class table_f_Z2 {};

// w_Z2_ind = 5 for float
template <> class table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [32];};
const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [32] = {
"0x0",
"0x0.0000000p0",
"0x0.0000002p0",
"0x0.0000004p0",
"0x0.0000008p0",
"0x0.000000Cp0",
"0x0.0000012p0",
"0x0.0000018p0",
"0x0.0000020p0",
"0x0.0000028p0",
"0x0.0000032p0",
"0x0.000003Cp0",
"0x0.0000048p0",
"0x0.0000054p0",
"0x0.0000062p0",
"0x0.0000070p0",
"0x0.0000080p0",
"0x0.0000090p0",
"0x0.00000A2p0",
"0x0.00000B4p0",
"0x0.00000C8p0",
"0x0.00000DCp0",
"0x0.00000F2p0",
"0x0.0000108p0",
"0x0.0000120p0",
"0x0.0000138p0",
"0x0.0000152p0",
"0x0.000016Cp0",
"0x0.0000188p0",
"0x0.00001A4p0",
"0x0.00001C2p0",
"0x0.00001E0p0",
};

// w_Z2 = 8 for double
template <> class table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.0000000080002AAp0",
"0x0.000000020001555p0",
"0x0.000000048004800p0",
"0x0.00000008000AAABp0",
"0x0.0000000C8014D56p0",
"0x0.000000120024003p0",
"0x0.0000001880392B0p0",
"0x0.000000200055560p0",
"0x0.000000288079811p0",
"0x0.0000003200A6AC4p0",
"0x0.0000003C80DDD7Bp0",
"0x0.000000480120036p0",
"0x0.00000054816E2F5p0",
"0x0.0000006201C95B9p0",
"0x0.000000708232883p0",
"0x0.0000008002AAB55p0",
"0x0.000000908332E2Ep0",
"0x0.000000A203CC111p0",
"0x0.000000B484773FEp0",
"0x0.000000C805356F6p0",
"0x0.000000DC86079FAp0",
"0x0.000000F206EED0Cp0",
"0x0.0000010887EC02Ep0",
"0x0.000001200900360p0",
"0x0.000001388A2C6A3p0",
"0x0.000001520B719FBp0",
"0x0.0000016C8CD0D68p0",
"0x0.000001880E4B0EBp0",
"0x0.000001A48FE1487p0",
"0x0.000001C2119483Dp0",
"0x0.000001E09365C0Fp0",
"0x0.000002001556000p0",
"0x0.000002209766410p0",
"0x0.000002421997843p0",
"0x0.000002649BEAC99p0",
"0x0.000002881E61116p0",
"0x0.000002ACA0FB5BBp0",
"0x0.000002D223BAA8Cp0",
"0x0.000002F8A69FF89p0",
"0x0.0000032029AC4B6p0",
"0x0.00000348ACE0A15p0",
"0x0.00000372303DFA8p0",
"0x0.0000039CB3C5572p0",
"0x0.000003C83777B77p0",
"0x0.000003F4BB561B8p0",
"0x0.000004223F61838p0",
"0x0.00000450C39AEFAp0",
"0x0.000004804803602p0",
"0x0.000004B0CC9BD51p0",
"0x0.000004E251654EBp0",
"0x0.00000514D660CD4p0",
"0x0.000005485B8F50Ep0",
"0x0.0000057CE0F1D9Cp0",
"0x0.000005B26689683p0",
"0x0.000005E8EC56FC4p0",
"0x0.00000620725B964p0",
"0x0.00000658F898366p0",
"0x0.000006927F0DDCDp0",
"0x0.000006CD05BD89Ep0",
"0x0.000007088CA83DCp0",
"0x0.0000074513CEF8Ap0",
"0x0.000007829B32BACp0",
"0x0.000007C122D4847p0",
"0x0.00000800AAB555Dp0",
"0x0.0000084132D62F4p0",
"0x0.00000882BB3810Fp0",
"0x0.000008C543DBFB2p0",
"0x0.00000908CCC2EE1p0",
"0x0.0000094D55EDEA1p0",
"0x0.00000992DF5DEF6p0",
"0x0.000009D96913FE3p0",
"0x0.00000A20F31116Fp0",
"0x0.00000A697D5639Cp0",
"0x0.00000AB307E4671p0",
"0x0.00000AFD92BC9F0p0",
"0x0.00000B491DDFE1Fp0",
"0x0.00000B95A94F303p0",
"0x0.00000BE3350B8A0p0",
"0x0.00000C31C115EFBp0",
"0x0.00000C814D6F61Ap0",
"0x0.00000CD1DA18E00p0",
"0x0.00000D2367136B4p0",
"0x0.00000D75F46003Ap0",
"0x0.00000DC981FFA97p0",
"0x0.00000E1E0FF35D1p0",
"0x0.00000E739E3C1ECp0",
"0x0.00000ECA2CDAEEFp0",
"0x0.00000F21BBD0CDFp0",
"0x0.00000F7A4B1EBC0p0",
"0x0.00000FD3DAC5B9Ap0",
"0x0.0000102E6AC6C70p0",
"0x0.00001089FB22E4Ap0",
"0x0.000010E68BDB12Cp0",
"0x0.000011441CF051Dp0",
"0x0.000011A2AE63A21p0",
"0x0.000012024036040p0",
"0x0.00001262D26877Fp0",
"0x0.000012C464FBFE5p0",
"0x0.00001326F7F1976p0",
"0x0.0000138A8B4A43Ap0",
"0x0.000013EF1F07037p0",
"0x0.00001454B328D73p0",
"0x0.000014BB47B0BF4p0",
"0x0.00001522DC9FBC0p0",
"0x0.0000158B71F6CDFp0",
"0x0.000015F507B6F57p0",
"0x0.0000165F9DE132Dp0",
"0x0.000016CB347686Ap0",
"0x0.00001737CB77F14p0",
"0x0.000017A562E6731p0",
"0x0.00001813FAC30C8p0",
"0x0.00001883930EBE1p0",
"0x0.000018F42BCA882p0",
"0x0.00001965C4F76B2p0",
"0x0.000019D85E96678p0",
"0x0.00001A4BF8A87DCp0",
"0x0.00001AC0932EAE5p0",
"0x0.00001B362E29F9Ap0",
"0x0.00001BACC99B602p0",
"0x0.00001C246583E25p0",
"0x0.00001C9D01E480Bp0",
"0x0.00001D169EBE3BAp0",
"0x0.00001D913C1213Ap0",
"0x0.00001E0CD9E1094p0",
"0x0.00001E89782C1CEp0",
"0x0.00001F0716F44F1p0",
"0x0.00001F85B63AA05p0",
"0x0.000020055600111p0",
"0x0.00002085F645A1Dp0",
"0x0.00002107970C531p0",
"0x0.0000218A3855256p0",
"0x0.0000220DDA21194p0",
"0x0.000022927C712F3p0",
"0x0.000023181F4667Ap0",
"0x0.0000239EC2A1C34p0",
"0x0.000024266684427p0",
"0x0.000024AF0AEEE5Cp0",
"0x0.00002538AFE2ADDp0",
"0x0.000025C355609B1p0",
"0x0.0000264EFB69AE1p0",
"0x0.000026DBA1FEE76p0",
"0x0.000027694921479p0",
"0x0.000027F7F0D1CF3p0",
"0x0.0000288799117ECp0",
"0x0.0000291841E156Dp0",
"0x0.000029A9EB42580p0",
"0x0.00002A3C953582Ep0",
"0x0.00002AD03FBBD7Fp0",
"0x0.00002B64EAD657Ep0",
"0x0.00002BFA9686033p0",
"0x0.00002C9142CBDA7p0",
"0x0.00002D28EFA8DE5p0",
"0x0.00002DC19D1E0F5p0",
"0x0.00002E5B4B2C6E1p0",
"0x0.00002EF5F9D4FB3p0",
"0x0.00002F91A918B74p0",
"0x0.0000302E58F8A2Ep0",
"0x0.000030CC0975BECp0",
"0x0.0000316ABA910B6p0",
"0x0.0000320A6C4B897p0",
"0x0.000032AB1EA6398p0",
"0x0.0000334CD1A21C4p0",
"0x0.000033EF8540325p0",
"0x0.0000349339817C5p0",
"0x0.00003537EE66FAEp0",
"0x0.000035DDA3F1AEAp0",
"0x0.000036845A22985p0",
"0x0.0000372C10FAB88p0",
"0x0.000037D4C87B0FDp0",
"0x0.0000387E80A49F0p0",
"0x0.00003929397866Ap0",
"0x0.000039D4F2F7678p0",
"0x0.00003A81AD22A22p0",
"0x0.00003B2F67FB175p0",
"0x0.00003BDE2381C7Bp0",
"0x0.00003C8DDFB7B3Ep0",
"0x0.00003D3E9C9DDCBp0",
"0x0.00003DF05A3542Bp0",
"0x0.00003EA3187EE6Ap0",
"0x0.00003F56D77BC94p0",
"0x0.0000400B972CEB3p0",
"0x0.000040C157934D3p0",
"0x0.0000417818AFEFEp0",
"0x0.0000422FDA83D42p0",
"0x0.000042E89D0FFA8p0",
"0x0.000043A2605563Dp0",
"0x0.0000445D245510Cp0",
"0x0.00004518E910021p0",
"0x0.000045D5AE87387p0",
"0x0.0000469374BBB4Bp0",
"0x0.000047523BAE778p0",
"0x0.00004812036081Ap0",
"0x0.000048D2CBD2D3Dp0",
"0x0.0000499495066EEp0",
"0x0.00004A575EFC538p0",
"0x0.00004B1B29B5827p0",
"0x0.00004BDFF532FC8p0",
"0x0.00004CA5C175C27p0",
"0x0.00004D6C8E7ED50p0",
"0x0.00004E345C4F350p0",
"0x0.00004EFD2AE7E33p0",
"0x0.00004FC6FA49E06p0",
"0x0.00005091CA762D6p0",
"0x0.0000515D9B6DCAFp0",
"0x0.0000522A6D31B9Dp0",
"0x0.000052F83FC2FAFp0",
"0x0.000053C713228EFp0",
"0x0.00005496E75176Dp0",
"0x0.00005567BC50B33p0",
"0x0.000056399221450p0",
"0x0.0000570C68C42D1p0",
"0x0.000057E0403A6C3p0",
"0x0.000058B51885032p0",
"0x0.0000598AF1A4F2Dp0",
"0x0.00005A61CB9B3C1p0",
"0x0.00005B39A668DFAp0",
"0x0.00005C12820EDE8p0",
"0x0.00005CEC5E8E396p0",
"0x0.00005DC73BE7F13p0",
"0x0.00005EA31A1D06Dp0",
"0x0.00005F7FF92E7B1p0",
"0x0.0000605DD91D4EDp0",
"0x0.0000613CB9EA82Ep0",
"0x0.0000621C9B97184p0",
"0x0.000062FD7E240FBp0",
"0x0.000063DF61926A2p0",
"0x0.000064C245E3288p0",
"0x0.000065A62B174B9p0",
"0x0.0000668B112FD45p0",
"0x0.00006770F82DC39p0",
"0x0.00006857E0121A4p0",
"0x0.0000693FC8DDD95p0",
"0x0.00006A28B29201Ap0",
"0x0.00006B129D2F942p0",
"0x0.00006BFD88B791Bp0",
"0x0.00006CE9752AFB3p0",
"0x0.00006DD6628AD1Ap0",
"0x0.00006EC450D815Fp0",
"0x0.00006FB34013C8Fp0",
"0x0.000070A3303EEBBp0",
"0x0.00007194215A7F2p0",
"0x0.000072861367841p0",
"0x0.000073790666FB9p0",
"0x0.0000746CFA59E68p0",
"0x0.00007561EF4145Fp0",
"0x0.00007657E51E1ABp0",
"0x0.0000774EDBF165Dp0",
"0x0.00007846D3BC284p0",
"0x0.0000793FCC7F62Fp0",
"0x0.00007A39C63C16Ep0",
"0x0.00007B34C0F3451p0",
"0x0.00007C30BCA5EE7p0",
"0x0.00007D2DB955140p0",
"0x0.00007E2BB701B6Cp0",
"0x0.00007F2AB5ACD7Bp0",
};

// =============================================== f_Z3 table for pow() ==========================
// f_Z3 table
template <typename T> class table_f_Z3 {};

// w_Z3 = 8 for double
template <> class table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.000000000000800p0",
"0x0.000000000002000p0",
"0x0.000000000004800p0",
"0x0.000000000008000p0",
"0x0.00000000000C800p0",
"0x0.000000000012000p0",
"0x0.000000000018800p0",
"0x0.000000000020000p0",
"0x0.000000000028800p0",
"0x0.000000000032000p0",
"0x0.00000000003C800p0",
"0x0.000000000048000p0",
"0x0.000000000054800p0",
"0x0.000000000062000p0",
"0x0.000000000070800p0",
"0x0.000000000080000p0",
"0x0.000000000090800p0",
"0x0.0000000000A2000p0",
"0x0.0000000000B4800p0",
"0x0.0000000000C8000p0",
"0x0.0000000000DC800p0",
"0x0.0000000000F2000p0",
"0x0.000000000108800p0",
"0x0.000000000120000p0",
"0x0.000000000138800p0",
"0x0.000000000152000p0",
"0x0.00000000016C800p0",
"0x0.000000000188000p0",
"0x0.0000000001A4800p0",
"0x0.0000000001C2001p0",
"0x0.0000000001E0801p0",
"0x0.000000000200001p0",
"0x0.000000000220801p0",
"0x0.000000000242001p0",
"0x0.000000000264801p0",
"0x0.000000000288001p0",
"0x0.0000000002AC802p0",
"0x0.0000000002D2002p0",
"0x0.0000000002F8802p0",
"0x0.000000000320002p0",
"0x0.000000000348802p0",
"0x0.000000000372003p0",
"0x0.00000000039C803p0",
"0x0.0000000003C8003p0",
"0x0.0000000003F4803p0",
"0x0.000000000422003p0",
"0x0.000000000450804p0",
"0x0.000000000480004p0",
"0x0.0000000004B0804p0",
"0x0.0000000004E2005p0",
"0x0.000000000514805p0",
"0x0.000000000548005p0",
"0x0.00000000057C806p0",
"0x0.0000000005B2006p0",
"0x0.0000000005E8806p0",
"0x0.000000000620007p0",
"0x0.000000000658807p0",
"0x0.000000000692007p0",
"0x0.0000000006CC808p0",
"0x0.000000000708008p0",
"0x0.000000000744809p0",
"0x0.000000000782009p0",
"0x0.0000000007C080Ap0",
"0x0.00000000080000Ap0",
"0x0.00000000084080Bp0",
"0x0.00000000088200Bp0",
"0x0.0000000008C480Cp0",
"0x0.00000000090800Cp0",
"0x0.00000000094C80Dp0",
"0x0.00000000099200Dp0",
"0x0.0000000009D880Ep0",
"0x0.000000000A2000Fp0",
"0x0.000000000A6880Fp0",
"0x0.000000000AB2010p0",
"0x0.000000000AFC811p0",
"0x0.000000000B48011p0",
"0x0.000000000B94812p0",
"0x0.000000000BE2013p0",
"0x0.000000000C30814p0",
"0x0.000000000C80014p0",
"0x0.000000000CD0815p0",
"0x0.000000000D22016p0",
"0x0.000000000D74817p0",
"0x0.000000000DC8018p0",
"0x0.000000000E1C818p0",
"0x0.000000000E72019p0",
"0x0.000000000EC881Ap0",
"0x0.000000000F2001Bp0",
"0x0.000000000F7881Cp0",
"0x0.000000000FD201Dp0",
"0x0.00000000102C81Ep0",
"0x0.00000000108801Fp0",
"0x0.0000000010E4820p0",
"0x0.000000001142021p0",
"0x0.0000000011A0822p0",
"0x0.000000001200024p0",
"0x0.000000001260825p0",
"0x0.0000000012C2026p0",
"0x0.000000001324827p0",
"0x0.000000001388028p0",
"0x0.0000000013EC829p0",
"0x0.00000000145202Bp0",
"0x0.0000000014B882Cp0",
"0x0.00000000152002Dp0",
"0x0.00000000158882Fp0",
"0x0.0000000015F2030p0",
"0x0.00000000165C831p0",
"0x0.0000000016C8033p0",
"0x0.000000001734834p0",
"0x0.0000000017A2036p0",
"0x0.000000001810837p0",
"0x0.000000001880039p0",
"0x0.0000000018F083Ap0",
"0x0.00000000196203Cp0",
"0x0.0000000019D483Dp0",
"0x0.000000001A4803Fp0",
"0x0.000000001ABC841p0",
"0x0.000000001B32042p0",
"0x0.000000001BA8844p0",
"0x0.000000001C20046p0",
"0x0.000000001C98848p0",
"0x0.000000001D12049p0",
"0x0.000000001D8C84Bp0",
"0x0.000000001E0804Dp0",
"0x0.000000001E8484Fp0",
"0x0.000000001F02051p0",
"0x0.000000001F80853p0",
"0x0.000000002000055p0",
"0x0.000000002080857p0",
"0x0.000000002102059p0",
"0x0.00000000218485Bp0",
"0x0.00000000220805Dp0",
"0x0.00000000228C85Fp0",
"0x0.000000002312061p0",
"0x0.000000002398864p0",
"0x0.000000002420066p0",
"0x0.0000000024A8868p0",
"0x0.00000000253206Ap0",
"0x0.0000000025BC86Dp0",
"0x0.00000000264806Fp0",
"0x0.0000000026D4872p0",
"0x0.000000002762074p0",
"0x0.0000000027F0876p0",
"0x0.000000002880079p0",
"0x0.00000000291087Cp0",
"0x0.0000000029A207Ep0",
"0x0.000000002A34881p0",
"0x0.000000002AC8083p0",
"0x0.000000002B5C886p0",
"0x0.000000002BF2089p0",
"0x0.000000002C8888Cp0",
"0x0.000000002D2008Ep0",
"0x0.000000002DB8891p0",
"0x0.000000002E52094p0",
"0x0.000000002EEC897p0",
"0x0.000000002F8809Ap0",
"0x0.00000000302489Dp0",
"0x0.0000000030C20A0p0",
"0x0.0000000031608A3p0",
"0x0.0000000032000A6p0",
"0x0.0000000032A08A9p0",
"0x0.0000000033420ACp0",
"0x0.0000000033E48B0p0",
"0x0.0000000034880B3p0",
"0x0.00000000352C8B6p0",
"0x0.0000000035D20BAp0",
"0x0.0000000036788BDp0",
"0x0.0000000037200C0p0",
"0x0.0000000037C88C4p0",
"0x0.0000000038720C7p0",
"0x0.00000000391C8CBp0",
"0x0.0000000039C80CFp0",
"0x0.000000003A748D2p0",
"0x0.000000003B220D6p0",
"0x0.000000003BD08DAp0",
"0x0.000000003C800DDp0",
"0x0.000000003D308E1p0",
"0x0.000000003DE20E5p0",
"0x0.000000003E948E9p0",
"0x0.000000003F480EDp0",
"0x0.000000003FFC8F1p0",
"0x0.0000000040B20F5p0",
"0x0.0000000041688F9p0",
"0x0.0000000042200FDp0",
"0x0.0000000042D8901p0",
"0x0.000000004392105p0",
"0x0.00000000444C90Ap0",
"0x0.00000000450810Ep0",
"0x0.0000000045C4912p0",
"0x0.000000004682117p0",
"0x0.00000000474091Bp0",
"0x0.000000004800120p0",
"0x0.0000000048C0924p0",
"0x0.000000004982129p0",
"0x0.000000004A4492Dp0",
"0x0.000000004B08132p0",
"0x0.000000004BCC937p0",
"0x0.000000004C9213Bp0",
"0x0.000000004D58940p0",
"0x0.000000004E20145p0",
"0x0.000000004EE894Ap0",
"0x0.000000004FB214Fp0",
"0x0.00000000507C954p0",
"0x0.000000005148159p0",
"0x0.00000000521495Ep0",
"0x0.0000000052E2163p0",
"0x0.0000000053B0968p0",
"0x0.00000000548016Ep0",
"0x0.000000005550973p0",
"0x0.000000005622178p0",
"0x0.0000000056F497Ep0",
"0x0.0000000057C8183p0",
"0x0.00000000589C989p0",
"0x0.00000000597218Ep0",
"0x0.000000005A48994p0",
"0x0.000000005B2019Ap0",
"0x0.000000005BF899Fp0",
"0x0.000000005CD21A5p0",
"0x0.000000005DAC9ABp0",
"0x0.000000005E881B1p0",
"0x0.000000005F649B7p0",
"0x0.0000000060421BDp0",
"0x0.0000000061209C3p0",
"0x0.0000000062001C9p0",
"0x0.0000000062E09CFp0",
"0x0.0000000063C21D5p0",
"0x0.0000000064A49DBp0",
"0x0.0000000065881E2p0",
"0x0.00000000666C9E8p0",
"0x0.0000000067521EFp0",
"0x0.0000000068389F5p0",
"0x0.0000000069201FCp0",
"0x0.000000006A08A02p0",
"0x0.000000006AF2209p0",
"0x0.000000006BDCA10p0",
"0x0.000000006CC8216p0",
"0x0.000000006DB4A1Dp0",
"0x0.000000006EA2224p0",
"0x0.000000006F90A2Bp0",
"0x0.000000007080232p0",
"0x0.000000007170A39p0",
"0x0.000000007262240p0",
"0x0.000000007354A47p0",
"0x0.00000000744824Fp0",
"0x0.00000000753CA56p0",
"0x0.00000000763225Dp0",
"0x0.000000007728A65p0",
"0x0.00000000782026Cp0",
"0x0.000000007918A74p0",
"0x0.000000007A1227Bp0",
"0x0.000000007B0CA83p0",
"0x0.000000007C0828Bp0",
"0x0.000000007D04A92p0",
"0x0.000000007E0229Ap0",
"0x0.000000007F00AA2p0",
};

}
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h" 2

template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void log_range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{
    //#pragma HLS inline self off
    const int T1size = 1 << alpha; // The size of the first table


    //#pragma HLS RESOURCE variable=log_lut core=ROM_1P_LUTRAM

    ap_ufixed<alpha, -p> a = zN; // Extract alpha MSBs from z1.
    ap_ufixed<size-alpha, -p-alpha> b = zN; // Extract the LSBs from z1.
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN; // Extend z1 for shift
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1; // Stage dependent?
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}

//   i  0  1  2  3   4   5   6   7   8
// =====================================
//  pi  0  4  7  12  17  22  27  32  37
const int p0 = 0; // We start with zero zeroed bits
const int alpha0 = 5; // 1+alpha0 = number of bits considered by stage 0.
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2); // The number of bits zeroed in y1.
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template<typename T>
class pow_traits {};

template <> class pow_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = 18;
    const static int org_wf = fp_struct<half>::SIG_BITS; // 10

    const static int log_gbits = 4;
    const static int LogMaxPrecision = p3+wf+1+log_gbits; // 35
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE; // < 41, 6 >

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p3, -p3> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;
        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }

    const static int exp_gbits = 3;
    const static int exp_gbits_Z2 = 3;
    const static int w_Z1 = 9;

    // input ap_ufixed < 4, -9 >
    // output ap_uifxed < 5, -8 >
    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> Z1P_l = Z1P;
        return Z1P_l;
    }
};
template <> class pow_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = 34;
    const static int org_wf = fp_struct<float>::SIG_BITS; // 23

    const static int log_gbits = 4;
    const static int LogMaxPrecision = p4+wf+1+log_gbits; // 56
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE; // < 65, 9 >

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p4, -p4> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < LogMaxPrecision-p4) ? w4 : (LogMaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;
        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;

        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;

        log_range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;

        return z4;
    }

    const static int exp_gbits = 4;
    const static int exp_gbits_Z2 = 3;
    const static int w_Z1 = 9;

    // input ap_ufixed < 18, -9 >
    // output ap_ufixed < 18, -8 >
    // Z = Z1 + Z1P = Z1 + Z2
    // e^Z1P - 1 = Z1P + Z2^2/2 = Z1P + f(Z2)
    // w_Z2_ind = w - w/2 - w1 = 5
    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2_ind = 5;
_ssdm_SpecConstant(&w_Z2_ind);
# 169 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        ap_uint<w_Z2_ind> Z2_ind = Z1P ( Z1P.wl()-1 , Z1P.wl()-w_Z2_ind );
        ap_ufixed<org_wf+exp_gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z2_ind ]; // < 8, -19 >
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = Z1P + f_Z2;
        return exp_Z1P_m_1;
    }

public :
inline __attribute__((always_inline)) pow_traits<float>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&org_wf); _ssdm_SpecConstant(&log_gbits); _ssdm_SpecConstant(&LogMaxPrecision); _ssdm_SpecConstant(&w1); _ssdm_SpecConstant(&w2); _ssdm_SpecConstant(&w3); _ssdm_SpecConstant(&w4); _ssdm_SpecConstant(&exp_gbits); _ssdm_SpecConstant(&exp_gbits_Z2); _ssdm_SpecConstant(&w_Z1); }
# 175 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
};

template <> class pow_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = 66;
    const static int org_wf = fp_struct<double>::SIG_BITS; // 52

    const static int log_gbits = 5 ;
    const static int LogMaxPrecision = p8+wf+1+log_gbits; // 109
    typedef ap_fixed<1 + we + LogMaxPrecision, 1 + we> LOG_TYPE; // < 121, 12>

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1); // MaxWidth of z2, needs to be truncted to MaxPrecision
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<LogMaxPrecision-p8, -p8> log_range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < LogMaxPrecision-p2) ? w2 : (LogMaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < LogMaxPrecision-p3) ? w3 : (LogMaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < LogMaxPrecision-p4) ? w4 : (LogMaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < LogMaxPrecision-p5) ? w5 : (LogMaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < LogMaxPrecision-p6) ? w6 : (LogMaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < LogMaxPrecision-p7) ? w7 : (LogMaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < LogMaxPrecision-p8) ? w8 : (LogMaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        log_range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        log_range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }

    // guard bits should be 7bit
    // but to reduce size of multiplier
    // use 7bit for exp_Z3_m_1 * exp_Z4_m_1 and exp_Z2_m_1 * exp_Z2P_m_1
    // use 5bit for exp_Z1 * exp_Z1P_m_1
    const static int exp_gbits = 7;
    const static int exp_gbits_Z2 = 5;
    const static int w_Z1 = 8;

    // input ap_ufixed < 51, -8 >
    // output ap_ufixed < 50, -7 >
    // Z = Z1 + Z2 + Z3 + Z4, w = 59, w1 = 8, w2 = 8, w3 = 8, w4 = 35
    static ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<org_wf+exp_gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2 = 8;
_ssdm_SpecConstant(&w_Z2);
# 237 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

 const static int w_Z2P = 43;
_ssdm_SpecConstant(&w_Z2P);
# 238 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int w_Z3 = 8;
_ssdm_SpecConstant(&w_Z3);
# 239 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int w_Z4 = 35;
_ssdm_SpecConstant(&w_Z4);
# 240 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"


 ap_ufixed < w_Z2 , -w_Z1 > Z2 = Z1P; // Z1P [ 50 .. 43 ]
 ap_ufixed < w_Z2P , -w_Z1-w_Z2 > Z2P = Z1P; // Z1P [ 42 ..  0 ]
 ap_ufixed < w_Z3 , -w_Z1-w_Z2 > Z3 = Z1P; // Z1P [ 42 .. 35 ]
 ap_ufixed < w_Z4 , -w_Z1-w_Z2-w_Z3 > Z4 = Z1P; // Z1P [ 34 ..  0 ]


 // e^Z = e^Z1 * e^Z2 * e^Z3 * e^Z4
 //     = e^Z1 * ( 1 + Z2 + f(Z2) ) * ( 1 + Z3 + f(Z3) ) * ( 1 + Z4 + f(Z4) )
 //
 // 1. let's start from
 //   e^Z2P - 1
 // = ( 1 + Z3 + f(Z3) ) * ( 1 + Z4 + f(Z4) ) - 1
 // = ( Z3 + f(Z3) ) + ( Z4 + f(Z4) ) + ( Z3 + f(Z3) ) * ( Z4 + f(Z4) )
 //
 // 1.1 Z4 + f(Z4)
 // w_Z4_ind = w4 - w/2 = 6
 // instead of using a f_Z4 table, we reuse f_Z3 table for f_Z4
        const static int w_Z4_ind = w_Z3;
_ssdm_SpecConstant(&w_Z4_ind);
# 259 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

 ap_uint<w_Z4_ind> Z4_ind = Z4 ( Z4.wl()-1 , Z4.wl()-w_Z4_ind );
 ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2+w_Z3)-1,-2*(w_Z1+w_Z2+w_Z3)-1> f_Z4 = table_f_Z3< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z4_ind ] >> ( 2*w_Z3 ); // < 10, -49 >
 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2-w_Z3+1,-w_Z1-w_Z2-w_Z3+1> exp_Z4_m_1 = Z4 + f_Z4; // < 36, -23 >

 // 1.2 Z3 + f(Z3)
 ap_uint<w_Z3> Z3_ind = Z3 ( Z3.wl()-1, 0 );
        ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2)-1,-2*(w_Z1+w_Z2)-1> f_Z3 = table_f_Z3< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z3_ind ]; // < 26, -33 >
        ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z3_m_1 = Z3 + f_Z3; // < 44, -15 >

 // 1.3 ( Z3 + f(Z3) ) * ( Z4 + f(Z4) )
 ap_ufixed<org_wf+exp_gbits-2*(w_Z1+w_Z2)-w_Z3+2,-2*(w_Z1+w_Z2)-w_Z3+2> exp_Z2P_m_1_lo = exp_Z3_m_1 * exp_Z4_m_1; // < 21, -38 >

        // 1.4 e^Z2P - 1
 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+2,-w_Z1-w_Z2+2> exp_Z2P_m_1_l = exp_Z3_m_1 + exp_Z4_m_1 + exp_Z2P_m_1_lo; // < 45, -14 >
 ((exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 274, __PRETTY_FUNCTION__));
 ap_ufixed<org_wf+exp_gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z2P_m_1 = exp_Z2P_m_1_l; // < 44, -15 >

 // 2. e^Z1P - 1
 //  = ( 1 + Z2 + f(Z2) ) * ( 1 + ( e^Z2P - 1 ) ) - 1
 //  = ( Z2 + f(Z2) ) + ( e^Z2P - 1 ) + ( Z2 + f(Z2) ) * ( e^Z2P - 1 )
 //
 // 2.1 Z2 + f(Z2)
        ap_uint<w_Z2> Z2_ind = Z2 ( Z2.wl()-1, 0 );
        ap_ufixed<org_wf+exp_gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<org_wf+exp_gbits,0> >::array [ Z2_ind ]; // < 42, -17 >
 ap_ufixed<org_wf+exp_gbits-w_Z1+1 -2,-w_Z1+1> exp_Z2_m_1 = Z2 + f_Z2; // < 52, -7 > -> < 50, -7> to save multipliers

 // 2.2 ( Z2 + f(Z2) ) * ( e^Z2P - 1 )
 ap_ufixed<org_wf+exp_gbits-2*w_Z1-w_Z2+2,-2*w_Z1-w_Z2+2> exp_Z1P_m_1_lo = exp_Z2_m_1 * exp_Z2P_m_1; // < 37, -22 >

 // 2.3 e^Z1P - 1
        ap_ufixed<org_wf+exp_gbits-w_Z1+2,-w_Z1+2> exp_Z1P_m_1_l = exp_Z2_m_1 + exp_Z2P_m_1 + exp_Z1P_m_1_lo; // < 53, -6 >
        ((exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 291, __PRETTY_FUNCTION__));
        ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1,-w_Z1+1> exp_Z1P_m_1 = exp_Z1P_m_1_l; // < 50, -7 >

 return exp_Z1P_m_1;
    }

public :
inline __attribute__((always_inline)) pow_traits<double>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&org_wf); _ssdm_SpecConstant(&log_gbits); _ssdm_SpecConstant(&LogMaxPrecision); _ssdm_SpecConstant(&w1); _ssdm_SpecConstant(&w2); _ssdm_SpecConstant(&w3); _ssdm_SpecConstant(&w4); _ssdm_SpecConstant(&w5); _ssdm_SpecConstant(&w6); _ssdm_SpecConstant(&w7); _ssdm_SpecConstant(&w8); _ssdm_SpecConstant(&exp_gbits); _ssdm_SpecConstant(&exp_gbits_Z2); _ssdm_SpecConstant(&w_Z1); }
# 296 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
};

template<typename T>
T pow_generic(T base, T exp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> bs(base);
 fp_struct<T> es(exp);
        const static int we = pow_traits<T>::we;
_ssdm_SpecConstant(&we);
# 305 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int wf = pow_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 306 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int org_wf = pow_traits<T>::org_wf;
_ssdm_SpecConstant(&org_wf);
# 307 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();
    int m_exp = es.expv();

// special cases include:
// x = 0, 1, -1, +inf, -inf, NaN
// y = 0, +inf, -inf, NaN
//
//	y \ x	|	0	|	+1	|	-1	|	inf	|	NaN	|	normal	
// =============================================================================================================
// 	0	|	1	|	1	|	1	|	1	|	1	|	1	
// 	inf	|		|	1	|	1	|		|	NaN	|		
// 	NaN	|	NaN	|	1	|	NaN	|	NaN	|	NaN	|	NaN	
// 	normal	|		|	1	|		|		|	NaN	|		
//
// x < 0 and y is non int, r = NaN
//
    bool y_is_0 = 0;
    bool x_is_1 = 0;
    bool x_is_p1 = 0;
    bool x_is_n1 = 0;
    bool y_is_inf = 0;
    bool y_is_NaN = 0;
    bool x_is_NaN = 0;
    bool x_is_0 = 0;
    bool x_is_inf = 0;
    bool x_is_neg = 0;
    bool y_is_int = 0; // not zero


    if (es.exp == 0)



 y_is_0 = 1;

    if (b_exp == 0 && bs.sig == 0) x_is_1 = 1;
    x_is_p1 = x_is_1 & ~bs.sign[0];
    x_is_n1 = x_is_1 & bs.sign[0];

    if ( ::hls::__isinf(exp) ) y_is_inf = 1;

    if ( ::hls::__isnan(exp) ) y_is_NaN = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if (bs.sign[0]==1 && x_is_0 == 0 && x_is_inf == 0) x_is_neg = 1;

    fp_struct<T> nes = es;
# 380 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
 if ( m_exp >= org_wf ) y_is_int = ~y_is_inf & ~y_is_NaN;
    else if ( m_exp >= 0 && nes.sig(org_wf-1-m_exp,0)==0 ) y_is_int = 1;


// priorities are different for different combinations:
// 1. y = 0 || x = 1 || (x = -1 && y = +/-inf), r = 1
    if ( y_is_0 | x_is_p1 | (x_is_n1 & y_is_inf) ) {
        // out = 1
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }
// 2. y = NaN || x = NaN, r = NaN
    if ( y_is_NaN | x_is_NaN | (x_is_neg & ~y_is_inf & ~y_is_int) ) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

// 3. r = +/-inf or +/-0
//	y \ x	|	+0	|	-0	|	+inf	|	-inf	|	|x|>1	|	|x|<1	
// =============================================================================================================
// 	+inf	|	0	|	0	|	+inf	|	+inf	|	+inf	|	0	
// 	-inf	|	+inf	|	+inf	|	0	|	0	|	0	|	+inf	
//  pos non int	|	0	|	0	|	+inf	|	+inf	|		
//  neg non int	|	+inf	|	+inf	|	0	|	0	|		
//  pos odd int	|	0	|	-0	|       +inf    |       -inf    |		
//  pos even int|	0	|	0	|	+inf	|	+inf	|		
//  neg odd int	|	+inf	|	-inf	|	0	|	-0	|		
//  neg even int|	+inf	|	+inf	|	0	|	0	|		
//
    bool y_is_pinf = 0;
    bool y_is_ninf = 0;
    bool x_abs_greater_1; // use for first 2 rows of the table only
    bool y_is_pos = 0; // use for 1st and 3rd columns of the table only
    bool y_is_odd = 0; // use for 2nd and 4th columns of the table only
    bool r_sign = 0; // use to calculate sgn(x)^y

    y_is_pinf = y_is_inf & ~es.sign[0];
    y_is_ninf = y_is_inf & es.sign[0];

    if (b_exp >= 0) x_abs_greater_1 = 1; else x_abs_greater_1 = 0; // not strongly correct, because +/-1 and NaN are not considered

    if (es.sign[0]==0) y_is_pos = 1; // not strongly correct, because 0, +/-inf and NaN are not considered

    // not strongly correct, assume y_is_int == 1 and m_exp >= 0
    if (m_exp == 0) y_is_odd = 1;
    else if (m_exp > 0 && m_exp <= org_wf) y_is_odd = nes.sig[org_wf-m_exp];

    r_sign = x_is_neg & y_is_odd;
    out.sign[0] = r_sign;

    if ( x_is_n1 ) {
        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }
    if ( (y_is_pinf & x_abs_greater_1) | (y_is_ninf & ~x_abs_greater_1) | (x_is_0 & ~y_is_pos) | (x_is_inf & y_is_pos) ) {
 // out = +/-inf
 //out.sign[0] = r_sign;
 //out.sig = 0;
 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if ( (y_is_pinf & ~x_abs_greater_1) | (y_is_ninf & x_abs_greater_1) | (x_is_0 & y_is_pos) | (x_is_inf & ~y_is_pos) ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


// 1. log|base|
        const static int log_bypass_threshold = wf/2;
_ssdm_SpecConstant(&log_bypass_threshold);
# 456 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
_ssdm_SpecConstant(&LogMaxPrecision);
# 457 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;

    // storing exp and frac of base using int b_exp and ap_ufixed<1+wf+1,1> b_frac
    //int b_exp = bs.expv();
    // initialization is necessary because we are extending the width of b_frac from org_wf to wf
    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
# 483 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
 int FirstBit = nbs.sig[org_wf-1];

    // Y is prenormalized, between 0.75 and 1.5
    b_frac[b_frac.wl()-b_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));

    // the first two bits of b_frac can only be 01 or 10
    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }

    //const ap_ufixed<wf+we+2, 0> LOG2 = 0.69314718055994530941723212145818;
    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0); // The size of the first table




        //ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-1, b_frac.wl()-(1+alpha0));
 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];

        // The first bits of y1 are always a 1, followed by p1 zeros, but
        // it gets dropped later
        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;
        // p_next = p1;

        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 519, __PRETTY_FUNCTION__)); // Check that the first stage zeros out p1 bits.

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1; // Extract a1+b1 from y1.

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);
    //sum = zk*2/(zk+2);

    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;




// 2. mult = m_frac * 2^m_exp = exp * log|base|
    //int m_exp = es.expv();
    ap_fixed<1 + 1 + org_wf, 1 + 1> e_frac = 0;

    //fp_struct<T> nes = es;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(org_wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    ap_fixed<1 + we+1 + wf+org_wf, 1 + we+1> m_frac_l = log_base * e_frac;
    // use f_frac_l instead of m_frac in the exp shift
    //ap_fixed<1 + we+1 + wf, 1 + we+1> m_frac = m_frac_l;


// 3. result = e ^ mult
    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_l = m_frac_l << m_exp; // used for overflow checking only
    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    const static int exp_gbits = pow_traits<T>::exp_gbits;
_ssdm_SpecConstant(&exp_gbits);
# 554 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix;

    // should we remove the if here??
    if ( m_exp >= 0 ) m_fix = m_frac_l << m_exp;
    else m_fix = m_frac_l >> -m_exp;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;

    //assert( (m_fix_back != m_frac_l) || ((r_exp*LOG2_s) < pow(2,we) && (r_exp*LOG2_s) > -pow(2,we)) );// to guarantee not overflow
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 576, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 577, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = pow_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 607 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
_ssdm_SpecConstant(&exp_gbits_Z2);
# 614 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 621, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +/-inf
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = +/-0
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
//    fp_struct<T> out;
    //out.sign[0] = r_sign;
    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static half pow(half base, half exp)
{
 return pow_generic(base,exp);
}
static float pow(float base, float exp)
{
 return pow_generic(base,exp);
}
static double pow(double base, double exp)
{
 return pow_generic(base,exp);
}

static float powf(float base, float exp)
{
 return pow_generic(base,exp);
}

static half half_pow(half base, half exp)
{
 return pow_generic(base,exp);
}

template<typename T>
T powr_generic(T base, T exp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> bs(base);
 fp_struct<T> es(exp);

        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();

// special cases for powr() include:
// x = 0, 1, -1, +inf, -inf, NaN
// y = 0, +inf, -inf, NaN
//
//	y \ x	|	0	|	+1	|	-1	|	inf	|	NaN	|	normal	
// =============================================================================================================
// 	0	|	NaN	|	1	|	NaN	|	NaN	|	NaN	|	1	
// 	inf	|		|	NaN	|	NaN	|		|	NaN	|		
// 	NaN	|	NaN	|	NaN	|	NaN	|	NaN	|	NaN	|	NaN	
// 	normal	|		|	1	|	NaN	|		|	NaN	|		
//
// x < 0 (including -1 and -inf), r = NaN
//
//	y \ x	|	+0	|	-0	|	+inf	|	-inf	|	x>1	|	0<x<1	
// =============================================================================================================
// 	+inf	|	0	|	0	|	+inf	|	NaN	|	+inf	|	0	
// 	-inf	|	+inf	|	+inf	|	0	|	NaN	|	0	|	+inf	
//  pos non int	|	0	|	0	|	+inf	|	NaN	|		
//  neg non int	|	+inf	|	+inf	|	0	|	NaN	|		
//  pos odd int	|	0	|	0	|       +inf    |       NaN	|		
//  pos even int|	0	|	0	|	+inf	|	NaN	|		
//  neg odd int	|	+inf	|	+inf	|	0	|	NaN	|		
//  neg even int|	+inf	|	+inf	|	0	|	NaN	|		
//
    bool y_is_0 = 0;
    bool x_is_0 = 0;
    bool x_is_n0 = 0;
    bool x_is_1 = 0;
    bool y_is_inf = 0;
    bool x_is_inf = 0;
    bool y_is_NaN = 0;
    bool x_is_NaN = 0;
    bool x_is_neg = 0; // including -inf


    if (es.exp == 0)



        y_is_0 = 1;


    if (bs.exp == 0)



                                x_is_0 = 1;
    x_is_n0 = x_is_0 & bs.sign[0];

    if (b_exp == 0 && bs.sig == 0) x_is_1 = 1;

    if ( ::hls::__isinf(exp) ) y_is_inf = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    if ( ::hls::__isnan(exp) ) y_is_NaN = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;

    if (bs.sign[0]==1 && x_is_0 == 0) x_is_neg = 1;

    if ( y_is_NaN | x_is_NaN | x_is_neg | ( ( x_is_0 | x_is_inf ) & y_is_0 ) | ( x_is_1 & y_is_inf ) ) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

    if ( x_is_n0 ) {
 base = -base;
    }

    return pow_generic(base,exp);

}

static half powr(half base, half exp)
{
        return powr_generic(base,exp);
}
static float powr(float base, float exp)
{
        return powr_generic(base,exp);
}
static double powr(double base, double exp)
{
        return powr_generic(base,exp);
}

static float powrf(float base, float exp)
{
        return powr_generic(base,exp);
}

static half half_powr(half base, half exp)
{
        return powr_generic(base,exp);
}

template<typename T>
T pown_generic(T base, int exp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

        fp_struct<T> bs(base);
 ap_fixed<1 + 31, 1 + 31> es = exp;
        const static int we = pow_traits<T>::we;
_ssdm_SpecConstant(&we);
# 807 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int wf = pow_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 808 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int org_wf = pow_traits<T>::org_wf;
_ssdm_SpecConstant(&org_wf);
# 809 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"


        fp_struct<T> out;
        out.sign[0] = 0;
        out.sig = 0;

    int b_exp = bs.expv();

// special cases include:
// x = 0, +inf, -inf, NaN
// y = 0
//
//	y \ x	|	0	|	inf	|	NaN	|	normal	
// =============================================================================
// 	0	|	1	|	1	|	1	|	1	
// 	normal	|		|		|	NaN	|		
//
    bool y_is_0 = 0;
    bool x_is_NaN = 0;

    if ( exp == 0 ) y_is_0 = 1;
    if ( ::hls::__isnan(base) ) x_is_NaN = 1;

    if ( y_is_0 ) {
        // out = 1
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = fp_struct<T>::EXP_BIAS;
        return out.to_ieee();
    }
    if ( x_is_NaN ) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

//	y \ x	|	+0	|	-0	|	+inf	|	-inf	
// =============================================================================
//  pos odd int	|	0	|	-0	|       +inf    |       -inf    
//  pos even int|	0	|	0	|	+inf	|	+inf	
//  neg odd int	|	+inf	|	-inf	|	0	|	-0	
//  neg even int|	+inf	|	+inf	|	0	|	0	
//
    bool x_is_0 = 0;
    bool x_is_inf = 0;
    bool y_is_pos = ~es[31]; // use for 1st and 3rd columns of the table only
    bool y_is_odd = es[0]; // use for 2nd and 4th columns of the table only
    bool x_is_neg = bs.sign[0]; // including -0 and -inf
    bool r_sign = 0; // use to calculate sgn(x)^y


    if (bs.exp == 0)



                                x_is_0 = 1;
    if ( ::hls::__isinf(base) ) x_is_inf = 1;

    r_sign = x_is_neg & y_is_odd;
    out.sign[0] = r_sign;

    if ( (x_is_0 & ~y_is_pos) | (x_is_inf & y_is_pos) ) {
        // out = +/-inf
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if ( (x_is_0 & y_is_pos) | (x_is_inf & ~y_is_pos) ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


// 1. log|base|
        const static int log_bypass_threshold = wf/2;
_ssdm_SpecConstant(&log_bypass_threshold);
# 889 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
_ssdm_SpecConstant(&LogMaxPrecision);
# 890 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;

    // storing exp and frac of base using int b_exp and ap_ufixed<1+wf+1,1> b_frac
    //int b_exp = bs.expv();
    // initialization is necessary because we are extending the width of b_frac from org_wf to wf
    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
# 916 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
 int FirstBit = nbs.sig[org_wf-1];

    // Y is prenormalized, between 0.75 and 1.5
    b_frac[b_frac.wl()-b_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));

    // the first two bits of b_frac can only be 01 or 10
    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }

    //const ap_ufixed<wf+we+2, 0> LOG2 = 0.69314718055994530941723212145818;
    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0); // The size of the first table




        //ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-1, b_frac.wl()-(1+alpha0));
 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];

        // The first bits of y1 are always a 1, followed by p1 zeros, but
        // it gets dropped later
        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;
        // p_next = p1;

        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 952, __PRETTY_FUNCTION__)); // Check that the first stage zeros out p1 bits.

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1; // Extract a1+b1 from y1.

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);
    //sum = zk*2/(zk+2);

    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;




// 2. mult = m_frac * 2^m_exp = exp * log|base|
    ap_fixed<1 + we+31 + wf, 1 + we+31> m_frac_l = log_base * es;


// 3. result = e ^ mult
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_frac_l; // used for overflow checking only

    const static int exp_gbits = pow_traits<T>::exp_gbits;
_ssdm_SpecConstant(&exp_gbits);
# 976 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix = m_frac_l;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;

    //assert( (m_fix_back != m_frac_l) || ((r_exp*LOG2_s) < pow(2,we) && (r_exp*LOG2_s) > -pow(2,we)) );// to guarantee not overflow
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 994, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 995, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = pow_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 1025 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
_ssdm_SpecConstant(&exp_gbits_Z2);
# 1032 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 1039, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( ( m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +/-inf
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = +/-0
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
//    fp_struct<T> out;
    //out.sign[0] = r_sign;
    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static double pown(double base, int exp)
{
        return pown_generic(base,exp);
}

template<typename T>
T rootn_generic(T base, int exp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> bs(base);
 ap_fixed<1 + 31, 1 + 31> es = exp;
        const static int we = pow_traits<T>::we;
_ssdm_SpecConstant(&we);
# 1095 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int wf = pow_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 1096 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int org_wf = pow_traits<T>::org_wf;
_ssdm_SpecConstant(&org_wf);
# 1097 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

    int b_exp = bs.expv();

// special cases include:
// x = 0, 1, -1, +inf, -inf, NaN
// y = 0, 1, -1
//
//	y \ x	|	<0	|	+0	|	-0	|	+inf	|	-inf	|	NaN	|	normal	
// =============================================================================================================================
// 	0	|	NaN	|	NaN	|	NaN	|	NaN	|	NaN	|	NaN	|	NaN	
// 	1/-1	|		|	0/+inf	|	-0/-inf	|	+inf/0	|	-inf/-0	|	NaN	|		
//   +/-others	|	NaN	|	0/+inf	|	NaN	|	+inf/0	|	NaN	|	NaN	|		
//
// x < 0 (including -inf) and 1/y is non int, r = NaN
//
    bool x_is_NaN = 0;
    bool x_is_neg = 0; // including -0 and -inf
    bool x_is_0 = 0;

    if ( ::hls::__isnan(base) ) x_is_NaN = 1;
    if (bs.sign[0]==1) x_is_neg = 1;

    if (bs.exp == 0)



                                x_is_0 = 1;

    if ( (es==0) | x_is_NaN | (x_is_neg & ~x_is_0 & (es!=1) & (es!=-1)) ) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }

    bool x_is_inf = 0;
    bool r_sign = 0; // use to calculate sgn(x)^y

    if ( ::hls::__isinf(base) ) x_is_inf = 1;
    ap_int<2> exp1 = exp;
    r_sign = x_is_neg & ( ~x_is_0 | ( x_is_0 & exp1[0] ) );
    out.sign[0] = r_sign;

    if ( ( x_is_0 & (es<0) ) | ( x_is_inf & (es>0) ) ) {
 // out = +/-inf
 //out.sign[0] = r_sign;
 //out.sig = 0;
 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if ( ( x_is_0 & (es>0) ) | ( x_is_inf & (es<0) ) ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


// 1. log|base|
        const static int log_bypass_threshold = wf/2;
_ssdm_SpecConstant(&log_bypass_threshold);
# 1163 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        const static int LogMaxPrecision = pow_traits<T>::LogMaxPrecision;
_ssdm_SpecConstant(&LogMaxPrecision);
# 1164 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

        typedef typename pow_traits<T>::LOG_TYPE LOG_TYPE;
        LOG_TYPE sum;
        LOG_TYPE log_sum;

    // storing exp and frac of base using int b_exp and ap_ufixed<1+wf+1,1> b_frac
    //int b_exp = bs.expv();
    // initialization is necessary because we are extending the width of b_frac from org_wf to wf
    ap_ufixed<1 + org_wf+1, 1> b_frac = 0;

    fp_struct<T> nbs = bs;
# 1190 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"
 int FirstBit = nbs.sig[org_wf-1];

    // Y is prenormalized, between 0.75 and 1.5
    b_frac[b_frac.wl()-b_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    b_frac(b_frac.wl()-b_frac.iwl()-1,1) = nbs.sig(org_wf-1,0);

    ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-b_frac.iwl()-1, b_frac.wl()-b_frac.iwl()-(1+alpha0));

    // the first two bits of b_frac can only be 01 or 10
    if(FirstBit) {
        b_frac = b_frac >> 1;
        b_exp += 1;
    }

    //const ap_ufixed<wf+we+2, 0> LOG2 = 0.69314718055994530941723212145818;
    const ap_ufixed<wf+we+2, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+we+2, 0> LOG2_lo = 0.60444058366692930952011528220776;
    const ap_ufixed<wf+we+2, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+we+2, 1 + we> Elog2 = LOG2 * b_exp;

    const int T0size = 1 << (1+alpha0); // The size of the first table




        //ap_uint<1+alpha0> index0 = b_frac(b_frac.wl()-1, b_frac.wl()-(1+alpha0));
 ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table_pow<p0,alpha0, T0size>::array[index0];

        log_sum = log0_lut_table<LOG_TYPE,T,p0,alpha0,T0size>::array[index0];

        // The first bits of y1 are always a 1, followed by p1 zeros, but
        // it gets dropped later
        ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;
        // p_next = p1;

        ((b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0) ? static_cast<void> (0) : __assert_fail ("b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 1226, __PRETTY_FUNCTION__)); // Check that the first stage zeros out p1 bits.

        const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
        ap_ufixed<z1_width, -p1> z1 = b_frac1; // Extract a1+b1 from y1.

    ap_fixed<1-log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk;
        zk = pow_traits<T>::log_range_reduction(z1,log_sum);

    ap_fixed<1-2*log_bypass_threshold+1+LogMaxPrecision, -log_bypass_threshold+1> zk_trunc = zk;
    sum = zk-(zk_trunc*zk_trunc/2);
    //sum = zk*2/(zk+2);

    ap_fixed<1 + we + wf, 1 + we> log_base = Elog2 + log_sum + sum;




// 2. mult = m_frac * 2^m_exp = exp * log|base|
    ap_fixed<1 + we + wf+org_wf, 1 + we> m_frac_l = log_base / es;


// 3. result = e ^ mult
    ap_fixed<1 + we + wf+org_wf, 1 + we> m_fix_back = m_frac_l;

    const static int exp_gbits = pow_traits<T>::exp_gbits;
_ssdm_SpecConstant(&exp_gbits);
# 1250 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix = m_frac_l;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<org_wf+exp_gbits+we+1, 0> LOG2_s = LOG2;

    //assert( (m_fix_back != m_frac_l) || ((r_exp*LOG2_s) < pow(2,we) && (r_exp*LOG2_s) > -pow(2,we)) );// to guarantee not overflow
    ap_fixed<1 + we + org_wf+exp_gbits, 1 + we> m_fix_a = r_exp * LOG2_s;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 1268, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 1269, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + org_wf+exp_gbits, 1 -1> m_diff = m_fix - m_fix_a;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = pow_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 1299 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<org_wf+exp_gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int exp_gbits_Z2 = pow_traits<T>::exp_gbits_Z2;
_ssdm_SpecConstant(&exp_gbits_Z2);
# 1306 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h"

    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<org_wf+exp_gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = pow_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + org_wf+exp_gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -org_wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + org_wf+exp_gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_pow.h", 1313, __PRETTY_FUNCTION__));
    ap_ufixed<1 + org_wf+exp_gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( r_exp > fp_struct<T>::EXP_BIAS ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +/-inf
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = +/-0
 //out.sign[0] = r_sign;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = +/-0
        //out.sign[0] = r_sign;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
//    fp_struct<T> out;
    //out.sign[0] = r_sign;
    out.sig(org_wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-org_wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;

    return out.to_ieee();

}

static half rootn(half base, int exp)
{
 return rootn_generic(base,exp);
}
static float rootn(float base, int exp)
{
 return rootn_generic(base,exp);
}
static double rootn(double base, int exp)
{
 return rootn_generic(base,exp);
}

static float rootnf(float base, int exp)
{
 return rootn_generic(base,exp);
}

static half half_rootn(half base, int exp)
{
 return rootn_generic(base,exp);
}

}
# 295 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_fmod_rem_quo.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_fmod_rem_quo.h
 *
 */


namespace fmdrmd{




template <int N,int S>
ap_uint<S+1> rcp_sub(ap_uint<N> d)
{
 ap_uint<N+S+1> b2 = 1;
 b2 <<=(N+S);
 ap_uint<S+1> rst = b2/d;
 return b2/d;
}
template <int N, int S, int E>
ap_uint<N> mod_sub(ap_uint<N> x, ap_uint<N> y, ap_int<E+2> n)
{
 ap_uint <N+1> rem(0);
 ap_uint <N> ret(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 const int LOOPEND = ((1<<E)-2+N-2);
 rem=x;
 i = n;
 for (loop =0; loop < LOOPEND; loop++){
  if(i==0)
   continue;
  i--;
  if(rem >= y)
   rem -=y;
  rem <<=1;
 }
 if(rem >= y)
  rem -=y;
 ret = rem;
 return ret;
}
template <int N, int S, int E>
ap_uint<N> mod_sub_nr2(ap_uint<N> x, ap_uint<N> y, ap_int<E+2> n)
{
 ap_uint <N> ret(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 ap_int <N+1> rem(0);
 ap_uint <N+1> rem2(0);
 ap_uint <1> s;
 i = n;
 rem(N-1,0) = x;
 rem2(N-1,0)= x;
 const int LOOPEND = ((1<<E)-2+N-2);
 for (loop =0; loop < LOOPEND; loop++){
  if(i==0)
   continue;
  i--;
  rem = rem2-y;
  s = rem(N,N);
  if(s==0)
   rem2 = rem;
  rem2 <<=1;
 }
 if(rem2 >= y)
  rem2 -=y;
 ret = rem2;
 return ret;
}
template <int N, int S, int E>
ap_uint<N> mod_rcp_mult(ap_uint<N> r_sh, ap_uint<N> d, ap_int<E+2> n)
{
 const int LOOPEND = ((1<<E)-2+N-2+S-1)/S;
 ap_uint <S+1> rcp;//
 ap_uint <6> shift(0);
 ap_uint <N+1> d2d(0);
 ap_int <E+2> i(0);
 ap_uint <E+1> loop(0);
 ap_uint <N+S+1> quo(0);
 ap_uint <S+1> quoN(0);
 ap_uint <N+S> prdct(0);
 ap_uint <N+S> r_shN(0);
 ap_uint <N+1> rem(0);

 i = n;
 d2d(N,1) = d;
 rcp = rcp_sub<N,S>(d);
//TODO  
//#pragma HLS unroll
 for (loop =0; loop < LOOPEND; loop++){
  if(i > S)
    shift = S;
  else
    shift = i;
     quo = rcp * r_sh;
     quoN = quo>>(N+S - shift);
     prdct = quoN * d;
     r_shN = r_sh;
     r_shN = r_shN << shift;
     rem = r_shN - prdct;
     if(rem>=d2d)
      rem -= d2d;
     if(rem>=d)
      rem -= d;
     r_sh(N-1,0) = rem (N-1,0);
     i -=shift;
 }//end of for
 return r_sh;
}

template <class T>
T generic_fmod_mult(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 const int S = N+12;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_e = fy.exp > fx.exp?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;

 if( (isZ_m_y&& isZ_e_y) ||
    ((isF_e_x)) ||
    ((isF_e_y) && (!isZ_m_y)) ){
    fz.exp = FF_E;
    fz.sig = FF_M;
    return fz.to_ieee();
  }
  if(isyBx_e){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    return fz.to_ieee();
  }else if ((isxEy_e )&&(isyBx_m) ){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    return fz.to_ieee();
  }else if ((isxEy_e)&&(isxEy_m) ){
    fz.exp = 0;
    fz.sig = 0;
    return fz.to_ieee();
  }
  if( isZ_e_x){
    LZ = fx.sig.countLeadingZeros();
    ix = -fx.EXP_BIAS+1 - LZ -1;
    ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
    ap_mx(LZ,0) = 0;
  }else{
    ix = fx.exp - fx.EXP_BIAS;
    ap_mx(M-1,0) = fx.sig;
    ap_mx[M] = 1;
  }
  if( isZ_e_y){
    LZ = fy.sig.countLeadingZeros();
    iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
    ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
    ap_my(LZ,0) = 0;
  }else{
    iy = fy.exp - fy.EXP_BIAS;
    ap_my(M-1,0) = fy.sig;
    ap_my[M] = 1;
  }

  n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
 ap_uint<N+0> r_sh(0);
 r_sh(N-1,0) = ap_mx(N-1,0);
 ap_uint <N> res(0);

 res = mod_rcp_mult<N,S,E>(ap_mx,d,n);

 r_sh = res;
 ap_uint<N+1> ap_mx_2(0);
 ap_mx_2(N-1,0) = (r_sh(N-1,0));

 if(ap_mx_2==0){
   fz.exp = 0;
   fz.sig = 0;
   return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);
 if(iy>= 1-fy.EXP_BIAS){
  fz.exp = iy+fy.EXP_BIAS;
  fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
template <class T>
T generic_fmod(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
  ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
  ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_e = fy.exp > fx.exp?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  return fz.to_ieee();
 }
 if(isyBx_e){
  fz.exp = fx.exp;
  fz.sig = fx.sig;
  return fz.to_ieee();
 }else if ((isxEy_e )&&(isyBx_m) ){
  fz.exp = fx.exp;
  fz.sig = fx.sig;
  return fz.to_ieee();
 }else if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }
 n = ix - iy;
        ap_uint<N> d = ap_my(N-1,0);
        ap_uint<N+1> r_sh(0);
        ap_int<E+2> i;
        r_sh(N-1,0) = ap_mx(N-1,0);
        i = n;

        const int LOOPEND = ((1<<E)-2+M);
        ap_uint<E+1> loop(0);
// TODO
// to be fixed for half
//#pragma HLS unroll
        for (loop =0; loop < LOOPEND; loop++){
                if(r_sh >= d)
                        r_sh = r_sh -d;
                if( i >0 ){
                        r_sh <<=1;
                        i--;
                };
        }//end of for


  ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);
 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
// BEGIN "remainder" --------------------------------------------------------------------------------------------
template <class T>
T generic_remainder(T x, T y)//T ggeneric_remainder_fast_2S(T x, T y)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_1e = (fy.exp-fx.exp)==1?1:0;
 ap_uint<1> isyBx_2e = (fy.exp-fx.exp)>1?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 ap_uint<M+1> sigx_2 ;
 sigx_2(M,1) =fx.sig(M-1,0);
 ap_uint<1> isyBE2x_m = fy.sig >= (sigx_2) ?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  return fz.to_ieee();
 }
 if((isF_e_y)&&(isZ_m_y)){
  fz = fx;
  return fz.to_ieee();
 }
 if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  fz.sign = fx.sign;//If the returned value is 0, it will have the same sign as x
  return fz.to_ieee();

 }else if(isyBx_2e){//(fy.exp-fx.exp)>1?1:0;

  fz.exp = fx.exp;
  fz.sig = fx.sig;
  fz.sign = fx.sign;
  return fz.to_ieee();

 }else if(isyBx_1e){
  if(isZ_e_x)
  {
   if(sigx_2(M-1,0)<= fy.sig){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
   }
  }else if(isyBx_m ){//fy.sig > fx.sig?1:0;
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
  }else if(isxEy_m){//fx.sig == fy.sig?1:0;
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    return fz.to_ieee();
  }
 }else if(isxEy_e && isZ_e_y){
  if (isyBE2x_m){
   fz.exp = fx.exp;
   fz.sig = fx.sig;
   fz.sign = fx.sign;
   return fz.to_ieee();

  }

 }

 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }

 n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
 ap_uint<N+1> d2d(0);
 ap_uint<N+1> r_sh(0);
 ap_uint<1> s_r(fx.sign);
 ap_int<E+2> i;
 ap_uint<1> even(1);
 d2d(N,1) = d(N-1,0);
 const int LOOPEND = ((1<<E)-2+M);
 ap_uint<E+1> loop(0);
 r_sh(N-1,0) = ap_mx(N-1,0);
 i = n;
//TODO 
//To be fixed for float and half
//#pragma HLS unroll
 for (loop =0; loop < LOOPEND; loop++){
  if(i>0){
   i--;
   if(r_sh >= d)
    r_sh = (r_sh -d)<<1;
   else
    r_sh = r_sh<<1;
  }
 }
 if(i==0 && r_sh>=d){
  r_sh -=d;
  even =0;
 }

 ap_uint<N+2> r_sh2 = (r_sh<<1);
 if(n<-1)
 {
  fz = fx;
  return fz.to_ieee();
 }
 if(r_sh2<d){
  ;
 }else if(r_sh2==d){
  if(even==0)
   s_r = 1-s_r;
 }else if(r_sh<d){//but > 1/2 d
  r_sh = d - r_sh;
  s_r = 1-s_r;
 }else if(r_sh>d){//&&n==-1 in fact
  r_sh = d2d - r_sh;
  s_r = 1-s_r;
 }

 fz.sign = s_r;
 ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 iy += i;
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);

 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS ;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy ;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
//remquo-------------------------------------------------------------------------------
template <class T>
T generic_remquo(T x, T y, int* quo)
{
 const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
 const int E = fp_struct<T>::EXP_BITS;
 const int M = W-E-1;
 const int N = M+1;
 fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 fp_struct<T> fz;
 ap_uint<E> FF_E = ((1<<E)-1) ;
 ap_uint<M> FF_M = ((1LL<<(W-E-1))-1) ;
 ap_uint<M+2> ap_mx (0LL) ;
 ap_uint<M+2> ap_my (0LL) ;
 ap_uint<1> isZ_e_x = fx.exp==0?1:0;
 ap_uint<1> isF_e_x = fx.exp==FF_E?1:0;
 ap_uint<1> isN_e_x = (isZ_e_x==0 && isF_e_x==0);
 ap_uint<1> isZ_m_x = fx.sig==0?1:0;
 ap_uint<1> isF_m_x = fx.sig==FF_M?1:0;
 ap_uint<1> isZ_e_y = fy.exp==0?1:0;
 ap_uint<1> isF_e_y = fy.exp==FF_E?1:0;
 ap_uint<1> isN_e_y = (isZ_e_y==0 && isF_e_y==0);
 ap_uint<1> isZ_m_y = fy.sig==0?1:0;
 ap_uint<1> isF_m_y = fy.sig==FF_M?1:0;
 ap_uint<1> isxEy_e = fx.exp == fy.exp?1:0;
 ap_uint<1> isyBx_1e = (fy.exp-fx.exp)==1?1:0;
 ap_uint<1> isyBx_2e = (fy.exp-fx.exp)>1?1:0;
 ap_uint<1> isxEy_m = fx.sig == fy.sig?1:0;
 ap_uint<1> isyBx_m = fy.sig > fx.sig?1:0;
 ap_uint<1> isE_s = fy.sign == fx.sign?1:0;
 ap_uint<M+1> sigx_2 ;
 sigx_2(M,1) =fx.sig(M-1,0);
 ap_uint<1> isyBE2x_m = fy.sig >= (sigx_2) ?1:0;
 fz.sign = fx.sign;
 ap_int<E+1> ix,iy;
 ap_int<E+2> n;
 ap_uint<6> LZ;
 if( (isZ_m_y&& isZ_e_y) ||
  ((isF_e_x)) ||
  ((isF_e_y) && (!isZ_m_y)) ){
  fz.exp = FF_E;
  fz.sig = FF_M;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();
 }
 if((isF_e_y)&&(isZ_m_y)){
  fz = fx;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();
 }
 if ((isxEy_e)&&(isxEy_m) ){
  fz.exp = 0;
  fz.sig = 0;
  fz.sign = fx.sign;//If the returned value is 0, it will have the same sign as x
  *quo = isE_s? 1 : -1;
  return fz.to_ieee();

 }else if(isyBx_2e){//(fy.exp-fx.exp)>1?1:0;

  fz.exp = fx.exp;
  fz.sig = fx.sig;
  fz.sign = fx.sign;
  *quo = isE_s? 0 : -0;
  return fz.to_ieee();

 }else if(isyBx_1e){
  if(isZ_e_x)
  {
   if(sigx_2(M-1,0)<= fy.sig){
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0;
    return fz.to_ieee();
   }
  }else if(isyBx_m ){//fy.sig > fx.sig?1:0;
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0;
    return fz.to_ieee();
  }else if(isxEy_m){//fx.sig == fy.sig?1:0;
    fz.exp = fx.exp;
    fz.sig = fx.sig;
    fz.sign = fx.sign;
    *quo = isE_s? 0 : -0 ;// to be even
    return fz.to_ieee();
  }
 }else if(isxEy_e && isZ_e_y){
  if (isyBE2x_m){
   fz.exp = fx.exp;
   fz.sig = fx.sig;
   fz.sign = fx.sign;
   *quo = isE_s? 0 : -0;
   return fz.to_ieee();
  }
 }

 if( isZ_e_x){
  LZ = fx.sig.countLeadingZeros();
  ix = -fx.EXP_BIAS+1 - LZ -1;
  ap_mx(M,LZ+1) = fx.sig(M-1-LZ,0);
  ap_mx(LZ,0) = 0;
 }else{
  ix = fx.exp - fx.EXP_BIAS;
  ap_mx(M-1,0) = fx.sig;
  ap_mx[M] = 1;
 }
 if( isZ_e_y){
  LZ = fy.sig.countLeadingZeros();
  iy = -fy.EXP_BIAS+1 - fy.sig.countLeadingZeros() -1 ;
  ap_my(M,LZ+1) = fy.sig(M-1-LZ,0);
  ap_my(LZ,0) = 0;
 }else{
  iy = fy.exp - fy.EXP_BIAS;
  ap_my(M-1,0) = fy.sig;
  ap_my[M] = 1;
 }
 n = ix - iy;
 ap_uint<N> d = ap_my(N-1,0);
        ap_uint<N+2> d2d(0);
        ap_uint<N+2> r_sh(0);
        ap_uint<1> s_r(fx.sign);
        ap_int<E+2> i;
        ap_uint<1> even(1);
        ap_uint<3> apq(0);
        ap_uint<E+1> loop(0);
        d2d(N,1) = d(N-1,0);
        r_sh(N-1,0) = ap_mx(N-1,0);
        i = n;//i can be negtive
 const int LOOPEND = ((1<<E)-2+M);
//TODO 
//To be fixed for float and half
//#pragma HLS unroll 	
 for (loop =0; loop < LOOPEND; loop++){
  if(i>0){
   i--;
   if(r_sh >= d){
    r_sh = (r_sh -d)<<1;
    apq[0] = 1;
    apq <<= 1;
   }
   else{
    r_sh = r_sh<<1;
    apq <<=1;
   }
  }
 }
 if(i==0 && r_sh>=d){
  r_sh -=d;
  even =0;
  apq[0] = 1;
 }

 ap_uint<N+2> r_sh2 = (r_sh<<1);
 if(n<-1)
 {
  fz = fx;
  return fz.to_ieee();
 }
 if(r_sh2<d){
  ;
 }else if(r_sh2==d){
  if(even==0){
   s_r = 1-s_r;
   apq+=1;
  }
 }else if(r_sh<d){//but > 1/2 d
  r_sh = d - r_sh;
  s_r = 1-s_r;
  apq+=1;
 }else if(r_sh>d){//&&n==-1 in fact
  r_sh = d2d - r_sh;
  s_r = 1-s_r;
  apq+=1;
 }
 if(isE_s)
  *quo = apq;
 else
  *quo = 0-apq;

 fz.sign = s_r;
 ap_uint<N+1> ap_mx_2(r_sh(N,0));
 if(ap_mx_2==0){
  fz.exp = 0;
  fz.sig = 0;
  return fz.to_ieee();
 }
 iy -= (ap_mx_2.countLeadingZeros()-1);
 iy += i;
 ap_mx_2 = ap_mx_2 << (ap_mx_2.countLeadingZeros()-1);

 if(iy>= 1-fy.EXP_BIAS){
     fz.exp = iy+fy.EXP_BIAS ;
     fz.sig(M-1,0) = ap_mx_2(M-1,0);
 } else {
    n = 1-fy.EXP_BIAS - iy ;
    ap_mx_2 >>= n;
    fz.exp = 0;
    fz.sig(M-1,0) = ap_mx_2(M-1,0);
 }
 return fz.to_ieee();
}
}// name space fmdrmd

static double fmod(double x, double y){
 return fmdrmd::generic_fmod<double>(x,y);
}
static float fmodf(float x, float y){
 return fmdrmd::generic_fmod_mult<float>(x,y);
}
static half half_fmod(half x, half y){
 return fmdrmd::generic_fmod<half>(x,y);
}
static float fmod(float x, float y){
 return hls::fmodf(x,y);
}
static half fmod(half x, half y){
 return hls::half_fmod(x,y);
}

static double remainder(double x, double y){
 return fmdrmd::generic_remainder<double>(x,y);
}
static float remainderf(float x, float y){
 return fmdrmd::generic_remainder<float>(x,y);
}
static half half_remainder(half x, half y){
 return fmdrmd::generic_remainder<half>(x,y);
}
static float remainder(float x, float y){
 return hls::remainderf(x,y);
}
static half remainder(half x, half y){
 return hls::half_remainder(x,y);
}

static double remquo(double x, double y, int* quo){
 return fmdrmd::generic_remquo<double>(x,y, quo);
}
static float remquof(float x, float y, int* quo){
 return fmdrmd::generic_remquo<float>(x,y, quo);
}
static half half_remquo(half x, half y, int* quo){
 return fmdrmd::generic_remquo<half>(x,y, quo);
}
static float remquo(float x, float y, int* quo){
 return hls::remquof(x,y, quo);
}
static half remquo(half x, half y, int* quo){
 return hls::half_remquo(x,y, quo);
}
// divide for Opencl----------------------------------------------------------------
template <class T>
T generic_divide(T x, T y){
        T z;
        z = x/y;
        return z;
}

static
double divide(double x, double y){
        return generic_divide<double>(x,y);
}

static
float dividef(float x, float y){
        return generic_divide<float>(x,y);
}

static
half half_divide(half x, half y){
        return generic_divide<half>(x,y);
}


static
float divide(float x, float y){
        return dividef(x,y);
}
static
half divide(half x, half y){
       return generic_divide<half>(x,y);
}


;
# 296 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_nextafter.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_nextafter.h
 */



template <class T>
T generic_nextafter(T x, T y)
{
  fp_struct<T> fx(x);
 fp_struct<T> fy(y);
 const int E = fp_struct<T>::EXP_BITS;
 const int W = fp_struct<T>::BITS;

 ap_uint<W-1> INF = ((1LL<<E)-1) << (W-1-E);
 ap_uint<1> ap_sx (fx.sign);
 ap_uint<W-1> ap_hx (fx.data()(W-2,0));
 ap_uint<1> ap_sy (fy.sign);
 ap_uint<W-1> ap_hy (fy.data()(W-2,0));
 ap_uint<1> ap_sz (0);
 ap_uint<W-1> ap_hz (0);
 ap_uint<1> sxEsy (ap_sx == ap_sy);
 ap_uint<1> hxEhy (ap_hx == ap_hy);
 ap_uint<1> hxLhy (ap_hx < ap_hy);;
 ap_uint<1> hxBinf(ap_hx > INF);
 ap_uint<1> hyBinf(ap_hy > INF);
 ap_uint<1> hxE0 (ap_hx == 0);
 ap_uint<W-1> ap_hy_p1(ap_hx+1);
 ap_uint<W-1> ap_hy_m1(ap_hx-1);

 /* MUX for sx */
 ap_sz = hyBinf ? ap_sy :// 1) y is NAN (not compliant with linux which return x+y)
   hxBinf ? ap_sx :// 2) only x is NAN (not compliant with linux which return x+y)
   hxEhy & sxEsy ? ap_sy :// 3) x==y
          hxE0 ? ap_sy :// 4) x is +0 or -0 and is not as same as y
                       ap_sx ;// 5) default

 ap_hz = hyBinf ? ap_hy : //1) y is NAN
  hxBinf ? ap_hx : //2) only x is NAN
  hxEhy && sxEsy ? ap_hy : //3) x==y
  hxEhy && (!sxEsy) && hxE0 ? ap_hy : //4) x,y are zero of diff sign
  (!sxEsy) && (!hxE0) ? ap_hy_m1 : //5) x,y are diff number with diff sign
  (!hxEhy) && hxE0 ? ap_hy_p1 : //6) hx is 0 and hy is not,so away from 0
  (!hxEhy) && sxEsy && hxLhy ? ap_hy_p1 : //7) same sign, normal number compare
          ap_hy_m1 ; //8) same sign, normal number compare
 /* assign output */
   fp_struct<T> fz;
   ap_int<W> out;
   fz.sign = ap_sz;
   fz.exp = ap_hz(W-2,W-E-1);
   fz.sig = ap_hz(W-E-2,0);
   return fz.to_ieee();
};

static
double nextafter(double x, double y)
{
 return generic_nextafter<double>(x,y);
}

static
float nextafterf(float x, float y)
{
 return generic_nextafter<float>(x,y);
}

static
half half_nextafter(half x, half y)
{
 return generic_nextafter<half>(x,y);
}


static
float nextafter(float x, float y)
{
 return generic_nextafter<float>(x,y);
}
static
half nextafter(half x, half y)
{
 return generic_nextafter<half>(x,y);
}

;
# 297 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

// Trig functions have 2 different possible implementations.


# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2008-2010 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file cordic.h
 * This file contains the CORDIC function.
 */




//#include "utils/x_hls_defines.h"
//#include "utils/x_hls_utils.h"



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_big_mult.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/




template<int W1, int W2>
void
big_mult_v1(ap_uint<W1> a, ap_uint<W2> b, ap_uint<W1+W2> &c)
{
    c = a * b;
}

template<int M>
void
aca(
    ap_uint<M> a0,
    ap_uint<M> a1,
    ap_uint<M> b0,
    ap_uint<M> b1,
    ap_uint<2*M> c,
    ap_uint<1> cin,
    ap_uint<2*M> &p,
    ap_uint<2> &out)
{
    ap_uint<2*M> p0;
    ap_uint<2*M> p1;
    ap_uint<(2*M)+2> pp0;
    ap_uint<(2*M)+2> pp1;

    p0 = a0 * b0;
    pp0 = p0 + c + cin;
    p1 = a1 * b1;
    pp1 = pp0 + p1;
    p = pp1((2*M)-1,0);
    out = pp1(((2*M)+1),(2*M));
}

template<int M>
void
acb(
    ap_uint<2> x,
    ap_uint<M> y,
    ap_uint<M> &r)
{
    r = x + y;
}

template<int M>
void
cr(
    ap_uint<M> din,
    ap_uint<M> &dout)
{
    dout = din;
}


template<int W, int M>
void
big_mult_v2(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    const int N = (W/M)-1;

    // 1st dim: pipeline stage (including before 1st stage)
    // 2nd dim: W/M breakdown
    ap_uint<2*M> z[N+1][N+1];
    //ap_uint<2*W> z[N+1];

    // 1st dim: pipeline stage
    // 2nd dim: row per stage
    ap_uint<2> ci[N][N+1]; // TODO check this

    for(int i=0; i<N+1; i++) {
        z[0][i] = a(M*(i+1)-1,M*i) * b(M*(i+1)-1,M*i);
        //z[0](2*M*(i+1)-1,2*M*i) = a(M*(i+1)-1,M*i) * b(M*(i+1)-1,M*i);
# 121 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_big_mult.h"
 }

//	m(M-1,0) = z[0][0]; // TODO check this
    for(int i=0; i<N; i++) {
        ci[i][0] = 0;

        ap_uint<M> a0, a1, b0, b1;
        ap_uint<2*M> c, p;
        ap_uint<1> cin;
        ap_uint<2> out;

        for(int j=0; j<N; j++) {
            if(j>=i) {
                a0 = a(M*(j-i+1)-1,M*(j-i));
                b0 = b(M*(j+2)-1,M*(j+1));
                a1 = a(M*(j+2)-1,M*(j+1));
                b1 = b(M*(j-i+1)-1,M*(j-i));
                c = (ap_uint<W>(z[i][j-i+1](M-1,0)),
                         ap_uint<M>(z[i][j-i]((2*M)-1,M)));
                //c     = z[i]((2*M*(j-i+1))+M-1,M*(2*(j-i)+1));
                cin = ci[i][j-i][0]; // TODO check this
                aca<M>(a0,a1,b0,b1,c,cin,p,out);
                ci[i][j-i+1] = out;
                z[i+1][j-i] = p;
                //z[i+1]((2*M*(j-i+1))-1,2*M*(j-i)) = p;
# 161 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_big_mult.h"
 }
        }
        //if((i == N-1) && (j == N-1)) {

        if(i == N-1) {
            //m((M*((2*N)+2-i))-1,M*((2*N)+1-i)) = z[N][0]// Store middle 34-bit result
            //m(M*(N+2)-1,M*(N)) = z[N][0];// Store middle 34-bit result
            m(M*(N+2)-1,M*(N)) = p; // Store middle 34-bit result
            //printf("\nm(%d,%d) = z[%d][0] = %s\n",M*(N+2)-1,M*N,N,z[N][0].to_string(16).c_str());
            //printf("\naca: m(%d,%d) = z[%d][0] = %s\n",M*(N+2)-1,M*N,N,p.to_string(16).c_str());



            //m(,) = p[N+1]// Store middle 34-bit result
        }

        // ACB blocks
        ap_uint<2> x;
        ap_uint<M> y, r;
        x = ci[i][N-i]; // TODO check this, should be good
        y = z[i][N-i]((2*M)-1,M);
        ////y = z[i](M*((2*(j-i))+2)-1,M*((2*N)-i+1));
        ////y = z[i](M*((2*N)-i+2)-1,M*((2*N)-i+1));
        ////y = z[i](M*((2*N)-i+2)-1,M*((2*N)-i+1));
        //y = z[i](M*((2*(N-i))+2)-1,M*((2*(N-i))+1));
        acb<M>(x,y,r);
        m((M*((2*N)+2-i))-1,M*((2*N)+1-i)) = r; // looks right






        // CR blocks
        ap_uint<M> din, dout;
        din = z[i][0]; // TODO check this
        //din = z[i](M-1,0); // TODO check this
        cr<M>(din,dout);
        //m((M*(i+2))-1,M*(i+1)) = dout;
        m((M*(i+1))-1,M*i) = dout; // looks right



    }
}

template<int W, int M>
void
big_mult_v3(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    const int N = (W+M-1)/M; // Take the ceiling of W/M
    // Partial products
    ap_uint<2*M> pp[N][N];
    int i, j;
    for (i = 0; i < N; ++i)
        for (j = 0; j < N; ++j) {
            unsigned Ui = (i == N-1) ? W-1 : M*(i+1)-1;
            unsigned Uj = (j == N-1) ? W-1 : M*(j+1)-1;
            pp[i][j] = a(Ui,M*i) * b(Uj,M*j);
        }

    // Partial product sums
    ap_uint<48> pps[2*N];
    pps[0] = pp[0][0];
    // Add partial products diagonally
    for (i = 1; i < 2*N; ++i) {
        pps[i] = pps[i-1] >> M;
        for (j = 0; j < N; ++j)
            if ((j <= i) && (i-j < N)) {
                pps[i] += pp[j][i-j];
            }
    }

    // Extract out the useful bits
    for (i = 0; i < 2*N; ++i) {
        unsigned Li = M*i;
        if (Li < 2*W) {
            unsigned Ui = M*(i+1)-1;
            if (Ui >= 2*W) { Ui = 2*W-1; }
            m(Ui,Li) = pps[i](M-1, 0);
        }
    }
}

// M is the size of multiplier to decompose into.
template<int W, int W2, int M>
void
big_mult_v3small(
    ap_uint<W> a,
    ap_uint<W2> b,
    ap_uint<W+W2> &m)
{
    const int N = (W+M-1)/M; // Take the ceiling of W/M
    // Partial products
    ap_uint<M+W2> pp[N];
    int i;
    for (i = 0; i < N; ++i) {
        unsigned Ui = (i == N-1) ? W-1 : M*(i+1)-1;
        pp[i] = a(Ui,M*i) * b;
    }

    // Partial product sums
    ap_uint<M+W2> pps[N];
    pps[0] = pp[0];
    // Add partial products
    for (i = 1; i < N; ++i) {
        pps[i] = pps[i-1] >> M;
        pps[i] += pp[i];
    }

    // Extract out the useful bits
    for (i = 0; i < N-1; ++i) {
        unsigned Li = M*i;
        if (Li < W+W2) {
            unsigned Ui = M*(i+1)-1;
            if (Ui >= W+W2) { Ui = W+W2-1; }
            m(Ui,Li) = pps[i](M-1, 0);
        }
    }
    unsigned Li = M*i;
    if (Li < W+W2) {
        // The highest term is larger than the others
        unsigned Ui = W+W2-1;
        m(Ui,Li) = pps[i];//(M-1, 0);
    }
}

template<int SELECT, int W, int M>
void
big_mult(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    switch(SELECT) {
        case 1:
            big_mult_v1(a,b,m);
            break;
        case 2:
            big_mult_v2<W,M>(a,b,m);
            break;
        default:
            big_mult_v3<W,M>(a,b,m);
            break;
    };
}

template<int W, int M>
void
big_mult(
    ap_uint<W> a,
    ap_uint<W> b,
    ap_uint<2*W> &m)
{
    big_mult<3,W,M>(a,b,m);
}


template<int W1, int W2>
void
big_mult(
    ap_uint<W1> a,
    ap_uint<W2> b,
    ap_uint<W1+W2> &m)
{
    if(W2 <= 64) {
        // Decompose into 17x64 multipliers
        big_mult_v3small<W1,W2,17>(a,b,m);
    } else {
        //const int W_MAX =(W1 > W2) ? W1 : W2;
//         const int tmp =(W1 > W2) ? W1 : W2;
//         const int mod = (tmp+ 16)/17;
//         const int W_MAX = 17*mod;

        ap_uint<(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> a_m = a;
        ap_uint<(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> b_m = b;
        ap_uint<2*(17*(((W1 > W2) ? W1 : W2)+ 16)/17)> m_m;
        big_mult<(17*(((W1 > W2) ? W1 : W2)+ 16)/17),17>(a_m,b_m,m_m);

        m = m_m;
    }
}

template <int W1, int I1, int W2, int I2>
void
big_mult(
    ap_ufixed<W1,I1> a,
    ap_ufixed<W2,I2> b,
    ap_ufixed<W1+W2,I1+I2> &m)
{
    ap_uint<W1> ai;
    ap_uint<W2> bi;
    ap_uint<W1+W2> mi;
    ai(W1-1, 0) = a(W1-1, 0);
    bi(W2-1, 0) = b(W2-1, 0);
    big_mult(ai,bi,mi);
    m(W1+W2-1,0) = mi(W1+W2-1,0);
}




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/






# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/




static const ap_uint<100> ref_cordic("9b74eda8435e5a67f5f9092c6",16);

//Q115.397
static const ap_uint<512> ref_4oPi_512("000000000000000000000000000028BE60DB9391054A7F09D5F47D4D377036D8A5664F10E4107F9458EAF7AEF1586DC91B8E909374B801924BBA827464873FBF",16);

/*
* Double-precision calculations
* hi: 400-1-2+( 53-e1+1)    = 451-e1    = 399 (e1=52)
* lo: 400-1-2+(-53-e1-1-p1) = 343-e1-p1 = 281 (e1=52,p1=10)
*
* left-justified alignment
* e1	hi	lo	i	<<
* ----	---	---	---	-------
* 52	399	281	1	0
* 53	398	281	1	1
* 61			1	9
* 179			1	127
* 180			2	0
*
*-------------------------------------------------------------------
* Need to select 119-bits from ~1024 bits.
* 256 bits allows 128-bit selection shifted 128 bits.
* 128-bits is bigger than 119 which we need in the double-precision
* range reduction payne-hanek.
* 128-bits * 10 = 1280 which is > 1024 bits
*-------------------------------------------------------------------
*/
static const ap_uint<256> ref_4oPi_table_256[10] = {
    "0x0000000000000000000000000000000028be60db9391054a7f09d5f47d4d3770",
    "0x28be60db9391054a7f09d5f47d4d377036d8a5664f10e4107f9458eaf7aef158",
    "0x36d8a5664f10e4107f9458eaf7aef1586dc91b8e909374b801924bba82746487",
    "0x6dc91b8e909374b801924bba827464873f877ac72c4a69cfba208d7d4baed121",
    "0x3f877ac72c4a69cfba208d7d4baed1213a671c09ad17df904e64758e60d4ce7d",
    "0x3a671c09ad17df904e64758e60d4ce7d272117e2ef7e4a0ec7fe25fff7816603",
    "0x272117e2ef7e4a0ec7fe25fff7816603fbcbc462d6829b47db4d9fb3c9f2c26d",
    "0xfbcbc462d6829b47db4d9fb3c9f2c26dd3d18fd9a797fa8b5d49eeb1faf97c5e",
    "0xd3d18fd9a797fa8b5d49eeb1faf97c5ecf41ce7de294a4ba9afed7ec47e35742",
    "0xcf41ce7de294a4ba9afed7ec47e357421580cc11bf1edaeafc33ef0826bd0d87",
};

static const ap_uint<100> ref_4oPi_table_100[13] = {
    "0x000000000000000000000028B", // -4
    "0x00000000000000000028BE60D", // -3
    "0x0000000000000028BE60DB939", // -2
    "0x000000000028BE60DB9391054", // -1
    "0x00000028BE60DB9391054A7F0", // 0
    "0x0028BE60DB9391054A7F09D5F", // 1
    "0xBE60DB9391054A7F09D5F47D4", // 2
    "0xDB9391054A7F09D5F47D4D377", // 3
    "0x91054A7F09D5F47D4D377036D", // 4
    "0x4A7F09D5F47D4D377036D8A56", // 5
    "0x09D5F47D4D377036D8A5664F1", // 6
    "0xF47D4D377036D8A5664F10E41", // 7
    "0x4D377036D8A5664F10E417F94", // 8
};

static const ap_uint<80> ref_4oPi_table_80[9] = {
    "0x00000028BE60DB939105", // 0
    "0x0028BE60DB9391054A7F", // 1
    "0xBE60DB9391054A7F09D5", // 2
    "0xDB9391054A7F09D5F47D", // 3
    "0x91054A7F09D5F47D4D37", // 4
    "0x4A7F09D5F47D4D377036", // 5
    "0x09D5F47D4D377036D8A5", // 6
    "0xF47D4D377036D8A5664F", // 7
    "0x4D377036D8A5664F10E4", // 8
};


// Q2.398
static const ap_uint<400> ref_Pio4_400("3243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89452821E638D01377BE5466CF34E90C6CC0A",16);

static const ap_uint<256> ref_Pio4_table[10] = {
    "0x000000000000000000000000000000003243f6a8885a308d313198a2e0370734",
    "0x3243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c8",
    "0x4a4093822299f31d0082efa98ec4e6c89452821e638d01377be5466cf34e90c6",
    "0x9452821e638d01377be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b547091",
    "0xcc0ac29b7c97c50dd3f84d5b5b54709179216d5d98979fb1bd1310ba698dfb5a",
    "0x79216d5d98979fb1bd1310ba698dfb5ac2ffd72dbd01adfb7b8e1afed6a267e9",
    "0xc2ffd72dbd01adfb7b8e1afed6a267e96ba7c9045f12c7f9924a19947b3916cf",
    "0x6ba7c9045f12c7f9924a19947b3916cf70801f2e2858efc16636920d871574e6",
    "0x70801f2e2858efc16636920d871574e69a458fea3f4933d7e0d95748f728eb65",
    "0x9a458fea3f4933d7e0d95748f728eb658718bcd5882154aee7b54a41dc25a59b",
};


template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, half &result, int prescale)
{
    //#pragma HLS inline self off
    fp_struct<half> out;
    out.sign[0] = in[in.wl()-1];

    // Note that when we chop off the sign bit, we don't loose any
    // bits to allow for -MAX to be converted correctly.
    ap_ufixed<W,I> ain = in;
    if(out.__signbit()) {
        ain = -in;
    }

    // Count the leading zeros and shift
    int shift = ain.countLeadingZeros();
    ap_ufixed<W, I> in_shift = ain << shift;

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = (int)fp_struct<half>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<half>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<half>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 153, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 154, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;

    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, half &result, int prescale)
{
    //#pragma HLS inline self off
    fp_struct<half> out;
    out.sign[0] = 0;

    ap_ufixed<W,I> ain = in;

    // Count the leading zeros and shift
    int shift = ain.countLeadingZeros();
    ap_ufixed<W, I> in_shift = ain << shift;

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = (int)fp_struct<half>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<half>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<half>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 191, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 192, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}



template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, float &result, int prescale)
{
    //#pragma HLS inline self off
    fp_struct<float> out;
    out.sign[0] = in[in.wl()-1];

    // Note that when we chop off the sign bit, we don't loose any
    // bits to allow for -MAX to be converted correctly.
    ap_ufixed<W,I> ain = in;

    if(out.__signbit()) {
        ain = -in;
    }

    //const int __hls_parts = (W+15)/16;
    //const int __hls_rem = W - (__hls_parts-1)*16;
    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) > 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 220, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) <= 16", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 221, __PRETTY_FUNCTION__));

    // Chop into 16 bit segments. 
    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;

    // Count the leading zeros in each segment.
    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];




        if(c[i] != 16) {
            break;
        }
    }

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = ((int)fp_struct<float>::EXP_BIAS+in_shift.iwl()-1-prescale-shift);





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<float>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<float>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 269, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 270, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}


template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, float &result, int prescale)
{
    //#pragma HLS inline self off

    fp_struct<float> out;
    out.sign[0] = 0;
    ap_ufixed<W,I> ain = in;

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) > 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 289, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) <= 16", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 290, __PRETTY_FUNCTION__));

    // Chop into 16 bit segments. out_bits[0] includes the MSBs.
    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;

    // Count the leading zeros in each segment.
    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = (int)fp_struct<float>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;





    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<float>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<float>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 334, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 335, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_fixed<W, I> in, double &result, int prescale)
{
    //#pragma HLS inline self off
    fp_struct<double> out;
    out.sign[0] = in[in.wl()-1];

    // Note that when we chop off the sign bit, we don't loose any
    // bits to allow for -MAX to be converted correctly.
    ap_ufixed<W,I> ain = in;

    if(out.__signbit()) {
        ain = -in;
    }

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) > 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 359, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) <= 16", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 360, __PRETTY_FUNCTION__));

    // Chop into 16 bit segments. 
    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;

    // Count the leading zeros in each segment.
    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_ufixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = (int)fp_struct<double>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;
    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<double>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<double>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 399, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 400, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;
    result = out.to_ieee();
}

template <int W, int I>
void scaled_fixed2ieee(ap_ufixed<W, I> in, double &result, int prescale)
{
    //#pragma HLS inline self off
    fp_struct<double> out;
    out.sign[0] = 0;
    ap_ufixed<W,I> ain = in;

    (((W - (((W+15)/16)-1)*16) > 0) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) > 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 417, __PRETTY_FUNCTION__));
    (((W - (((W+15)/16)-1)*16) <= 16) ? static_cast<void> (0) : __assert_fail ("(W - (((W+15)/16)-1)*16) <= 16", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 418, __PRETTY_FUNCTION__));

    // Chop into 16 bit segments.
    ap_uint<32> out_bits[((W+15)/16)] = {};
    for(int i = 0; i < ((W+15)/16)-1; i++) {
        out_bits[i](31, 16) = ain(ain.wl()-16*i-1,
                                  ain.wl()-16*i-16);
        out_bits[i][15] = 1;
    }
    out_bits[((W+15)/16)-1](32-1,32-(W - (((W+15)/16)-1)*16)) = ain(ain.wl()-16*(((W+15)/16)-1)-1,
                                         ain.wl()-16*(((W+15)/16)-1)-(W - (((W+15)/16)-1)*16));
    out_bits[((W+15)/16)-1][32-(W - (((W+15)/16)-1)*16)-1] = 1;

    // Count the leading zeros in each segment.
    int c[((W+15)/16)];
    for(int i = 0; i < ((W+15)/16); i++) {
        c[i] = clz(out_bits[i].to_uint());
    }

    int shift = 0;
    ap_fixed<W, I> in_shift = ain;

    for(int i = 0; i < ((W+15)/16); i++) {
        shift += c[i];
        in_shift = in_shift << c[i];
        if(c[i] != 16) {
            break;
        }
    }

    //    assert(in_shift[W-1] == 1);
    ap_ufixed<W,1> result_mantissa; // Reinterpret the bits as a mantissa.

    int newexp = (int)fp_struct<double>::EXP_BIAS+in_shift.iwl()-1-prescale-shift;
    if(newexp < 0 || in == 0) {
        result_mantissa = 0;
        newexp = 0;
    } else {
        result_mantissa(W-1,0) = in_shift(W-1,0);
        ((newexp<fp_struct<double>::EXP_INFNAN) ? static_cast<void> (0) : __assert_fail ("newexp<fp_struct<double>::EXP_INFNAN", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 457, __PRETTY_FUNCTION__));
        ((newexp>=0) ? static_cast<void> (0) : __assert_fail ("newexp>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/utils/x_hls_float_utils.h", 458, __PRETTY_FUNCTION__));
    }

    // Truncate the implicit one and zero extend, if necessary.
    out.set_mantissa(result_mantissa);
    out.exp = newexp;

    result = out.to_ieee();
}






// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h" 2




/**
 * This function converts ap_uint to float being sure to
 * truncate unnecessary bits off the end and returns the float.
 * Input format is Q1.x
 *
 * @param W The input data width
 */
template<int W>
float
convToFloat(
    ap_uint<W> din)
{
    ap_ufixed<W,1> d;
    d(W-1,0) = din(W-1,0);
    int prescale = 0;
    fp_struct<float> out;
    out.sign[0] = 0; // unsigned

    ap_ufixed<W,1> ain = d;

    ap_uint<32> out_bits_1 = 0, out_bits_2 = 0, out_bits_3 = 0;
    out_bits_1(31, 16) = ain(ain.wl()-1,ain.wl()-16); out_bits_1[15] = 1;
    out_bits_2(31, 16) = ain(ain.wl()-16-1,ain.wl()-32); out_bits_2[15] = 1;
    if(ain.wl() > 48) {
        out_bits_3(31, 16) = ain(ain.wl()-32-1,ain.wl()-48);
    } else {
        out_bits_3(31, 16) = 0xFFFF;
    }
    out_bits_3[15] = 1;

    int c1 = clz(out_bits_1.to_uint());
    int c2 = clz(out_bits_2.to_uint());
    int c3 = clz(out_bits_3.to_uint());
    int shift = c1;

    ap_ufixed<W,1> in_shift = ain << c1;
    if(c1 == 16) {
        shift += c2;
        in_shift = in_shift << c2;
        if(c2 == 16) {
            // FIXME: All these stages may not be necessary
            shift += c3;
            in_shift = in_shift << c3;
        }
    }
    out.sig(fp_struct<float>::SIG_BITS-1,0) =
        in_shift(in_shift.wl()-1-1,
                 in_shift.wl()-fp_struct<float>::SIG_BITS-1);
    out.exp = (din == 0) ? 0 : (fp_struct<float>::EXP_BIAS+in_shift.iwl())-prescale-shift-1;

    return out.to_ieee();
}

/**
 * This function converts ap_ufixed to float being sure to
 * truncate unnecessary bits off the end and returns the float.
 * Input format is Q1.x so ufixed values larger than this will 
 * have the integer bits truncated as well.
 *
 * @param W The input data width
 */
template<int W, int I>
float
convToFloat(
 ap_ufixed<W,I> din)
{
    ap_ufixed<W,1> d;
 d = din;
 ap_uint<W> di;
 di(W-1,0) = d(W-1,0);
 return convToFloat<W>(di);
}


/**
 * This function converts float to ap_uint.
 * Assume W > 53.
 *
 * @param W The input data width
 */
template<int W>
ap_uint<W>
convToInt(
    float din)
{
    fp_struct<float> fps(din);

    ap_uint<W> dout = ((ap_uint<W>)0x1 << 23) | fps.sig;
    dout = dout << (W-24);
    dout = dout >> (-1-fps.expv());






    return dout;
}

/**
 * This function converts ap_uint to double being sure to
 * truncate unnecessary bits off the end and returns the double.
 * Input format is Q1.x
 *
 * @param W The input data width
 */
template<int W>
double
convToDouble(
    ap_uint<W> din)
{
    ap_ufixed<W,1> d;
    d(W-1,0) = din(W-1,0);
    int prescale = 0;
    fp_struct<double> out;
    out.sign[0] = 0;

    ap_ufixed<W,1> ain = d;

    ap_uint<32> out_bits_1 = 0, out_bits_2 = 0, out_bits_3 = 0, out_bits_4 = 0;
    out_bits_1(31, 16) = ain(ain.wl()-1,ain.wl()-16); out_bits_1[15] = 1;
    out_bits_2(31, 16) = ain(ain.wl()-16-1,ain.wl()-32); out_bits_2[15] = 1;
    out_bits_3(31, 16) = ain(ain.wl()-32-1,ain.wl()-48); out_bits_3[15] = 1;
    out_bits_4(31, 16) = ain(ain.wl()-48-1,ain.wl()-64); out_bits_4[15] = 1;

    int c1 = clz(out_bits_1.to_uint());
    int c2 = clz(out_bits_2.to_uint());
    int c3 = clz(out_bits_3.to_uint());
    int c4 = clz(out_bits_4.to_uint());
    int shift = c1;

    ap_ufixed<W,1> in_shift = ain << c1;
    if(c1 == 16) {
        shift += c2;
        in_shift = in_shift << c2;
        if(c2 == 16) {
            // FIXME: All these stages may not be necessary
            shift += c3;
            in_shift = in_shift << c3;
            if(c3 == 16) {
                shift += c4;
                in_shift = in_shift << c4; // leading one is now in the sign bit.
            }
        }
    }
    out.sig(fp_struct<double>::SIG_BITS-1,0) =
        in_shift(in_shift.wl()-1-1,
                 in_shift.wl()-fp_struct<double>::SIG_BITS-1);
    out.exp = (din == 0) ? 0 : (fp_struct<double>::EXP_BIAS+in_shift.iwl())-prescale-shift-1;

    return out.to_ieee();
}

/**
 * This function converts ap_ufixed to double being sure to
 * truncate unnecessary bits off the end and returns the double.
 * Input format is Q1.x so ufixed values larger than this will 
 * have the integer bits truncated as well.
 *
 * @param W The input data width
 */
template<int W, int I>
double
convToDouble(
 ap_ufixed<W,I> din)
{
    ap_ufixed<W,1> d;
 d = din;
 ap_uint<W> di;
 di(W-1,0) = d(W-1,0);
 return convToDouble<W>(di);
}


/**
 * This function converts double to ap_uint.
 * Assume W > 53.
 *
 * @param W The input data width
 */
template<int W>
ap_uint<W>
convToInt(
    double din)
{
    fp_struct<double> fps(din);

    ap_uint<W> dout = ((ap_uint<W>)0x1 << 52) | fps.sig;
    dout = dout << (W-53);
    dout = dout >> (-1-fps.expv());






    return dout;
}

/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for halfs.
 *
 * @param SB Number of mantissa bits (e.g. 10 for half)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate half type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, half dummy)
{
_ssdm_op_SpecResource(ref_4oPi_table_80, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
    ap_int<9> addr = exp+14;
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h", 254, __PRETTY_FUNCTION__));
    ap_uint<80> table_80 = ref_4oPi_table_80[addr >> 4];
    return (table_80 << (ap_uint<4>)(addr(3,0)))(79,80-((2*(SB+1)+p1+3)));
}


/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for floats.
 *
 * @param SB Number of mantissa bits (e.g. 23 for float)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate float type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, float dummy)
{
_ssdm_op_SpecResource(ref_4oPi_table_100, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
    ap_int<9> addr = exp+(1+4*16);
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h", 275, __PRETTY_FUNCTION__));
    ap_uint<100> table_100 = ref_4oPi_table_100[addr >> 4];
    return (table_100 << (ap_uint<4>)(addr(3,0)))(99,100-((2*(SB+1)+p1+3)));
}

/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for doubles.
 *
 * @param SB Number of mantissa bits (e.g. 53 for double)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate float type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi(int exp, double dummy)
{
    ap_uint<2*(SB+1)+p1+3> ret;
    ap_int<12> addr = exp+76;
    ap_uint<256> table_256 = ref_4oPi_table_256[addr(10,7)];
    ret = (table_256 << (ap_uint<7>)(addr(6,0)))(255,256-((2*(SB+1))+p1+3));
    if(addr < 0) {
        ret = 0;
    }
    return ret;
}

/**
 * Payne-hanek algorithm for range reduction (single precision)
 *
 * NOTE: p1 = 10 for double, p1 = 16 for single
 *
 * @param p1 Padding bits
 * @param T data type (float, double)
 * @param din Unreduced data input (float, double)
 * @param k Relevant LSB used to adjust sin/cos identities following reduction
 * @param dout Reduced data output
 */
template<int p1, int CW, class T>
void
range_redux_payne_hanek(
    T din,
    ap_uint<3> &k,
    ap_uint<CW> &dout)
{
    const int EB = fp_struct<T>::EXP_BIAS;
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int exp = fps1.exp - EB;




    if(exp > -1) {
        ap_uint<CW> Pio4_i1; // Relevant bits from Pio4
        ap_uint<CW+1> Pio4_i2; // Relevant bits from Pio4
        ap_uint<SB+1> X; // mantissa (din) in integer format
        ap_uint<2*(SB+1)+p1+3> Med; // significant bits of 4oPi
        ap_uint<3*(SB+1)+p1+3> h; // X*Med
        ap_uint<(SB+1)+3> h_int; // integer portion of h
        ap_uint<CW> h_fract; // fractional portion of h
        ap_uint<2*CW> prod; // h_fract*Pio4
        ap_uint<CW+1> prod_adj;

        Pio4_i1 = ref_Pio4_400(400-1-2,400-1-2-CW+1);
        Pio4_i2 = ref_Pio4_400(400-1-2,400-1-2-(CW+1)+1);

        X = ((ap_uint<SB+1>)0x1 << SB) | (fps1.sig);
        Med = table_lookup_4oPi<SB,p1>(exp,din);

        big_mult(Med, X, h);

        h_int = h >> (2*(SB+1)+p1);
        h_fract = h(2*(SB+1)+p1-1,2*(SB+1)+p1-CW);
        k = h_int(2,0);

        big_mult(h_fract, Pio4_i1, prod);

  prod_adj = prod((2*CW)-1,CW-1);
  prod_adj = (k[0] == 1) ? (ap_uint<CW+1>)(Pio4_i2 - prod_adj) : prod_adj;

  dout = prod_adj(CW,1);
    } else {
        k = 0;
        dout = convToInt<CW>(din);
    }
}

/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for halfs.
 *
 * @param SB Number of mantissa bits (e.g. 10 for half)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate half type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, half dummy)
{
_ssdm_op_SpecResource(ref_4oPi_table_80, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
    ap_int<9> addr = exp+14;
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h", 380, __PRETTY_FUNCTION__));
    ap_uint<80> table_80 = ref_4oPi_table_80[addr >> 4];
    return (table_80 << (ap_uint<4>)(addr(3,0)))(79,80-((2*(SB+1)+p1+3)));
}


/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for floats.
 *
 * @param SB Number of mantissa bits (e.g. 23 for float)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate float type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, float dummy)
{
_ssdm_op_SpecResource(ref_4oPi_table_100, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
    ap_int<9> addr = exp+(1+4*16);
    ((addr >= 0) ? static_cast<void> (0) : __assert_fail ("addr >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h", 401, __PRETTY_FUNCTION__));
    ap_uint<100> table_100 = ref_4oPi_table_100[addr >> 4];
    return (table_100 << (ap_uint<4>)(addr(3,0)))(99,100-((2*(SB+1)+p1+3)));
}

/**
 * This function performs a table lookup to get the relevant values
 * of 4oPi given an exponent value for doubles.
 *
 * @param SB Number of mantissa bits (e.g. 53 for double)
 * @param p1 Padding bits
 * @param exp Exponent value
 * @param dummy dummy value to indicate float type.
 */
template<int SB, int p1>
ap_uint<2*(SB+1)+p1+3>
table_lookup_4oPi_hotbm(int exp, double dummy)
{
    ap_uint<2*(SB+1)+p1+3> ret;
    ap_int<12> addr = exp+76;
    ap_uint<256> table_256 = ref_4oPi_table_256[addr(10,7)];
    ret = (table_256 << (ap_uint<7>)(addr(6,0)))(255,256-((2*(SB+1))+p1+3));
    if(addr < 0) {
        ret = 0;
    }
    return ret;
}

/**
 * Algorithm for trigonometric range reduction, based on the method
 * published by Payne and Hanek.  Basically, this maps an arbitrary
 * range input onto the unit circle.  The output is expressed as the
 * quadrant k and fixed point number in [0,1).
 *
 * The Quadrants k for positive numbers:
 *  2 1
 * 3   0
 * 4   7
 *  5 6
 * The Quadrants k for negative numbers:
 *  5 6
 * 4   7
 * 3   0
 *  2 1
 * NOTE: p1 = 10 for double, p1 = 16 for single
 *
 * @param p1 Padding bits
 * @param T data type (float, double)
 * @param din Unreduced data input (float, double)
 * @param k quadrant of the circle that we are in.
 * @param dout Reduced data output
 */
template<int p1, class T, int W_dout, int W_Mx>
void
range_redux_payne_hanek_hotbm(
    T din,
    ap_uint<3> &k,
    ap_ufixed<W_dout, 0> &dout,
    ap_ufixed<W_Mx, 0> &Mx,
    ap_int<fp_struct<T>::EXP_BITS> &Ex)
{
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int expv = fps1.expv();





    // The primary result of range reduction, with roughly 2*Wf + p1 fractional bits.
    // The 3 least significant integer bits indicate the quadrant of the result.
    ap_ufixed<3*(SB+1)+p1+3,SB+1+3> h_fixed;

    bool closepath = ((fps1.exp) < fp_struct<T>::EXP_BIAS-1);

    if(closepath) {
        Ex = expv+2;
        expv = -2;
    } else {
        Ex = 0;
    }

    {
        ap_uint<SB+1> X; // mantissa (din) in integer format
        ap_uint<2*(SB+1)+p1+3> Med; // significant bits of 4oPi
        ap_uint<3*(SB+1)+p1+3> h; // X*Med
        // Construct the mantissa, Q1.SIG_BITS
        X(fp_struct<T>::SIG_BITS-1,0) = fps1.sig(fp_struct<T>::SIG_BITS-1,0);
        X[fp_struct<T>::SIG_BITS] = 1;
        Med = table_lookup_4oPi_hotbm<SB,p1>(expv,din);
        h = Med * X;
        //big_mult(Med, X, h);
        //reinterpret bits of h.
        h_fixed(h_fixed.wl()-1, 0) = h(h_fixed.wl()-1, 0);
# 504 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h"
 }

    // W_Mx is approximately Wf+g.
    ap_ufixed<W_Mx+p1, 0> Mx_bits = h_fixed; // Mx_bits is not normalized !
    if(closepath) {
        k = 0;
    } else {
        k = h_fixed; // Extract the quadrant from the integer bits of h_fixed.
    }

    // If we're in an odd quadrant, then the base functions need to be flipped.
    if(k[0] == 1) {
        Mx_bits = 1-Mx_bits;
    }

    ap_uint<BitWidth<p1>::Value> Mx_zeros = clz<p1>(Mx_bits);






    // Can't round here, because Mx_bits might round up to one.
    // Probably better to just add more guard bits.
    Mx = ap_ufixed<W_Mx, 0>(Mx_bits << Mx_zeros);
    Ex -= Mx_zeros;
    dout = ap_ufixed<W_dout, 0>(Mx << Ex); // A negative shift!
# 539 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h"
}

/**
 * Algorithm for trigonometric range reduction, based on the method
 * published by Payne and Hanek.  Basically, this maps an arbitrary
 * range input onto the unit circle.  The output is expressed as the
 * quadrant k and fixed point number in [0,1).
 *
 * The Quadrants k for positive numbers:
 *  2 1
 * 3   0
 * 4   7
 *  5 6
 * The Quadrants k for negative numbers:
 *  5 6
 * 4   7
 * 3   0
 *  2 1
 * NOTE: p1 = 10 for double, p1 = 16 for single
 *
 * @param p1 Padding bits
 * @param T data type (float, double)
 * @param din Unreduced data input (float, double)
 * @param k quadrant of the circle that we are in.
 * @param dout Reduced data output
 */
template<int p1, class T, int W_dout, int W_Mx>
void
range_redux_payne_hanek_hotbm_pi(
    T din,
    ap_uint<3> &k,
    ap_ufixed<W_dout, 0> &dout,
    ap_ufixed<W_Mx, 0> &Mx,
    ap_int<fp_struct<T>::EXP_BITS> &Ex,
    int &exactly_pi_over_2)
{
    const int SB = fp_struct<T>::SIG_BITS;

    fp_struct<T> fps1(din);
    int expv = fps1.expv();





    ap_ufixed<3*(SB+1)+p1+3,SB+1+3> h_fixed; // X*Med

    bool closepath = ((fps1.exp) < fp_struct<T>::EXP_BIAS-3);

    if(closepath) {
        Ex = expv+4;
        expv = -4;
    } else {
        Ex = 0;
    }

    {
        ap_uint<SB+1> X; // mantissa (din) in integer format
        ap_uint<2*(SB+1)+p1+3> Med; // significant bits of 4oPi
        ap_uint<3*(SB+1)+p1+3> h; // X*Med
        // Construct the mantissa, Q1.SIG_BITS
        X(fp_struct<T>::SIG_BITS-1,0) = fps1.sig(fp_struct<T>::SIG_BITS-1,0);
        X[fp_struct<T>::SIG_BITS] = 1; // Don't handle subnormals (fps1.exp == 0) ? 0 : 1; // handle subnormals

        h = X;
        h <<= SB+p1+2; //align
        h <<= 2; // Multiply by 4
        h <<= expv;

        //reinterpret bits of h.
        h_fixed(h_fixed.wl()-1, 0) = h(h_fixed.wl()-1, 0);
# 618 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h"
 }

    ap_ufixed<W_Mx+p1, 1> Mx_bits_extended = h_fixed; // Mx_bits is not normalized !
    exactly_pi_over_2 = (Mx_bits_extended == 1);

    ap_ufixed<W_Mx+p1, 0> Mx_bits = h_fixed; // Mx_bits is not normalized !

    if(closepath) {
        k = 0;
    } else {
        k = h_fixed; // Extract the quadrant from the integer bits of h_fixed.
    }

    // If we're in an odd quadrant, then the base functions need to be flipped.
    if(k[0] == 1) {
        Mx_bits = 1-Mx_bits;
    }

    ap_uint<BitWidth<p1>::Value> Mx_zeros = clz<p1>(Mx_bits);






    // Can't round here, because Mx_bits might round up to one.
    // Probably better to just add more guard bits.
    Mx = ap_ufixed<W_Mx, 0>(Mx_bits << Mx_zeros);
    Ex -= Mx_zeros;
    dout = ap_ufixed<W_dout, 0>(Mx << Ex); // A negative shift!
# 656 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_range_redux.h"
}




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 45 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic_tables.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/






static const ap_uint<128> cordic_ctab_table_int_128[128] = {
    "0x3243F6A8885A308D313198A2E0370734",
    "0x1DAC670561BB4F68ADFC88BD978751A0",
    "0xFADBAFC96406EB156DC79EF5F7A217E",
    "0x7F56EA6AB0BDB719644BCC4F9F44477",
    "0x3FEAB76E59FBD38DB2C9E4B7038B835",
    "0x1FFD55BBA97624A84EF3AEEDBB518C4",
    "0xFFFAAADDDB94D5BBE78C564015F760",
    "0x7FFF5556EEEA5CB40311A8FDDF3057",
    "0x3FFFEAAAB7776E52EC4ABEDADB53DF",
    "0x1FFFFD5555BBBBA9729AB7AAC08947",
    "0xFFFFFAAAAADDDDDB94B968067EF3A",
    "0x7FFFFF555556EEEEEA5CA5D895892",
    "0x3FFFFFEAAAAAB777776E52E5356F5",
    "0x1FFFFFFD555555BBBBBBA972972D0",
    "0xFFFFFFFAAAAAAADDDDDDDB94B94B",
    "0x7FFFFFFF55555556EEEEEEEA5CA5",
    "0x3FFFFFFFEAAAAAAAB77777776E52",
    "0x1FFFFFFFFD55555555BBBBBBBBA9",
    "0xFFFFFFFFFAAAAAAAAADDDDDDDDD",
    "0x7FFFFFFFFF5555555556EEEEEEE",
    "0x3FFFFFFFFFEAAAAAAAAAB777777",
    "0x1FFFFFFFFFFD5555555555BBBBB",
    "0xFFFFFFFFFFFAAAAAAAAAAADDDD",
    "0x7FFFFFFFFFFF555555555556EE",
    "0x3FFFFFFFFFFFEAAAAAAAAAAAB7",
    "0x1FFFFFFFFFFFFD555555555555",
    "0xFFFFFFFFFFFFFAAAAAAAAAAAA",
    "0x7FFFFFFFFFFFFF55555555555",
    "0x3FFFFFFFFFFFFFEAAAAAAAAAA",
    "0x1FFFFFFFFFFFFFFD555555555",
    "0xFFFFFFFFFFFFFFFAAAAAAAAA",
    "0x7FFFFFFFFFFFFFFF55555555",
    "0x3FFFFFFFFFFFFFFFEAAAAAAA",
    "0x1FFFFFFFFFFFFFFFFD555555",
    "0xFFFFFFFFFFFFFFFFFAAAAAA",
    "0x7FFFFFFFFFFFFFFFFF55555",
    "0x3FFFFFFFFFFFFFFFFFEAAAA",
    "0x1FFFFFFFFFFFFFFFFFFD555",
    "0xFFFFFFFFFFFFFFFFFFFAAA",
    "0x7FFFFFFFFFFFFFFFFFFF55",
    "0x3FFFFFFFFFFFFFFFFFFFEA",
    "0x1FFFFFFFFFFFFFFFFFFFFD",
    "0xFFFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFFF",
    "0x3FFFFFFFFFFFFF",
    "0x1FFFFFFFFFFFFF",
    "0xFFFFFFFFFFFFF",
    "0x7FFFFFFFFFFFF",
    "0x3FFFFFFFFFFFF",
    "0x1FFFFFFFFFFFF",
    "0xFFFFFFFFFFFF",
    "0x7FFFFFFFFFFF",
    "0x3FFFFFFFFFFF",
    "0x1FFFFFFFFFFF",
    "0xFFFFFFFFFFF",
    "0x7FFFFFFFFFF",
    "0x3FFFFFFFFFF",
    "0x1FFFFFFFFFF",
    "0xFFFFFFFFFF",
    "0x7FFFFFFFFF",
    "0x3FFFFFFFFF",
    "0x1FFFFFFFFF",
    "0xFFFFFFFFF",
    "0x7FFFFFFFF",
    "0x3FFFFFFFF",
    "0x1FFFFFFFF",
    "0xFFFFFFFF",
    "0x7FFFFFFF",
    "0x3FFFFFFF",
    "0x1FFFFFFF",
    "0xFFFFFFF",
    "0x7FFFFFF",
    "0x3FFFFFF",
    "0x1FFFFFF",
    "0xFFFFFF",
    "0x7FFFFF",
    "0x3FFFFF",
    "0x1FFFFF",
    "0xFFFFF",
    "0x7FFFF",
    "0x3FFFF",
    "0x1FFFF",
    "0xFFFF",
    "0x7FFF",
    "0x3FFF",
    "0x1FFF",
    "0xFFF",
    "0x7FF",
    "0x3FF",
    "0x1FF",
    "0xFF",
    "0x7F",
    "0x3F",
    "0x1F",
    "0xF",
    "0x7",
    "0x3",
    "0x1",
    "0x0",
    "0x0",
};

static const ap_ufixed<128,2> cordic_ctab_table_128[128] = {
    "0x0.C90FDAA22168C234C4C6628B80DC1CD0",
    "0x0.76B19C1586ED3DA2B7F222F65E1D4680",
    "0x0.3EB6EBF25901BAC55B71E7BD7DE885F8",
    "0x0.1FD5BA9AAC2F6DC65912F313E7D111DC",
    "0x0.0FFAADDB967EF4E36CB2792DC0E2E0D4",
    "0x0.07FF556EEA5D892A13BCEBBB6ED46310",
    "0x0.03FFEAAB776E5356EF9E31590057DD80",
    "0x0.01FFFD555BBBA972D00C46A3F77CC15C",
    "0x0.00FFFFAAAADDDDB94BB12AFB6B6D4F7C",
    "0x0.007FFFF55556EEEEA5CA6ADEAB02251C",
    "0x0.003FFFFEAAAAB77776E52E5A019FBCE8",
    "0x0.001FFFFFD55555BBBBBA972976256248",
    "0x0.000FFFFFFAAAAAADDDDDDB94B94D5BD4",
    "0x0.0007FFFFFF5555556EEEEEEA5CA5CB40",
    "0x0.0003FFFFFFEAAAAAAB7777776E52E52C",
    "0x0.0001FFFFFFFD5555555BBBBBBBA97294",
    "0x0.0000FFFFFFFFAAAAAAAADDDDDDDDB948",
    "0x0.00007FFFFFFFF555555556EEEEEEEEA4",
    "0x0.00003FFFFFFFFEAAAAAAAAB777777774",
    "0x0.00001FFFFFFFFFD555555555BBBBBBB8",
    "0x0.00000FFFFFFFFFFAAAAAAAAAADDDDDDC",
    "0x0.000007FFFFFFFFFF55555555556EEEEC",
    "0x0.000003FFFFFFFFFFEAAAAAAAAAAB7774",
    "0x0.000001FFFFFFFFFFFD55555555555BB8",
    "0x0.000000FFFFFFFFFFFFAAAAAAAAAAAADC",
    "0x0.0000007FFFFFFFFFFFF5555555555554",
    "0x0.0000003FFFFFFFFFFFFEAAAAAAAAAAA8",
    "0x0.0000001FFFFFFFFFFFFFD55555555554",
    "0x0.0000000FFFFFFFFFFFFFFAAAAAAAAAA8",
    "0x0.00000007FFFFFFFFFFFFFF5555555554",
    "0x0.00000003FFFFFFFFFFFFFFEAAAAAAAA8",
    "0x0.00000001FFFFFFFFFFFFFFFD55555554",
    "0x0.00000000FFFFFFFFFFFFFFFFAAAAAAA8",
    "0x0.000000007FFFFFFFFFFFFFFFF5555554",
    "0x0.000000003FFFFFFFFFFFFFFFFEAAAAA8",
    "0x0.000000001FFFFFFFFFFFFFFFFFD55554",
    "0x0.000000000FFFFFFFFFFFFFFFFFFAAAA8",
    "0x0.0000000007FFFFFFFFFFFFFFFFFF5554",
    "0x0.0000000003FFFFFFFFFFFFFFFFFFEAA8",
    "0x0.0000000001FFFFFFFFFFFFFFFFFFFD54",
    "0x0.0000000000FFFFFFFFFFFFFFFFFFFFA8",
    "0x0.00000000007FFFFFFFFFFFFFFFFFFFF4",
    "0x0.00000000003FFFFFFFFFFFFFFFFFFFFC",
    "0x0.00000000001FFFFFFFFFFFFFFFFFFFFC",
    "0x0.00000000000FFFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000007FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000003FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000001FFFFFFFFFFFFFFFFFFFC",
    "0x0.000000000000FFFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000007FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000003FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000001FFFFFFFFFFFFFFFFFFC",
    "0x0.0000000000000FFFFFFFFFFFFFFFFFFC",
    "0x0.00000000000007FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000003FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000001FFFFFFFFFFFFFFFFFC",
    "0x0.00000000000000FFFFFFFFFFFFFFFFFC",
    "0x0.000000000000007FFFFFFFFFFFFFFFFC",
    "0x0.000000000000003FFFFFFFFFFFFFFFFC",
    "0x0.000000000000001FFFFFFFFFFFFFFFFC",
    "0x0.000000000000000FFFFFFFFFFFFFFFFC",
    "0x0.0000000000000007FFFFFFFFFFFFFFFC",
    "0x0.0000000000000003FFFFFFFFFFFFFFFC",
    "0x0.0000000000000001FFFFFFFFFFFFFFFC",
    "0x0.0000000000000000FFFFFFFFFFFFFFFC",
    "0x0.00000000000000007FFFFFFFFFFFFFFC",
    "0x0.00000000000000003FFFFFFFFFFFFFFC",
    "0x0.00000000000000001FFFFFFFFFFFFFFC",
    "0x0.00000000000000000FFFFFFFFFFFFFFC",
    "0x0.000000000000000007FFFFFFFFFFFFFC",
    "0x0.000000000000000003FFFFFFFFFFFFFC",
    "0x0.000000000000000001FFFFFFFFFFFFFC",
    "0x0.000000000000000000FFFFFFFFFFFFFC",
    "0x0.0000000000000000007FFFFFFFFFFFFC",
    "0x0.0000000000000000003FFFFFFFFFFFFC",
    "0x0.0000000000000000001FFFFFFFFFFFFC",
    "0x0.0000000000000000000FFFFFFFFFFFFC",
    "0x0.00000000000000000007FFFFFFFFFFFC",
    "0x0.00000000000000000003FFFFFFFFFFFC",
    "0x0.00000000000000000001FFFFFFFFFFFC",
    "0x0.00000000000000000000FFFFFFFFFFFC",
    "0x0.000000000000000000007FFFFFFFFFFC",
    "0x0.000000000000000000003FFFFFFFFFFC",
    "0x0.000000000000000000001FFFFFFFFFFC",
    "0x0.000000000000000000000FFFFFFFFFFC",
    "0x0.0000000000000000000007FFFFFFFFFC",
    "0x0.0000000000000000000003FFFFFFFFFC",
    "0x0.0000000000000000000001FFFFFFFFFC",
    "0x0.0000000000000000000000FFFFFFFFFC",
    "0x0.00000000000000000000007FFFFFFFFC",
    "0x0.00000000000000000000003FFFFFFFFC",
    "0x0.00000000000000000000001FFFFFFFFC",
    "0x0.00000000000000000000000FFFFFFFFC",
    "0x0.000000000000000000000007FFFFFFFC",
    "0x0.000000000000000000000003FFFFFFFC",
    "0x0.000000000000000000000001FFFFFFFC",
    "0x0.000000000000000000000000FFFFFFFC",
    "0x0.0000000000000000000000007FFFFFFC",
    "0x0.0000000000000000000000003FFFFFFC",
    "0x0.0000000000000000000000001FFFFFFC",
    "0x0.0000000000000000000000000FFFFFFC",
    "0x0.00000000000000000000000007FFFFFC",
    "0x0.00000000000000000000000003FFFFFC",
    "0x0.00000000000000000000000001FFFFFC",
    "0x0.00000000000000000000000000FFFFFC",
    "0x0.000000000000000000000000007FFFFC",
    "0x0.000000000000000000000000003FFFFC",
    "0x0.000000000000000000000000001FFFFC",
    "0x0.000000000000000000000000000FFFFC",
    "0x0.0000000000000000000000000007FFFC",
    "0x0.0000000000000000000000000003FFFC",
    "0x0.0000000000000000000000000001FFFC",
    "0x0.0000000000000000000000000000FFFC",
    "0x0.00000000000000000000000000007FFC",
    "0x0.00000000000000000000000000003FFC",
    "0x0.00000000000000000000000000001FFC",
    "0x0.00000000000000000000000000000FFC",
    "0x0.000000000000000000000000000007FC",
    "0x0.000000000000000000000000000003FC",
    "0x0.000000000000000000000000000001FC",
    "0x0.000000000000000000000000000000FC",
    "0x0.0000000000000000000000000000007C",
    "0x0.0000000000000000000000000000003C",
    "0x0.0000000000000000000000000000001C",
    "0x0.0000000000000000000000000000000C",
    "0x0.00000000000000000000000000000004",
    "0x0.00000000000000000000000000000000",
    "0x0.00000000000000000000000000000000",
};


static const float cordic_ctab_table_floatdouble_128[128] = {
7.853982e-01,
4.636476e-01,
2.449787e-01,
1.243550e-01,
6.241881e-02,
3.123983e-02,
1.562373e-02,
7.812341e-03,
3.906230e-03,
1.953123e-03,
9.765622e-04,
4.882812e-04,
2.441406e-04,
1.220703e-04,
6.103516e-05,
3.051758e-05,
1.525879e-05,
7.629395e-06,
3.814697e-06,
1.907349e-06,
9.536743e-07,
4.768372e-07,
2.384186e-07,
1.192093e-07,
5.960464e-08,
2.980232e-08,
1.490116e-08,
7.450581e-09,
3.725290e-09,
1.862645e-09,
9.313226e-10,
4.656613e-10,
2.328306e-10,
1.164153e-10,
5.820766e-11,
2.910383e-11,
1.455192e-11,
7.275958e-12,
3.637979e-12,
1.818989e-12,
9.094947e-13,
4.547474e-13,
2.273737e-13,
1.136868e-13,
5.684342e-14,
2.842171e-14,
1.421085e-14,
7.105427e-15,
3.552714e-15,
1.776357e-15,
8.881784e-16,
4.440892e-16,
2.220446e-16,
1.110223e-16,
5.551115e-17,
2.775558e-17,
1.387779e-17,
6.938894e-18,
3.469447e-18,
1.734723e-18,
8.673617e-19,
4.336809e-19,
2.168404e-19,
1.084202e-19,
5.421011e-20,
2.710505e-20,
1.355253e-20,
6.776264e-21,
3.388132e-21,
1.694066e-21,
8.470329e-22,
4.235165e-22,
2.117582e-22,
1.058791e-22,
5.293956e-23,
2.646978e-23,
1.323489e-23,
6.617445e-24,
3.308722e-24,
1.654361e-24,
8.271806e-25,
4.135903e-25,
2.067952e-25,
1.033976e-25,
5.169879e-26,
2.584939e-26,
1.292470e-26,
6.462349e-27,
3.231174e-27,
1.615587e-27,
8.077936e-28,
4.038968e-28,
2.019484e-28,
1.009742e-28,
5.048710e-29,
2.524355e-29,
1.262177e-29,
6.310887e-30,
3.155444e-30,
1.577722e-30,
7.888609e-31,
3.944305e-31,
1.972152e-31,
9.860761e-32,
4.930381e-32,
2.465190e-32,
1.232595e-32,
6.162976e-33,
3.081488e-33,
1.540744e-33,
7.703720e-34,
3.851860e-34,
1.925930e-34,
9.629650e-35,
4.814825e-35,
2.407412e-35,
1.203706e-35,
6.018531e-36,
3.009266e-36,
1.504633e-36,
7.523164e-37,
3.761582e-37,
1.880791e-37,
9.403955e-38,
4.701977e-38,
2.350989e-38,
1.175494e-38,
5.877472e-39,
};

static const float cordic_hyperb_table_floatdouble_128[128] = {
5.493061e-01,
2.554128e-01,
1.256572e-01,
6.258157e-02,
3.126018e-02,
1.562627e-02,
7.812659e-03,
3.906270e-03,
1.953127e-03,
9.765628e-04,
4.882813e-04,
2.441406e-04,
1.220703e-04,
6.103516e-05,
3.051758e-05,
1.525879e-05,
7.629395e-06,
3.814697e-06,
1.907349e-06,
9.536743e-07,
4.768372e-07,
2.384186e-07,
1.192093e-07,
5.960464e-08,
2.980232e-08,
1.490116e-08,
7.450581e-09,
3.725290e-09,
1.862645e-09,
9.313226e-10,
4.656613e-10,
2.328306e-10,
1.164153e-10,
5.820766e-11,
2.910383e-11,
1.455192e-11,
7.275958e-12,
3.637979e-12,
1.818989e-12,
9.094947e-13,
4.547474e-13,
2.273737e-13,
1.136868e-13,
5.684342e-14,
2.842171e-14,
1.421085e-14,
7.105427e-15,
3.552714e-15,
1.776357e-15,
8.881784e-16,
4.440892e-16,
2.220446e-16,
1.110223e-16,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
0.000000e+00,
};


static const ap_ufixed<128,4> cordic_hyperb_table_128[128] = {
"0x0.8c9f53d5681854bb520cc6aa829dbe5",
"0x0.4162bbea0451469c9daf0be0810eda9",
"0x0.202b12393d5deed328cf41ed722d8c9",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.0800aac448d77125a4ee9fee2db3774",
"0x0.04001556222b47263834e958ab3b4ca",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.01000055558888ad1aee1ef93404079",
"0x0.0080000aaaac44448d68e4c64f4d811",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.002000002aaaab11111235a35dc3dc4",
"0x0.001000000555555888888ad1ad1c98c",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0004000000155555562222222b46b46",
"0x0.000200000002aaaaaab1111111235a3",
"0x0.0001000000005555555588888888ad1",
"0x0.0000800000000aaaaaaaac444444448",
"0x0.0000400000000155555555622222222",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.0000100000000005555555555888888",
"0x0.0000080000000000aaaaaaaaaac4444",
"0x0.0000040000000000155555555556222",
"0x0.000002000000000002aaaaaaaaaab11",
"0x0.0000010000000000005555555555558",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000004000000000000155555555555",
"0x0.000000200000000000002aaaaaaaaaa",
"0x0.0000001000000000000005555555555",
"0x0.0000000800000000000000aaaaaaaaa",
"0x0.0000000400000000000000155555555",
"0x0.000000020000000000000002aaaaaaa",
"0x0.0000000100000000000000005555555",
"0x0.0000000080000000000000000aaaaaa",
"0x0.0000000040000000000000000155555",
"0x0.000000002000000000000000002aaaa",
"0x0.0000000010000000000000000005555",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000004000000000000000000155",
"0x0.000000000200000000000000000002a",
"0x0.0000000001000000000000000000005",
"0x0.0000000000800000000000000000000",
"0x0.0000000000400000000000000000000",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000000ffffffffffffffffffff",
"0x0.000000000007fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000001fffffffffffffffffff",
"0x0.000000000000fffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000003ffffffffffffffffff",
"0x0.0000000000001ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.00000000000007fffffffffffffffff",
"0x0.00000000000003fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000000fffffffffffffffff",
"0x0.000000000000007ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000001ffffffffffffffff",
"0x0.000000000000000ffffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000003fffffffffffffff",
"0x0.0000000000000001fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.00000000000000007ffffffffffffff",
"0x0.00000000000000003ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000000ffffffffffffff",
"0x0.000000000000000007fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000001fffffffffffff",
"0x0.000000000000000000fffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000003ffffffffffff",
"0x0.0000000000000000001ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.00000000000000000007fffffffffff",
"0x0.00000000000000000003fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000000fffffffffff",
"0x0.000000000000000000007ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000001ffffffffff",
"0x0.000000000000000000000ffffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000003fffffffff",
"0x0.0000000000000000000001fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.00000000000000000000007ffffffff",
"0x0.00000000000000000000003ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000000ffffffff",
"0x0.000000000000000000000007fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000001fffffff",
"0x0.000000000000000000000000fffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000003ffffff",
"0x0.0000000000000000000000001ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.00000000000000000000000007fffff",
"0x0.00000000000000000000000003fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000000fffff",
"0x0.000000000000000000000000007ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000001ffff",
"0x0.000000000000000000000000000ffff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000003fff",
"0x0.0000000000000000000000000001fff",
"0x0.0000000000000000000000000000fff",
"0x0.00000000000000000000000000007ff",
"0x0.00000000000000000000000000003ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000000ff",
"0x0.000000000000000000000000000007f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000001f",
"0x0.000000000000000000000000000000f",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000003",
"0x0.0000000000000000000000000000001",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
};


static const ap_ufixed<128,4> cordic_hyperb_table_128_160[170] = {
"0x0.8c9f53d5681854bb520cc6aa829dbe5",
"0x0.4162bbea0451469c9daf0be0810eda9",
"0x0.202b12393d5deed328cf41ed722d8c9",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.1005588ad375acdcb1312a563c68525",
"0x0.0800aac448d77125a4ee9fee2db3774",
"0x0.04001556222b47263834e958ab3b4ca",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.020002aab111235a6e87a29f88bb425",
"0x0.01000055558888ad1aee1ef93404079",
"0x0.0080000aaaac44448d68e4c64f4d811",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.004000015555622222b46b4dd0dd6ae",
"0x0.002000002aaaab11111235a35dc3dc4",
"0x0.001000000555555888888ad1ad1c98c",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0008000000aaaaaac4444448d68d69b",
"0x0.0004000000155555562222222b46b46",
"0x0.000200000002aaaaaab1111111235a3",
"0x0.0001000000005555555588888888ad1",
"0x0.0001000000005555555588888888ad1",
"0x0.0000800000000aaaaaaaac444444448",
"0x0.0000400000000155555555622222222",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.000020000000002aaaaaaaab1111111",
"0x0.0000100000000005555555555888888",
"0x0.0000080000000000aaaaaaaaaac4444",
"0x0.0000040000000000155555555556222",
"0x0.0000040000000000155555555556222",
"0x0.000002000000000002aaaaaaaaaab11",
"0x0.0000010000000000005555555555558",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000008000000000000aaaaaaaaaaaa",
"0x0.0000004000000000000155555555555",
"0x0.000000200000000000002aaaaaaaaaa",
"0x0.0000001000000000000005555555555",
"0x0.0000001000000000000005555555555",
"0x0.0000000800000000000000aaaaaaaaa",
"0x0.0000000400000000000000155555555",
"0x0.000000020000000000000002aaaaaaa",
"0x0.000000020000000000000002aaaaaaa",
"0x0.0000000100000000000000005555555",
"0x0.0000000080000000000000000aaaaaa",
"0x0.0000000040000000000000000155555",
"0x0.0000000040000000000000000155555",
"0x0.000000002000000000000000002aaaa",
"0x0.0000000010000000000000000005555",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000008000000000000000000aaa",
"0x0.0000000004000000000000000000155",
"0x0.000000000200000000000000000002a",
"0x0.0000000001000000000000000000005",
"0x0.0000000001000000000000000000005",
"0x0.0000000000800000000000000000000",
"0x0.0000000000400000000000000000000",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000001ffffffffffffffffffff",
"0x0.00000000000ffffffffffffffffffff",
"0x0.000000000007fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000003fffffffffffffffffff",
"0x0.000000000001fffffffffffffffffff",
"0x0.000000000000fffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000007ffffffffffffffffff",
"0x0.0000000000003ffffffffffffffffff",
"0x0.0000000000001ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.0000000000000ffffffffffffffffff",
"0x0.00000000000007fffffffffffffffff",
"0x0.00000000000003fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000001fffffffffffffffff",
"0x0.00000000000000fffffffffffffffff",
"0x0.000000000000007ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000003ffffffffffffffff",
"0x0.000000000000001ffffffffffffffff",
"0x0.000000000000000ffffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000007fffffffffffffff",
"0x0.0000000000000003fffffffffffffff",
"0x0.0000000000000001fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.0000000000000000fffffffffffffff",
"0x0.00000000000000007ffffffffffffff",
"0x0.00000000000000003ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000001ffffffffffffff",
"0x0.00000000000000000ffffffffffffff",
"0x0.000000000000000007fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000003fffffffffffff",
"0x0.000000000000000001fffffffffffff",
"0x0.000000000000000000fffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000007ffffffffffff",
"0x0.0000000000000000003ffffffffffff",
"0x0.0000000000000000001ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.0000000000000000000ffffffffffff",
"0x0.00000000000000000007fffffffffff",
"0x0.00000000000000000003fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000001fffffffffff",
"0x0.00000000000000000000fffffffffff",
"0x0.000000000000000000007ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000003ffffffffff",
"0x0.000000000000000000001ffffffffff",
"0x0.000000000000000000000ffffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000007fffffffff",
"0x0.0000000000000000000003fffffffff",
"0x0.0000000000000000000001fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.0000000000000000000000fffffffff",
"0x0.00000000000000000000007ffffffff",
"0x0.00000000000000000000003ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000001ffffffff",
"0x0.00000000000000000000000ffffffff",
"0x0.000000000000000000000007fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000003fffffff",
"0x0.000000000000000000000001fffffff",
"0x0.000000000000000000000000fffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000007ffffff",
"0x0.0000000000000000000000003ffffff",
"0x0.0000000000000000000000001ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.0000000000000000000000000ffffff",
"0x0.00000000000000000000000007fffff",
"0x0.00000000000000000000000003fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000001fffff",
"0x0.00000000000000000000000000fffff",
"0x0.000000000000000000000000007ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000003ffff",
"0x0.000000000000000000000000001ffff",
"0x0.000000000000000000000000000ffff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000007fff",
"0x0.0000000000000000000000000003fff",
"0x0.0000000000000000000000000001fff",
"0x0.0000000000000000000000000000fff",
"0x0.0000000000000000000000000000fff",
"0x0.00000000000000000000000000007ff",
"0x0.00000000000000000000000000003ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000001ff",
"0x0.00000000000000000000000000000ff",
"0x0.000000000000000000000000000007f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000003f",
"0x0.000000000000000000000000000001f",
"0x0.000000000000000000000000000000f",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000007",
"0x0.0000000000000000000000000000003",
"0x0.0000000000000000000000000000001",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
"0x0.0000000000000000000000000000000",
};



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 46 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h" 2

/**
 * The CORDIC function implements a configurable optimized CORDIC block.
 * The block naturally operates on fixed point data but the input data width and
 * associated number of iterations can be arbitrarily extended.
 *
 *
 */

/* @{ */

namespace cordic
{

template <typename T>
class _const
{
};
template <>
class _const<half>
{
public:
    static const uint16_t zero = 0x0000;
    static const uint16_t pi_4 = 0x3a48;
    static const uint16_t pi_2 = 0x3e48;
    static const uint16_t _3pi_4 = 0x40b6;
    static const uint16_t pi = 0x4248;
};
template <>
class _const<float>
{
public:
    static const uint32_t zero = 0x00000000;
    static const uint32_t pi_4 = 0x3F490FDB;
    static const uint32_t pi_2 = 0x3FC90FDB;
    static const uint32_t _3pi_4 = 0x4016CBE4;
    static const uint32_t pi = 0x40490FDB;

public :
inline __attribute__((always_inline)) _const<float>() { _ssdm_SpecConstant(&zero); _ssdm_SpecConstant(&pi_4); _ssdm_SpecConstant(&pi_2); _ssdm_SpecConstant(&_3pi_4); _ssdm_SpecConstant(&pi); }
# 83 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

template <>
class _const<double>
{
public:
    static const uint64_t zero = 0x0000000000000000;
    static const uint64_t pi_4 = 0x3FE921FB54442D18;
    static const uint64_t pi_2 = 0x3FF921FB54442D18;
    static const uint64_t _3pi_4 = 0x4002D97C7F3321D2;
    static const uint64_t pi = 0x400921FB54442D18;

public :
inline __attribute__((always_inline)) _const<double>() { _ssdm_SpecConstant(&zero); _ssdm_SpecConstant(&pi_4); _ssdm_SpecConstant(&pi_2); _ssdm_SpecConstant(&_3pi_4); _ssdm_SpecConstant(&pi); }
# 94 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

/**
 * Performs selectable add/sub operation.
 *
 * @param a First input variable.
 * @param b Second input variable.
 * @param add Add/sub selector. 1 = add. 0 = subtract.
 *
 * @return Result of addsub operation.
 */
template<int II1, int LAT1, class T2, class T3, class T4>
typename x_traits<T2,T3>::ADD_T addsub(
    T2 a,
    T3 b,
    T4 add)
{
    if(II1 == 0) {
        if(LAT1 == 1) {
_ssdm_op_SpecInterface(0, "ap_none", 1, 1, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
        }
    }
_ssdm_op_SpecLatency(0, LAT1, "");

    typename x_traits<T2,T3>::ADD_T tmp;
    if(add) {
        tmp = a + b;
    } else {
        tmp = a - b;
    }
    return tmp;
}

/**
 * Main CORDIC sub-function (version 1) which performs the shift/addsub operations.
 * K =~ 1.64676
 * MODE 0: 'Rotation' : rotate by angle z.  x' <- K*(x*cos(z) - y*sin(z)), y' <- K*(x*sin(z) + y*cos(z))
 * MODE 1: 'Vectoring': rotate y to zero.   x' <- sqrt(x^2 + y^2)  , z' <- atan(y/x)
 */
template<int N, int MODE, int II1, int LAT1, int W, int I, int W2, int I2>
void cordic_circ_v1(
 ap_fixed<W,I> &x,
 ap_fixed<W,I> &y,
 ap_fixed<W2,I2> &z)
{
_ssdm_InlineSelf(0, "");






    typedef ap_fixed<W,I> T;

    const int n = (N>W) ? W : N;
    const int LAT2 = LAT1/N;

 int k;
 T tx, ty;
    ap_fixed<W2,I2> tz;
 ap_uint<1> d;

 for (k=0; k<n; ++k) {



  if(MODE == 1) {
   d = ~y[W-1];






  } else { // == 0
   d = z[W-1];






  }
  T y_s = y >> k;
  tx = addsub<II1,LAT2>(x, y_s, d);
  T x_s = x >> k;
  ty = addsub<II1,LAT2>(y, x_s, !d);
  ap_fixed<W2,I2,SC_RND> z_s; z_s = cordic_ctab_table_128[k]; // Round here.
  tz = addsub<II1,LAT2>(z, z_s, d);
  x = tx; y = ty; z = tz;
 }





}

/**
 * Main hyperbolic CORDIC sub-function (version 1) which performs the shift/addsub operations.
 * K =~ 0.82816
 * MODE 0: 'Rotation' : rotate by angle z.  x' <- K*(x*cosh(z) + y*sinh(z)), y' <- x*sinh(z) + y*cosh(z)
 * MODE 1: 'Vectoring': rotate y to zero.   x' <- K*sqrt(x^2 - y^2)  , z' <- z+atanh(y/x)
 */
template<int W, int N, int MODE, int II1, int LAT1, class T, class T2>
void cordic_hyperb_v1(
 T &x,
 T &y,
 T2 &z)
{
_ssdm_InlineSelf(0, "");






 const int n = (N>W) ? W : N;
 const int n1 = n + n/4;
 const int LAT2 = LAT1/N;

 int k1;
 T tx, ty;
    T2 tz;
 ap_uint<1> d;

 for (k1=0; k1<n1; ++k1) {
  int k = k1 - (k1/4) + 1;



  if(MODE == 1) {
   d = ~y[n-1];






  } else { // == 0
   d = z[n-1];







  }
  T y_s = y >> k;
  tx = addsub<II1,LAT2>(x, y_s, !d);
  T x_s = x >> k;
  ty = addsub<II1,LAT2>(y, x_s, !d);
  T z_s = cordic_hyperb_table_128[k-1];
  tz = addsub<II1,LAT2>(z, z_s, d);
  x = tx; y = ty; z = tz;
    }





}


template<typename T>
struct cordic_sincos_traits {};

template <>
struct cordic_sincos_traits<double> {
    typedef double T;
    static const int p1 = 61;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 27;
    // For cordic, the # fractional bits we need is SIG_BITS + the
    // number of potential zeros + some guard bits
    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;

public :
inline __attribute__((always_inline)) cordic_sincos_traits<double>() { _ssdm_SpecConstant(&p1); _ssdm_SpecConstant(&g); _ssdm_SpecConstant(&SMALL_ANGLE_THRESHOLD_BITS); _ssdm_SpecConstant(&CW); }
# 271 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

template <>
struct cordic_sincos_traits<float> {
    typedef float T;
    static const int p1 = 29;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 12;
    // For cordic, the # fractional bits we need is SIG_BITS + the
    // number of potential zeros + some guard bits
    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;

public :
inline __attribute__((always_inline)) cordic_sincos_traits<float>() { _ssdm_SpecConstant(&p1); _ssdm_SpecConstant(&g); _ssdm_SpecConstant(&SMALL_ANGLE_THRESHOLD_BITS); _ssdm_SpecConstant(&CW); }
# 282 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

template <>
struct cordic_sincos_traits<half> {
    typedef half T;
    static const int p1 = 12;
    static const int g = 5;
    static const int SMALL_ANGLE_THRESHOLD_BITS = 5;
    // For cordic, the # fractional bits we need is SIG_BITS + the
    // number of potential zeros + some guard bits
    static const int CW = fp_struct<T>::SIG_BITS+SMALL_ANGLE_THRESHOLD_BITS+g;
};

/*
* CORDIC-based sin/cos using payne-hanek range-reduction algorithm
* single-precision float
*/
template <typename T>
void cordic_sincos_generic(T t_in,
                           T &s_out,
                           T &c_out) {
    const int p1 = cordic_sincos_traits<T>::p1;
    const int bits = cordic_sincos_traits<T>::SMALL_ANGLE_THRESHOLD_BITS;
    // For cordic, the # fractional bits we need is SIG_BITS + the
    // number of potential zeros + some guard bits
    const int CW = cordic_sincos_traits<T>::CW;

    fp_struct<T> din(t_in);

 if(din.exp == fp_struct<T>::EXP_INFNAN) { // +inf, -inf, nan
        s_out = hls::nan("");
        c_out = hls::nan("");
        return;
    } else if(din.exp < (fp_struct<T>::EXP_BIAS-bits)) {
        // Small input approximation
        c_out = (T)1.0;
        s_out = t_in;
        return;
    }

    ap_uint<3> k;
    ap_ufixed<CW, 0> fout;
    // Mx could be narrower (~SIG_BITS), but the range reduction function below
    // uses the width of Mx to perform the computation for fout.
    // HOTBM requires more precision from Mx than fout.  For cordic,
    // the situation is reversed.
    ap_ufixed<CW, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex, yprescale;
    range_redux_payne_hanek_hotbm<p1>(t_in,k,fout,Mx,Ex);
    ap_ufixed<CW,0> piover4("0.78539816339744830961566084581987572104929234984377");

    ap_fixed<CW+3,3> x, y, z;
    if(Ex < -bits) {
        x = (T)1.0;
        y = Mx * piover4;
        yprescale = -Ex;



    } else {






        x = ap_fixed<CW+3,3,SC_RND>("0.6072529350088812561694467525116341097505455558743"); // cordic constant
        y = 0;
        // This is a moderately large multiplier.  However, the cordic
        // coefficients could alternatively be scaled by piover4.
        z = fout * piover4;
        cordic_circ_v1<CW+3,0,0,0>(x,y,z);
        yprescale = 0;
    }
# 364 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
 T tmp_s_out, tmp_c_out;
    scaled_fixed2ieee(y, tmp_s_out, yprescale);
    scaled_fixed2ieee(x, tmp_c_out, 0);
    //    T tmp_c_out = x; // this doesn't work!;
# 377 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
 // This could probably be simplified
    int sel = (din.__signbit()) ? 7 - k.to_uint() : k.to_uint();
    switch(sel) {
    case 0:
        s_out = tmp_s_out;
        c_out = tmp_c_out;
        break;
    case 1:
        s_out = tmp_c_out;
        c_out = tmp_s_out;
        break;
    case 2:
        s_out = tmp_c_out;
        c_out = -tmp_s_out;
        break;
    case 3:
        s_out = tmp_s_out;
        c_out = -tmp_c_out;
        break;
    case 4:
        s_out = -tmp_s_out;
        c_out = -tmp_c_out;
        break;
    case 5:
        s_out = -tmp_c_out;
        c_out = -tmp_s_out;
        break;
    case 6:
        s_out = -tmp_c_out;
        c_out = tmp_s_out;
        break;
    case 7:
        s_out = -tmp_s_out;
        c_out = tmp_c_out;
        break;
    default: // case 0
        s_out = tmp_s_out;
        c_out = tmp_c_out;
 }
}



/*
* CORDIC-based sin/cos using payne-hanek range-reduction algorithm

static void
cordic_sincos_generic(
    double t_in,
    double &s_out,
    double &c_out)
{
    const int p1 = 16;
    const int CW = 78;

    fp_struct<double> din(t_in);

    ap_uint<3> k;
	ap_uint<CW> dout;

    range_redux_payne_hanek<p1,CW,double>(t_in,k,dout);

    ap_int<CW> dina1, souta, couta;
    dina1 = dout >> 2;
#ifdef DEBUG
    printf("dout: %s, dina1: %s, k: %d\n",dout.to_string(16).c_str(),dina1.to_string(16).c_str(),k.to_uint());
#endif
	ap_fixed<CW+1,3> x, y, z;
	x.range() = ref_cordic(99,100-CW) >> 2;
	y = 0;
	z.range() = dina1;
	cordic_circ_v1<CW,0,0,0>(x,y,z);
	couta = x.range();
	souta = y.range();
#ifdef DEBUG
    ap_fixed<CW,2> dina1_fxd; dina1_fxd.range() = dina1; double dina1_d = dina1_fxd;
    ap_fixed<CW,2> souta_fxd; souta_fxd.range() = souta; double souta_d = souta_fxd;
    ap_fixed<CW,2> couta_fxd; couta_fxd.range() = couta; double couta_d = couta_fxd;

    std::cout << "dina1: " << std::scientific << dina1_d
              << "(" << dina1_fxd.to_string(16).c_str() << "), "
              << "souta: " << std::scientific << souta_d
              << "(" << souta_fxd.to_string(16).c_str() << "), "
              << "couta: " << std::scientific << couta_d
              << "(" << couta_fxd.to_string(16).c_str() << ")\n";
#endif

    if(dina1 != 0) {
        souta = souta << 1;
        couta = couta << 1;
    } else {
#ifdef DEBUG
        std::cout << "dina1 is all 0s\n";
#endif
        souta = 0;
        couta = ((ap_uint<CW>)0x1 << (CW-1)) - dina1;
    }
    double tmp_s_out, tmp_c_out;
    tmp_s_out = convToDouble<CW>(souta);
    tmp_c_out = convToDouble<CW>(couta);

    int sel = (din.__signbit()) ? 7 - k.to_uint() : k.to_uint();
    switch(sel) {
        case 0:
            s_out =  tmp_s_out;
            c_out =  tmp_c_out;
            break;
        case 1:
            s_out =  tmp_c_out;
            c_out =  tmp_s_out;
            break;
        case 2:
            s_out =  tmp_c_out;
            c_out = -tmp_s_out;
            break;
        case 3:
            s_out =  tmp_s_out;
            c_out = -tmp_c_out;
            break;
        case 4:
            s_out = -tmp_s_out;
            c_out = -tmp_c_out;
            break;
        case 5:
            s_out = -tmp_c_out;
            c_out = -tmp_s_out;
            break;
        case 6:
            s_out = -tmp_c_out;
            c_out =  tmp_s_out;
            break;
        case 7:
            s_out = -tmp_s_out;
            c_out =  tmp_c_out;
            break;
        default: // case 0
            s_out = tmp_s_out;
            c_out = tmp_c_out;
    }

    if(din.exp == fp_struct<double>::EXP_INFNAN) { // +inf, -inf, nan
        s_out = hls::nan("");
        c_out = hls::nan("");
    } else if(din.exp < (fp_struct<double>::EXP_BIAS-25)) {  // exp=-24 -> ulp=3, exp=-25 -> ulp=1
        // small numbers
        c_out = 1.0;
        s_out = t_in;
    }
}
*/

static void sincos(double t_in,
                   double *s,
                   double *c) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}
static double sin(double t_in) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}
static double cos(double t_in) {
    double s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}

static void sincosf( float t_in,
                     float *s,
                     float *c) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}

static float sinf(float t_in) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}

static float cosf(float t_in) {
    float s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}

static void half_sincos(half t_in,
                   half *s,
                   half *c) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    *s = s_out;
    *c = c_out;
}
static half half_sin(half t_in) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return s_out;
}
static half half_cos(half t_in) {
    half s_out, c_out;
    cordic_sincos_generic(t_in, s_out, c_out);
    return c_out;
}

/*
* CORDIC-based atan restricted to range 0 to 1
* single-precision float
*/

template <typename T> struct atan_traits {
};

template <> struct atan_traits<half> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=7;
    // 40 bits of precision requires 4 guard bits.
    static const int GUARD_BITS=4;
    static half div(half y, half x) {
        return y/x;
    }
};
template <> struct atan_traits<float> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=11;
    // 40 bits of precision requires 4 guard bits.
    static const int GUARD_BITS=4;
    static float div(float y, float x) {
        return ((y)/(x));
    }

public :
inline __attribute__((always_inline)) atan_traits<float>() { _ssdm_SpecConstant(&SMALL_ANGLE_THRESHOLD_BITS); _ssdm_SpecConstant(&GUARD_BITS); }
# 610 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};
template <> struct atan_traits<double> {
    static const int SMALL_ANGLE_THRESHOLD_BITS=27;
    // 80 bits of precision requires 5 guard bits.
    static const int GUARD_BITS=5;
    static double div(double y, double x) {
        return ((y)/(x));
    }

public :
inline __attribute__((always_inline)) atan_traits<double>() { _ssdm_SpecConstant(&SMALL_ANGLE_THRESHOLD_BITS); _ssdm_SpecConstant(&GUARD_BITS); }
# 618 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

/*
* CORDIC-based atan
* Assumptions: Range of t_in is [0..1], corresponding to atan(din) in [0..pi/4]
*/
template <typename T>
T atan_generic(T t_in) {
 fp_struct<T> fps1(t_in);

    if(fps1.exp < fp_struct<T>::EXP_BIAS - atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS) {
        // small angle approximation: atan(din) ~= din;



        return t_in;
    }

    // This comes from (approximately, for float):
    // 1) We know that there is a 1 in the first 12 bits, since we're not doing the small angle approximation.
    // 2) After the first 12 bits, we need 24 significant bits for single precision mantissa
    // 3) We know there is going to be some rounding error.  The rounding error is very small after a number
    // of terms, so we can bound this error based on the angle constants in the cordic table.
    // 40 bits of precision requires 4 guard bits.
    // 12 + 24 + 4 = 40.
    const int CW =
        atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS + 1 +
        fp_struct<T>::SIG_BITS +
        atan_traits<T>::GUARD_BITS;

    // The maximum mantissa value is 1.FFFFF...  (basically 2).
    // The maximum value of x or y is sqrt(2*2+1*1)*1.67 ~= 3.73, which requires 2 bits + sign bit.
    // z has a max value of pi/4 ~= .785, so just a sign bit is enough.
 ap_fixed<CW+3,3> x, y;
    ap_fixed<CW+1, 1> z;

 int exp = fps1.expv();
    ap_ufixed<CW+1,1> X = fps1.mantissa();
    // This is a negative shift
 X = X << exp;






 x = 1;
 y = X;
 z = 0;

 cordic_circ_v1<CW+3,1,0,0>(x,y,z);

 return z;//convToFloat<CW,3>(z);
}

/**
 * atan(x) = pi/2 - atan(1/x)
 */
template <typename T>
T atan_cordic(T x) {
 fp_struct<T> xs(x);
 ap_uint<1> neg = xs.sign;
 xs.sign = 0;
 T absx = xs.to_ieee();

    const T pi_over_2 = fp_struct<T>(_const<T>::pi_2).to_ieee();
    const T pi_over_4 = fp_struct<T>(_const<T>::pi_4).to_ieee();
 T res;
    if(xs.exp == fp_struct<T>::EXP_INFNAN) { // +inf, -inf, nan
  if(xs.sig == 0) { // +inf, - inf
            res = pi_over_2;
  } else {
   res = hls::nan("");
  }
 } else if(absx == (T)1.0) {
        // special case for input == 1.0
        res = pi_over_4;
    } else {
        // octant 0 or 1
        bool octant1 = xs.exp >= fp_struct<T>::EXP_BIAS; // (absx > (T)1.0);
        // Range of din is [0..1], corresponding to atan(din) in [0..pi/4]
        T one_over_x = (T)1.0/absx;
        T din = octant1 ? one_over_x : absx;
        res = atan_generic(din);
        if(octant1) {



            // octant 1 : atan(x) = pi/2-atan(din0);
            res = pi_over_2 - res;
        } else {



        }
    }

    fp_struct<T> tmpout(res);
 tmpout.sign = neg;
 return tmpout.to_ieee();;
}

static half half_atan(half t_in) {
 return atan_cordic(t_in);
}
static float atanf(float t_in) {
 return atan_cordic(t_in);
}
static double atan(double t_in) {
 return atan_cordic(t_in);
}


/*
* x_in and y_in are both positive and y_in < x_in
* output is in [0..pi/4]
*/
template <typename T>
T atan2_generic(T y_in, T x_in) {
    // normalize y_in and x_in
    fp_struct<T> fps_x(x_in);
    fp_struct<T> fps_y(y_in);

    // Note that there is some subnormal handling that is probably duplicated
    // in the floating point division core.
    if ( fps_y.exp + atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS < fps_x.exp) {
        // small angle approximation: atan(din) ~= din;



        return atan_traits<T>::div(y_in,x_in);
    }
    if ( fps_y.exp == 0 ) {
        return (T)0;
    }

    // This comes from (approximately, for float):
    // 1) We know that there is a 1 in the first 12 bits, since we're not doing the small angle approximation.
    // 2) After the first 12 bits, we need 24 significant bits for single precision mantissa
    // 3)hls::__isinf(x_in) We know there is going to be some rounding error.  The rounding error is very small after a number
    // of terms, so we can bound this error based on the angle constants in the cordic table.
    // 40 bits of precision requires 4 guard bits.
    // 12 + 24 + 4 = 40.
    const int CW =
        atan_traits<T>::SMALL_ANGLE_THRESHOLD_BITS + 1 +
        fp_struct<T>::SIG_BITS +
        atan_traits<T>::GUARD_BITS;

    // The maximum mantissa value is 1.FFFFF...  (basically 2).
    // The maximum value of x or y is 2*sqrt(2)*1.67 ~= 4.72, which requires 3 bits + sign bit.
    // z has a max value of pi/4 ~= .785, so just a sign bit is enough.
    ap_fixed<CW+4, 4> x, y;
    ap_fixed<CW+1, 1> z;

    // This is the number of bits we need to shift left if
    // both x and y are subnormals, in order to avoid loss of precision
    // int lz = (fps_x.sig | fps_y.sig).countLeadingZeros();

    int d_exp = fps_x.exp - fps_y.exp;
    // Handle shifting correctly if y is subnormal and x is not.

    x=fps_x.mantissa();
    y=fps_y.mantissa();
    //    if (!x_subnormal && y_subnormal) d_exp--;

    y >>= d_exp;
    z = 0;
    //if(both_subnormal) y <<= lz;
    //if(both_subnormal) x <<= lz;

    cordic_circ_v1<CW+3,1,0,0>(x,y,z);

    return z;//convToFloat(z);
}


/*
* x_in and y_in are both positive (first quadrant)
* output is in [0..pi/2]
*/
template<class T>
static T atan2_cordic_Q1(T y_in, T x_in) {
    //#pragma HLS ALLOCATION instances=atan2_generic limit=1 function
    fp_struct<T> fpsx(x_in);
    fp_struct<T> fpsy(y_in);
    if (fpsx.data() == fpsy.data())
        return fp_struct<T>(_const<T>::pi_4).to_ieee();
    else if (y_in > x_in)
        return fp_struct<T>(_const<T>::pi_2).to_ieee() - atan2_generic(x_in, y_in);
    else
        return atan2_generic(y_in, x_in);
}


template<class T>
static T atan2_cordic(T y_in, T x_in) {
    fp_struct<T> fpsx(x_in);
    fp_struct<T> fpsy(y_in);
    if ( hls::__isnan(y_in) || hls::__isnan(x_in) ) { // y or x is NaN
        return hls::nan("");
    }

    // process y or x is zero
    if(fpsy.exp == 0 && fpsy.sig == 0 && fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::pi).to_ieee(), y_in);
    if(fpsy.exp == 0 && fpsy.sig == 0 && ~fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::zero).to_ieee(), y_in);
    if(fpsx.exp == 0 && fpsx.sig == 0 )
        return hls::copysign(fp_struct<T>(_const<T>::pi_2).to_ieee(), y_in);

    // Flush subnormals to zero.
    if(fpsx.exp == 0) { fpsx.sig = 0; }
    if(fpsy.exp == 0) { fpsy.sig = 0; }
    if(fpsy.exp == 0 && fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::pi).to_ieee(), y_in);
    if(fpsy.exp == 0 && ~fpsx.__signbit())
        return hls::copysign(fp_struct<T>(_const<T>::zero).to_ieee(), y_in);
    if(fpsx.exp == 0)
        return hls::copysign(fp_struct<T>(_const<T>::pi_2).to_ieee(), y_in);

    int m = ( (fpsx.sign.to_int() << 1) | fpsy.sign.to_int() ); // m: bit_1: sign of x; bit_0: sign of y

//     if ( fpsy.exp == 0 ) { // y = +-0 or subnormal
//         switch(m) {
//             case 0: return fp_struct<T>(_const<T>::zero).to_ieee();                         // atan2(+0, +x) = +0
//             case 1: return -fp_struct<T>(_const<T>::zero).to_ieee();                        // atan2(-0, +x) = -0
//             case 2: return fp_struct<T>(_const<T>::pi).to_ieee();                           // atan2(+0, -x) = pi
//             case 3: return -fp_struct<T>(_const<T>::pi).to_ieee();                          // atan2(-0, -x) = -pi
//         }
//     } else if ( fpsx.exp == 0 ) { // x = +-0 or subnormal, y != 0
//         switch(m&1) {
//             case 0: return fp_struct<T>(_const<T>::pi_2).to_ieee();                         // atan2(+y, +-0) = pi/2
//             case 1: return -fp_struct<T>(_const<T>::pi_2).to_ieee();                        // atan2(-y, +-0) = -pi/2
//         }
//     } else
    if ( hls::__isinf(x_in) && hls::__isinf(y_in) ) { // x, y = +-INF
        switch(m) {
            case 0: return fp_struct<T>(_const<T>::pi_4).to_ieee(); // atan2(+INF, +INF) = pi/4
            case 1: return -fp_struct<T>(_const<T>::pi_4).to_ieee(); // atan2(-INF, +INF) = -pi/4
            case 2: return fp_struct<T>(_const<T>::_3pi_4).to_ieee(); // atan2(+INF, -INF) = 3*pi/4
            case 3: return -fp_struct<T>(_const<T>::_3pi_4).to_ieee(); // atan2(-INF, -INF) = -3*pi/4
        }
    } else if ( hls::__isinf(x_in) ) { // x = +- INF, y != +- INF
        switch(m) {
            case 0: return fp_struct<T>(_const<T>::zero).to_ieee(); // atan2(+y, +INF) = +0
            case 1: return -fp_struct<T>(_const<T>::zero).to_ieee(); // atan2(-y, +INF) = -0
            case 2: return fp_struct<T>(_const<T>::pi).to_ieee(); // atan2(+y, -INF) = pi
            case 3: return -fp_struct<T>(_const<T>::pi).to_ieee(); // atan2(-y, -INF) = -pi
        }
    } else if ( hls::__isinf(y_in) ) { // y = +- INF, x != +- INF
        switch(m&1) {
            case 0: return fp_struct<T>(_const<T>::pi_2).to_ieee(); // atan2(+INF, +-x) = pi/2
            case 1: return -fp_struct<T>(_const<T>::pi_2).to_ieee(); // atan2(-INF, +-x) = -pi/2
        }
    } else { // x, y != +-INF
        T a = hls::abs(y_in);
        T b = hls::abs(x_in);
        T c = atan2_cordic_Q1(a,b);
        T d = fp_struct<T>(_const<T>::pi).to_ieee() - c;
        switch(m) {
            case 0: // quadrant I
                return c; //atan2_cordic_floatdouble(y_in, x_in);
            case 1: // quadrant IV
                return -c; //-atan2_cordic_floatdouble(-y_in, x_in);
            case 2: // quadrant II
                return d; //fp_struct<T>(_const<T>::pi).to_ieee() - atan2_cordic_floatdouble(y_in, -x_in);
            case 3: // quadrant III
                return -d; //atan2_cordic_floatdouble(-y_in, -x_in) - fp_struct<T>(_const<T>::pi).to_ieee();
        }
    }
    return 0;
}

static half
half_atan2(half y_in, half x_in) {
    return atan2_cordic(y_in, x_in);
}

static float
atan2f(float y_in, float x_in) {
    return atan2_cordic(y_in, x_in);
}

static double
atan2(double y_in, double x_in) {
    return atan2_cordic(y_in, x_in);
}


template <typename T> struct hyperbolic_traits {
    /*
     * H_INT_MAX: maximum value for which sinh(x) = inf. float(7), double(9), theoretical(11)
     * Basically: ceil(log2(H_MAX_INPUT));
     * H_DEC_MIN: minimum value fo rwhich sinh(x) = x.   float(-12), double(-28)
     * N: Fractional bits of precision for cordic.  ~SIG_BITS + H_DEC_MIN + guard bits.
     */
};

template <> struct hyperbolic_traits<half> {
    // max = 65504.  asinh(65504) ~= 11.783.
    static const typename fp_struct<half>::inttype H_MAX_INPUT = 0x49e4; // 11.783013669079;
    static const int H_INT_MAX = 4;
    static const int H_DEC_MIN = 5;
    static const int N = fp_struct<half>::SIG_BITS + H_DEC_MIN + 2;
};
template <> struct hyperbolic_traits<float> {
    static const typename fp_struct<float>::inttype H_MAX_INPUT = 0x42b2d4fc; // 710.48;
    static const int H_INT_MAX = 7;
    static const int H_DEC_MIN = 12;
    static const int N = fp_struct<float>::SIG_BITS + H_DEC_MIN + 4;

public :
inline __attribute__((always_inline)) hyperbolic_traits<float>() { _ssdm_SpecConstant(&H_MAX_INPUT); _ssdm_SpecConstant(&H_INT_MAX); _ssdm_SpecConstant(&H_DEC_MIN); _ssdm_SpecConstant(&N); }
# 928 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};
template <> struct hyperbolic_traits<double> {
    static const typename fp_struct<double>::inttype H_MAX_INPUT = 0x408633ce8fb9f87d; // asinh(std::numeric_limits<double>::max());
    static const int H_INT_MAX = 10;
    static const int H_DEC_MIN = 28;
    static const int N = fp_struct<double>::SIG_BITS + H_DEC_MIN + 5;

public :
inline __attribute__((always_inline)) hyperbolic_traits<double>() { _ssdm_SpecConstant(&H_MAX_INPUT); _ssdm_SpecConstant(&H_INT_MAX); _ssdm_SpecConstant(&H_DEC_MIN); _ssdm_SpecConstant(&N); }
# 934 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
};

/**
 * Range reduces input to between 0 and ln2 by
 * solving for k and r in x = k*ln2 + r, where x = t_in.
 *
 * Theoretical max value of x is 710.48 where any larger value gives sinh(x) = inf
 * In practcie, for sinhf(float), x,max < 2^7 and sinh(double), x,max < 2^9
 *
 * k = (int)(x/ln2); k,max = 1025 (11 bits)
 * y = (dec)(x/ln2)*ln2
 *
 * If t_in > X, the final sinh/cosh result will be inf so we set k = 130 to indicate
 * that downstream.
 *
 * H_INT_MAX: maximum value for which sinh(x) = inf. float(7), double(9), theoretical(11)
 * H_DEC_MIN: minimum value fo rwhich sinh(x) = x.   float(-12), double(-28)
 * k,max = x,max/ln2 or approx x,width+1
 *
 * Assumptions:
 * T is a floating point type.
 * 0 < t <= H_MAX_INPUT
 */
template<typename T>
void hyperb_range_redux(
 T t,
 ap_uint<hyperbolic_traits<T>::H_INT_MAX+1> &k,
 ap_ufixed<hyperbolic_traits<T>::N,0> &t_out)
{
 fp_struct<T> ts(t);

    const int F1 = hyperbolic_traits<T>::N;
 const int I1 = hyperbolic_traits<T>::H_INT_MAX;
 const int W1 = I1 + F1;

 ap_ufixed<W1,I1> t_f = ts.mantissa();
    // May be negative shift
 t_f <<= ts.expv();

 ap_ufixed<F1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0"); // ~= 1.44269;
 ap_ufixed<F1,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4"); //~= 0.693147

 ap_ufixed<W1+F1,I1+1> prod;
 big_mult(t_f, inv_ln2, prod);

    // Strip off the integer bits and the fractional bits.
    k = prod;
 ap_ufixed<F1,0> prod_dec = prod;

 ap_ufixed<2*(F1),0> tmp_t_out;
 big_mult(prod_dec, ln2, tmp_t_out);
 t_out = tmp_t_out;
# 1002 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
}


template <typename T>
void sinh_cosh_range_redux_cordic(
 T d,
 T &s_out,
 T &c_out)
{
    fp_struct<T> ds(d);
    // Record the sign of the input and force it to be positive.
    bool sign = ds.sign;
    ds.sign = 0;

    if(ds.to_ieee() > fp_struct<T>(hyperbolic_traits<T>::H_MAX_INPUT).to_ieee()) {
        // input is large, return infinity
        ds.exp = fp_struct<T>::EXP_INFNAN;
        ds.sig = 0;
        ds.sign = sign;
        s_out = ds.to_ieee();
        ds.sign = 0;
        c_out = ds.to_ieee();
        return;
    } else if(ds.exp == fp_struct<T>::EXP_INFNAN) { // +inf, -inf, nan
        // if the input is infinity or nan, then the output corresponds
        ds.sign = sign;
        s_out = ds.to_ieee();
        ds.sign = 0;
        c_out = ds.to_ieee();
        return;
 } else if(ds.exp < (fp_struct<T>::EXP_BIAS - hyperbolic_traits<T>::H_DEC_MIN)) {
        // if input is small, return the input.
        s_out = d;
  c_out = (T)1.0;
        return;
    }

 ap_uint<hyperbolic_traits<T>::H_INT_MAX+1> k;
 ap_ufixed<hyperbolic_traits<T>::N,0> r;
 hyperb_range_redux(d, k, r);

 const int N = hyperbolic_traits<T>::N;

 ap_fixed<N,2> tmp_x(1.0/8.28133692173427360395e-01);
 ap_fixed<N,2> tmp_y(0);
 ap_fixed<N,2> tmp_z(r);
 cordic_hyperb_v1<N,N,0,0,0>(tmp_x,tmp_y,tmp_z);
 T x = tmp_x; // ~cosh(r);
 T y = tmp_y; // ~sinh(r);
# 1068 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
 T two_p_plus_k, two_p_minus_k;
    // extra -1 in the exponent, since we want to compute
    // (exp(k*ln(2)) +- exp(-k*ln(2)))/2 = (2^k +- 2^-k)/2 = 2^(k-1) +- 2^(-k-1)
 unsigned int pos_exp = (int)(k+fp_struct<T>::EXP_BIAS-1);
 unsigned int neg_exp = (k >= fp_struct<T>::EXP_BIAS) ? 0 : (int)(-k+fp_struct<T>::EXP_BIAS-1);
    fp_struct<T> two_p_plus_s((typename fp_struct<T>::inttype)0);
    fp_struct<T> two_p_minus_s((typename fp_struct<T>::inttype)0);
    two_p_plus_s.exp = pos_exp;
    two_p_minus_s.exp = neg_exp;
 two_p_plus_k = two_p_plus_s.to_ieee();
 two_p_minus_k = two_p_minus_s.to_ieee();

 T sinhkln2 = two_p_plus_k - two_p_minus_k;
 T coshkln2 = two_p_plus_k + two_p_minus_k;

    // based on the half angle identity for sinh/cosh, and t = k*ln2 + 2;
 T s_out_tmp = coshkln2*y + sinhkln2*x;
 T c_out_tmp = coshkln2*x + sinhkln2*y;
# 1111 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_cordic.h"
 fp_struct<T> s_fp(s_out_tmp);
    fp_struct<T> c_fp(c_out_tmp);
 s_fp.sign = sign;
 c_fp.sign = 0;

 s_out = s_fp.to_ieee();
 c_out = c_fp.to_ieee();

}



static half half_sinh(half t_in) {
 half s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static half half_cosh(half t_in) {
 half s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}

static float sinhf(float t_in) {
 float s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static float coshf(float t_in) {
 float s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}

static double sinh(double t_in) {
 double s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return s_out;
}

static double cosh(double t_in) {
 double s_out, c_out;
 sinh_cosh_range_redux_cordic(t_in,s_out,c_out);
 return c_out;
}


} // namespace

/* @}*/




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 300 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_hotbm.h
 * An implementation of sin/cos, based on the HOTBM method published by
 * Detrey and deDinechin, "Floating-point Trigonometric Functions for FPGAs"
 */
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
namespace hotbm
{



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm_tables.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm_tables.h" 2

namespace second_order_float {
// Tables for f= 1 - cos((pi) / 4 * x)
//  K0  estimated  -1  integer bits.
static const ap_fixed< 29 , 0 > cos_K0 [ 128 ] = {
"0", "0x1.3bdp-16", "0x4.ef48p-16", "0xb.1a6p-16", "0x1.3bcf8p-12", "0x1.ed71p-12", "0x2.c688p-12", "0x3.c7128p-12",
"0x4.ef0ep-12", "0x6.3e78p-12", "0x7.b54dp-12", "0x9.53898p-12", "0xb.19298p-12", "0xd.06288p-12", "0xf.1a818p-12", "0x1.1563p-8",
"0x1.3b92ep-8", "0x1.64376p-8", "0x1.8f501p-8", "0x1.bcdc98p-8", "0x1.ecdc78p-8", "0x2.1f4f4p-8", "0x2.54347p-8", "0x2.8b8b9p-8",
"0x2.c55408p-8", "0x3.018d5p-8", "0x3.4036d8p-8", "0x3.815p-8", "0x3.c4d828p-8", "0x4.0acebp-8", "0x4.5332ep-8", "0x4.9e041p-8",
"0x4.eb418p-8", "0x5.3aea7p-8", "0x5.8cfe28p-8", "0x5.e17bdp-8", "0x6.386298p-8", "0x6.91b1b8p-8", "0x6.ed684p-8", "0x7.4b856p-8",
"0x7.ac082p-8", "0x8.0eefap-8", "0x8.743aep-8", "0x8.dbe8e8p-8", "0x9.45f8cp-8", "0x9.b2696p-8", "0xa.2139b8p-8", "0xa.9268b8p-8",
"0xb.05f548p-8", "0xb.7bde5p-8", "0xb.f422a8p-8", "0xc.6ec12p-8", "0xc.ebb8ap-8", "0xd.6b07d8p-8", "0xd.ecada8p-8", "0xe.70a8b8p-8",
"0xe.f6f7d8p-8", "0xf.7f99bp-8", "0x1.00a8cfp-4", "0x1.097d04p-4", "0x1.1276248p-4", "0x1.1b941a8p-4", "0x1.24d6cfp-4", "0x1.2e3e2bp-4",
"0x1.37ca188p-4", "0x1.417a7e8p-4", "0x1.4b4f46p-4", "0x1.5548568p-4", "0x1.5f6597p-4", "0x1.69a6ef8p-4", "0x1.740c458p-4", "0x1.7e95808p-4",
"0x1.8942858p-4", "0x1.94133bp-4", "0x1.9f0786p-4", "0x1.aa1f4bp-4", "0x1.b55a6f8p-4", "0x1.c0b8d7p-4", "0x1.cc3a658p-4", "0x1.d7deff8p-4",
"0x1.e3a687p-4", "0x1.ef90ep-4", "0x1.fb9dec8p-4", "0x2.07cd8fp-4", "0x2.141fa98p-4", "0x2.20941d8p-4", "0x2.2d2accp-4", "0x2.39e3968p-4",
"0x2.46be5d8p-4", "0x2.53bb008p-4", "0x2.60d9608p-4", "0x2.6e195c8p-4", "0x2.7b7ad4p-4", "0x2.88fda58p-4", "0x2.96a1b1p-4", "0x2.a466d38p-4",
"0x2.b24ceb8p-4", "0x2.c053d68p-4", "0x2.ce7b728p-4", "0x2.dcc39cp-4", "0x2.eb2c2f8p-4", "0x2.f9b50a8p-4", "0x3.085e08p-4", "0x3.172705p-4",
"0x3.260fdcp-4", "0x3.3518688p-4", "0x3.4440858p-4", "0x3.53880d8p-4", "0x3.62eedbp-4", "0x3.7274c8p-4", "0x3.8219aep-4", "0x3.91dd668p-4",
"0x3.a1bfca8p-4", "0x3.b1c0b28p-4", "0x3.c1dff8p-4", "0x3.d21d728p-4", "0x3.e278fap-4", "0x3.f2f266p-4", "0x4.03898ep-4", "0x4.143e498p-4",
"0x4.25106e8p-4", "0x4.35ffd4p-4", "0x4.470c508p-4", "0x4.5835b9p-4", "0x4.697be4p-4", "0x4.7adea6p-4", "0x4.8c5dd58p-4", "0x4.9df946p-4",
};
//  K1  estimated  0  integer bits.
static const ap_fixed< 23 , 1 > cos_K1 [ 128 ] = {
"0x4.p-24", "0x1.3bdcp-8", "0x2.77a8p-8", "0x3.b36cp-8", "0x4.ef38p-8", "0x6.2ae4p-8", "0x7.668cp-8", "0x8.a21cp-8",
"0x9.dda8p-8", "0xb.190cp-8", "0xc.5454p-8", "0xd.8f7cp-8", "0xe.ca84p-8", "0x1.00568p-4", "0x1.1402cp-4", "0x1.27acp-4",
"0x1.3b524p-4", "0x1.4ef54p-4", "0x1.62964p-4", "0x1.76328p-4", "0x1.89cbcp-4", "0x1.9d614p-4", "0x1.b0f28p-4", "0x1.c47f4p-4",
"0x1.d8084p-4", "0x1.eb8ccp-4", "0x1.ff0c4p-4", "0x2.1286cp-4", "0x2.25fc8p-4", "0x2.396c8p-4", "0x2.4cd74p-4", "0x2.603cp-4",
"0x2.739bp-4", "0x2.86f4cp-4", "0x2.9a47p-4", "0x2.ad934p-4", "0x2.c0d9cp-4", "0x2.d4184p-4", "0x2.e751p-4", "0x2.fa81p-4",
"0x3.0dab4p-4", "0x3.20cdp-4", "0x3.33e74p-4", "0x3.46fap-4", "0x3.5a048p-4", "0x3.6d064p-4", "0x3.7fffcp-4", "0x3.92f0cp-4",
"0x3.a5d8cp-4", "0x3.b8b78p-4", "0x3.cb8d4p-4", "0x3.de5acp-4", "0x3.f11ccp-4", "0x4.03d7p-4", "0x4.1685cp-4", "0x4.292cp-4",
"0x4.3bc64p-4", "0x4.4e56cp-4", "0x4.60ddp-4", "0x4.73588p-4", "0x4.85c88p-4", "0x4.982dp-4", "0x4.aa86cp-4", "0x4.bcd5cp-4",
"0x4.cf174p-4", "0x4.e14ecp-4", "0x4.f3794p-4", "0x5.05974p-4", "0x5.17aap-4", "0x5.29aecp-4", "0x5.3ba84p-4", "0x5.4d938p-4",
"0x5.5f728p-4", "0x5.7143cp-4", "0x5.83074p-4", "0x5.94bep-4", "0x5.a6664p-4", "0x5.b800cp-4", "0x5.c98ep-4", "0x5.db0bcp-4",
"0x5.ec7cp-4", "0x5.fddd4p-4", "0x6.0f3p-4", "0x6.20738p-4", "0x6.31a7cp-4", "0x6.42cccp-4", "0x6.53e2cp-4", "0x6.64e8cp-4",
"0x6.75de4p-4", "0x6.86c54p-4", "0x6.979bp-4", "0x6.a861p-4", "0x6.b9164p-4", "0x6.c9bcp-4", "0x6.da4f8p-4", "0x6.ead2cp-4",
"0x6.fb44cp-4", "0x7.0ba68p-4", "0x7.1bf5cp-4", "0x7.2c338p-4", "0x7.3c608p-4", "0x7.4c7acp-4", "0x7.5c84p-4", "0x7.6c798p-4",
"0x7.7c5d4p-4", "0x7.8c2ecp-4", "0x7.9beep-4", "0x7.ab9a4p-4", "0x7.bb338p-4", "0x7.cab94p-4", "0x7.da2c8p-4", "0x7.e98bcp-4",
"0x7.f8d7cp-4", "0x8.0810cp-4", "0x8.1734cp-4", "0x8.26458p-4", "0x8.3541cp-4", "0x8.442a4p-4", "0x8.52fe4p-4", "0x8.61bd4p-4",
"0x8.70684p-4", "0x8.7efe4p-4", "0x8.8d7e4p-4", "0x8.9beap-4", "0x8.aa40cp-4", "0x8.b882cp-4", "0x8.c6adp-4", "0x8.d4c34p-4",
};
//  K2  estimated  -1  integer bits.
static const ap_fixed< 15 , 0 > cos_K2 [ 128 ] = {
"0x4.ef2p-4", "0x4.efp-4", "0x4.ef2p-4", "0x4.efp-4", "0x4.eeap-4", "0x4.eeap-4", "0x4.ee4p-4", "0x4.ee2p-4",
"0x4.ed4p-4", "0x4.ecep-4", "0x4.ec8p-4", "0x4.ec2p-4", "0x4.ebap-4", "0x4.ebp-4", "0x4.ea4p-4", "0x4.e98p-4",
"0x4.e8ep-4", "0x4.e84p-4", "0x4.e7p-4", "0x4.e64p-4", "0x4.e54p-4", "0x4.e42p-4", "0x4.e34p-4", "0x4.e24p-4",
"0x4.e1p-4", "0x4.dfcp-4", "0x4.de8p-4", "0x4.dd6p-4", "0x4.dbep-4", "0x4.da8p-4", "0x4.d92p-4", "0x4.d7cp-4",
"0x4.d66p-4", "0x4.d48p-4", "0x4.d32p-4", "0x4.d1ap-4", "0x4.cfap-4", "0x4.ce2p-4", "0x4.ccp-4", "0x4.caap-4",
"0x4.c86p-4", "0x4.c68p-4", "0x4.c4ap-4", "0x4.c28p-4", "0x4.c04p-4", "0x4.be4p-4", "0x4.bc2p-4", "0x4.b9ep-4",
"0x4.b7cp-4", "0x4.b5ap-4", "0x4.b36p-4", "0x4.b0ap-4", "0x4.aeap-4", "0x4.abcp-4", "0x4.a98p-4", "0x4.a68p-4",
"0x4.a44p-4", "0x4.a1ap-4", "0x4.9ecp-4", "0x4.9bep-4", "0x4.994p-4", "0x4.96ap-4", "0x4.93cp-4", "0x4.908p-4",
"0x4.8ep-4", "0x4.8a8p-4", "0x4.878p-4", "0x4.84ap-4", "0x4.812p-4", "0x4.7e4p-4", "0x4.7aap-4", "0x4.77ap-4",
"0x4.744p-4", "0x4.70ep-4", "0x4.6dcp-4", "0x4.6a2p-4", "0x4.66cp-4", "0x4.636p-4", "0x4.5f8p-4", "0x4.5c2p-4",
"0x4.586p-4", "0x4.54ap-4", "0x4.50cp-4", "0x4.4dp-4", "0x4.494p-4", "0x4.456p-4", "0x4.416p-4", "0x4.3d6p-4",
"0x4.39cp-4", "0x4.356p-4", "0x4.318p-4", "0x4.2d6p-4", "0x4.296p-4", "0x4.24ep-4", "0x4.20ep-4", "0x4.1cap-4",
"0x4.188p-4", "0x4.13cp-4", "0x4.0f8p-4", "0x4.0b4p-4", "0x4.06ap-4", "0x4.022p-4", "0x3.fd4p-4", "0x3.f9p-4",
"0x3.f4ap-4", "0x3.fp-4", "0x3.eb2p-4", "0x3.e66p-4", "0x3.e1ap-4", "0x3.ddp-4", "0x3.d7ep-4", "0x3.d32p-4",
"0x3.ce4p-4", "0x3.c92p-4", "0x3.c46p-4", "0x3.bf2p-4", "0x3.ba4p-4", "0x3.b5p-4", "0x3.afep-4", "0x3.aacp-4",
"0x3.a56p-4", "0x3.ap-4", "0x3.9b2p-4", "0x3.95ep-4", "0x3.904p-4", "0x3.8a8p-4", "0x3.85cp-4", "0x3.802p-4",
};

// Tables for f= sin((pi) / 4 * x) / x
//  K0  estimated  0  integer bits.
static const ap_fixed< 30 , 1 > sin_K0 [ 128 ] = {
"0xc.90fdaap-4", "0xc.90f87fp-4", "0xc.90e8fe8p-4", "0xc.90cf28p-4", "0xc.90aafcp-4", "0xc.907c7a8p-4", "0xc.9043a4p-4", "0xc.9000788p-4",
"0xc.8fb2f88p-4", "0xc.8f5b25p-4", "0xc.8ef8fd8p-4", "0xc.8e8c838p-4", "0xc.8e15b7p-4", "0xc.8d94998p-4", "0xc.8d092a8p-4", "0xc.8c736cp-4",
"0xc.8bd35ep-4", "0xc.8b2902p-4", "0xc.8a74588p-4", "0xc.89b563p-4", "0xc.88ec228p-4", "0xc.881898p-4", "0xc.873ac5p-4", "0xc.8652aa8p-4",
"0xc.8560498p-4", "0xc.8463a48p-4", "0xc.835cbcp-4", "0xc.824b918p-4", "0xc.813027p-4", "0xc.800a7e8p-4", "0xc.7eda988p-4", "0xc.7da078p-4",
"0xc.7c5c1ep-4", "0xc.7b0d8dp-4", "0xc.79b4c68p-4", "0xc.7851cc8p-4", "0xc.76e4a1p-4", "0xc.756d468p-4", "0xc.73ebbfp-4", "0xc.72600c8p-4",
"0xc.70ca318p-4", "0xc.6f2a3p-4", "0xc.6d800bp-4", "0xc.6bcbc48p-4", "0xc.6a0d5fp-4", "0xc.6844dd8p-4", "0xc.6672428p-4", "0xc.64959p-4",
"0xc.62aecap-4", "0xc.60bdf2p-4", "0xc.5ec30cp-4", "0xc.5cbe1a8p-4", "0xc.5aaf2p-4", "0xc.58962p-4", "0xc.56731ep-4", "0xc.54461c8p-4",
"0xc.520f1e8p-4", "0xc.4fce28p-4", "0xc.4d833c8p-4", "0xc.4b2e5e8p-4", "0xc.48cf918p-4", "0xc.4666dap-4", "0xc.43f43a8p-4", "0xc.4177b7p-4",
"0xc.3ef1538p-4", "0xc.3c6113p-4", "0xc.39c6fap-4", "0xc.37230cp-4", "0xc.34754dp-4", "0xc.31bdc1p-4", "0xc.2efc6b8p-4", "0xc.2c31518p-4",
"0xc.295c76p-4", "0xc.267dde8p-4", "0xc.23958ep-4", "0xc.20a389p-4", "0xc.1da7d48p-4", "0xc.1aa275p-4", "0xc.17936ep-4", "0xc.147ac48p-4",
"0xc.11587dp-4", "0xc.0e2c9cp-4", "0xc.0af7268p-4", "0xc.07b8218p-4", "0xc.046f91p-4", "0xc.011d7ap-4", "0xb.fdc1e18p-4", "0xb.fa5ccdp-4",
"0xb.f6ee41p-4", "0xb.f376428p-4", "0xb.eff4d68p-4", "0xb.ec6a028p-4", "0xb.e8d5cbp-4", "0xb.e538368p-4", "0xb.e191498p-4", "0xb.dde1098p-4",
"0xb.da277cp-4", "0xb.d664a6p-4", "0xb.d2988ep-4", "0xb.cec3388p-4", "0xb.cae4acp-4", "0xb.c6fceep-4", "0xb.c30c04p-4", "0xb.bf11f38p-4",
"0xb.bb0ec3p-4", "0xb.b70278p-4", "0xb.b2ed19p-4", "0xb.aeceabp-4", "0xb.aaa735p-4", "0xb.a676bc8p-4", "0xb.a23d48p-4", "0xb.9dfaddp-4",
"0xb.99af83p-4", "0xb.955b3fp-4", "0xb.90fe188p-4", "0xb.8c9815p-4", "0xb.88293b8p-4", "0xb.83b1928p-4", "0xb.7f312p-4", "0xb.7aa7ebp-4",
"0xb.7615fap-4", "0xb.717b54p-4", "0xb.6cd7ffp-4", "0xb.682c03p-4", "0xb.637766p-4", "0xb.5eba2e8p-4", "0xb.59f4648p-4", "0xb.55260e8p-4",
};
//  K1  estimated  -2  integer bits.
static const ap_fixed< 21 , -1 > sin_K1 [ 128 ] = {
"0x8.p-24", "-0x5.2a8p-12", "-0xa.56p-12", "-0xf.81p-12", "-0x1.4acp-8", "-0x1.9d64p-8", "-0x1.f014p-8", "-0x2.42b4p-8",
"-0x2.955p-8", "-0x2.e7f4p-8", "-0x3.3a84p-8", "-0x3.8d18p-8", "-0x3.dfa8p-8", "-0x4.3238p-8", "-0x4.84b4p-8", "-0x4.d734p-8",
"-0x5.29a8p-8", "-0x5.7c14p-8", "-0x5.ce74p-8", "-0x6.20dp-8", "-0x6.7328p-8", "-0x6.c574p-8", "-0x7.17bcp-8", "-0x7.69fp-8",
"-0x7.bc18p-8", "-0x8.0e4p-8", "-0x8.6054p-8", "-0x8.b254p-8", "-0x9.044cp-8", "-0x9.564p-8", "-0x9.a814p-8", "-0x9.f9e8p-8",
"-0xa.4ba8p-8", "-0xa.9d64p-8", "-0xa.ef08p-8", "-0xb.4098p-8", "-0xb.9218p-8", "-0xb.e39p-8", "-0xc.34f4p-8", "-0xc.8644p-8",
"-0xc.d78p-8", "-0xd.28a4p-8", "-0xd.79bcp-8", "-0xd.cab8p-8", "-0xe.1bap-8", "-0xe.6c7cp-8", "-0xe.bd4p-8", "-0xf.0de4p-8",
"-0xf.5e7cp-8", "-0xf.aef4p-8", "-0xf.ff64p-8", "-0x1.04fb8p-4", "-0x1.09fecp-4", "-0x1.0f00cp-4", "-0x1.1401cp-4", "-0x1.19008p-4",
"-0x1.1dfdp-4", "-0x1.22f88p-4", "-0x1.27f38p-4", "-0x1.2ceb8p-4", "-0x1.31e14p-4", "-0x1.36d6cp-4", "-0x1.3bc94p-4", "-0x1.40ba4p-4",
"-0x1.45a9cp-4", "-0x1.4a968p-4", "-0x1.4f82p-4", "-0x1.546b8p-4", "-0x1.59538p-4", "-0x1.5e39p-4", "-0x1.631c4p-4", "-0x1.67fep-4",
"-0x1.6cdccp-4", "-0x1.71bb4p-4", "-0x1.7696p-4", "-0x1.7b6e4p-4", "-0x1.8045p-4", "-0x1.851bp-4", "-0x1.89ed4p-4", "-0x1.8ebd8p-4",
"-0x1.938bp-4", "-0x1.9856p-4", "-0x1.9d1fp-4", "-0x1.a1e6cp-4", "-0x1.a6abp-4", "-0x1.ab6c4p-4", "-0x1.b02b8p-4", "-0x1.b4e9p-4",
"-0x1.b9a38p-4", "-0x1.be5cp-4", "-0x1.c310cp-4", "-0x1.c7c3cp-4", "-0x1.cc734p-4", "-0x1.d1214p-4", "-0x1.d5cc4p-4", "-0x1.da748p-4",
"-0x1.df19cp-4", "-0x1.e3bc4p-4", "-0x1.e85c4p-4", "-0x1.ecf8cp-4", "-0x1.f1938p-4", "-0x1.f62acp-4", "-0x1.fabfcp-4", "-0x1.ff51p-4",
"-0x2.03df8p-4", "-0x2.086bp-4", "-0x2.0cf48p-4", "-0x2.117ap-4", "-0x2.15fdp-4", "-0x2.1a7c4p-4", "-0x2.1ef9p-4", "-0x2.2371cp-4",
"-0x2.27e84p-4", "-0x2.2c5bp-4", "-0x2.30cb4p-4", "-0x2.3537cp-4", "-0x2.39a14p-4", "-0x2.3e088p-4", "-0x2.426b4p-4", "-0x2.46cacp-4",
"-0x2.4b268p-4", "-0x2.4f7fcp-4", "-0x2.53d5p-4", "-0x2.58274p-4", "-0x2.5c764p-4", "-0x2.60c0cp-4", "-0x2.6509p-4", "-0x2.694d4p-4",
};
//  K2  estimated  -3  integer bits.
static const ap_fixed< 13 , -2 > sin_K2 [ 128 ] = {
"-0x1.4bp-4", "-0x1.4aep-4", "-0x1.4aap-4", "-0x1.4a8p-4", "-0x1.4a6p-4", "-0x1.4aap-4", "-0x1.4a4p-4", "-0x1.4a6p-4",
"-0x1.4a6p-4", "-0x1.4a4p-4", "-0x1.4a6p-4", "-0x1.4a6p-4", "-0x1.4a2p-4", "-0x1.4ap-4", "-0x1.4ap-4", "-0x1.49ep-4",
"-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49ap-4", "-0x1.496p-4", "-0x1.492p-4", "-0x1.48cp-4", "-0x1.48cp-4",
"-0x1.488p-4", "-0x1.482p-4", "-0x1.48p-4", "-0x1.48p-4", "-0x1.47cp-4", "-0x1.478p-4", "-0x1.478p-4", "-0x1.474p-4",
"-0x1.47p-4", "-0x1.468p-4", "-0x1.464p-4", "-0x1.462p-4", "-0x1.45ep-4", "-0x1.456p-4", "-0x1.45p-4", "-0x1.44ap-4",
"-0x1.446p-4", "-0x1.442p-4", "-0x1.43cp-4", "-0x1.43ap-4", "-0x1.436p-4", "-0x1.42ep-4", "-0x1.42ap-4", "-0x1.426p-4",
"-0x1.422p-4", "-0x1.41ep-4", "-0x1.414p-4", "-0x1.40ep-4", "-0x1.40ap-4", "-0x1.402p-4", "-0x1.3f8p-4", "-0x1.3f4p-4",
"-0x1.3f2p-4", "-0x1.3ecp-4", "-0x1.3dcp-4", "-0x1.3d8p-4", "-0x1.3d6p-4", "-0x1.3c8p-4", "-0x1.3c4p-4", "-0x1.3bcp-4",
"-0x1.3b4p-4", "-0x1.3bp-4", "-0x1.3a8p-4", "-0x1.3ap-4", "-0x1.394p-4", "-0x1.38ep-4", "-0x1.386p-4", "-0x1.37ep-4",
"-0x1.37ap-4", "-0x1.368p-4", "-0x1.364p-4", "-0x1.36p-4", "-0x1.358p-4", "-0x1.344p-4", "-0x1.33cp-4", "-0x1.332p-4",
"-0x1.32cp-4", "-0x1.326p-4", "-0x1.31ep-4", "-0x1.30cp-4", "-0x1.304p-4", "-0x1.3p-4", "-0x1.2f6p-4", "-0x1.2e8p-4",
"-0x1.2ep-4", "-0x1.2dp-4", "-0x1.2ccp-4", "-0x1.2cp-4", "-0x1.2b8p-4", "-0x1.2aap-4", "-0x1.29ep-4", "-0x1.292p-4",
"-0x1.28ap-4", "-0x1.27ep-4", "-0x1.274p-4", "-0x1.26cp-4", "-0x1.25cp-4", "-0x1.254p-4", "-0x1.244p-4", "-0x1.23ap-4",
"-0x1.23p-4", "-0x1.226p-4", "-0x1.214p-4", "-0x1.208p-4", "-0x1.1fap-4", "-0x1.1f2p-4", "-0x1.1e4p-4", "-0x1.1dap-4",
"-0x1.1cep-4", "-0x1.1c2p-4", "-0x1.1b4p-4", "-0x1.1a8p-4", "-0x1.19cp-4", "-0x1.186p-4", "-0x1.17ap-4", "-0x1.16ep-4",
"-0x1.166p-4", "-0x1.156p-4", "-0x1.148p-4", "-0x1.13cp-4", "-0x1.12cp-4", "-0x1.122p-4", "-0x1.11p-4", "-0x1.104p-4",
};

///////////////////////////////
// Tables for f= cos((pi) / 4 * x)
// Tables for f= sin((pi) / 4 * x) / x
//  K0  estimated  0  integer bits.
static const ap_ufixed< 30 , 1 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.ffec43p-4", "0xf.ffb10b8p-4", "0xf.ff4e5ap-4", "0xf.fec4308p-4", "0xf.fe128fp-4", "0xf.fd3978p-4", "0xf.fc38ed8p-4",
"0xf.fb10f2p-4", "0xf.f9c188p-4", "0xf.f84ab3p-4", "0xf.f6ac768p-4", "0xf.f4e6d68p-4", "0xf.f2f9d78p-4", "0xf.f0e57e8p-4", "0xf.eea9dp-4",
"0xf.ec46d2p-4", "0xf.e9bc8ap-4", "0xf.e70affp-4", "0xf.e432368p-4", "0xf.e132388p-4", "0xf.de0b0cp-4", "0xf.dabcb9p-4", "0xf.d74747p-4",
"0xf.d3aabf8p-4", "0xf.cfe72bp-4", "0xf.cbfc928p-4", "0xf.c7ebp-4", "0xf.c3b27d8p-4", "0xf.bf5315p-4", "0xf.baccd2p-4", "0xf.b61fbfp-4",
"0xf.b14be8p-4", "0xf.ac5159p-4", "0xf.a7301d8p-4", "0xf.a1e843p-4", "0xf.9c79d68p-4", "0xf.96e4e48p-4", "0xf.91297cp-4", "0xf.8b47aap-4",
"0xf.853f7ep-4", "0xf.7f1106p-4", "0xf.78bc52p-4", "0xf.7241718p-4", "0xf.6ba074p-4", "0xf.64d96ap-4", "0xf.5dec648p-4", "0xf.56d9748p-4",
"0xf.4fa0ab8p-4", "0xf.48421bp-4", "0xf.40bdd58p-4", "0xf.3913eep-4", "0xf.314476p-4", "0xf.294f828p-4", "0xf.2135258p-4", "0xf.18f5748p-4",
"0xf.1090828p-4", "0xf.080665p-4", "0xe.ff5731p-4", "0xe.f682fcp-4", "0xe.ed89db8p-4", "0xe.e46be58p-4", "0xe.db2931p-4", "0xe.d1c1d5p-4",
"0xe.c835e78p-4", "0xe.be85818p-4", "0xe.b4b0bap-4", "0xe.aab7a98p-4", "0xe.a09a69p-4", "0xe.9659108p-4", "0xe.8bf3ba8p-4", "0xe.816a7f8p-4",
"0xe.76bd7a8p-4", "0xe.6becc5p-4", "0xe.60f87ap-4", "0xe.55e0b5p-4", "0xe.4aa5908p-4", "0xe.3f4729p-4", "0xe.33c59a8p-4", "0xe.2821008p-4",
"0xe.1c5979p-4", "0xe.106f2p-4", "0xe.0462138p-4", "0xd.f83271p-4", "0xd.ebe0568p-4", "0xd.df6be28p-4", "0xd.d2d534p-4", "0xd.c61c698p-4",
"0xd.b941a28p-4", "0xd.ac44ff8p-4", "0xd.9f269f8p-4", "0xd.91e6a38p-4", "0xd.84852cp-4", "0xd.77025a8p-4", "0xd.695e4fp-4", "0xd.5b992c8p-4",
"0xd.4db3148p-4", "0xd.3fac298p-4", "0xd.31848d8p-4", "0xd.233c64p-4", "0xd.14d3d08p-4", "0xd.064af58p-4", "0xc.f7a1f8p-4", "0xc.e8d8fbp-4",
"0xc.d9f024p-4", "0xc.cae7978p-4", "0xc.bbbf7a8p-4", "0xc.ac77f28p-4", "0xc.9d1125p-4", "0xc.8d8b38p-4", "0xc.7de652p-4", "0xc.6e22998p-4",
"0xc.5e40358p-4", "0xc.4e3f4d8p-4", "0xc.3e2008p-4", "0xc.2de28d8p-4", "0xc.1d8706p-4", "0xc.0d0d9ap-4", "0xb.fc7672p-4", "0xb.ebc1b68p-4",
"0xb.daef918p-4", "0xb.ca002cp-4", "0xb.b8f3af8p-4", "0xb.a7ca47p-4", "0xb.96841cp-4", "0xb.85215ap-4", "0xb.73a22a8p-4", "0xb.6206bap-4",
///
"0xc.90fdaap-4", "0xc.90f87fp-4", "0xc.90e8fe8p-4", "0xc.90cf28p-4", "0xc.90aafcp-4", "0xc.907c7a8p-4", "0xc.9043a4p-4", "0xc.9000788p-4",
"0xc.8fb2f88p-4", "0xc.8f5b25p-4", "0xc.8ef8fd8p-4", "0xc.8e8c838p-4", "0xc.8e15b7p-4", "0xc.8d94998p-4", "0xc.8d092a8p-4", "0xc.8c736cp-4",
"0xc.8bd35ep-4", "0xc.8b2902p-4", "0xc.8a74588p-4", "0xc.89b563p-4", "0xc.88ec228p-4", "0xc.881898p-4", "0xc.873ac5p-4", "0xc.8652aa8p-4",
"0xc.8560498p-4", "0xc.8463a48p-4", "0xc.835cbcp-4", "0xc.824b918p-4", "0xc.813027p-4", "0xc.800a7e8p-4", "0xc.7eda988p-4", "0xc.7da078p-4",
"0xc.7c5c1ep-4", "0xc.7b0d8dp-4", "0xc.79b4c68p-4", "0xc.7851cc8p-4", "0xc.76e4a1p-4", "0xc.756d468p-4", "0xc.73ebbfp-4", "0xc.72600c8p-4",
"0xc.70ca318p-4", "0xc.6f2a3p-4", "0xc.6d800bp-4", "0xc.6bcbc48p-4", "0xc.6a0d5fp-4", "0xc.6844dd8p-4", "0xc.6672428p-4", "0xc.64959p-4",
"0xc.62aecap-4", "0xc.60bdf2p-4", "0xc.5ec30cp-4", "0xc.5cbe1a8p-4", "0xc.5aaf2p-4", "0xc.58962p-4", "0xc.56731ep-4", "0xc.54461c8p-4",
"0xc.520f1e8p-4", "0xc.4fce28p-4", "0xc.4d833c8p-4", "0xc.4b2e5e8p-4", "0xc.48cf918p-4", "0xc.4666dap-4", "0xc.43f43a8p-4", "0xc.4177b7p-4",
"0xc.3ef1538p-4", "0xc.3c6113p-4", "0xc.39c6fap-4", "0xc.37230cp-4", "0xc.34754dp-4", "0xc.31bdc1p-4", "0xc.2efc6b8p-4", "0xc.2c31518p-4",
"0xc.295c76p-4", "0xc.267dde8p-4", "0xc.23958ep-4", "0xc.20a389p-4", "0xc.1da7d48p-4", "0xc.1aa275p-4", "0xc.17936ep-4", "0xc.147ac48p-4",
"0xc.11587dp-4", "0xc.0e2c9cp-4", "0xc.0af7268p-4", "0xc.07b8218p-4", "0xc.046f91p-4", "0xc.011d7ap-4", "0xb.fdc1e18p-4", "0xb.fa5ccdp-4",
"0xb.f6ee41p-4", "0xb.f376428p-4", "0xb.eff4d68p-4", "0xb.ec6a028p-4", "0xb.e8d5cbp-4", "0xb.e538368p-4", "0xb.e191498p-4", "0xb.dde1098p-4",
"0xb.da277cp-4", "0xb.d664a6p-4", "0xb.d2988ep-4", "0xb.cec3388p-4", "0xb.cae4acp-4", "0xb.c6fceep-4", "0xb.c30c04p-4", "0xb.bf11f38p-4",
"0xb.bb0ec3p-4", "0xb.b70278p-4", "0xb.b2ed19p-4", "0xb.aeceabp-4", "0xb.aaa735p-4", "0xb.a676bc8p-4", "0xb.a23d48p-4", "0xb.9dfaddp-4",
"0xb.99af83p-4", "0xb.955b3fp-4", "0xb.90fe188p-4", "0xb.8c9815p-4", "0xb.88293b8p-4", "0xb.83b1928p-4", "0xb.7f312p-4", "0xb.7aa7ebp-4",
"0xb.7615fap-4", "0xb.717b54p-4", "0xb.6cd7ffp-4", "0xb.682c03p-4", "0xb.637766p-4", "0xb.5eba2e8p-4", "0xb.59f4648p-4", "0xb.55260e8p-4",
};
//  K1  estimated  0  integer bits.
static const ap_fixed< 23 , 1 > sin_cos_K1 [ 256 ] = {
"-0x4.p-24", "-0x1.3bdcp-8", "-0x2.77a8p-8", "-0x3.b36cp-8", "-0x4.ef38p-8", "-0x6.2ae4p-8", "-0x7.668cp-8", "-0x8.a21cp-8",
"-0x9.dda8p-8", "-0xb.190cp-8", "-0xc.5454p-8", "-0xd.8f7cp-8", "-0xe.ca84p-8", "-0x1.00568p-4", "-0x1.1402cp-4", "-0x1.27acp-4",
"-0x1.3b524p-4", "-0x1.4ef54p-4", "-0x1.62964p-4", "-0x1.76328p-4", "-0x1.89cbcp-4", "-0x1.9d614p-4", "-0x1.b0f28p-4", "-0x1.c47f4p-4",
"-0x1.d8084p-4", "-0x1.eb8ccp-4", "-0x1.ff0c4p-4", "-0x2.1286cp-4", "-0x2.25fc8p-4", "-0x2.396c8p-4", "-0x2.4cd74p-4", "-0x2.603cp-4",
"-0x2.739bp-4", "-0x2.86f4cp-4", "-0x2.9a47p-4", "-0x2.ad934p-4", "-0x2.c0d9cp-4", "-0x2.d4184p-4", "-0x2.e751p-4", "-0x2.fa81p-4",
"-0x3.0dab4p-4", "-0x3.20cdp-4", "-0x3.33e74p-4", "-0x3.46fap-4", "-0x3.5a048p-4", "-0x3.6d064p-4", "-0x3.7fffcp-4", "-0x3.92f0cp-4",
"-0x3.a5d8cp-4", "-0x3.b8b78p-4", "-0x3.cb8d4p-4", "-0x3.de5acp-4", "-0x3.f11ccp-4", "-0x4.03d7p-4", "-0x4.1685cp-4", "-0x4.292cp-4",
"-0x4.3bc64p-4", "-0x4.4e56cp-4", "-0x4.60ddp-4", "-0x4.73588p-4", "-0x4.85c88p-4", "-0x4.982dp-4", "-0x4.aa86cp-4", "-0x4.bcd5cp-4",
"-0x4.cf174p-4", "-0x4.e14ecp-4", "-0x4.f3794p-4", "-0x5.05974p-4", "-0x5.17aap-4", "-0x5.29aecp-4", "-0x5.3ba84p-4", "-0x5.4d938p-4",
"-0x5.5f728p-4", "-0x5.7143cp-4", "-0x5.83074p-4", "-0x5.94bep-4", "-0x5.a6664p-4", "-0x5.b800cp-4", "-0x5.c98ep-4", "-0x5.db0bcp-4",
"-0x5.ec7cp-4", "-0x5.fddd4p-4", "-0x6.0f3p-4", "-0x6.20738p-4", "-0x6.31a7cp-4", "-0x6.42cccp-4", "-0x6.53e2cp-4", "-0x6.64e8cp-4",
"-0x6.75de4p-4", "-0x6.86c54p-4", "-0x6.979bp-4", "-0x6.a861p-4", "-0x6.b9164p-4", "-0x6.c9bcp-4", "-0x6.da4f8p-4", "-0x6.ead2cp-4",
"-0x6.fb44cp-4", "-0x7.0ba68p-4", "-0x7.1bf5cp-4", "-0x7.2c338p-4", "-0x7.3c608p-4", "-0x7.4c7acp-4", "-0x7.5c84p-4", "-0x7.6c798p-4",
"-0x7.7c5d4p-4", "-0x7.8c2fp-4", "-0x7.9beep-4", "-0x7.ab9a4p-4", "-0x7.bb338p-4", "-0x7.cab94p-4", "-0x7.da2c8p-4", "-0x7.e98cp-4",
"-0x7.f8d7cp-4", "-0x8.0810cp-4", "-0x8.1734cp-4", "-0x8.26458p-4", "-0x8.3541cp-4", "-0x8.442a4p-4", "-0x8.52fe4p-4", "-0x8.61bd4p-4",
"-0x8.70684p-4", "-0x8.7efe4p-4", "-0x8.8d7e4p-4", "-0x8.9beap-4", "-0x8.aa40cp-4", "-0x8.b882cp-4", "-0x8.c6adp-4", "-0x8.d4c34p-4",
////
"0x8.p-24", "-0x5.2a8p-12", "-0xa.56p-12", "-0xf.81p-12", "-0x1.4acp-8", "-0x1.9d64p-8", "-0x1.f014p-8", "-0x2.42b4p-8",
"-0x2.955p-8", "-0x2.e7f4p-8", "-0x3.3a84p-8", "-0x3.8d18p-8", "-0x3.dfa8p-8", "-0x4.3238p-8", "-0x4.84b4p-8", "-0x4.d734p-8",
"-0x5.29a8p-8", "-0x5.7c14p-8", "-0x5.ce74p-8", "-0x6.20dp-8", "-0x6.7328p-8", "-0x6.c574p-8", "-0x7.17bcp-8", "-0x7.69fp-8",
"-0x7.bc18p-8", "-0x8.0e4p-8", "-0x8.6054p-8", "-0x8.b254p-8", "-0x9.044cp-8", "-0x9.564p-8", "-0x9.a814p-8", "-0x9.f9e8p-8",
"-0xa.4ba8p-8", "-0xa.9d64p-8", "-0xa.ef08p-8", "-0xb.4098p-8", "-0xb.9218p-8", "-0xb.e39p-8", "-0xc.34f4p-8", "-0xc.8644p-8",
"-0xc.d78p-8", "-0xd.28a4p-8", "-0xd.79bcp-8", "-0xd.cab8p-8", "-0xe.1bap-8", "-0xe.6c7cp-8", "-0xe.bd4p-8", "-0xf.0de4p-8",
"-0xf.5e7cp-8", "-0xf.aef4p-8", "-0xf.ff64p-8", "-0x1.04fb8p-4", "-0x1.09fecp-4", "-0x1.0f00cp-4", "-0x1.1401cp-4", "-0x1.19008p-4",
"-0x1.1dfdp-4", "-0x1.22f88p-4", "-0x1.27f38p-4", "-0x1.2ceb8p-4", "-0x1.31e14p-4", "-0x1.36d6cp-4", "-0x1.3bc94p-4", "-0x1.40ba4p-4",
"-0x1.45a9cp-4", "-0x1.4a968p-4", "-0x1.4f82p-4", "-0x1.546b8p-4", "-0x1.59538p-4", "-0x1.5e39p-4", "-0x1.631c4p-4", "-0x1.67fep-4",
"-0x1.6cdccp-4", "-0x1.71bb4p-4", "-0x1.7696p-4", "-0x1.7b6e4p-4", "-0x1.8045p-4", "-0x1.851bp-4", "-0x1.89ed4p-4", "-0x1.8ebd8p-4",
"-0x1.938bp-4", "-0x1.9856p-4", "-0x1.9d1fp-4", "-0x1.a1e6cp-4", "-0x1.a6abp-4", "-0x1.ab6c4p-4", "-0x1.b02b8p-4", "-0x1.b4e9p-4",
"-0x1.b9a38p-4", "-0x1.be5cp-4", "-0x1.c310cp-4", "-0x1.c7c3cp-4", "-0x1.cc734p-4", "-0x1.d1214p-4", "-0x1.d5cc4p-4", "-0x1.da748p-4",
"-0x1.df19cp-4", "-0x1.e3bc4p-4", "-0x1.e85c4p-4", "-0x1.ecf8cp-4", "-0x1.f1938p-4", "-0x1.f62acp-4", "-0x1.fabfcp-4", "-0x1.ff51p-4",
"-0x2.03df8p-4", "-0x2.086bp-4", "-0x2.0cf48p-4", "-0x2.117ap-4", "-0x2.15fdp-4", "-0x2.1a7c4p-4", "-0x2.1ef9p-4", "-0x2.2371cp-4",
"-0x2.27e84p-4", "-0x2.2c5bp-4", "-0x2.30cb4p-4", "-0x2.3537cp-4", "-0x2.39a14p-4", "-0x2.3e088p-4", "-0x2.426b4p-4", "-0x2.46cacp-4",
"-0x2.4b268p-4", "-0x2.4f7fcp-4", "-0x2.53d5p-4", "-0x2.58274p-4", "-0x2.5c764p-4", "-0x2.60c0cp-4", "-0x2.6509p-4", "-0x2.694d4p-4",
};
//  K2  estimated  -1  integer bits.
static const ap_fixed< 15 , 0 > sin_cos_K2 [ 256 ] = {
"-0x4.ef2p-4", "-0x4.efp-4", "-0x4.ef2p-4", "-0x4.efp-4", "-0x4.eeap-4", "-0x4.eeap-4", "-0x4.ee4p-4", "-0x4.ee2p-4",
"-0x4.ed4p-4", "-0x4.ecep-4", "-0x4.ec8p-4", "-0x4.ec2p-4", "-0x4.ebap-4", "-0x4.ebp-4", "-0x4.ea4p-4", "-0x4.e98p-4",
"-0x4.e8ep-4", "-0x4.e84p-4", "-0x4.e7p-4", "-0x4.e64p-4", "-0x4.e54p-4", "-0x4.e42p-4", "-0x4.e34p-4", "-0x4.e24p-4",
"-0x4.e1p-4", "-0x4.dfcp-4", "-0x4.de8p-4", "-0x4.dd6p-4", "-0x4.dbep-4", "-0x4.da8p-4", "-0x4.d92p-4", "-0x4.d7cp-4",
"-0x4.d66p-4", "-0x4.d48p-4", "-0x4.d32p-4", "-0x4.d1ap-4", "-0x4.cfap-4", "-0x4.ce2p-4", "-0x4.ccp-4", "-0x4.caap-4",
"-0x4.c86p-4", "-0x4.c68p-4", "-0x4.c4ap-4", "-0x4.c28p-4", "-0x4.c04p-4", "-0x4.be4p-4", "-0x4.bc2p-4", "-0x4.b9ep-4",
"-0x4.b7cp-4", "-0x4.b5ap-4", "-0x4.b36p-4", "-0x4.b0ap-4", "-0x4.aeap-4", "-0x4.abcp-4", "-0x4.a98p-4", "-0x4.a68p-4",
"-0x4.a44p-4", "-0x4.a1ap-4", "-0x4.9ecp-4", "-0x4.9bep-4", "-0x4.994p-4", "-0x4.96ap-4", "-0x4.93cp-4", "-0x4.908p-4",
"-0x4.8ep-4", "-0x4.8a8p-4", "-0x4.878p-4", "-0x4.84ap-4", "-0x4.812p-4", "-0x4.7e4p-4", "-0x4.7aap-4", "-0x4.77ap-4",
"-0x4.744p-4", "-0x4.70ep-4", "-0x4.6dcp-4", "-0x4.6a2p-4", "-0x4.66cp-4", "-0x4.636p-4", "-0x4.5f8p-4", "-0x4.5c2p-4",
"-0x4.586p-4", "-0x4.54ap-4", "-0x4.50cp-4", "-0x4.4dp-4", "-0x4.494p-4", "-0x4.456p-4", "-0x4.416p-4", "-0x4.3d6p-4",
"-0x4.39cp-4", "-0x4.356p-4", "-0x4.318p-4", "-0x4.2d6p-4", "-0x4.296p-4", "-0x4.24ep-4", "-0x4.20ep-4", "-0x4.1cap-4",
"-0x4.188p-4", "-0x4.13cp-4", "-0x4.0f8p-4", "-0x4.0b4p-4", "-0x4.06ap-4", "-0x4.022p-4", "-0x3.fd4p-4", "-0x3.f9p-4",
"-0x3.f4ap-4", "-0x3.efep-4", "-0x3.eb2p-4", "-0x3.e66p-4", "-0x3.e1ap-4", "-0x3.ddp-4", "-0x3.d7ep-4", "-0x3.d3p-4",
"-0x3.ce4p-4", "-0x3.c92p-4", "-0x3.c46p-4", "-0x3.bf2p-4", "-0x3.ba4p-4", "-0x3.b5p-4", "-0x3.afep-4", "-0x3.aacp-4",
"-0x3.a56p-4", "-0x3.ap-4", "-0x3.9b2p-4", "-0x3.95ep-4", "-0x3.904p-4", "-0x3.8a8p-4", "-0x3.85cp-4", "-0x3.802p-4",
/////
"-0x1.4bp-4", "-0x1.4aep-4", "-0x1.4aap-4", "-0x1.4a8p-4", "-0x1.4a6p-4", "-0x1.4aap-4", "-0x1.4a4p-4", "-0x1.4a6p-4",
"-0x1.4a6p-4", "-0x1.4a4p-4", "-0x1.4a6p-4", "-0x1.4a6p-4", "-0x1.4a2p-4", "-0x1.4ap-4", "-0x1.4ap-4", "-0x1.49ep-4",
"-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49cp-4", "-0x1.49ap-4", "-0x1.496p-4", "-0x1.492p-4", "-0x1.48cp-4", "-0x1.48cp-4",
"-0x1.488p-4", "-0x1.482p-4", "-0x1.48p-4", "-0x1.48p-4", "-0x1.47cp-4", "-0x1.478p-4", "-0x1.478p-4", "-0x1.474p-4",
"-0x1.47p-4", "-0x1.468p-4", "-0x1.464p-4", "-0x1.462p-4", "-0x1.45ep-4", "-0x1.456p-4", "-0x1.45p-4", "-0x1.44ap-4",
"-0x1.446p-4", "-0x1.442p-4", "-0x1.43cp-4", "-0x1.43ap-4", "-0x1.436p-4", "-0x1.42ep-4", "-0x1.42ap-4", "-0x1.426p-4",
"-0x1.422p-4", "-0x1.41ep-4", "-0x1.414p-4", "-0x1.40ep-4", "-0x1.40ap-4", "-0x1.402p-4", "-0x1.3f8p-4", "-0x1.3f4p-4",
"-0x1.3f2p-4", "-0x1.3ecp-4", "-0x1.3dcp-4", "-0x1.3d8p-4", "-0x1.3d6p-4", "-0x1.3c8p-4", "-0x1.3c4p-4", "-0x1.3bcp-4",
"-0x1.3b4p-4", "-0x1.3bp-4", "-0x1.3a8p-4", "-0x1.3ap-4", "-0x1.394p-4", "-0x1.38ep-4", "-0x1.386p-4", "-0x1.37ep-4",
"-0x1.37ap-4", "-0x1.368p-4", "-0x1.364p-4", "-0x1.36p-4", "-0x1.358p-4", "-0x1.344p-4", "-0x1.33cp-4", "-0x1.332p-4",
"-0x1.32cp-4", "-0x1.326p-4", "-0x1.31ep-4", "-0x1.30cp-4", "-0x1.304p-4", "-0x1.3p-4", "-0x1.2f6p-4", "-0x1.2e8p-4",
"-0x1.2ep-4", "-0x1.2dp-4", "-0x1.2ccp-4", "-0x1.2cp-4", "-0x1.2b8p-4", "-0x1.2aap-4", "-0x1.29ep-4", "-0x1.292p-4",
"-0x1.28ap-4", "-0x1.27ep-4", "-0x1.274p-4", "-0x1.26cp-4", "-0x1.25cp-4", "-0x1.254p-4", "-0x1.244p-4", "-0x1.23ap-4",
"-0x1.23p-4", "-0x1.226p-4", "-0x1.214p-4", "-0x1.208p-4", "-0x1.1fap-4", "-0x1.1f2p-4", "-0x1.1e4p-4", "-0x1.1dap-4",
"-0x1.1cep-4", "-0x1.1c2p-4", "-0x1.1b4p-4", "-0x1.1a8p-4", "-0x1.19cp-4", "-0x1.186p-4", "-0x1.17ap-4", "-0x1.16ep-4",
"-0x1.166p-4", "-0x1.156p-4", "-0x1.148p-4", "-0x1.13cp-4", "-0x1.12cp-4", "-0x1.122p-4", "-0x1.11p-4", "-0x1.104p-4",
};
};

namespace first_order_half {
// Tables for f= 1 - cos((pi) / 4 * x)
//  K0  estimated  -1  integer bits.
static const ap_fixed< 15 , 0 > cos_K0 [ 256 ] = {
"0", "0", "0", "0x4.p-16", "0x4.p-16", "0x8.p-16", "0xc.p-16", "0x1.p-12",
"0x1.4p-12", "0x1.8p-12", "0x2.p-12", "0x2.4p-12", "0x2.cp-12", "0x3.4p-12", "0x3.cp-12", "0x4.4p-12",
"0x5.p-12", "0x5.8p-12", "0x6.4p-12", "0x7.p-12", "0x7.cp-12", "0x8.8p-12", "0x9.4p-12", "0xa.4p-12",
"0xb.p-12", "0xc.p-12", "0xd.p-12", "0xe.p-12", "0xf.p-12", "0x1.04p-8", "0x1.14p-8", "0x1.28p-8",
"0x1.3cp-8", "0x1.5p-8", "0x1.64p-8", "0x1.78p-8", "0x1.9p-8", "0x1.a4p-8", "0x1.bcp-8", "0x1.d4p-8",
"0x1.ecp-8", "0x2.04p-8", "0x2.2p-8", "0x2.38p-8", "0x2.54p-8", "0x2.7p-8", "0x2.8cp-8", "0x2.a8p-8",
"0x2.c4p-8", "0x2.e4p-8", "0x3.p-8", "0x3.2p-8", "0x3.4p-8", "0x3.6p-8", "0x3.8p-8", "0x3.a4p-8",
"0x3.c4p-8", "0x3.e8p-8", "0x4.0cp-8", "0x4.3p-8", "0x4.54p-8", "0x4.78p-8", "0x4.9cp-8", "0x4.c4p-8",
"0x4.ecp-8", "0x5.14p-8", "0x5.3cp-8", "0x5.64p-8", "0x5.8cp-8", "0x5.b8p-8", "0x5.ep-8", "0x6.0cp-8",
"0x6.38p-8", "0x6.64p-8", "0x6.9p-8", "0x6.cp-8", "0x6.ecp-8", "0x7.1cp-8", "0x7.4cp-8", "0x7.7cp-8",
"0x7.acp-8", "0x7.dcp-8", "0x8.1p-8", "0x8.4p-8", "0x8.74p-8", "0x8.a8p-8", "0x8.dcp-8", "0x9.1p-8",
"0x9.44p-8", "0x9.7cp-8", "0x9.b4p-8", "0x9.e8p-8", "0xa.2p-8", "0xa.58p-8", "0xa.94p-8", "0xa.ccp-8",
"0xb.04p-8", "0xb.4p-8", "0xb.7cp-8", "0xb.b8p-8", "0xb.f4p-8", "0xc.3p-8", "0xc.7p-8", "0xc.acp-8",
"0xc.ecp-8", "0xd.2cp-8", "0xd.6cp-8", "0xd.acp-8", "0xd.ecp-8", "0xe.3p-8", "0xe.7p-8", "0xe.b4p-8",
"0xe.f8p-8", "0xf.3cp-8", "0xf.8p-8", "0xf.c4p-8", "0x1.00cp-4", "0x1.05p-4", "0x1.098p-4", "0x1.0ep-4",
"0x1.128p-4", "0x1.17p-4", "0x1.1b8p-4", "0x1.204p-4", "0x1.24cp-4", "0x1.298p-4", "0x1.2e4p-4", "0x1.33p-4",
"0x1.37cp-4", "0x1.3c8p-4", "0x1.418p-4", "0x1.464p-4", "0x1.4b4p-4", "0x1.504p-4", "0x1.554p-4", "0x1.5a4p-4",
"0x1.5f8p-4", "0x1.648p-4", "0x1.69cp-4", "0x1.6ecp-4", "0x1.74p-4", "0x1.794p-4", "0x1.7e8p-4", "0x1.84p-4",
"0x1.894p-4", "0x1.8ecp-4", "0x1.94p-4", "0x1.998p-4", "0x1.9fp-4", "0x1.a48p-4", "0x1.aap-4", "0x1.afcp-4",
"0x1.b54p-4", "0x1.bbp-4", "0x1.c0cp-4", "0x1.c68p-4", "0x1.cc4p-4", "0x1.d2p-4", "0x1.d7cp-4", "0x1.ddcp-4",
"0x1.e3cp-4", "0x1.e98p-4", "0x1.ef8p-4", "0x1.f58p-4", "0x1.fb8p-4", "0x2.01cp-4", "0x2.07cp-4", "0x2.0ep-4",
"0x2.14p-4", "0x2.1a4p-4", "0x2.208p-4", "0x2.26cp-4", "0x2.2d4p-4", "0x2.338p-4", "0x2.3ap-4", "0x2.404p-4",
"0x2.46cp-4", "0x2.4d4p-4", "0x2.53cp-4", "0x2.5a4p-4", "0x2.60cp-4", "0x2.678p-4", "0x2.6ep-4", "0x2.74cp-4",
"0x2.7b8p-4", "0x2.824p-4", "0x2.89p-4", "0x2.8fcp-4", "0x2.96cp-4", "0x2.9d8p-4", "0x2.a48p-4", "0x2.ab4p-4",
"0x2.b24p-4", "0x2.b94p-4", "0x2.c04p-4", "0x2.c78p-4", "0x2.ce8p-4", "0x2.d58p-4", "0x2.dccp-4", "0x2.e4p-4",
"0x2.eb4p-4", "0x2.f28p-4", "0x2.f9cp-4", "0x3.01p-4", "0x3.084p-4", "0x3.0fcp-4", "0x3.174p-4", "0x3.1e8p-4",
"0x3.26p-4", "0x3.2d8p-4", "0x3.35p-4", "0x3.3ccp-4", "0x3.444p-4", "0x3.4bcp-4", "0x3.538p-4", "0x3.5b4p-4",
"0x3.63p-4", "0x3.6acp-4", "0x3.728p-4", "0x3.7a4p-4", "0x3.82p-4", "0x3.8ap-4", "0x3.91cp-4", "0x3.99cp-4",
"0x3.a1cp-4", "0x3.a9cp-4", "0x3.b1cp-4", "0x3.b9cp-4", "0x3.c1cp-4", "0x3.cap-4", "0x3.d2p-4", "0x3.da4p-4",
"0x3.e28p-4", "0x3.eacp-4", "0x3.f3p-4", "0x3.fb4p-4", "0x4.038p-4", "0x4.0bcp-4", "0x4.144p-4", "0x4.1ccp-4",
"0x4.25p-4", "0x4.2d8p-4", "0x4.36p-4", "0x4.3e8p-4", "0x4.47p-4", "0x4.4f8p-4", "0x4.584p-4", "0x4.60cp-4",
"0x4.698p-4", "0x4.724p-4", "0x4.7acp-4", "0x4.838p-4", "0x4.8c4p-4", "0x4.954p-4", "0x4.9ep-4", "0x4.a6cp-4",
};
//  K1  estimated  0  integer bits.
static const ap_fixed< 7 , 1 > cos_K1 [ 256 ] = {
"0", "0", "0x4.p-8", "0", "0x4.p-8", "0x4.p-8", "0x4.p-8", "0x4.p-8",
"0x4.p-8", "0x8.p-8", "0x4.p-8", "0x8.p-8", "0x8.p-8", "0x8.p-8", "0x8.p-8", "0xc.p-8",
"0x8.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0xc.p-8", "0x1.p-4", "0xc.p-8",
"0x1.p-4", "0x1.p-4", "0x1.p-4", "0x1.p-4", "0x1.4p-4", "0x1.p-4", "0x1.4p-4", "0x1.4p-4",
"0x1.4p-4", "0x1.4p-4", "0x1.4p-4", "0x1.8p-4", "0x1.4p-4", "0x1.8p-4", "0x1.8p-4", "0x1.8p-4",
"0x1.cp-4", "0x1.cp-4", "0x1.8p-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4", "0x1.cp-4",
"0x2.p-4", "0x1.cp-4", "0x2.p-4", "0x2.p-4", "0x2.p-4", "0x2.p-4", "0x2.4p-4", "0x2.p-4",
"0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.4p-4", "0x2.8p-4", "0x2.8p-4", "0x2.8p-4",
"0x2.8p-4", "0x2.8p-4", "0x2.8p-4", "0x2.8p-4", "0x2.cp-4", "0x2.8p-4", "0x2.cp-4", "0x2.cp-4",
"0x2.cp-4", "0x2.cp-4", "0x3.p-4", "0x2.cp-4", "0x3.p-4", "0x3.p-4", "0x3.p-4", "0x3.p-4",
"0x3.p-4", "0x3.4p-4", "0x3.p-4", "0x3.4p-4", "0x3.4p-4", "0x3.4p-4", "0x3.4p-4", "0x3.8p-4",
"0x3.8p-4", "0x3.8p-4", "0x3.4p-4", "0x3.8p-4", "0x3.8p-4", "0x3.cp-4", "0x3.8p-4", "0x3.8p-4",
"0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x3.cp-4", "0x4.p-4", "0x3.cp-4", "0x4.p-4",
"0x4.p-4", "0x4.p-4", "0x4.p-4", "0x4.p-4", "0x4.4p-4", "0x4.p-4", "0x4.4p-4", "0x4.4p-4",
"0x4.4p-4", "0x4.4p-4", "0x4.4p-4", "0x4.8p-4", "0x4.4p-4", "0x4.8p-4", "0x4.8p-4", "0x4.8p-4",
"0x4.8p-4", "0x4.8p-4", "0x4.cp-4", "0x4.8p-4", "0x4.cp-4", "0x4.cp-4", "0x4.cp-4", "0x4.cp-4",
"0x5.p-4", "0x5.p-4", "0x4.cp-4", "0x5.p-4", "0x5.p-4", "0x5.p-4", "0x5.p-4", "0x5.4p-4",
"0x5.p-4", "0x5.4p-4", "0x5.p-4", "0x5.4p-4", "0x5.4p-4", "0x5.4p-4", "0x5.8p-4", "0x5.4p-4",
"0x5.8p-4", "0x5.4p-4", "0x5.8p-4", "0x5.8p-4", "0x5.8p-4", "0x5.cp-4", "0x5.cp-4", "0x5.8p-4",
"0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x5.cp-4", "0x6.p-4", "0x6.p-4", "0x6.p-4",
"0x5.cp-4", "0x6.p-4", "0x6.p-4", "0x6.4p-4", "0x6.4p-4", "0x6.p-4", "0x6.4p-4", "0x6.p-4",
"0x6.4p-4", "0x6.4p-4", "0x6.8p-4", "0x6.8p-4", "0x6.4p-4", "0x6.8p-4", "0x6.4p-4", "0x6.8p-4",
"0x6.8p-4", "0x6.8p-4", "0x6.8p-4", "0x6.8p-4", "0x6.cp-4", "0x6.8p-4", "0x6.cp-4", "0x6.cp-4",
"0x6.cp-4", "0x6.cp-4", "0x6.cp-4", "0x7.p-4", "0x6.cp-4", "0x7.p-4", "0x6.cp-4", "0x7.p-4",
"0x7.p-4", "0x7.p-4", "0x7.4p-4", "0x7.p-4", "0x7.p-4", "0x7.4p-4", "0x7.4p-4", "0x7.4p-4",
"0x7.4p-4", "0x7.4p-4", "0x7.4p-4", "0x7.4p-4", "0x7.8p-4", "0x7.8p-4", "0x7.4p-4", "0x7.8p-4",
"0x7.8p-4", "0x7.8p-4", "0x7.cp-4", "0x7.8p-4", "0x7.8p-4", "0x7.cp-4", "0x7.cp-4", "0x7.cp-4",
"0x7.cp-4", "0x7.cp-4", "0x7.cp-4", "0x7.cp-4", "0x8.p-4", "0x7.cp-4", "0x8.p-4", "0x8.p-4",
"0x8.p-4", "0x8.p-4", "0x8.p-4", "0x8.4p-4", "0x8.4p-4", "0x8.p-4", "0x8.4p-4", "0x8.4p-4",
"0x8.4p-4", "0x8.4p-4", "0x8.4p-4", "0x8.4p-4", "0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.4p-4",
"0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.8p-4", "0x8.cp-4", "0x8.cp-4", "0x8.8p-4", "0x8.cp-4",
"0x8.cp-4", "0x8.8p-4", "0x9.p-4", "0x9.p-4", "0x9.p-4", "0x8.cp-4", "0x8.cp-4", "0x9.p-4",
};

// Tables for f= sin((pi) / 4 * x) / x
//  K0  estimated  0  integer bits.
static const ap_fixed< 16 , 1 > sin_K0 [ 256 ] = {
"0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.90cp-4", "0xc.90cp-4", "0xc.90cp-4",
"0xc.90cp-4", "0xc.908p-4", "0xc.908p-4", "0xc.908p-4", "0xc.904p-4", "0xc.904p-4", "0xc.9p-4", "0xc.8fcp-4",
"0xc.8fcp-4", "0xc.8f8p-4", "0xc.8f4p-4", "0xc.8f4p-4", "0xc.8fp-4", "0xc.8ecp-4", "0xc.8e8p-4", "0xc.8e4p-4",
"0xc.8ep-4", "0xc.8dcp-4", "0xc.8d8p-4", "0xc.8d4p-4", "0xc.8dp-4", "0xc.8ccp-4", "0xc.8c8p-4", "0xc.8c4p-4",
"0xc.8bcp-4", "0xc.8b8p-4", "0xc.8b4p-4", "0xc.8acp-4", "0xc.8a8p-4", "0xc.8ap-4", "0xc.89cp-4", "0xc.894p-4",
"0xc.89p-4", "0xc.888p-4", "0xc.88p-4", "0xc.87cp-4", "0xc.874p-4", "0xc.86cp-4", "0xc.864p-4", "0xc.85cp-4",
"0xc.858p-4", "0xc.85p-4", "0xc.848p-4", "0xc.84p-4", "0xc.834p-4", "0xc.82cp-4", "0xc.824p-4", "0xc.81cp-4",
"0xc.814p-4", "0xc.808p-4", "0xc.8p-4", "0xc.7f8p-4", "0xc.7ecp-4", "0xc.7e4p-4", "0xc.7dcp-4", "0xc.7dp-4",
"0xc.7c4p-4", "0xc.7bcp-4", "0xc.7bp-4", "0xc.7a8p-4", "0xc.79cp-4", "0xc.79p-4", "0xc.784p-4", "0xc.778p-4",
"0xc.77p-4", "0xc.764p-4", "0xc.758p-4", "0xc.74cp-4", "0xc.74p-4", "0xc.734p-4", "0xc.728p-4", "0xc.718p-4",
"0xc.70cp-4", "0xc.7p-4", "0xc.6f4p-4", "0xc.6e4p-4", "0xc.6d8p-4", "0xc.6ccp-4", "0xc.6bcp-4", "0xc.6bp-4",
"0xc.6ap-4", "0xc.694p-4", "0xc.684p-4", "0xc.674p-4", "0xc.668p-4", "0xc.658p-4", "0xc.648p-4", "0xc.63cp-4",
"0xc.62cp-4", "0xc.61cp-4", "0xc.60cp-4", "0xc.5fcp-4", "0xc.5ecp-4", "0xc.5dcp-4", "0xc.5ccp-4", "0xc.5bcp-4",
"0xc.5acp-4", "0xc.59cp-4", "0xc.588p-4", "0xc.578p-4", "0xc.568p-4", "0xc.554p-4", "0xc.544p-4", "0xc.534p-4",
"0xc.52p-4", "0xc.51p-4", "0xc.4fcp-4", "0xc.4ecp-4", "0xc.4d8p-4", "0xc.4c4p-4", "0xc.4b4p-4", "0xc.4ap-4",
"0xc.48cp-4", "0xc.478p-4", "0xc.468p-4", "0xc.454p-4", "0xc.44p-4", "0xc.42cp-4", "0xc.418p-4", "0xc.404p-4",
"0xc.3fp-4", "0xc.3dcp-4", "0xc.3c8p-4", "0xc.3bp-4", "0xc.39cp-4", "0xc.388p-4", "0xc.374p-4", "0xc.35cp-4",
"0xc.348p-4", "0xc.33p-4", "0xc.31cp-4", "0xc.304p-4", "0xc.2fp-4", "0xc.2d8p-4", "0xc.2c4p-4", "0xc.2acp-4",
"0xc.294p-4", "0xc.28p-4", "0xc.268p-4", "0xc.25p-4", "0xc.238p-4", "0xc.22p-4", "0xc.20cp-4", "0xc.1f4p-4",
"0xc.1dcp-4", "0xc.1c4p-4", "0xc.1acp-4", "0xc.19p-4", "0xc.178p-4", "0xc.16p-4", "0xc.148p-4", "0xc.13p-4",
"0xc.114p-4", "0xc.0fcp-4", "0xc.0e4p-4", "0xc.0c8p-4", "0xc.0bp-4", "0xc.094p-4", "0xc.07cp-4", "0xc.06p-4",
"0xc.048p-4", "0xc.02cp-4", "0xc.01p-4", "0xb.ff8p-4", "0xb.fdcp-4", "0xb.fcp-4", "0xb.fa4p-4", "0xb.f8cp-4",
"0xb.f7p-4", "0xb.f54p-4", "0xb.f38p-4", "0xb.f1cp-4", "0xb.fp-4", "0xb.ee4p-4", "0xb.ec8p-4", "0xb.eacp-4",
"0xb.e8cp-4", "0xb.e7p-4", "0xb.e54p-4", "0xb.e38p-4", "0xb.e18p-4", "0xb.dfcp-4", "0xb.dep-4", "0xb.dcp-4",
"0xb.da4p-4", "0xb.d84p-4", "0xb.d68p-4", "0xb.d48p-4", "0xb.d28p-4", "0xb.d0cp-4", "0xb.cecp-4", "0xb.cccp-4",
"0xb.cbp-4", "0xb.c9p-4", "0xb.c7p-4", "0xb.c5p-4", "0xb.c3p-4", "0xb.c1p-4", "0xb.bfp-4", "0xb.bdp-4",
"0xb.bbp-4", "0xb.b9p-4", "0xb.b7p-4", "0xb.b5p-4", "0xb.b3p-4", "0xb.b0cp-4", "0xb.aecp-4", "0xb.accp-4",
"0xb.aacp-4", "0xb.a88p-4", "0xb.a68p-4", "0xb.a44p-4", "0xb.a24p-4", "0xb.ap-4", "0xb.9ep-4", "0xb.9bcp-4",
"0xb.99cp-4", "0xb.978p-4", "0xb.954p-4", "0xb.934p-4", "0xb.91p-4", "0xb.8ecp-4", "0xb.8c8p-4", "0xb.8a8p-4",
"0xb.884p-4", "0xb.86p-4", "0xb.83cp-4", "0xb.818p-4", "0xb.7f4p-4", "0xb.7dp-4", "0xb.7acp-4", "0xb.788p-4",
"0xb.76p-4", "0xb.73cp-4", "0xb.718p-4", "0xb.6f4p-4", "0xb.6ccp-4", "0xb.6a8p-4", "0xb.684p-4", "0xb.65cp-4",
"0xb.638p-4", "0xb.61p-4", "0xb.5ecp-4", "0xb.5c4p-4", "0xb.5ap-4", "0xb.578p-4", "0xb.554p-4", "0xb.52cp-4",
};
//  K1  estimated  -2  integer bits.
static const ap_fixed< 6 , -1 > sin_K1 [ 256 ] = {
"0", "0", "0", "0", "-0x4.p-8", "0", "0", "0",
"-0x4.p-8", "0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "0",
"-0x4.p-8", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x8.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8",
"-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x4.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8",
"-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4",
"-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4",
"-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
};

static const ap_fixed< 15 , 1 > sin_cos_K0 [ 512 ] = {
"0x1.p0", "0x1.p0", "0x1.p0", "0xf.ffcp-4", "0xf.ffcp-4", "0xf.ff8p-4", "0xf.ff4p-4", "0xf.ffp-4",
"0xf.fecp-4", "0xf.fe8p-4", "0xf.fep-4", "0xf.fdcp-4", "0xf.fd4p-4", "0xf.fccp-4", "0xf.fc4p-4", "0xf.fbcp-4",
"0xf.fbp-4", "0xf.fa8p-4", "0xf.f9cp-4", "0xf.f9p-4", "0xf.f84p-4", "0xf.f78p-4", "0xf.f6cp-4", "0xf.f5cp-4",
"0xf.f5p-4", "0xf.f4p-4", "0xf.f3p-4", "0xf.f2p-4", "0xf.f1p-4", "0xf.efcp-4", "0xf.eecp-4", "0xf.ed8p-4",
"0xf.ec4p-4", "0xf.ebp-4", "0xf.e9cp-4", "0xf.e88p-4", "0xf.e7p-4", "0xf.e5cp-4", "0xf.e44p-4", "0xf.e2cp-4",
"0xf.e14p-4", "0xf.dfcp-4", "0xf.dep-4", "0xf.dc8p-4", "0xf.dacp-4", "0xf.d9p-4", "0xf.d74p-4", "0xf.d58p-4",
"0xf.d3cp-4", "0xf.d1cp-4", "0xf.dp-4", "0xf.cep-4", "0xf.ccp-4", "0xf.cap-4", "0xf.c8p-4", "0xf.c5cp-4",
"0xf.c3cp-4", "0xf.c18p-4", "0xf.bf4p-4", "0xf.bdp-4", "0xf.bacp-4", "0xf.b88p-4", "0xf.b64p-4", "0xf.b3cp-4",
"0xf.b14p-4", "0xf.aecp-4", "0xf.ac4p-4", "0xf.a9cp-4", "0xf.a74p-4", "0xf.a48p-4", "0xf.a2p-4", "0xf.9f4p-4",
"0xf.9c8p-4", "0xf.99cp-4", "0xf.97p-4", "0xf.94p-4", "0xf.914p-4", "0xf.8e4p-4", "0xf.8b4p-4", "0xf.884p-4",
"0xf.854p-4", "0xf.824p-4", "0xf.7fp-4", "0xf.7cp-4", "0xf.78cp-4", "0xf.758p-4", "0xf.724p-4", "0xf.6fp-4",
"0xf.6bcp-4", "0xf.684p-4", "0xf.64cp-4", "0xf.618p-4", "0xf.5ep-4", "0xf.5a8p-4", "0xf.56cp-4", "0xf.534p-4",
"0xf.4fcp-4", "0xf.4cp-4", "0xf.484p-4", "0xf.448p-4", "0xf.40cp-4", "0xf.3dp-4", "0xf.39p-4", "0xf.354p-4",
"0xf.314p-4", "0xf.2d4p-4", "0xf.294p-4", "0xf.254p-4", "0xf.214p-4", "0xf.1dp-4", "0xf.19p-4", "0xf.14cp-4",
"0xf.108p-4", "0xf.0c4p-4", "0xf.08p-4", "0xf.03cp-4", "0xe.ff4p-4", "0xe.fbp-4", "0xe.f68p-4", "0xe.f2p-4",
"0xe.ed8p-4", "0xe.e9p-4", "0xe.e48p-4", "0xe.dfcp-4", "0xe.db4p-4", "0xe.d68p-4", "0xe.d1cp-4", "0xe.cdp-4",
"0xe.c84p-4", "0xe.c38p-4", "0xe.be8p-4", "0xe.b9cp-4", "0xe.b4cp-4", "0xe.afcp-4", "0xe.aacp-4", "0xe.a5cp-4",
"0xe.a08p-4", "0xe.9b8p-4", "0xe.964p-4", "0xe.914p-4", "0xe.8cp-4", "0xe.86cp-4", "0xe.818p-4", "0xe.7cp-4",
"0xe.76cp-4", "0xe.714p-4", "0xe.6cp-4", "0xe.668p-4", "0xe.61p-4", "0xe.5b8p-4", "0xe.56p-4", "0xe.504p-4",
"0xe.4acp-4", "0xe.45p-4", "0xe.3f4p-4", "0xe.398p-4", "0xe.33cp-4", "0xe.2ep-4", "0xe.284p-4", "0xe.224p-4",
"0xe.1c4p-4", "0xe.168p-4", "0xe.108p-4", "0xe.0a8p-4", "0xe.048p-4", "0xd.fe4p-4", "0xd.f84p-4", "0xd.f2p-4",
"0xd.ecp-4", "0xd.e5cp-4", "0xd.df8p-4", "0xd.d94p-4", "0xd.d2cp-4", "0xd.cc8p-4", "0xd.c6p-4", "0xd.bfcp-4",
"0xd.b94p-4", "0xd.b2cp-4", "0xd.ac4p-4", "0xd.a5cp-4", "0xd.9f4p-4", "0xd.988p-4", "0xd.92p-4", "0xd.8b4p-4",
"0xd.848p-4", "0xd.7dcp-4", "0xd.77p-4", "0xd.704p-4", "0xd.694p-4", "0xd.628p-4", "0xd.5b8p-4", "0xd.54cp-4",
"0xd.4dcp-4", "0xd.46cp-4", "0xd.3fcp-4", "0xd.388p-4", "0xd.318p-4", "0xd.2a8p-4", "0xd.234p-4", "0xd.1cp-4",
"0xd.14cp-4", "0xd.0d8p-4", "0xd.064p-4", "0xc.ffp-4", "0xc.f7cp-4", "0xc.f04p-4", "0xc.e8cp-4", "0xc.e18p-4",
"0xc.dap-4", "0xc.d28p-4", "0xc.cbp-4", "0xc.c34p-4", "0xc.bbcp-4", "0xc.b44p-4", "0xc.ac8p-4", "0xc.a4cp-4",
"0xc.9dp-4", "0xc.954p-4", "0xc.8d8p-4", "0xc.85cp-4", "0xc.7ep-4", "0xc.76p-4", "0xc.6e4p-4", "0xc.664p-4",
"0xc.5e4p-4", "0xc.564p-4", "0xc.4e4p-4", "0xc.464p-4", "0xc.3e4p-4", "0xc.36p-4", "0xc.2ep-4", "0xc.25cp-4",
"0xc.1d8p-4", "0xc.154p-4", "0xc.0dp-4", "0xc.04cp-4", "0xb.fc8p-4", "0xb.f44p-4", "0xb.ebcp-4", "0xb.e34p-4",
"0xb.dbp-4", "0xb.d28p-4", "0xb.cap-4", "0xb.c18p-4", "0xb.b9p-4", "0xb.b08p-4", "0xb.a7cp-4", "0xb.9f4p-4",
"0xb.968p-4", "0xb.8dcp-4", "0xb.854p-4", "0xb.7c8p-4", "0xb.73cp-4", "0xb.6acp-4", "0xb.62p-4", "0xb.594p-4",
//
"0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.91p-4", "0xc.90cp-4", "0xc.90cp-4", "0xc.90cp-4",
"0xc.90cp-4", "0xc.908p-4", "0xc.908p-4", "0xc.908p-4", "0xc.904p-4", "0xc.904p-4", "0xc.9p-4", "0xc.8fcp-4",
"0xc.8fcp-4", "0xc.8f8p-4", "0xc.8f4p-4", "0xc.8f4p-4", "0xc.8fp-4", "0xc.8ecp-4", "0xc.8e8p-4", "0xc.8e4p-4",
"0xc.8ep-4", "0xc.8dcp-4", "0xc.8d8p-4", "0xc.8d4p-4", "0xc.8dp-4", "0xc.8ccp-4", "0xc.8c8p-4", "0xc.8c4p-4",
"0xc.8bcp-4", "0xc.8b8p-4", "0xc.8b4p-4", "0xc.8acp-4", "0xc.8a8p-4", "0xc.8ap-4", "0xc.89cp-4", "0xc.894p-4",
"0xc.89p-4", "0xc.888p-4", "0xc.88p-4", "0xc.87cp-4", "0xc.874p-4", "0xc.86cp-4", "0xc.864p-4", "0xc.85cp-4",
"0xc.858p-4", "0xc.85p-4", "0xc.848p-4", "0xc.84p-4", "0xc.834p-4", "0xc.82cp-4", "0xc.824p-4", "0xc.81cp-4",
"0xc.814p-4", "0xc.808p-4", "0xc.8p-4", "0xc.7f8p-4", "0xc.7ecp-4", "0xc.7e4p-4", "0xc.7dcp-4", "0xc.7dp-4",
"0xc.7c4p-4", "0xc.7bcp-4", "0xc.7bp-4", "0xc.7a8p-4", "0xc.79cp-4", "0xc.79p-4", "0xc.784p-4", "0xc.778p-4",
"0xc.77p-4", "0xc.764p-4", "0xc.758p-4", "0xc.74cp-4", "0xc.74p-4", "0xc.734p-4", "0xc.728p-4", "0xc.718p-4",
"0xc.70cp-4", "0xc.7p-4", "0xc.6f4p-4", "0xc.6e4p-4", "0xc.6d8p-4", "0xc.6ccp-4", "0xc.6bcp-4", "0xc.6bp-4",
"0xc.6ap-4", "0xc.694p-4", "0xc.684p-4", "0xc.674p-4", "0xc.668p-4", "0xc.658p-4", "0xc.648p-4", "0xc.63cp-4",
"0xc.62cp-4", "0xc.61cp-4", "0xc.60cp-4", "0xc.5fcp-4", "0xc.5ecp-4", "0xc.5dcp-4", "0xc.5ccp-4", "0xc.5bcp-4",
"0xc.5acp-4", "0xc.59cp-4", "0xc.588p-4", "0xc.578p-4", "0xc.568p-4", "0xc.554p-4", "0xc.544p-4", "0xc.534p-4",
"0xc.52p-4", "0xc.51p-4", "0xc.4fcp-4", "0xc.4ecp-4", "0xc.4d8p-4", "0xc.4c4p-4", "0xc.4b4p-4", "0xc.4ap-4",
"0xc.48cp-4", "0xc.478p-4", "0xc.468p-4", "0xc.454p-4", "0xc.44p-4", "0xc.42cp-4", "0xc.418p-4", "0xc.404p-4",
"0xc.3fp-4", "0xc.3dcp-4", "0xc.3c8p-4", "0xc.3bp-4", "0xc.39cp-4", "0xc.388p-4", "0xc.374p-4", "0xc.35cp-4",
"0xc.348p-4", "0xc.33p-4", "0xc.31cp-4", "0xc.304p-4", "0xc.2fp-4", "0xc.2d8p-4", "0xc.2c4p-4", "0xc.2acp-4",
"0xc.294p-4", "0xc.28p-4", "0xc.268p-4", "0xc.25p-4", "0xc.238p-4", "0xc.22p-4", "0xc.20cp-4", "0xc.1f4p-4",
"0xc.1dcp-4", "0xc.1c4p-4", "0xc.1acp-4", "0xc.19p-4", "0xc.178p-4", "0xc.16p-4", "0xc.148p-4", "0xc.13p-4",
"0xc.114p-4", "0xc.0fcp-4", "0xc.0e4p-4", "0xc.0c8p-4", "0xc.0bp-4", "0xc.094p-4", "0xc.07cp-4", "0xc.06p-4",
"0xc.048p-4", "0xc.02cp-4", "0xc.01p-4", "0xb.ff8p-4", "0xb.fdcp-4", "0xb.fcp-4", "0xb.fa4p-4", "0xb.f8cp-4",
"0xb.f7p-4", "0xb.f54p-4", "0xb.f38p-4", "0xb.f1cp-4", "0xb.fp-4", "0xb.ee4p-4", "0xb.ec8p-4", "0xb.eacp-4",
"0xb.e8cp-4", "0xb.e7p-4", "0xb.e54p-4", "0xb.e38p-4", "0xb.e18p-4", "0xb.dfcp-4", "0xb.dep-4", "0xb.dcp-4",
"0xb.da4p-4", "0xb.d84p-4", "0xb.d68p-4", "0xb.d48p-4", "0xb.d28p-4", "0xb.d0cp-4", "0xb.cecp-4", "0xb.cccp-4",
"0xb.cbp-4", "0xb.c9p-4", "0xb.c7p-4", "0xb.c5p-4", "0xb.c3p-4", "0xb.c1p-4", "0xb.bfp-4", "0xb.bdp-4",
"0xb.bbp-4", "0xb.b9p-4", "0xb.b7p-4", "0xb.b5p-4", "0xb.b3p-4", "0xb.b0cp-4", "0xb.aecp-4", "0xb.accp-4",
"0xb.aacp-4", "0xb.a88p-4", "0xb.a68p-4", "0xb.a44p-4", "0xb.a24p-4", "0xb.ap-4", "0xb.9ep-4", "0xb.9bcp-4",
"0xb.99cp-4", "0xb.978p-4", "0xb.954p-4", "0xb.934p-4", "0xb.91p-4", "0xb.8ecp-4", "0xb.8c8p-4", "0xb.8a8p-4",
"0xb.884p-4", "0xb.86p-4", "0xb.83cp-4", "0xb.818p-4", "0xb.7f4p-4", "0xb.7dp-4", "0xb.7acp-4", "0xb.788p-4",
"0xb.76p-4", "0xb.73cp-4", "0xb.718p-4", "0xb.6f4p-4", "0xb.6ccp-4", "0xb.6a8p-4", "0xb.684p-4", "0xb.65cp-4",
"0xb.638p-4", "0xb.61p-4", "0xb.5ecp-4", "0xb.5c4p-4", "0xb.5ap-4", "0xb.578p-4", "0xb.554p-4", "0xb.52cp-4",
};

static const ap_fixed< 7 , 1 > sin_cos_K1 [ 512 ] = {
"0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.8p-4", "-0x2.cp-4", "-0x2.8p-4", "-0x2.cp-4", "-0x2.cp-4",
"-0x2.cp-4", "-0x2.cp-4", "-0x3.p-4", "-0x2.cp-4", "-0x3.p-4", "-0x3.p-4", "-0x3.p-4", "-0x3.p-4",
"-0x3.p-4", "-0x3.4p-4", "-0x3.p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.4p-4", "-0x3.8p-4",
"-0x3.8p-4", "-0x3.8p-4", "-0x3.4p-4", "-0x3.8p-4", "-0x3.8p-4", "-0x3.cp-4", "-0x3.8p-4", "-0x3.8p-4",
"-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x3.cp-4", "-0x4.p-4", "-0x3.cp-4", "-0x4.p-4",
"-0x4.p-4", "-0x4.p-4", "-0x4.p-4", "-0x4.p-4", "-0x4.4p-4", "-0x4.p-4", "-0x4.4p-4", "-0x4.4p-4",
"-0x4.4p-4", "-0x4.4p-4", "-0x4.4p-4", "-0x4.8p-4", "-0x4.4p-4", "-0x4.8p-4", "-0x4.8p-4", "-0x4.8p-4",
"-0x4.8p-4", "-0x4.8p-4", "-0x4.cp-4", "-0x4.8p-4", "-0x4.cp-4", "-0x4.cp-4", "-0x4.cp-4", "-0x4.cp-4",
"-0x5.p-4", "-0x5.p-4", "-0x4.cp-4", "-0x5.p-4", "-0x5.p-4", "-0x5.p-4", "-0x5.p-4", "-0x5.4p-4",
"-0x5.p-4", "-0x5.4p-4", "-0x5.p-4", "-0x5.4p-4", "-0x5.4p-4", "-0x5.4p-4", "-0x5.8p-4", "-0x5.4p-4",
"-0x5.8p-4", "-0x5.4p-4", "-0x5.8p-4", "-0x5.8p-4", "-0x5.8p-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.8p-4",
"-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x5.cp-4", "-0x6.p-4", "-0x6.p-4", "-0x6.p-4",
"-0x5.cp-4", "-0x6.p-4", "-0x6.p-4", "-0x6.4p-4", "-0x6.4p-4", "-0x6.p-4", "-0x6.4p-4", "-0x6.p-4",
"-0x6.4p-4", "-0x6.4p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.4p-4", "-0x6.8p-4", "-0x6.4p-4", "-0x6.8p-4",
"-0x6.8p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.8p-4", "-0x6.cp-4", "-0x6.8p-4", "-0x6.cp-4", "-0x6.cp-4",
"-0x6.cp-4", "-0x6.cp-4", "-0x6.cp-4", "-0x7.p-4", "-0x6.cp-4", "-0x7.p-4", "-0x6.cp-4", "-0x7.p-4",
"-0x7.p-4", "-0x7.p-4", "-0x7.4p-4", "-0x7.p-4", "-0x7.p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4",
"-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.4p-4", "-0x7.8p-4", "-0x7.8p-4", "-0x7.4p-4", "-0x7.8p-4",
"-0x7.8p-4", "-0x7.8p-4", "-0x7.cp-4", "-0x7.8p-4", "-0x7.8p-4", "-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4",
"-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4", "-0x7.cp-4", "-0x8.p-4", "-0x7.cp-4", "-0x8.p-4", "-0x8.p-4",
"-0x8.p-4", "-0x8.p-4", "-0x8.p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.p-4", "-0x8.4p-4", "-0x8.4p-4",
"-0x8.4p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.4p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.4p-4",
"-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.8p-4", "-0x8.cp-4", "-0x8.cp-4", "-0x8.8p-4", "-0x8.cp-4",
"-0x8.cp-4", "-0x8.8p-4", "-0x9.p-4", "-0x9.p-4", "-0x9.p-4", "-0x8.cp-4", "-0x8.cp-4", "-0x9.p-4",
//
"0", "0", "0", "0", "-0x4.p-8", "0", "0", "0",
"-0x4.p-8", "0", "0", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "0",
"-0x4.p-8", "-0x4.p-8", "0", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x4.p-8", "-0x8.p-8",
"-0x4.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x4.p-8",
"-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x4.p-8", "-0x4.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8",
"-0x8.p-8", "-0xc.p-8", "-0x8.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x8.p-8", "-0x8.p-8",
"-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8",
"-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0xc.p-8", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4", "-0x1.p-4", "-0xc.p-8", "-0x1.p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.p-4",
"-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.p-4", "-0x1.p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.4p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4",
"-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4",
"-0x1.4p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.4p-4", "-0x1.4p-4", "-0x1.cp-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.8p-4",
"-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.8p-4", "-0x1.8p-4", "-0x1.cp-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4",
"-0x1.cp-4", "-0x1.cp-4", "-0x1.cp-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4", "-0x2.p-4", "-0x2.p-4", "-0x1.cp-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",
"-0x2.4p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4",
"-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.4p-4", "-0x2.8p-4", "-0x2.8p-4",

};
};

namespace fourth_order_double {
// Tables for f= 1 - cos((pi) / 4 * x)
//  K0  estimated  -1  integer bits.
static const ap_fixed< 59 , 0 > cos_K0 [ 128 ] = {
"0", "0x1.3bd38bab6dap-16", "0x4.ef4b2369256p-16", "0xb.1a5da572f6ep-16", "0x1.3bcfbd9979a6p-12", "0x1.ed71071603eep-12", "0x2.c688008451b8p-12", "0x3.c712923f106ep-12",
"0x4.ef0e43494116p-12", "0x6.3e7839545222p-12", "0x7.b54d38c7296ap-12", "0x9.5389a4c61e2ap-12", "0xb.19297f3be302p-12", "0xd.062868e35fd8p-12", "0xf.1a81a1527b82p-12", "0x1.156300705d52ap-8",
"0x1.3b92e176d6d42p-8", "0x1.64375eefa3de8p-8", "0x1.8f501492cc2a8p-8", "0x1.bcdc980a46f6ep-8", "0x1.ecdc78f30167p-8", "0x2.1f4f40ddf3d18p-8", "0x2.5434735145f84p-8", "0x2.8b8b8dc9822acp-8",
"0x2.c55407bad74c8p-8", "0x3.018d529269bfap-8", "0x3.4036d9b7b32d6p-8", "0x3.8150028df12b4p-8", "0x3.c4d82c75a2b82p-8", "0x4.0aceb0ce148e6p-8", "0x4.5332e2f6fc46ep-8", "0x4.9e04105222486p-8",
"0x4.eb4180451a80ap-8", "0x5.3aea743b0be1p-8", "0x5.8cfe27a6869bcp-8", "0x5.e17bd003691d6p-8", "0x6.38629cd8d3bc2p-8", "0x6.91b1b7bb2b1a2p-8", "0x6.ed68444e2934ap-8", "0x7.4b856046fd1bp-8",
"0x7.ac08236e79492p-8", "0x8.0eef9fa3509fp-8", "0x8.743ae0dc61efep-8", "0x8.dbe8ed2b12246p-8", "0x9.45f8c4bdb4e8ep-8", "0x9.b26961e203e1cp-8", "0xa.2139b907a4612p-8", "0xa.9268b8c2bb962p-8",
"0xb.05f549ce913p-8", "0xb.7bde4f10406f6p-8", "0xb.f422a599779cep-8", "0xc.6ec124ab45e0ep-8", "0xc.ebb89db8f773cp-8", "0xd.6b07dc6b00202p-8", "0xd.ecada6a1f41p-8", "0xe.70a8bc798edd2p-8",
"0xe.f6f7d84bc8dd8p-8", "0xf.7f99aeb3faa4p-8", "0x1.00a8cee920eae4p-4", "0x1.097d0410dc136p-4", "0x1.127624999ee20ap-4", "0x1.1b941a5f7ed026p-4","0x1.24d6cee3afb2d8p-4", "0x1.2e3e2b4cbb3c68p-4",
"0x1.37ca1866b95d2ap-4", "0x1.417a7ea389839p-4", "0x1.4b4f461b0cbadep-4","0x1.5548568b60a7f2p-4", "0x1.5f6597591b636cp-4", "0x1.69a6ef8f8830e2p-4", "0x1.740c45e0e51248p-4", "0x1.7e9580a6a13722p-4",
"0x1.894285e19c46cep-4", "0x1.94133b3a668556p-4", "0x1.9f07860181d22ap-4", "0x1.aa1f4b2fa3801p-4", "0x1.b55a6f65f705cep-4", "0x1.c0b8d6ee6186bcp-4", "0x1.cc3a65bbc632bcp-4", "0x1.d7deff6a4b7cd6p-4",
"0x1.e3a6873fa127e4p-4", "0x1.ef90e02b472884p-4", "0x1.fb9decc6d55bc8p-4", "0x2.07cd8f564411c6p-4", "0x2.141fa9c8356b8p-4", "0x2.20941db63f8b4ep-4", "0x2.2d2acc65379722p-4", "0x2.39e396c57d8bf6p-4",
"0x2.46be5d7348e18cp-4", "0x2.53bb00b6f5fde4p-4", "0x2.60d96085547792p-4", "0x2.6e195c7ff6264p-4", "0x2.7b7ad3f57f008ap-4", "0x2.88fda5e1f5c68p-4", "0x2.96a1b0ef157802p-4", "0x2.a466d3749f9624p-4",
"0x2.b24ceb78af2ed8p-4", "0x2.c053d6b00cb20ep-4", "0x2.ce7b727e828f7ap-4", "0x2.dcc39bf7329c3ap-4", "0x2.eb2c2fdcec3f7p-4", "0x2.f9b50aa283651ap-4", "0x3.085e086b283644p-4", "0x3.1727050abf95a8p-4",
"0x3.260fdc063c6008p-4", "0x3.35186893f96f4ap-4", "0x3.4440859c145f86p-4", "0x3.53880db8c9150ep-4", "0x3.62eedb36ce02bcp-4", "0x3.7274c815b12f6ep-4", "0x3.8219ae0835f9f2p-4", "0x3.91dd6674b39a5ep-4",
"0x3.a1bfca7574600cp-4", "0x3.b1c0b2d915ab2cp-4", "0x3.c1dff822e8a10ep-4", "0x3.d21d728b539a4p-4", "0x3.e278fa00344982p-4", "0x3.f2f26625429a96p-4", "0x4.03898e5474482p-4", "0x4.143e499e61275cp-4",
"0x4.25106ecaa828fep-4", "0x4.35ffd458550e1p-4", "0x4.470c507e46cfdap-4","0x4.5835b92b96b9fp-4", "0x4.697be40800354ep-4", "0x4.7adea67449438ep-4","0x4.8c5dd58aaba92ep-4", "0x4.9df9461f3ec5eap-4",
};
//  K1  estimated  0  integer bits.
static const ap_fixed< 53 , 1 > cos_K1 [ 128 ] = {
"-0x7.p-52", "0x1.3bd34abafa4p-8", "0x2.77a38a3203ep-8", "0x3.b36db328ae7p-8", "0x4.ef2eba71922p-8", "0x6.2ae394f5ccdp-8", "0x7.668937bc897p-8", "0x8.a21c97f27dbp-8",
"0x9.dd9aaaf16cfp-8", "0xb.19006647aabp-8", "0xc.544abfbf99dp-8", "0xd.8f76ad672dep-8", "0xe.ca81259769bp-8", "0x1.005671efbde3p-4", "0x1.14025909a299p-4", "0x1.27ab971d9728p-4",
"0x1.3b51fba89e4fp-4", "0x1.4ef5562ec2f5p-4", "0x1.6295763b8f9ep-4", "0x1.76322b6285fcp-4", "0x1.89cb453f969fp-4", "0x1.9d6093779807p-4", "0x1.b0f1e5b8be47p-4", "0x1.c47f0bbb11fcp-4",
"0x1.d807d540e7b4p-4", "0x1.eb8c121756a3p-4", "0x1.ff0b9216afc9p-4", "0x2.12862522f4aep-4", "0x2.25fb9b2c4e2bp-4", "0x2.396bc42f82ecp-4", "0x2.4cd670366de1p-4", "0x2.603b6f5874b8p-4",
"0x2.739a91bafddbp-4", "0x2.86f3a791e6b3p-4", "0x2.9a46811ff99dp-4", "0x2.ad92eeb76388p-4", "0x2.c0d8c0ba29b5p-4", "0x2.d417c79a9f2fp-4", "0x2.e74fd3dbda1ep-4", "0x2.fa80b6122902p-4",
"0x3.0daa3ee387acp-4", "0x3.20cc3f0813f4p-4", "0x3.33e6874a82a3p-4", "0x3.46f8e88893c1p-4", "0x3.5a0333b386cdp-4", "0x3.6d0539d08f2p-4", "0x3.7ffecbf94795p-4", "0x3.92efbb5c265dp-4",
"0x3.a5d7d93cf095p-4", "0x3.b8b6f6f52d5ap-4", "0x3.cb8ce5f4993p-4", "0x3.de5977c198bbp-4", "0x3.f11c7df9ab71p-4", "0x4.03d5ca51de12p-4", "0x4.16852e973cd5p-4", "0x4.292a7caf4574p-4",
"0x4.3bc5869858ecp-4", "0x4.4e561e6a2dp-4", "0x4.60dc16563d65p-4", "0x4.735740a83d02p-4", "0x4.85c76fc68676p-4", "0x4.982c76328cb5p-4", "0x4.aa8626894b6ap-4", "0x4.bcd45383b6bdp-4",
"0x4.cf16cff72b1ap-4", "0x4.e14d6ed5dcbap-4", "0x4.f378032f46cfp-4", "0x5.059660309a1dp-4", "0x5.17a859252c16p-4", "0x5.29adc176e4a4p-4", "0x5.3ba66caeac7dp-4", "0x5.4d922e74dabcp-4",
"0x5.5f70da91a259p-4", "0x5.714244ed7f3ep-4", "0x5.83064191a2eep-4", "0x5.94bca4a86155p-4", "0x5.a665427d9c8cp-4", "0x5.b7ffef7f30f5p-4", "0x5.c98c803d6099p-4", "0x5.db0ac96b3e6fp-4",
"0x5.ec7a9fdf1912p-4", "0x5.fddbd892e56fp-4", "0x6.0f2e48a4a8bp-4", "0x6.2071c556e25p-4", "0x6.31a62410f54cp-4", "0x6.42cb3a5f916cp-4", "0x6.53e0ddf51bffp-4", "0x6.64e6e4aa1815p-4",
"0x6.75dd247d8eb3p-4", "0x6.86c373957657p-4", "0x6.9799a83f1a4ap-4", "0x6.a85f98ef8169p-4", "0x6.b9151c43d4c7p-4", "0x6.c9ba0901c5d7p-4", "0x6.da4e3617f3efp-4", "0x6.ead17a9e51bap-4",
"0x6.fb43add68a2fp-4", "0x7.0ba4a72c650cp-4", "0x7.1bf43e362b06p-4", "0x7.2c324ab5095ep-4", "0x7.3c5ea495756p-4", "0x7.4c7923ef8f26p-4", "0x7.5c81a10783eep-4", "0x7.6c77f44df068p-4",
"0x7.7c5bf6604235p-4", "0x7.8c2d8009191p-4", "0x7.9bec6a40a76fp-4", "0x7.ab988e2d1327p-4", "0x7.bb31c522d4e2p-4", "0x7.cab7e8a517c7p-4", "0x7.da2ad266186p-4", "0x7.e98a5c478338p-4",
"0x7.f8d6605ad2b5p-4", "0x8.080eb8e1acc1p-4", "0x8.1733404e4009p-4", "0x8.2643d143a092p-4", "0x8.3540469623cfp-4", "0x8.44287b4bbca3p-4", "0x8.52fc4a9c5628p-4", "0x8.61bb8ff22efp-4",
"0x8.706626ea32fap-4", "0x8.7efbeb545571p-4", "0x8.8d7cb933ea3bp-4", "0x8.9be86cbffe93p-4", "0x8.aa3ee263b157p-4", "0x8.b87ff6be8accp-4", "0x8.c6ab86a4d407p-4", "0x8.d4c16f1fedb3p-4",
};
//  K2  estimated  -1  integer bits.
static const ap_fixed< 45 , 0 > cos_K2 [ 128 ] = {
"0x4.ef4f326fb2p-4", "0x4.ef491be5bp-4", "0x4.ef36d855f9p-4", "0x4.ef1867ed908p-4", "0x4.eeedcaf7868p-4", "0x4.eeb701dd21p-4", "0x4.ee740d2569p-4", "0x4.ee24ed75a08p-4",
"0x4.edc9a3910cp-4", "0x4.ed623058e7p-4", "0x4.ecee94cc75p-4", "0x4.ec6ed208ec8p-4", "0x4.ebe2e9498dp-4", "0x4.eb4adbe79p-4", "0x4.eaa6ab5a0f8p-4", "0x4.e9f659363a8p-4",
"0x4.e939e72f2ep-4", "0x4.e8715715c1p-4", "0x4.e79caad8ep-4", "0x4.e6bbe485578p-4", "0x4.e5cf0645a68p-4", "0x4.e4d612626p-4", "0x4.e3d10b41b7p-4", "0x4.e2bff367c98p-4",
"0x4.e1a2cd7644p-4", "0x4.e0799c2cd58p-4", "0x4.df446268ca8p-4", "0x4.de032325268p-4", "0x4.dcb5e17a7dp-4", "0x4.db5ca09f12p-4", "0x4.d9f763e6d4p-4", "0x4.d8862ec3198p-4",
"0x4.d70904c2fdp-4", "0x4.d57fe993008p-4", "0x4.d3eae0fcf68p-4", "0x4.d249eee8448p-4", "0x4.d09d1759b3p-4", "0x4.cee45e7369p-4", "0x4.cd1fc874db8p-4", "0x4.cb4f59babdp-4",
"0x4.c97316bee28p-4", "0x4.c78b04189cp-4", "0x4.c597267c0f8p-4", "0x4.c39782ba87p-4", "0x4.c18c1dc29d8p-4", "0x4.bf74fc9f99p-4", "0x4.bd522479e5p-4", "0x4.bb239a96cep-4",
"0x4.b8e964585b8p-4", "0x4.b6a3873da9p-4", "0x4.b45208e255p-4", "0x4.b1f4eefebdp-4", "0x4.af8c3f67e7p-4", "0x4.ad18000f68p-4", "0x4.aa9837036ep-4", "0x4.a80cea6e95p-4",
"0x4.a5762097d3p-4", "0x4.a2d3dfe2838p-4", "0x4.a0262ece6p-4", "0x4.9d6d13f729p-4", "0x4.9aa89614fdp-4", "0x4.97d8bbfc06p-4", "0x4.94fd8c9c538p-4", "0x4.92170f0204p-4",
"0x4.8f254a553p-4", "0x4.8c2845d9b18p-4", "0x4.892008eefap-4", "0x4.860c9b1099p-4", "0x4.82ee03d5298p-4", "0x4.7fc44aef42p-4", "0x4.7c8f782cc78p-4", "0x4.794f937708p-4",
"0x4.7604a4d2988p-4", "0x4.72aeb45f3c8p-4", "0x4.6f4dca582ap-4", "0x4.6be1ef13398p-4", "0x4.686b2b01a38p-4", "0x4.64e986af61p-4", "0x4.615d0ac34d8p-4", "0x4.5dc5bffef98p-4",
"0x4.5a23af3ebp-4", "0x4.5676e17933p-4", "0x4.52bf5fbff4p-4", "0x4.4efd333e8b8p-4", "0x4.4b30653b2a8p-4", "0x4.4758ff1612p-4", "0x4.43770a49a4p-4", "0x4.3f8a906a6e8p-4",
"0x4.3b939b26d38p-4", "0x4.37923447238p-4", "0x4.338665ad638p-4", "0x4.2f7039556c8p-4", "0x4.2b4fb9549f8p-4", "0x4.2724efd9928p-4", "0x4.22efe72c88p-4", "0x4.1eb0a9af0bp-4",
"0x4.1a6741dbb48p-4", "0x4.1613ba46478p-4", "0x4.11b61d9b7p-4", "0x4.0d4e76a0d88p-4", "0x4.08dcd034c48p-4", "0x4.0461354e2cp-4", "0x3.ffdbb0fccfp-4", "0x3.fb4c4e68b9p-4",
"0x3.f6b318d23ep-4", "0x3.f2101b91f58p-4", "0x3.ed636218cf8p-4", "0x3.e8acf7ef5ep-4", "0x3.e3ece8b6738p-4", "0x3.df2340269c8p-4", "0x3.da500a1001p-4", "0x3.d573525a478p-4",
"0x3.d08d2504a98p-4", "0x3.cb9d8e25cfp-4", "0x3.c6a499eb778p-4", "0x3.c1a2549a6c8p-4", "0x3.bc96ca8eb28p-4", "0x3.b782083acf8p-4", "0x3.b2641a2879p-4", "0x3.ad3d0cf7a68p-4",
"0x3.a80ced5ee8p-4", "0x3.a2d3c82b74p-4", "0x3.9d91aa4072p-4", "0x3.9846a09738p-4", "0x3.92f2b83f328p-4", "0x3.8d95fe5dcd8p-4", "0x3.8830802e0b8p-4", "0x3.82c24b0083p-4",
};
//  K3  estimated  -4  integer bits.
static const ap_fixed< 35 , -3 > cos_K3 [ 128 ] = {
"-0x2.c8p-32", "-0x2.0783c18p-12", "-0x4.0f025e4p-12", "-0x6.1676f14p-12", "-0x8.1ddc7ap-12", "-0xa.252e074p-12", "-0xc.2c668p-12", "-0xe.3380ef8p-12",
"-0x1.03a78578p-8", "-0x1.24147b8cp-8", "-0x1.447ea13p-8", "-0x1.64e5a6p-8", "-0x1.85493a48p-8", "-0x1.a5a90e18p-8", "-0x1.c604d0ccp-8", "-0x1.e65c338p-8",
"-0x2.06aee6dp-8", "-0x2.26fc9974p-8", "-0x2.4744fcdp-8", "-0x2.6787c13p-8", "-0x2.87c4965p-8", "-0x2.a7fb2da4p-8", "-0x2.c82b3764p-8", "-0x2.e854643cp-8",
"-0x3.0876637cp-8", "-0x3.2890e704p-8", "-0x3.48a39fccp-8", "-0x3.68ae3ee8p-8", "-0x3.88b07484p-8", "-0x3.a8a9f1b4p-8", "-0x3.c89a682p-8", "-0x3.e88187cp-8",
"-0x4.085f0328p-8", "-0x4.28328c18p-8", "-0x4.47fbd2b4p-8", "-0x4.67ba88acp-8", "-0x4.876e5fdcp-8", "-0x4.a7170a84p-8", "-0x4.c6b43a94p-8", "-0x4.e645a23p-8",
"-0x5.05caf1d8p-8", "-0x5.2543de38p-8", "-0x5.44b01854p-8", "-0x5.640f517cp-8", "-0x5.83613ea4p-8", "-0x5.a2a590dcp-8", "-0x5.c1dbfb8p-8", "-0x5.e10431b4p-8",
"-0x6.001de584p-8", "-0x6.1f28cbfcp-8", "-0x6.3e2497ccp-8", "-0x6.5d10fc5p-8", "-0x6.7bedad4p-8", "-0x6.9aba5e34p-8", "-0x6.b976c3b4p-8", "-0x6.d8229204p-8",
"-0x6.f6bd7cacp-8", "-0x7.1547389p-8", "-0x7.33bf7acp-8", "-0x7.5225f6fp-8", "-0x7.707a635p-8", "-0x7.8ebc74f8p-8", "-0x7.acebe0ap-8", "-0x7.cb085b8p-8",
"-0x7.e9119c1p-8", "-0x8.070758ap-8", "-0x8.24e9456p-8", "-0x8.42b71bcp-8", "-0x8.60708eccp-8", "-0x8.7e1556e4p-8", "-0x8.9ba52aecp-8", "-0x8.b91fc1ecp-8",
"-0x8.d684d3p-8", "-0x8.f3d4147cp-8", "-0x9.110d40acp-8", "-0x9.2e300c8cp-8", "-0x9.4b3c31dp-8", "-0x9.683168a8p-8", "-0x9.850f699cp-8", "-0x9.a1d5ed88p-8",
"-0x9.be84ad68p-8", "-0x9.db1b62p-8", "-0x9.f799c5d8p-8", "-0xa.13ff90ep-8", "-0xa.304c7eb8p-8", "-0xa.4c8048cp-8", "-0xa.689aa94p-8", "-0xa.849b5b6cp-8",
"-0xa.a08219a4p-8", "-0xa.bc4e9f54p-8", "-0xa.d800a738p-8", "-0xa.f397ee04p-8", "-0xb.0f1430bp-8", "-0xb.2a752884p-8", "-0xb.45ba931p-8", "-0xb.60e42e2p-8",
"-0xb.7bf1b5b4p-8", "-0xb.96e2e774p-8", "-0xb.b1b780b4p-8", "-0xb.cc6f3fep-8", "-0xb.e709e204p-8", "-0xc.018724e8p-8", "-0xc.1be6c8ap-8", "-0xc.36288c68p-8",
"-0xc.504c2eap-8", "-0xc.6a516e44p-8", "-0xc.84380cd4p-8", "-0xc.9dffc8p-8", "-0xc.b7a86188p-8", "-0xc.d1319bp-8", "-0xc.ea9b348cp-8", "-0xd.03e4eedcp-8",
"-0xd.1d0e8b78p-8", "-0xd.3617cd8p-8", "-0xd.4f00772p-8", "-0xd.67c8498p-8", "-0xd.806f096p-8", "-0xd.98f477c4p-8", "-0xd.b1585a4p-8", "-0xd.c99a7358p-8",
"-0xd.e1ba8648p-8", "-0xd.f9b85a28p-8", "-0xe.1193b294p-8", "-0xe.294c53c4p-8", "-0xe.40e2036p-8", "-0xe.585488cp-8", "-0xe.6fa3a938p-8", "-0xe.86cf2a74p-8",
};
//  K4  estimated  -5  integer bits.
static const ap_fixed< 27 , -4 > cos_K4 [ 128 ] = {
"-0x4.0f067ep-8", "-0x4.0efc84p-8", "-0x4.0ee85cp-8", "-0x4.0eca56p-8", "-0x4.0ea25p-8", "-0x4.0e7026p-8", "-0x4.0e342ap-8", "-0x4.0dee24p-8",
"-0x4.0d9e18p-8", "-0x4.0d43f8p-8", "-0x4.0cdfccp-8", "-0x4.0c71aep-8", "-0x4.0bf98ap-8", "-0x4.0b776cp-8", "-0x4.0aeb8p-8","-0x4.0a5582p-8",
"-0x4.09b56ap-8", "-0x4.090b98p-8", "-0x4.0857b4p-8", "-0x4.0799e4p-8", "-0x4.06d232p-8", "-0x4.06007cp-8", "-0x4.0524bep-8", "-0x4.043f14p-8",
"-0x4.034fbap-8", "-0x4.025672p-8", "-0x4.01532ep-8", "-0x4.0045ecp-8", "-0x3.ff2edep-8", "-0x3.fe0dfap-8", "-0x3.fce326p-8", "-0x3.fbaebp-8",
"-0x3.fa7052p-8", "-0x3.f927f4p-8", "-0x3.f7d5e6p-8", "-0x3.f67a28p-8", "-0x3.f514b2p-8", "-0x3.f3a564p-8", "-0x3.f22c48p-8", "-0x3.f0a94cp-8",
"-0x3.ef1ceap-8", "-0x3.ed8682p-8", "-0x3.ebe666p-8", "-0x3.ea3cfp-8", "-0x3.e8898ap-8", "-0x3.e6cc9cp-8", "-0x3.e5060cp-8", "-0x3.e335d8p-8",
"-0x3.e15c4p-8", "-0x3.df78e4p-8", "-0x3.dd8bf2p-8", "-0x3.db957ap-8", "-0x3.d9958p-8", "-0x3.d78c16p-8", "-0x3.d57922p-8", "-0x3.d35ca2p-8",
"-0x3.d136d6p-8", "-0x3.cf0794p-8", "-0x3.cccee2p-8", "-0x3.ca8cfcp-8", "-0x3.c84194p-8", "-0x3.c5eccep-8", "-0x3.c38ebcp-8", "-0x3.c12784p-8",
"-0x3.beb706p-8", "-0x3.bc3d1cp-8", "-0x3.b9ba46p-8", "-0x3.b72dc8p-8", "-0x3.b4987cp-8", "-0x3.b1fap-8", "-0x3.af5252p-8", "-0x3.aca182p-8",
"-0x3.a9e798p-8", "-0x3.a724ecp-8", "-0x3.a458d8p-8", "-0x3.a1841ep-8", "-0x3.9ea664p-8", "-0x3.9bbfbp-8", "-0x3.98d018p-8", "-0x3.95d78cp-8",
"-0x3.92d62cp-8", "-0x3.8fcc04p-8", "-0x3.8cb8e4p-8", "-0x3.899d44p-8", "-0x3.8678bap-8", "-0x3.834b9p-8", "-0x3.8015cp-8","-0x3.7cd74p-8",
"-0x3.799034p-8", "-0x3.76408ep-8", "-0x3.72e884p-8", "-0x3.6f87e8p-8", "-0x3.6c1e6ep-8", "-0x3.68ace6p-8", "-0x3.653308p-8", "-0x3.61b09p-8",
"-0x3.5e25d6p-8", "-0x3.5a92c8p-8", "-0x3.56f76cp-8", "-0x3.5353b4p-8", "-0x3.4fa7e2p-8", "-0x3.4bf41cp-8", "-0x3.483826p-8", "-0x3.4473e4p-8",
"-0x3.40a794p-8", "-0x3.3cd35ep-8", "-0x3.38f6fp-8", "-0x3.3512ep-8", "-0x3.3126e6p-8", "-0x3.2d32c8p-8", "-0x3.2936ep-8","-0x3.25334p-8",
"-0x3.212804p-8", "-0x3.1d14eep-8", "-0x3.18fap-8", "-0x3.14d7aap-8", "-0x3.10ad7ap-8", "-0x3.0c7bfp-8", "-0x3.0842b2p-8", "-0x3.040206p-8",
"-0x2.ffba3cp-8", "-0x2.fb6ab4p-8", "-0x2.f713bep-8", "-0x2.f2b5a6p-8", "-0x2.ee506ap-8", "-0x2.e9e3b2p-8", "-0x2.e56fcap-8", "-0x2.e0f4dep-8",

};


// Tables for f= sin((pi) / 4 * x) / x
//  K0  estimated  0  integer bits.
static const ap_fixed< 60 , 1 > sin_K0 [ 128 ] = {
"0xc.90fdaa22168c24p-4", "0xc.90f87f3380388ep-4", "0xc.90e8fe6f63c232p-4", "0xc.90cf27ecb4a8cep-4", "0xc.90aafbd1b33efcp-4", "0xc.907c7a53ec66ccp-4", "0xc.9043a3b8393364p-4", "0xc.90007852be6fa8p-4",
"0xc.8fb2f886ec09f2p-4", "0xc.8f5b24c77c64ccp-4", "0xc.8ef8fd96738cc4p-4", "0xc.8e8c83851e5344p-4", "0xc.8e15b734114e88p-4", "0xc.8d94995327be9p-4", "0xc.8d092aa1825748p-4", "0xc.8c736bed85efa4p-4",
"0xc.8bd35e14da15fp-4", "0xc.8b290204678928p-4", "0xc.8a7458b8569788p-4","0xc.89b5633c0d622p-4", "0xc.88ec22aa2e05acp-4", "0xc.8818982c94a87ap-4","0xc.873ac4fc556d92p-4", "0xc.8652aa61ba4d02p-4",
"0xc.856049b440d16ap-4", "0xc.8463a45a97bab2p-4", "0xc.835cbbca9c860ep-4", "0xc.824b918958db3cp-4", "0xc.8130272affdf08p-4", "0xc.800a7e52eb6b28p-4", "0xc.7eda98b3992b56p-4", "0xc.7da0780ea79fd8p-4",
"0xc.7c5c1e34d30558p-4", "0xc.7b0d8d05f2221ep-4", "0xc.79b4c670f2f8cp-4", "0xc.7851cc73d7602ep-4", "0xc.76e4a11bb1815p-4", "0xc.756d4684a039fep-4", "0xc.73ebbed9cb659cp-4", "0xc.72600c55600b3p-4",
"0xc.70ca31408c710ep-4", "0xc.6f2a2ff37c161cp-4", "0xc.6d800ad55390bep-4", "0xc.6bcbc45c2c5364p-4", "0xc.6a0d5f0d1056ccp-4", "0xc.6844dd7bf5aa0ap-4", "0xc.6672424bb9e834p-4", "0xc.6495902e1d94p-4",
"0xc.62aec9e3bf5916p-4", "0xc.60bdf23c173356p-4", "0xc.5ec30c15717bfp-4", "0xc.5cbe1a5ce9dc84p-4", "0xc.5aaf200e662824p-4", "0xc.58962034911a64p-4", "0xc.56731de8d4fc82p-4", "0xc.54461c5356309p-4",
"0xc.520f1eaaeda2d4p-4", "0xc.4fce283523214ap-4", "0xc.4d833c46279964p-4", "0xc.4b2e5e40cf3c04p-4", "0xc.48cf91968b87cep-4", "0xc.4666d9c76539d4p-4", "0xc.43f43a61f624ap-4", "0xc.4177b70362edaap-4",
"0xc.3ef1535754b162p-4", "0xc.3c611317f28daap-4", "0xc.39c6fa0ddb12f8p-4", "0xc.37230c101d9c06p-4", "0xc.34754d04338c4ap-4", "0xc.31bdc0ddf9751ap-4", "0xc.2efc6b9fa82196p-4", "0xc.2c315159cd8978p-4",
"0xc.295c762b45aab6p-4", "0xc.267dde41334a24p-4", "0xc.23958dd6f89b0cp-4", "0xc.20a389362fcddcp-4", "0xc.1da7d4b6a385e6p-4", "0xc.1aa274be47365p-4", "0xc.17936dc12f6642p-4", "0xc.147ac44189dc4cp-4",
"0xc.11587ccf95b136p-4", "0xc.0e2c9c099b4a2ap-4", "0xc.0af7269be43a52p-4", "0xc.07b82140b30c04p-4", "0xc.046f90c03af17cp-4", "0xc.011d79f0975d38p-4", "0xb.fdc1e1b5c38216p-4", "0xb.fa5ccd0191bb22p-4",
"0xb.f6ee40d3a2db4cp-4", "0xb.f37642395d65p-4", "0xb.eff4d64de4a9a4p-4","0xb.ec6a023a0fd13ep-4", "0xb.e8d5cb3460ca1p-4", "0xb.e5383680fb2078p-4","0xb.e19149719abf06p-4", "0xb.dde109658a96dp-4",
"0xb.da277bc99b303ep-4", "0xb.d664a618192434p-4", "0xb.d2988dd8c37dccp-4", "0xb.cec338a0c204ap-4", "0xb.cae4ac129b6fbep-4", "0xb.c6fcedde2b8154p-4", "0xb.c30c03c0990b3ap-4", "0xb.bf11f3844bdc46p-4",
"0xb.bb0ec300e296a6p-4", "0xb.b702781b286f3ep-4", "0xb.b2ed18c50ad62p-4", "0xb.aeceaafd8f0836p-4", "0xb.aaa734d0c78a2cp-4", "0xb.a676bc57c98cbap-4", "0xb.a23d47b8a23a5p-4", "0xb.9dfadd264bee4cp-4",
"0xb.99af82e0a355b8p-4", "0xb.955b3f345c79cap-4", "0xb.90fe187af7b4p-4", "0xb.8c98151ab68c38p-4", "0xb.88293b8690808cp-4", "0xb.83b1923e27b74cp-4", "0xb.7f311fcdbd9af6p-4", "0xb.7aa7eace276064p-4",
"0xb.7615f9e4c2773ap-4", "0xb.717b53c368e4ap-4", "0xb.6cd7ff2865887ap-4","0xb.682c02de684d14p-4", "0xb.637765bc7a416cp-4", "0xb.5eba2ea5f19e3p-4", "0xb.59f4648a65b582p-4", "0xb.55260e65a2cd9p-4",
};
//  K1  estimated  -2  integer bits.
static const ap_fixed< 51 , -1 > sin_K1 [ 128 ] = {
"-0x5.p-52", "-0x5.2aedf31dc8p-12", "-0xa.55d43fb839p-12", "-0xf.80ab3f599ep-12", "-0x1.4ab6b4ba721p-8", "-0x1.9d60cbe6e5ap-8", "-0x1.f0087f1b2cep-8", "-0x2.42ad53fbb72p-8",
"-0x2.954ed032029p-8", "-0x2.e7ec796d722p-8", "-0x3.3a85d56426ap-8", "-0x3.8d1a69d3d49p-8", "-0x3.dfa9bc829f4p-8", "-0x4.3233533fe9dp-8", "-0x4.84b6b3e5367p-8", "-0x4.d7336456f7p-8",
"-0x5.29a8ea85688p-8", "-0x5.7c16cc6d658p-8", "-0x5.ce7c901943ap-8", "-0x6.20d9bba1a36p-8", "-0x6.732dd52e4dfp-8", "-0x6.c57862f7056p-8", "-0x7.17b8eb445f3p-8", "-0x7.69eef470986p-8",
"-0x7.bc1a04e86f7p-8", "-0x8.0e39a32bf52p-8", "-0x8.604d55cf66dp-8", "-0x8.b254a37c02cp-8", "-0x9.044f12f0dc9p-8", "-0x9.563c2b03b6bp-8", "-0x9.a81b72a1d22p-8", "-0x9.f9ec70d0c78p-8",
"-0xa.4baeacaf5c6p-8", "-0xa.9d61ad76543p-8", "-0xa.ef04fa794a7p-8", "-0xb.40981b2780ap-8", "-0xb.921a970cb9fp-8", "-0xb.e38bf5d2079p-8", "-0xc.34ebbf3ea2p-8", "-0xc.86397b38ba4p-8",
"-0xc.d774b1c64e1p-8", "-0xd.289ceb0df9ap-8", "-0xd.79b1af57cbcp-8", "-0xd.cab2870e182p-8", "-0xe.1b9efabe483p-8", "-0xe.6c769319b1bp-8", "-0xe.bd38d8f6614p-8", "-0xf.0de5554ff2ap-8",
"-0xf.5e7b91485dbp-8", "-0xf.aefb1628ca8p-8", "-0xf.ff636d625ddp-8", "-0x1.04fb4208f0f1p-4", "-0x1.09fecb97273ep-4", "-0x1.0f00cc1fa8f7p-4", "-0x1.14013c440a69p-4", "-0x1.190014a8a09cp-4",
"-0x1.1dfd4df48e78p-4", "-0x1.22f8e0d1d185p-4", "-0x1.27f2c5ed4efap-4", "-0x1.2ceaf5f6e057p-4", "-0x1.31e169a1605fp-4", "-0x1.36d619a2b807p-4", "-0x1.3bc8feb3eb28p-4", "-0x1.40ba11912502p-4",
"-0x1.45a94af9c571p-4", "-0x1.4a96a3b06d4cp-4", "-0x1.4f82147b0b59p-4", "-0x1.546b9622e8ap-4", "-0x1.59532174b564p-4", "-0x1.5e38af4095aep-4", "-0x1.631c385a2dc1p-4", "-0x1.67fdb598aeddp-4",
"-0x1.6cdd1fd6e39dp-4", "-0x1.71ba6ff33c96p-4", "-0x1.76959ecfdccap-4", "-0x1.7b6ea552a631p-4", "-0x1.80457c654609p-4", "-0x1.851a1cf5413fp-4", "-0x1.89ec7ff40103p-4", "-0x1.8ebc9e56dec4p-4",
"-0x1.938a711730dcp-4", "-0x1.9855f13256adp-4", "-0x1.9d1f17a9c4d9p-4", "-0x1.a1e5dd831197p-4", "-0x1.a6aa3bc800d9p-4", "-0x1.ab6c2b869064p-4", "-0x1.b02ba5d10424p-4", "-0x1.b4e8a3bdf205p-4",
"-0x1.b9a31e684e25p-4", "-0x1.be5b0eef7706p-4", "-0x1.c3106e77411bp-4", "-0x1.c7c336280355p-4", "-0x1.cc735f2ea287p-4", "-0x1.d120e2bc9d9fp-4", "-0x1.d5cbba081996p-4", "-0x1.da73de4bece8p-4",
"-0x1.df1948c7abb4p-4", "-0x1.e3bbf2bfb353p-4", "-0x1.e85bd57d3624p-4", "-0x1.ecf8ea4e473ep-4", "-0x1.f1932a85e614p-4", "-0x1.f62a8f7c09e9p-4", "-0x1.fabf128dadc3p-4", "-0x1.ff50ad1cdb9bp-4",
"-0x2.03df5890b801p-4", "-0x2.086b0e558d96p-4", "-0x2.0cf3c7dcd875p-4", "-0x2.11797e9d5192p-4", "-0x2.15fc2c12fa0dp-4", "-0x2.1a7bc9bf26a1p-4", "-0x2.1ef851288ab8p-4", "-0x2.2371bbdb43e3p-4",
"-0x2.27e80368e4b7p-4", "-0x2.2c5b2168805ap-4", "-0x2.30cb0f76b52dp-4", "-0x2.3537c735b84bp-4", "-0x2.39a1424d602fp-4", "-0x2.3e077a6b2ffap-4", "-0x2.426a69426239p-4", "-0x2.46ca088bf3c7p-4",
"-0x2.4b265206aed8p-4", "-0x2.4f7f3f773577p-4", "-0x2.53d4caa80c9fp-4", "-0x2.5826ed69a6c7p-4", "-0x2.5c75a1926e89p-4", "-0x2.60c0e0fed15dp-4", "-0x2.6508a5914a28p-4", "-0x2.694ce9326b9fp-4",
};
//  K2  estimated  -3  integer bits.
static const ap_fixed< 43 , -2 > sin_K2 [ 128 ] = {
"-0x1.4abbce62538p-4", "-0x1.4abad991ae8p-4", "-0x1.4ab7fb2168p-4", "-0x1.4ab33316748p-4", "-0x1.4aac8179398p-4", "-0x1.4aa3e6558e8p-4", "-0x1.4a9961bab6p-4", "-0x1.4a8cf3bb2fp-4",
"-0x1.4a7e9c6cd08p-4", "-0x1.4a6e5be8e58p-4", "-0x1.4a5c324c0c8p-4", "-0x1.4a481fb6678p-4", "-0x1.4a32244b23p-4", "-0x1.4a1a40313fp-4", "-0x1.4a007392a28p-4", "-0x1.49e4be9cd98p-4",
"-0x1.49c72180968p-4", "-0x1.49a79c7244p-4", "-0x1.49862fa9398p-4", "-0x1.4962db6096p-4", "-0x1.493d9fd65ap-4", "-0x1.49167d4c4p-4", "-0x1.48ed7407358p-4", "-0x1.48c2844faf8p-4",
"-0x1.4895ae71188p-4", "-0x1.4866f2baa1p-4", "-0x1.4836517e92p-4", "-0x1.4803cb1294p-4", "-0x1.47cf5fcfccp-4", "-0x1.479910125ep-4", "-0x1.4760dc3a19p-4", "-0x1.4726c4aa14p-4",
"-0x1.46eac9c878p-4", "-0x1.46acebff29p-4", "-0x1.466d2bbaecp-4", "-0x1.462b896c48p-4", "-0x1.45e80586a4p-4", "-0x1.45a2a08117p-4", "-0x1.455b5ad5cbp-4", "-0x1.45123502558p-4",
"-0x1.44c72f877c8p-4", "-0x1.447a4ae96ep-4", "-0x1.442b87af9ep-4", "-0x1.43dae664b5p-4", "-0x1.43886796d08p-4", "-0x1.43340bd7078p-4", "-0x1.42ddd3ba148p-4", "-0x1.4285bfd7bb8p-4",
"-0x1.422bd0cb1fp-4", "-0x1.41d0073283p-4", "-0x1.417263afb28p-4", "-0x1.4112e6e75d8p-4", "-0x1.40b1918198p-4", "-0x1.404e6429f3p-4", "-0x1.3fe95f8ee3p-4", "-0x1.3f82846256p-4",
"-0x1.3f19d35946p-4", "-0x1.3eaf4d2c14p-4", "-0x1.3e42f2960e8p-4", "-0x1.3dd4c4560b8p-4", "-0x1.3d64c32e17p-4", "-0x1.3cf2efe32dp-4", "-0x1.3c7f4b3d758p-4", "-0x1.3c09d608cp-4",
"-0x1.3b929113908p-4", "-0x1.3b197d2fdb8p-4", "-0x1.3a9e9b32788p-4", "-0x1.3a21ebf3ca8p-4", "-0x1.39a3704f2a8p-4", "-0x1.39232923048p-4", "-0x1.38a117510e8p-4", "-0x1.381d3bbe01p-4",
"-0x1.37979751d58p-4", "-0x1.37102af7ap-4", "-0x1.3686f79d8c8p-4", "-0x1.35fbfe34ce8p-4", "-0x1.356f3fb1c98p-4", "-0x1.34e0bd0c1b8p-4", "-0x1.3450773e1bp-4", "-0x1.33be6f45ae8p-4",
"-0x1.332aa623708p-4", "-0x1.32951cdb28p-4", "-0x1.31fdd473bfp-4", "-0x1.3164cdf7168p-4", "-0x1.30ca0a72228p-4", "-0x1.302d8af4f08p-4", "-0x1.2f8f509267p-4", "-0x1.2eef5c60a18p-4",
"-0x1.2e4daf78c78p-4", "-0x1.2daa4af6a28p-4", "-0x1.2d052ff993p-4", "-0x1.2c5e5fa3548p-4", "-0x1.2bb5db19278p-4", "-0x1.2b0ba38313p-4", "-0x1.2a5fba0bcb8p-4", "-0x1.29b21fe1608p-4",
"-0x1.2902d634a2p-4", "-0x1.2851de395fp-4", "-0x1.279f3926578p-4", "-0x1.26eae83524p-4", "-0x1.2634eca2378p-4", "-0x1.257d47ad3d8p-4", "-0x1.24c3fa9856p-4", "-0x1.240906a8c1p-4",
"-0x1.234c6d2699p-4", "-0x1.228e2f5ccd8p-4", "-0x1.21ce4e9923p-4", "-0x1.210ccc2c428p-4", "-0x1.2049a969b38p-4", "-0x1.1f84e7a7a48p-4", "-0x1.1ebe883f548p-4", "-0x1.1df68c8c778p-4",
"-0x1.1d2cf5edf08p-4", "-0x1.1c61c5c50fp-4", "-0x1.1b94fd763ap-4", "-0x1.1ac69e6853p-4", "-0x1.19f6aa0539p-4", "-0x1.192521b9588p-4", "-0x1.185206f3e68p-4", "-0x1.177d5b26f88p-4",
"-0x1.16a71fc7038p-4", "-0x1.15cf564b998p-4", "-0x1.14f6002ea9p-4", "-0x1.141b1eecep-4", "-0x1.133eb405ad8p-4", "-0x1.1260c0fb0b8p-4", "-0x1.11814751a1p-4", "-0x1.10a04890ecp-4",
};
//  K3  estimated  -6  integer bits.
static const ap_fixed< 33 , -5 > sin_K3 [ 128 ] = {
"-0x4.p-36", "0x5.19ae6p-16", "0xa.3354acp-16", "0xf.4ce8d4p-16", "0x1.466611cp-12", "0x1.97fb50cp-12", "0x1.e98dd1cp-12", "0x2.3b1cf74p-12",
"0x2.8ca828cp-12", "0x2.de2ed7cp-12", "0x3.2fb070cp-12", "0x3.812c7dp-12", "0x3.d2a247p-12", "0x4.24116dp-12", "0x4.75793d8p-12", "0x4.c6d936cp-12",
"0x5.1830b08p-12", "0x5.697f454p-12", "0x5.bac441cp-12", "0x6.0bff41p-12", "0x6.5d2f81cp-12", "0x6.ae548b4p-12", "0x6.ff6dc8p-12", "0x7.507ac8cp-12",
"0x7.a17acbp-12", "0x7.f26d698p-12", "0x8.435207p-12", "0x8.9428114p-12", "0x8.e4ef11cp-12", "0x9.35a651cp-12", "0x9.864d554p-12", "0x9.d6e3a34p-12",
"0xa.276884p-12", "0xa.77db994p-12", "0xa.c83c29p-12", "0xb.1889cc4p-12", "0xb.68c3d4cp-12", "0xb.b8e9cecp-12", "0xc.08fb1cp-12", "0xc.58f73d4p-12",
"0xc.a8dd98p-12", "0xc.f8ada5cp-12", "0xd.4866e3p-12", "0xd.9808b34p-12", "0xd.e7929c8p-12", "0xe.3703fa4p-12", "0xe.865c574p-12", "0xe.d59b224p-12",
"0xf.24bfd14p-12", "0xf.73c9cc8p-12", "0xf.c2b8a78p-12", "0x1.0118bb88p-8", "0x1.060426a4p-8", "0x1.0aedc5ap-8", "0x1.0fd58e54p-8", "0x1.14bb7924p-8",
"0x1.199f7c54p-8", "0x1.1e8190bcp-8", "0x1.2361ab4cp-8", "0x1.283fc4f8p-8", "0x1.2d1bd6dp-8", "0x1.31f5d68cp-8", "0x1.36cdb9e4p-8", "0x1.3ba37cp-8",
"0x1.40771248p-8", "0x1.4548758p-8", "0x1.4a179bp-8", "0x1.4ee47c4cp-8", "0x1.53af1104p-8", "0x1.58774ffp-8", "0x1.5d3d3108p-8", "0x1.6200ab54p-8",
"0x1.66c1b6f8p-8", "0x1.6b804c1cp-8", "0x1.703c623cp-8", "0x1.74f5f04cp-8", "0x1.79acedfcp-8", "0x1.7e6154ep-8", "0x1.831319b4p-8", "0x1.87c23778p-8",
"0x1.8c6ea438p-8", "0x1.911857ccp-8", "0x1.95bf4a98p-8", "0x1.9a637414p-8", "0x1.9f04cc68p-8", "0x1.a3a34bccp-8", "0x1.a83ee92p-8", "0x1.acd79cecp-8",
"0x1.b16d6084p-8", "0x1.b60028a4p-8", "0x1.ba8ff134p-8", "0x1.bf1cae64p-8", "0x1.c3a65b44p-8", "0x1.c82cf03cp-8", "0x1.ccb06288p-8", "0x1.d130abecp-8",
"0x1.d5adc45p-8", "0x1.da27a3ep-8", "0x1.de9e4384p-8", "0x1.e3119b14p-8", "0x1.e781a19p-8", "0x1.ebee51ecp-8", "0x1.f057a23cp-8", "0x1.f4bd8b44p-8",
"0x1.f920059cp-8", "0x1.fd7f0998p-8", "0x2.01da8f48p-8", "0x2.06328f9p-8", "0x2.0a870374p-8", "0x2.0ed7e21cp-8", "0x2.1325260cp-8", "0x2.176ec534p-8",
"0x2.1bb4ba3cp-8", "0x2.1ff6fc6p-8", "0x2.24358558p-8", "0x2.28704cdcp-8", "0x2.2ca74c8p-8", "0x2.30da7c38p-8", "0x2.3509d46p-8", "0x2.39354f9cp-8",
"0x2.3d5ce414p-8", "0x2.41808d54p-8", "0x2.45a042d4p-8", "0x2.49bbfd3p-8", "0x2.4dd3b5e4p-8", "0x2.51e7650cp-8", "0x2.55f703c4p-8", "0x2.5a028d04p-8",
};
//  K4  estimated  -8  integer bits.
static const ap_fixed< 24 , -7 > sin_K4 [ 128 ] = {
"0xa.335e2p-12", "0xa.334cp-12", "0xa.3325ap-12", "0xa.32ed2p-12","0xa.32a6ap-12", "0xa.32502p-12", "0xa.31e2cp-12", "0xa.31632p-12",
"0xa.30d2ap-12", "0xa.30316p-12", "0xa.2f804p-12", "0xa.2eb8ep-12", "0xa.2de48p-12", "0xa.2cf8ap-12", "0xa.2bfccp-12","0xa.2aedep-12",
"0xa.29d22p-12", "0xa.289fap-12", "0xa.275eap-12", "0xa.2604cp-12", "0xa.249eap-12", "0xa.2326ep-12", "0xa.219f2p-12","0xa.1fffp-12",
"0xa.1e546p-12", "0xa.1c93ep-12", "0xa.1ac1ep-12", "0xa.18df2p-12", "0xa.16e5ap-12", "0xa.14df4p-12", "0xa.12c88p-12","0xa.109acp-12",
"0xa.0e61ap-12", "0xa.0c108p-12", "0xa.09b2cp-12", "0xa.073fcp-12", "0xa.04bdep-12", "0xa.0227ep-12", "0x9.ff82ap-12","0x9.fcc9cp-12",
"0x9.fa00cp-12", "0x9.f726ap-12", "0x9.f4386p-12", "0x9.f13bp-12", "0x9.ee2acp-12", "0x9.eb0b6p-12", "0x9.e7d96p-12", "0x9.e495p-12",
"0x9.e13f2p-12", "0x9.ddd9ep-12", "0x9.da5e8p-12", "0x9.d6d3ep-12", "0x9.d33d6p-12", "0x9.cf914p-12", "0x9.cbd4ep-12","0x9.c804ep-12",
"0x9.c4262p-12", "0x9.c0322p-12", "0x9.bc334p-12", "0x9.b8238p-12", "0x9.b3fc6p-12", "0x9.afc54p-12", "0x9.ab84cp-12","0x9.a72cap-12",
"0x9.a2c58p-12", "0x9.9e4a2p-12", "0x9.99c3p-12", "0x9.95298p-12","0x9.907dp-12", "0x9.8bc02p-12", "0x9.86f2ap-12", "0x9.82162p-12",
"0x9.7d292p-12", "0x9.78296p-12", "0x9.73188p-12", "0x9.6df9p-12", "0x9.68cb6p-12", "0x9.6387ep-12", "0x9.5e3b4p-12", "0x9.58d82p-12",
"0x9.53664p-12", "0x9.4de4ep-12", "0x9.48526p-12", "0x9.42b08p-12", "0x9.3cfd6p-12", "0x9.37394p-12", "0x9.31672p-12","0x9.2b858p-12",
"0x9.258ecp-12", "0x9.1f8fcp-12", "0x9.19794p-12", "0x9.135bp-12", "0x9.0d288p-12", "0x9.06e0ep-12", "0x9.008f4p-12", "0x8.fa2dep-12",
"0x8.f3bd2p-12", "0x8.ed3ep-12", "0x8.e6acep-12", "0x8.e00b4p-12","0x8.d95eap-12", "0x8.d29cep-12", "0x8.cbce2p-12", "0x8.c4f0ep-12",
"0x8.be046p-12", "0x8.b708ep-12", "0x8.afffep-12", "0x8.a8e72p-12", "0x8.a1bd2p-12", "0x8.9a874p-12", "0x8.933cep-12","0x8.8be8ep-12",
"0x8.8483cp-12", "0x8.7d10ep-12", "0x8.758e6p-12", "0x8.6dfep-12", "0x8.665dap-12", "0x8.5eafcp-12", "0x8.56f64p-12", "0x8.4f29p-12",
"0x8.47534p-12", "0x8.3f69ep-12", "0x8.3772cp-12", "0x8.2f6e8p-12", "0x8.275b4p-12", "0x8.1f3cep-12", "0x8.1711cp-12","0x8.0ed32p-12",
};


static const ap_fixed< 59 , 1 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.ffec42c7454924p-4", "0xf.ffb10b4dc96da8p-4", "0xf.ff4e5a25a8d094p-4", "0xf.fec43042668658p-4", "0xf.fe128ef8e9fc14p-4", "0xf.fd3977ff7bae48p-4", "0xf.fc38ed6dc0ef9p-4",
"0xf.fb10f1bcb6bee8p-4", "0xf.f9c187c6abaddcp-4", "0xf.f84ab2c738d694p-4", "0xf.f6ac765b39e1d8p-4", "0xf.f4e6d680c41dp-4", "0xf.f2f9d7971ca028p-4", "0xf.f0e57e5ead848p-4", "0xf.eea9cff8fa2ad4p-4",
"0xf.ec46d1e89292cp-4", "0xf.e9bc8a1105c218p-4", "0xf.e70afeb6d33d58p-4", "0xf.e432367f5b9094p-4", "0xf.e1323870cfe99p-4", "0xf.de0b0bf220c2e8p-4", "0xf.dabcb8caeba07cp-4", "0xf.d747472367dd54p-4",
"0xf.d3aabf84528b38p-4", "0xf.cfe72ad6d96404p-4", "0xf.cbfc926484cd28p-4", "0xf.c7eaffd720ed4cp-4", "0xf.c3b27d38a5d48p-4","0xf.bf5314f31eb718p-4", "0xf.baccd1d0903b94p-4", "0xf.b61fbefadddb78p-4",
"0xf.b14be7fbae57f4p-4", "0xf.ac5158bc4f41fp-4", "0xf.a7301d85979644p-4", "0xf.a1e842ffc96e2cp-4", "0xf.9c79d63272c44p-4", "0xf.96e4e4844d4e5cp-4", "0xf.91297bbb1d6cb4p-4", "0xf.8b47a9fb902e5p-4",
"0xf.853f7dc9186b6cp-4", "0xf.7f110605caf61p-4", "0xf.78bc51f239e104p-4", "0xf.7241712d4eddb8p-4", "0xf.6ba073b424b174p-4", "0xf.64d969e1dfc1e4p-4", "0xf.5dec646f85b9fp-4", "0xf.56d97473d446ap-4",
"0xf.4fa0ab6316edp-4", "0xf.48421b0efbf908p-4", "0xf.40bdd5a668863p-4", "0xf.3913edb54ba1fp-4", "0xf.314476247088c4p-4", "0xf.294f82394ffdfcp-4", "0xf.21352595e0bfp-4", "0xf.18f5743867122cp-4",
"0xf.1090827b437228p-4", "0xf.08066514c055cp-4", "0xe.ff573116df151cp-4", "0xe.f682fbef23ecap-4", "0xe.ed89db66611df4p-4", "0xe.e46be5a0812fdcp-4", "0xe.db29311c504d28p-4", "0xe.d1c1d4b344c398p-4",
"0xe.c835e79946a2d4p-4", "0xe.be85815c767c7p-4", "0xe.b4b0b9e4f3452p-4", "0xe.aab7a9749f581p-4", "0xe.a09a68a6e49c94p-4", "0xe.9659107077cf1cp-4", "0xe.8bf3ba1f1aedb8p-4", "0xe.816a7f595ec8dcp-4",
"0xe.76bd7a1e63b934p-4", "0xe.6becc4c5997aa8p-4", "0xe.60f879fe7e2dd8p-4", "0xe.55e0b4d05c7ffp-4", "0xe.4aa5909a08fa3p-4", "0xe.3f4729119e7944p-4", "0xe.33c59a4439cd44p-4", "0xe.28210095b48328p-4",
"0xe.1c5978c05ed81cp-4", "0xe.106f1fd4b8d77cp-4", "0xe.046213392aa438p-4", "0xd.f83270a9bbee38p-4", "0xd.ebe05637ca948p-4","0xd.df6be249c074bp-4", "0xd.d2d5339ac868dcp-4", "0xd.c61c693a827408p-4",
"0xd.b941a28cb71e74p-4", "0xd.ac44ff490a021cp-4", "0xd.9f269f7aab886cp-4", "0xd.91e6a38009d9cp-4", "0xd.84852c0a80ff74p-4", "0xd.77025a1e0a398p-4", "0xd.695e4f10ea87fcp-4", "0xd.5b992c8b6069dcp-4",
"0xd.4db3148750d128p-4", "0xd.3fac294ff34dfp-4", "0xd.31848d817d7084p-4", "0xd.233c6408cd63c4p-4", "0xd.14d3d02313c09p-4", "0xd.064af55d7c9ae4p-4", "0xc.f7a1f794d7c9bcp-4", "0xc.e8d8faf5406a58p-4",
"0xc.d9f023f9c39ff8p-4", "0xc.cae7976c0690b4p-4", "0xc.bbbf7a63eba078p-4", "0xc.ac77f24736eafp-4", "0xc.9d1124c931fd44p-4", "0xc.8d8b37ea4ed09p-4", "0xc.7de651f7ca060cp-4", "0xc.6e22998b4c65ap-4",
"0xc.5e40358a8b9ff4p-4", "0xc.4e3f4d26ea54d4p-4", "0xc.3e2007dd175efp-4", "0xc.2de28d74ac65cp-4", "0xc.1d8705ffcbb67cp-4", "0xc.0d0d99dabd6568p-4", "0xb.fc7671ab8bb7ep-4", "0xb.ebc1b6619ed8a4p-4",
"0xb.daef913557d7p-4", "0xb.ca002ba7aaf1fp-4", "0xb.b8f3af81b93028p-4", "0xb.a7ca46d469461p-4", "0xb.96841bf7ffcabp-4", "0xb.8521598bb6bc7p-4","0xb.73a22a755456dp-4", "0xb.6206b9e0c13a14p-4",
//
"0xc.90fdaa22168c24p-4", "0xc.90f87f3380388cp-4", "0xc.90e8fe6f63c234p-4", "0xc.90cf27ecb4a8dp-4", "0xc.90aafbd1b33efcp-4", "0xc.907c7a53ec66ccp-4", "0xc.9043a3b8393364p-4", "0xc.90007852be6fa8p-4",
"0xc.8fb2f886ec09f4p-4", "0xc.8f5b24c77c64ccp-4", "0xc.8ef8fd96738cc4p-4", "0xc.8e8c83851e5344p-4", "0xc.8e15b734114e88p-4","0xc.8d94995327be9p-4", "0xc.8d092aa1825748p-4", "0xc.8c736bed85efa4p-4",
"0xc.8bd35e14da15fp-4", "0xc.8b290204678928p-4", "0xc.8a7458b8569788p-4", "0xc.89b5633c0d622p-4", "0xc.88ec22aa2e05acp-4", "0xc.8818982c94a878p-4", "0xc.873ac4fc556d9p-4", "0xc.8652aa61ba4d04p-4",
"0xc.856049b440d168p-4", "0xc.8463a45a97babp-4", "0xc.835cbbca9c860cp-4", "0xc.824b918958db3cp-4", "0xc.8130272affdf08p-4", "0xc.800a7e52eb6b28p-4", "0xc.7eda98b3992b54p-4", "0xc.7da0780ea79fd8p-4",
"0xc.7c5c1e34d30558p-4", "0xc.7b0d8d05f2221cp-4", "0xc.79b4c670f2f8cp-4", "0xc.7851cc73d7603p-4", "0xc.76e4a11bb1815p-4", "0xc.756d4684a039fcp-4", "0xc.73ebbed9cb659cp-4", "0xc.72600c55600b3p-4",
"0xc.70ca31408c711p-4", "0xc.6f2a2ff37c161cp-4", "0xc.6d800ad55390bcp-4", "0xc.6bcbc45c2c5364p-4", "0xc.6a0d5f0d1056ccp-4", "0xc.6844dd7bf5aa08p-4", "0xc.6672424bb9e834p-4", "0xc.6495902e1d94p-4",
"0xc.62aec9e3bf5914p-4", "0xc.60bdf23c173354p-4", "0xc.5ec30c15717bfp-4", "0xc.5cbe1a5ce9dc84p-4", "0xc.5aaf200e662824p-4", "0xc.58962034911a64p-4", "0xc.56731de8d4fc8p-4", "0xc.54461c5356309p-4",
"0xc.520f1eaaeda2d4p-4", "0xc.4fce283523214cp-4", "0xc.4d833c46279964p-4", "0xc.4b2e5e40cf3c04p-4", "0xc.48cf91968b87dp-4","0xc.4666d9c76539d4p-4", "0xc.43f43a61f624ap-4", "0xc.4177b70362eda8p-4",
"0xc.3ef1535754b16p-4", "0xc.3c611317f28dacp-4", "0xc.39c6fa0ddb12f8p-4", "0xc.37230c101d9c04p-4", "0xc.34754d04338c4cp-4", "0xc.31bdc0ddf97518p-4", "0xc.2efc6b9fa82198p-4", "0xc.2c315159cd8978p-4",
"0xc.295c762b45aab8p-4", "0xc.267dde41334a24p-4", "0xc.23958dd6f89b0cp-4", "0xc.20a389362fcddcp-4", "0xc.1da7d4b6a385e8p-4","0xc.1aa274be47365p-4", "0xc.17936dc12f664p-4", "0xc.147ac44189dc4cp-4",
"0xc.11587ccf95b138p-4", "0xc.0e2c9c099b4a28p-4", "0xc.0af7269be43a5p-4", "0xc.07b82140b30c04p-4", "0xc.046f90c03af17cp-4", "0xc.011d79f0975d38p-4", "0xb.fdc1e1b5c38214p-4", "0xb.fa5ccd0191bb2p-4",
"0xb.f6ee40d3a2db4cp-4", "0xb.f37642395d65p-4", "0xb.eff4d64de4a9a4p-4", "0xb.ec6a023a0fd13cp-4", "0xb.e8d5cb3460ca1p-4", "0xb.e5383680fb2078p-4", "0xb.e19149719abf08p-4", "0xb.dde109658a96dp-4",
"0xb.da277bc99b304p-4", "0xb.d664a618192434p-4", "0xb.d2988dd8c37dccp-4", "0xb.cec338a0c204ap-4", "0xb.cae4ac129b6fbcp-4", "0xb.c6fcedde2b8154p-4", "0xb.c30c03c0990b3cp-4", "0xb.bf11f3844bdc48p-4",
"0xb.bb0ec300e296a8p-4", "0xb.b702781b286f4p-4", "0xb.b2ed18c50ad62p-4", "0xb.aeceaafd8f0834p-4", "0xb.aaa734d0c78a2cp-4", "0xb.a676bc57c98cb8p-4", "0xb.a23d47b8a23a5p-4", "0xb.9dfadd264bee4cp-4",
"0xb.99af82e0a355b8p-4", "0xb.955b3f345c79c8p-4", "0xb.90fe187af7b4p-4", "0xb.8c98151ab68c38p-4", "0xb.88293b8690808cp-4", "0xb.83b1923e27b74cp-4", "0xb.7f311fcdbd9af4p-4", "0xb.7aa7eace276064p-4",
"0xb.7615f9e4c27738p-4", "0xb.717b53c368e4ap-4", "0xb.6cd7ff2865887cp-4", "0xb.682c02de684d14p-4", "0xb.637765bc7a416cp-4", "0xb.5eba2ea5f19e3p-4", "0xb.59f4648a65b58p-4", "0xb.55260e65a2cd9p-4",
};

//  K1  estimated  0  integer bits.
static const ap_fixed< 52 , 1 > sin_cos_K1 [ 256 ] = {
"0x8.p-52", "-0x1.3bd34abaf94p-8", "-0x2.77a38a3203p-8", "-0x3.b36db328afp-8", "-0x4.ef2eba71914p-8", "-0x6.2ae394f5cdap-8", "-0x7.668937bc896p-8", "-0x8.a21c97f27ccp-8",
"-0x9.dd9aaaf16c2p-8", "-0xb.19006647a9cp-8", "-0xc.544abfbf99p-8", "-0xd.8f76ad672eep-8", "-0xe.ca8125976aap-8", "-0x1.005671efbde6p-4", "-0x1.14025909a2a6p-4", "-0x1.27ab971d971ep-4",
"-0x1.3b51fba89e6p-4", "-0x1.4ef5562ec2f4p-4", "-0x1.6295763b8f9ep-4", "-0x1.76322b628608p-4", "-0x1.89cb453f969cp-4", "-0x1.9d6093779806p-4", "-0x1.b0f1e5b8be48p-4", "-0x1.c47f0bbb11fcp-4",
"-0x1.d807d540e7b2p-4", "-0x1.eb8c12175692p-4", "-0x1.ff0b9216afb8p-4", "-0x2.12862522f4bp-4", "-0x2.25fb9b2c4e36p-4", "-0x2.396bc42f82dcp-4", "-0x2.4cd670366dfp-4", "-0x2.603b6f5874aap-4",
"-0x2.739a91bafddp-4", "-0x2.86f3a791e6b2p-4", "-0x2.9a46811ff99cp-4", "-0x2.ad92eeb7639p-4", "-0x2.c0d8c0ba29cp-4", "-0x2.d417c79a9f1ep-4", "-0x2.e74fd3dbda0cp-4", "-0x2.fa80b61229p-4",
"-0x3.0daa3ee3879ap-4", "-0x3.20cc3f0813fp-4", "-0x3.33e6874a82bp-4", "-0x3.46f8e88893aep-4", "-0x3.5a0333b386d6p-4", "-0x3.6d0539d08f1ap-4", "-0x3.7ffecbf947ap-4", "-0x3.92efbb5c2664p-4",
"-0x3.a5d7d93cf08ep-4", "-0x3.b8b6f6f52d4ap-4", "-0x3.cb8ce5f4991cp-4", "-0x3.de5977c198a8p-4", "-0x3.f11c7df9ab6cp-4", "-0x4.03d5ca51dep-4", "-0x4.16852e973ccep-4", "-0x4.292a7caf4568p-4",
"-0x4.3bc5869858eap-4", "-0x4.4e561e6a2dp-4", "-0x4.60dc16563d62p-4", "-0x4.735740a83dp-4", "-0x4.85c76fc68662p-4", "-0x4.982c76328cbcp-4", "-0x4.aa8626894b64p-4", "-0x4.bcd45383b6bcp-4",
"-0x4.cf16cff72b0ap-4", "-0x4.e14d6ed5dcb4p-4", "-0x4.f378032f46bcp-4", "-0x5.059660309a26p-4", "-0x5.17a859252c12p-4", "-0x5.29adc176e494p-4", "-0x5.3ba66caeac78p-4", "-0x5.4d922e74daa8p-4",
"-0x5.5f70da91a264p-4", "-0x5.714244ed7f2ap-4", "-0x5.83064191a2f8p-4", "-0x5.94bca4a86152p-4", "-0x5.a665427d9c7ap-4", "-0x5.b7ffef7f30eep-4", "-0x5.c98c803d6092p-4", "-0x5.db0ac96b3e5ap-4",
"-0x5.ec7a9fdf190cp-4", "-0x5.fddbd892e568p-4", "-0x6.0f2e48a4a8aap-4", "-0x6.2071c556e23ep-4", "-0x6.31a62410f548p-4", "-0x6.42cb3a5f9158p-4", "-0x6.53e0ddf51beep-4", "-0x6.64e6e4aa1804p-4",
"-0x6.75dd247d8eaap-4", "-0x6.86c373957652p-4", "-0x6.9799a83f1a38p-4", "-0x6.a85f98ef8162p-4", "-0x6.b9151c43d4b4p-4", "-0x6.c9ba0901c5d2p-4", "-0x6.da4e3617f3dcp-4", "-0x6.ead17a9e51b4p-4",
"-0x6.fb43add68a2ap-4", "-0x7.0ba4a72c64f6p-4", "-0x7.1bf43e362af4p-4", "-0x7.2c324ab5094cp-4", "-0x7.3c5ea495755cp-4", "-0x7.4c7923ef8f16p-4", "-0x7.5c81a10783e4p-4", "-0x7.6c77f44df062p-4",
"-0x7.7c5bf660422cp-4", "-0x7.8c2d800918fcp-4", "-0x7.9bec6a40a75cp-4", "-0x7.ab988e2d1314p-4", "-0x7.bb31c522d4dcp-4", "-0x7.cab7e8a517b2p-4", "-0x7.da2ad266184ep-4", "-0x7.e98a5c478322p-4",
"-0x7.f8d6605ad2aep-4", "-0x8.080eb8e1acbap-4", "-0x8.1733404e3ff2p-4", "-0x8.2643d143a08cp-4", "-0x8.3540469623bcp-4", "-0x8.44287b4bbc9p-4", "-0x8.52fc4a9c561ep-4", "-0x8.61bb8ff22eeap-4",
"-0x8.706626ea32e4p-4", "-0x8.7efbeb545568p-4", "-0x8.8d7cb933ea4p-4", "-0x8.9be86cbffe8ap-4", "-0x8.aa3ee263b144p-4", "-0x8.b87ff6be8ab4p-4", "-0x8.c6ab86a4d3f4p-4", "-0x8.d4c16f1fed9ep-4",
//
"-0x2.p-52", "-0x5.2aedf31dbcp-12", "-0xa.55d43fb846p-12", "-0xf.80ab3f59aap-12", "-0x1.4ab6b4ba722p-8", "-0x1.9d60cbe6e56p-8", "-0x1.f0087f1b2dp-8", "-0x2.42ad53fbb72p-8",
"-0x2.954ed03203ap-8", "-0x2.e7ec796d724p-8", "-0x3.3a85d56426ap-8", "-0x3.8d1a69d3d46p-8", "-0x3.dfa9bc829f4p-8", "-0x4.3233533fe9cp-8", "-0x4.84b6b3e5366p-8", "-0x4.d7336456f74p-8",
"-0x5.29a8ea85688p-8", "-0x5.7c16cc6d658p-8", "-0x5.ce7c9019438p-8", "-0x6.20d9bba1a36p-8", "-0x6.732dd52e4e2p-8", "-0x6.c57862f704cp-8", "-0x7.17b8eb445e6p-8", "-0x7.69eef470996p-8",
"-0x7.bc1a04e86eap-8", "-0x8.0e39a32bf46p-8", "-0x8.604d55cf65cp-8", "-0x8.b254a37c02cp-8", "-0x9.044f12f0dccp-8", "-0x9.563c2b03b6ap-8", "-0x9.a81b72a1d16p-8", "-0x9.f9ec70d0c7cp-8",
"-0xa.4baeacaf5c2p-8", "-0xa.9d61ad7653ap-8", "-0xa.ef04fa794aap-8", "-0xb.40981b27818p-8", "-0xb.921a970cba2p-8", "-0xb.e38bf5d206cp-8", "-0xc.34ebbf3ea1cp-8", "-0xc.86397b38ba4p-8",
"-0xc.d774b1c64ecp-8", "-0xd.289ceb0df9ap-8", "-0xd.79b1af57caep-8", "-0xd.cab2870e184p-8", "-0xe.1b9efabe484p-8", "-0xe.6c769319b0cp-8", "-0xe.bd38d8f661p-8", "-0xf.0de5554ff2ap-8",
"-0xf.5e7b91485cep-8", "-0xf.aefb1628c9ap-8", "-0xf.ff636d625dep-8", "-0x1.04fb4208f0f4p-4", "-0x1.09fecb97273ep-4", "-0x1.0f00cc1fa8f4p-4", "-0x1.14013c440a5cp-4", "-0x1.190014a8a09cp-4",
"-0x1.1dfd4df48e78p-4", "-0x1.22f8e0d1d192p-4", "-0x1.27f2c5ed4efap-4", "-0x1.2ceaf5f6e056p-4", "-0x1.31e169a1606ep-4", "-0x1.36d619a2b806p-4", "-0x1.3bc8feb3eb28p-4", "-0x1.40ba119124f4p-4",
"-0x1.45a94af9c56p-4", "-0x1.4a96a3b06d56p-4", "-0x1.4f82147b0b58p-4", "-0x1.546b9622e89p-4", "-0x1.59532174b56ep-4", "-0x1.5e38af40959ep-4", "-0x1.631c385a2dcep-4", "-0x1.67fdb598aedap-4",
"-0x1.6cdd1fd6e3aap-4", "-0x1.71ba6ff33c96p-4", "-0x1.76959ecfdccap-4", "-0x1.7b6ea552a634p-4", "-0x1.80457c654612p-4", "-0x1.851a1cf54142p-4", "-0x1.89ec7ff400f4p-4", "-0x1.8ebc9e56dec4p-4",
"-0x1.938a711730e8p-4", "-0x1.9855f13256ap-4", "-0x1.9d1f17a9c4c8p-4", "-0x1.a1e5dd831194p-4", "-0x1.a6aa3bc800dcp-4", "-0x1.ab6c2b869064p-4", "-0x1.b02ba5d10418p-4", "-0x1.b4e8a3bdf1f8p-4",
"-0x1.b9a31e684e28p-4", "-0x1.be5b0eef7706p-4", "-0x1.c3106e77411cp-4", "-0x1.c7c336280348p-4", "-0x1.cc735f2ea284p-4", "-0x1.d120e2bc9da2p-4", "-0x1.d5cbba0819a4p-4", "-0x1.da73de4beceap-4",
"-0x1.df1948c7abcp-4", "-0x1.e3bbf2bfb35p-4", "-0x1.e85bd57d3622p-4", "-0x1.ecf8ea4e4742p-4", "-0x1.f1932a85e60ap-4", "-0x1.f62a8f7c09eap-4", "-0x1.fabf128daddp-4", "-0x1.ff50ad1cdba8p-4",
"-0x2.03df5890b80ep-4", "-0x2.086b0e558da6p-4", "-0x2.0cf3c7dcd876p-4", "-0x2.11797e9d5188p-4", "-0x2.15fc2c12fa0ep-4", "-0x2.1a7bc9bf2694p-4", "-0x2.1ef851288abap-4", "-0x2.2371bbdb43e4p-4",
"-0x2.27e80368e4b4p-4", "-0x2.2c5b2168804cp-4", "-0x2.30cb0f76b52ep-4", "-0x2.3537c735b84cp-4", "-0x2.39a1424d603p-4", "-0x2.3e077a6b2ffep-4", "-0x2.426a69426228p-4", "-0x2.46ca088bf3cap-4",
"-0x2.4b265206aec8p-4", "-0x2.4f7f3f773578p-4", "-0x2.53d4caa80cbp-4", "-0x2.5826ed69a6cap-4", "-0x2.5c75a1926e8cp-4", "-0x2.60c0e0fed15cp-4", "-0x2.6508a5914a1cp-4", "-0x2.694ce9326b9cp-4",
};

//  K2  estimated  -1  integer bits.
static const ap_fixed< 44 , 0 > sin_cos_K2 [ 256 ] = {
"-0x4.ef4f326fb5p-4", "-0x4.ef491be5d2p-4", "-0x4.ef36d85612p-4", "-0x4.ef1867ed86p-4", "-0x4.eeedcaf7ap-4", "-0x4.eeb701dd0ap-4", "-0x4.ee740d256cp-4", "-0x4.ee24ed75bfp-4",
"-0x4.edc9a39123p-4", "-0x4.ed62305906p-4", "-0x4.ecee94cc8cp-4", "-0x4.ec6ed208cbp-4", "-0x4.ebe2e9496ep-4", "-0x4.eb4adbe785p-4", "-0x4.eaa6ab59f9p-4", "-0x4.e9f6593647p-4",
"-0x4.e939e72f0ap-4", "-0x4.e8715715c4p-4", "-0x4.e79caad8ep-4", "-0x4.e6bbe48544p-4", "-0x4.e5cf0645b2p-4", "-0x4.e4d6126263p-4", "-0x4.e3d10b41b1p-4", "-0x4.e2bff367cap-4",
"-0x4.e1a2cd7649p-4", "-0x4.e0799c2cfap-4", "-0x4.df446268eep-4", "-0x4.de0323251fp-4", "-0x4.dcb5e17a6bp-4", "-0x4.db5ca09f34p-4", "-0x4.d9f763e6b5p-4", "-0x4.d8862ec333p-4",
"-0x4.d70904c30cp-4", "-0x4.d57fe99304p-4", "-0x4.d3eae0fcfap-4", "-0x4.d249eee83ep-4", "-0x4.d09d1759a1p-4", "-0x4.cee45e738ep-4", "-0x4.cd1fc87504p-4", "-0x4.cb4f59bac3p-4",
"-0x4.c97316bf0ap-4", "-0x4.c78b0418aap-4", "-0x4.c597267bf6p-4", "-0x4.c39782bab1p-4", "-0x4.c18c1dc295p-4", "-0x4.bf74fc9facp-4", "-0x4.bd522479d4p-4", "-0x4.bb239a96cap-4",
"-0x4.b8e9645871p-4", "-0x4.b6a3873dc8p-4", "-0x4.b45208e281p-4", "-0x4.b1f4eefee7p-4", "-0x4.af8c3f67f8p-4", "-0x4.ad18000f9p-4", "-0x4.aa98370383p-4", "-0x4.a80cea6ea7p-4",
"-0x4.a5762097d9p-4", "-0x4.a2d3dfe282p-4", "-0x4.a0262ece69p-4", "-0x4.9d6d13f72fp-4", "-0x4.9aa896152ap-4", "-0x4.97d8bbfc03p-4", "-0x4.94fd8c9c67p-4", "-0x4.92170f0205p-4",
"-0x4.8f254a554fp-4", "-0x4.8c2845d9c5p-4", "-0x4.892008ef24p-4", "-0x4.860c9b108ep-4", "-0x4.82ee03d534p-4", "-0x4.7fc44aef62p-4", "-0x4.7c8f782cd5p-4", "-0x4.794f937736p-4",
"-0x4.7604a4d285p-4", "-0x4.72aeb45f6ap-4", "-0x4.6f4dca581dp-4", "-0x4.6be1ef1343p-4", "-0x4.686b2b01c9p-4", "-0x4.64e986af77p-4", "-0x4.615d0ac363p-4", "-0x4.5dc5bfff2ap-4",
"-0x4.5a23af3ec1p-4", "-0x4.5676e17949p-4", "-0x4.52bf5fc005p-4", "-0x4.4efd333eb1p-4", "-0x4.4b30653b36p-4", "-0x4.4758ff163fp-4", "-0x4.43770a49c6p-4", "-0x4.3f8a906a92p-4",
"-0x4.3b939b26efp-4", "-0x4.3792344732p-4", "-0x4.338665ad89p-4", "-0x4.2f70395583p-4", "-0x4.2b4fb954c7p-4", "-0x4.2724efd9a1p-4", "-0x4.22efe72cbp-4", "-0x4.1eb0a9af1cp-4",
"-0x4.1a6741dbc4p-4", "-0x4.1613ba467ap-4", "-0x4.11b61d9b96p-4", "-0x4.0d4e76a0fep-4", "-0x4.08dcd034cdp-4", "-0x4.0461354e49p-4", "-0x3.ffdbb0fceep-4", "-0x3.fb4c4e68cap-4",
"-0x3.f6b318d25ap-4", "-0x3.f2101b922p-4", "-0x3.ed636218f8p-4", "-0x3.e8acf7ef86p-4", "-0x3.e3ece8b685p-4", "-0x3.df234026cdp-4", "-0x3.da500a1027p-4", "-0x3.d573525a7ap-4",
"-0x3.d08d2504bep-4", "-0x3.cb9d8e25e3p-4", "-0x3.c6a499ebadp-4", "-0x3.c1a2549a7ep-4", "-0x3.bc96ca8edbp-4", "-0x3.b782083af9p-4", "-0x3.b2641a2898p-4", "-0x3.ad3d0cf7b8p-4",
"-0x3.a80ced5f1bp-4", "-0x3.a2d3c82b9p-4", "-0x3.9d91aa4071p-4", "-0x3.9846a09755p-4", "-0x3.92f2b83f5bp-4", "-0x3.8d95fe5e06p-4", "-0x3.8830802e34p-4", "-0x3.82c24b00bp-4",
//
"-0x1.4abbce625ep-4", "-0x1.4abad991c2p-4", "-0x1.4ab7fb2152p-4", "-0x1.4ab333166p-4", "-0x1.4aac817937p-4", "-0x1.4aa3e6559bp-4", "-0x1.4a9961baadp-4", "-0x1.4a8cf3bb2ep-4",
"-0x1.4a7e9c6cadp-4", "-0x1.4a6e5be8ddp-4", "-0x1.4a5c324c0cp-4", "-0x1.4a481fb672p-4", "-0x1.4a32244b23p-4", "-0x1.4a1a403142p-4", "-0x1.4a007392a5p-4", "-0x1.49e4be9ccdp-4",
"-0x1.49c7218097p-4", "-0x1.49a79c7243p-4", "-0x1.49862fa942p-4", "-0x1.4962db6096p-4", "-0x1.493d9fd65p-4", "-0x1.49167d4c4cp-4", "-0x1.48ed74074cp-4", "-0x1.48c2844f8dp-4",
"-0x1.4895ae712fp-4", "-0x1.4866f2bab5p-4", "-0x1.4836517eb7p-4", "-0x1.4803cb1293p-4", "-0x1.47cf5fcfc2p-4", "-0x1.479910126p-4", "-0x1.4760dc3a2dp-4", "-0x1.4726c4aa07p-4",
"-0x1.46eac9c886p-4", "-0x1.46acebff33p-4", "-0x1.466d2bbae1p-4", "-0x1.462b896c2fp-4", "-0x1.45e8058699p-4", "-0x1.45a2a0812dp-4", "-0x1.455b5ad5d9p-4", "-0x1.4512350255p-4",
"-0x1.44c72f876ep-4", "-0x1.447a4ae96fp-4", "-0x1.442b87afb8p-4", "-0x1.43dae664acp-4", "-0x1.43886796cep-4", "-0x1.43340bd727p-4", "-0x1.42ddd3ba22p-4", "-0x1.4285bfd7bbp-4",
"-0x1.422bd0cb36p-4", "-0x1.41d007329dp-4", "-0x1.417263afbp-4", "-0x1.4112e6e753p-4", "-0x1.40b1918199p-4", "-0x1.404e6429fep-4", "-0x1.3fe95f8efap-4", "-0x1.3f82846257p-4",
"-0x1.3f19d35945p-4", "-0x1.3eaf4d2bfep-4", "-0x1.3e42f2960fp-4", "-0x1.3dd4c4560ep-4", "-0x1.3d64c32df8p-4", "-0x1.3cf2efe32fp-4", "-0x1.3c7f4b3d76p-4", "-0x1.3c09d608dap-4",
"-0x1.3b929113b5p-4", "-0x1.3b197d2fdp-4", "-0x1.3a9e9b327bp-4", "-0x1.3a21ebf3ecp-4", "-0x1.39a3704f1ep-4", "-0x1.3923292326p-4", "-0x1.38a11750f7p-4", "-0x1.381d3bbe0cp-4",
"-0x1.37979751bfp-4", "-0x1.37102af7a1p-4", "-0x1.3686f79d8dp-4", "-0x1.35fbfe34c3p-4", "-0x1.356f3fb1cp-4", "-0x1.34e0bd0c11p-4", "-0x1.3450773e3bp-4", "-0x1.33be6f45afp-4",
"-0x1.332aa6235dp-4", "-0x1.32951cdb3ep-4", "-0x1.31fdd473e3p-4", "-0x1.3164cdf722p-4", "-0x1.30ca0a7218p-4", "-0x1.302d8af4fp-4", "-0x1.2f8f50927bp-4", "-0x1.2eef5c60b8p-4",
"-0x1.2e4daf78bcp-4", "-0x1.2daa4af6a3p-4", "-0x1.2d052ff991p-4", "-0x1.2c5e5fa36cp-4", "-0x1.2bb5db1931p-4", "-0x1.2b0ba38309p-4", "-0x1.2a5fba0bb2p-4", "-0x1.29b21fe158p-4",
"-0x1.2902d6348ep-4", "-0x1.2851de396ap-4", "-0x1.279f39266p-4", "-0x1.26eae83517p-4", "-0x1.2634eca244p-4", "-0x1.257d47ad3bp-4", "-0x1.24c3fa984p-4", "-0x1.240906a8abp-4",
"-0x1.234c6d2682p-4", "-0x1.228e2f5cacp-4", "-0x1.21ce4e992p-4", "-0x1.210ccc2c4ep-4", "-0x1.2049a969b1p-4", "-0x1.1f84e7a7bbp-4", "-0x1.1ebe883f4cp-4", "-0x1.1df68c8c76p-4",
"-0x1.1d2cf5edfbp-4", "-0x1.1c61c5c529p-4", "-0x1.1b94fd7637p-4", "-0x1.1ac69e6851p-4", "-0x1.19f6aa0536p-4", "-0x1.192521b94bp-4", "-0x1.185206f40bp-4", "-0x1.177d5b26edp-4",
"-0x1.16a71fc724p-4", "-0x1.15cf564b97p-4", "-0x1.14f6002e85p-4", "-0x1.141b1eecd5p-4", "-0x1.133eb405a2p-4", "-0x1.1260c0fb0ep-4", "-0x1.11814751b6p-4", "-0x1.10a04890f6p-4",
};

//  K3  estimated  -4  integer bits.
static const ap_fixed< 34 , -3 > sin_cos_K3 [ 256 ] = {
"0x2.fp-32", "0x2.0783db8p-12", "0x4.0f026e8p-12", "0x6.1676eep-12", "0x8.1ddc8bp-12", "0xa.252df8p-12", "0xc.2c66828p-12", "0xe.3381068p-12",
"0x1.03a78668p-8", "0x1.24147d08p-8", "0x1.447ea22p-8", "0x1.64e5a468p-8", "0x1.854938dp-8", "0x1.a5a90d68p-8", "0x1.c604cfe8p-8", "0x1.e65c33c8p-8",
"0x2.06aee518p-8", "0x2.26fc99ap-8", "0x2.4744fcdp-8", "0x2.6787c07p-8", "0x2.87c49708p-8", "0x2.a7fb2ddp-8", "0x2.c82b36fp-8", "0x2.e8546448p-8",
"0x3.087663b8p-8", "0x3.2890e8c8p-8", "0x3.48a3a178p-8", "0x3.68ae3e68p-8", "0x3.88b073dp-8", "0x3.a8a9f358p-8", "0x3.c89a66a8p-8", "0x3.e88188dp-8",
"0x4.085f039p-8", "0x4.28328c48p-8", "0x4.47fbd2e8p-8", "0x4.67ba88bp-8", "0x4.876e5f28p-8", "0x4.a7170c5p-8", "0x4.c6b43c9p-8", "0x4.e645a28p-8",
"0x5.05caf3cp-8", "0x5.2543df1p-8", "0x5.44b0172p-8", "0x5.640f538p-8", "0x5.83613e98p-8", "0x5.a2a591fp-8", "0x5.c1dbfaep-8", "0x5.e10431d8p-8",
"0x6.001de6b8p-8", "0x6.1f28cd5p-8", "0x6.3e2499e8p-8", "0x6.5d10fe58p-8", "0x6.7bedae4p-8", "0x6.9aba6028p-8", "0x6.b976c4ep-8", "0x6.d8229298p-8",
"0x6.f6bd7dp-8", "0x7.1547386p-8", "0x7.33bf7b38p-8", "0x7.5225f74p-8", "0x7.707a658p-8", "0x7.8ebc753p-8", "0x7.acebe1cp-8", "0x7.cb085b7p-8",
"0x7.e9119d68p-8", "0x8.070759cp-8", "0x8.24e94768p-8", "0x8.42b71b7p-8", "0x8.60708f5p-8", "0x8.7e15585p-8", "0x8.9ba52b98p-8", "0x8.b91fc43p-8",
"0x8.d684d22p-8", "0x8.f3d416b8p-8", "0x9.110d4048p-8", "0x9.2e300d1p-8", "0x9.4b3c338p-8", "0x9.683169e8p-8", "0x9.850f6adp-8", "0x9.a1d5efe8p-8",
"0x9.be84ae48p-8", "0x9.db1b634p-8", "0x9.f799c6b8p-8", "0xa.13ff929p-8", "0xa.304c7f5p-8", "0xa.4c804afp-8", "0xa.689aaacp-8", "0xa.849b5d08p-8",
"0xa.a0821b28p-8", "0xa.bc4ea018p-8", "0xa.d800a8e8p-8", "0xa.f397ef5p-8", "0xb.0f143278p-8", "0xb.2a752948p-8", "0xb.45ba94ep-8", "0xb.60e42fp-8",
"0xb.7bf1b688p-8", "0xb.96e2e9e8p-8", "0xb.b1b7827p-8", "0xb.cc6f419p-8", "0xb.e709e25p-8", "0xc.01872608p-8", "0xc.1be6ca58p-8", "0xc.36288d48p-8",
"0xc.504c303p-8", "0xc.6a51703p-8", "0xc.84380ebp-8", "0xc.9dffc9dp-8", "0xc.b7a8627p-8", "0xc.d1319d6p-8", "0xc.ea9b3648p-8", "0xd.03e4f15p-8",
"0xd.1d0e8c88p-8", "0xd.3617ce88p-8", "0xd.4f0079cp-8", "0xd.67c84a68p-8", "0xd.806f0b38p-8", "0xd.98f479bp-8", "0xd.b1585bf8p-8", "0xd.c99a744p-8",
"0xd.e1ba88c8p-8", "0xd.f9b85bb8p-8", "0xe.1193b2cp-8", "0xe.294c5568p-8", "0xe.40e20538p-8", "0xe.58548b88p-8", "0xe.6fa3ab1p-8", "0xe.86cf2c8p-8",
//
"0x6.8p-36", "0x5.19af2p-16", "0xa.3353dp-16", "0xf.4ce8p-16", "0x1.46661p-12", "0x1.97fb5c8p-12", "0x1.e98dc8p-12", "0x2.3b1cf6p-12",
"0x2.8ca80ep-12", "0x2.de2ece8p-12", "0x3.2fb07p-12", "0x3.812c878p-12", "0x3.d2a247p-12", "0x4.24116f8p-12", "0x4.75793f8p-12", "0x4.c6d92bp-12",
"0x5.1830b1p-12", "0x5.697f44p-12", "0x5.bac44bp-12", "0x6.0bff41p-12", "0x6.5d2f78p-12", "0x6.ae548f8p-12", "0x6.ff6dd68p-12", "0x7.507aaep-12",
"0x7.a17ad98p-12", "0x7.f26d76p-12", "0x8.4352238p-12", "0x8.94281p-12", "0x8.e4ef08p-12", "0x9.35a653p-12", "0x9.864d62p-12", "0x9.d6e397p-12",
"0xa.2768918p-12", "0xa.77db9cp-12", "0xa.c83c1ep-12", "0xb.1889bcp-12", "0xb.68c3c98p-12", "0xb.b8e9dc8p-12", "0xc.08fb298p-12", "0xc.58f73c8p-12",
"0xc.a8dd92p-12", "0xc.f8ada7p-12", "0xd.4866f48p-12", "0xd.9808a98p-12", "0xd.e7929a8p-12", "0xe.3704128p-12", "0xe.865c64p-12", "0xe.d59b218p-12",
"0xf.24bfe08p-12", "0xf.73c9dep-12", "0xf.c2b8a58p-12", "0x1.0118baep-8", "0x1.060426b8p-8", "0x1.0aedc65p-8", "0x1.0fd58f48p-8", "0x1.14bb7938p-8",
"0x1.199f7c4p-8", "0x1.1e818fep-8", "0x1.2361ab58p-8", "0x1.283fc518p-8", "0x1.2d1bd558p-8", "0x1.31f5d6ap-8", "0x1.36cdb9fp-8", "0x1.3ba37d18p-8",
"0x1.40771408p-8", "0x1.45487548p-8", "0x1.4a179b2p-8", "0x1.4ee47dep-8", "0x1.53af10b8p-8", "0x1.58775188p-8", "0x1.5d3d301p-8", "0x1.6200ac08p-8",
"0x1.66c1b61p-8", "0x1.6b804c3p-8", "0x1.703c6248p-8", "0x1.74f5ef9p-8", "0x1.79acedd8p-8", "0x1.7e615438p-8", "0x1.83131b4p-8", "0x1.87c2378p-8",
"0x1.8c6ea378p-8", "0x1.911858a8p-8", "0x1.95bf4c5p-8", "0x1.9a6374dp-8", "0x1.9f04cbcp-8", "0x1.a3a34bcp-8", "0x1.a83ee9e8p-8", "0x1.acd79ddp-8",
"0x1.b16d5fc8p-8", "0x1.b60028bp-8", "0x1.ba8ff12p-8", "0x1.bf1caf6p-8", "0x1.c3a65bd8p-8", "0x1.c82cefap-8", "0x1.ccb06178p-8", "0x1.d130ab58p-8",
"0x1.d5adc388p-8", "0x1.da27a49p-8", "0x1.de9e4418p-8", "0x1.e3119a5p-8", "0x1.e781a1d8p-8", "0x1.ebee51dp-8", "0x1.f057a16p-8", "0x1.f4bd8a68p-8",
"0x1.f92004a8p-8", "0x1.fd7f08p-8", "0x2.01da8f2p-8", "0x2.06328fc8p-8", "0x2.0a870358p-8", "0x2.0ed7e3p-8", "0x2.13252578p-8", "0x2.176ec528p-8",
"0x2.1bb4baep-8", "0x2.1ff6fd78p-8", "0x2.2435853p-8", "0x2.28704cc8p-8", "0x2.2ca74c58p-8", "0x2.30da7b68p-8", "0x2.3509d62p-8", "0x2.39354eep-8",
"0x2.3d5ce598p-8", "0x2.41808d38p-8", "0x2.45a0412p-8", "0x2.49bbfc8p-8", "0x2.4dd3b528p-8", "0x2.51e76528p-8", "0x2.55f704ap-8", "0x2.5a028dap-8",
};

//  K4  estimated  -5  integer bits.
static const ap_fixed< 26 , -4 > sin_cos_K4 [ 256 ] = {
"0x4.0f0674p-8", "0x4.0efc1cp-8", "0x4.0ee824p-8", "0x4.0eca54p-8", "0x4.0ea214p-8", "0x4.0e705cp-8", "0x4.0e342p-8", "0x4.0dedc8p-8",
"0x4.0d9de4p-8", "0x4.0d4398p-8", "0x4.0cdf98p-8", "0x4.0c7214p-8", "0x4.0bf9e8p-8", "0x4.0b77ap-8", "0x4.0aebbp-8","0x4.0a558p-8",
"0x4.09b5d8p-8", "0x4.090b8cp-8", "0x4.0857b4p-8", "0x4.079a0cp-8", "0x4.06d1fcp-8", "0x4.06007p-8", "0x4.0524e4p-8","0x4.043f1p-8",
"0x4.034facp-8", "0x4.0256p-8", "0x4.0152c4p-8", "0x4.004614p-8", "0x3.ff2f04p-8", "0x3.fe0d9p-8", "0x3.fce384p-8", "0x3.fbae74p-8",
"0x3.fa7048p-8", "0x3.f927e8p-8", "0x3.f7d5d8p-8", "0x3.f67a18p-8", "0x3.f514d8p-8", "0x3.f3a4fp-8", "0x3.f22bc8p-8","0x3.f0a938p-8",
"0x3.ef1c7p-8", "0x3.ed8644p-8", "0x3.ebe6b4p-8", "0x3.ea3c7p-8", "0x3.e8897cp-8", "0x3.e6cc5p-8", "0x3.e5062cp-8", "0x3.e335cp-8",
"0x3.e15becp-8", "0x3.df7898p-8", "0x3.dd8b6cp-8", "0x3.db94f8p-8", "0x3.d99538p-8", "0x3.d78b98p-8", "0x3.d578dp-8", "0x3.d35c8cp-8",
"0x3.d136cp-8", "0x3.cf07a8p-8", "0x3.cccec4p-8", "0x3.ca8ce8p-8", "0x3.c84108p-8", "0x3.c5ecbp-8", "0x3.c38e6cp-8", "0x3.c1279p-8",
"0x3.beb6b8p-8", "0x3.bc3cccp-8", "0x3.b9b9c4p-8", "0x3.b72dd4p-8", "0x3.b4985cp-8", "0x3.b1f9acp-8", "0x3.af5228p-8", "0x3.aca0fp-8",
"0x3.a9e7dp-8", "0x3.a7245cp-8", "0x3.a458e8p-8", "0x3.a183fcp-8", "0x3.9ea6p-8", "0x3.9bbf58p-8", "0x3.98cfc4p-8", "0x3.95d6f4p-8",
"0x3.92d5f4p-8", "0x3.8fcbacp-8", "0x3.8cb8acp-8", "0x3.899cep-8", "0x3.867894p-8", "0x3.834b04p-8", "0x3.801568p-8","0x3.7cd6ep-8",
"0x3.798fccp-8", "0x3.76405cp-8", "0x3.72e82p-8", "0x3.6f878cp-8", "0x3.6c1e04p-8", "0x3.68acb4p-8", "0x3.65329cp-8","0x3.61b058p-8",
"0x3.5e25ap-8", "0x3.5a922cp-8", "0x3.56f704p-8", "0x3.53535p-8", "0x3.4fa7d8p-8", "0x3.4bf3e4p-8", "0x3.4837bp-8", "0x3.4473acp-8",
"0x3.40a728p-8", "0x3.3cd2ecp-8", "0x3.38f68p-8", "0x3.351274p-8", "0x3.3126acp-8", "0x3.2d323p-8", "0x3.293678p-8", "0x3.2532a4p-8",
"0x3.2127cp-8", "0x3.1d14acp-8", "0x3.18f958p-8", "0x3.14d77p-8", "0x3.10ad0cp-8", "0x3.0c7b7cp-8", "0x3.08423cp-8", "0x3.0401ccp-8",
"0x2.ffb99cp-8", "0x2.fb6a48p-8", "0x2.f713acp-8", "0x2.f2b534p-8", "0x2.ee4ffcp-8", "0x2.e9e3p-8", "0x2.e56f5cp-8","0x2.e0f464p-8",
//
"0xa.335bp-12", "0xa.33498p-12", "0xa.33288p-12", "0xa.32fp-12", "0xa.32a7p-12", "0xa.324ccp-12", "0xa.31e5cp-12", "0xa.31638p-12",
"0xa.30d94p-12", "0xa.30344p-12", "0xa.2f808p-12", "0xa.2eb5cp-12", "0xa.2de48p-12", "0xa.2cf8p-12", "0xa.2bfc4p-12","0xa.2af14p-12",
"0xa.29d2p-12", "0xa.28ap-12", "0xa.275bcp-12", "0xa.2604cp-12", "0xa.24a18p-12", "0xa.2326cp-12", "0xa.219cp-12", "0xa.2005cp-12",
"0xa.1e514p-12", "0xa.1c914p-12", "0xa.1abacp-12", "0xa.18df8p-12", "0xa.16e88p-12", "0xa.14dfp-12", "0xa.12c5cp-12","0xa.109e4p-12",
"0xa.0e5dcp-12", "0xa.0c10cp-12", "0xa.09b6p-12", "0xa.07434p-12", "0xa.04c14p-12", "0xa.0225p-12", "0x9.ff7ecp-12", "0x9.fccap-12",
"0x9.fa014p-12", "0x9.f7264p-12", "0x9.f4348p-12", "0x9.f13ep-12", "0x9.ee2b4p-12", "0x9.eb054p-12", "0x9.e7d5cp-12","0x9.e4954p-12",
"0x9.e13bcp-12", "0x9.ddd6p-12", "0x9.da5fp-12", "0x9.d6d7p-12", "0x9.d33dp-12", "0x9.cf8ep-12", "0x9.cbd18p-12", "0x9.c8048p-12",
"0x9.c4268p-12", "0x9.c035p-12", "0x9.bc33p-12", "0x9.b823p-12", "0x9.b4024p-12", "0x9.afc5p-12", "0x9.ab848p-12", "0x9.a728cp-12",
"0x9.a2be8p-12", "0x9.9e4ap-12", "0x9.99c28p-12", "0x9.95234p-12", "0x9.907d4p-12", "0x9.8bb9cp-12", "0x9.86f6p-12","0x9.8212cp-12",
"0x9.7d2c4p-12", "0x9.7829p-12", "0x9.73184p-12", "0x9.6dfc8p-12", "0x9.68cbp-12", "0x9.638bp-12", "0x9.5e35p-12", "0x9.58d8p-12",
"0x9.5368cp-12", "0x9.4de2p-12", "0x9.484b8p-12", "0x9.42adp-12", "0x9.3d008p-12", "0x9.37398p-12", "0x9.31648p-12", "0x9.2b828p-12",
"0x9.25924p-12", "0x9.1f8f8p-12", "0x9.19798p-12", "0x9.13578p-12", "0x9.0d25cp-12", "0x9.06e3cp-12", "0x9.0093p-12", "0x8.fa30cp-12",
"0x8.f3bfcp-12", "0x8.ed3acp-12", "0x8.e6aap-12", "0x8.e00ecp-12", "0x8.d95e8p-12", "0x8.d29d4p-12", "0x8.cbd1p-12","0x8.c4f3cp-12",
"0x8.be07cp-12", "0x8.b70f4p-12", "0x8.b0008p-12", "0x8.a8e74p-12", "0x8.a1bd8p-12", "0x8.9a844p-12", "0x8.933fcp-12", "0x8.8be9p-12",
"0x8.8480cp-12", "0x8.7d0dp-12", "0x8.758fp-12", "0x8.6dfe4p-12", "0x8.665e4p-12", "0x8.5eb38p-12", "0x8.56ef4p-12", "0x8.4f2c8p-12",
"0x8.474d4p-12", "0x8.3f6a4p-12", "0x8.37798p-12", "0x8.2f71cp-12", "0x8.275ecp-12", "0x8.1f3c8p-12", "0x8.170ecp-12", "0x8.0ed04p-12",
};
};

namespace first_order_fixed_16 {
// Tables for f= cos((pi) / 2 * x)
//  K0  estimated  1  integer bits.
static const ap_fixed< 19 , 2 > sin_cos_K0 [ 256 ] = {
"0x1.p0", "0xf.fffp-4", "0xf.ffbp-4", "0xf.ff5p-4", "0xf.fec8p-4", "0xf.fe18p-4", "0xf.fd38p-4", "0xf.fc38p-4",
"0xf.fb1p-4", "0xf.f9cp-4", "0xf.f85p-4", "0xf.f6bp-4", "0xf.f4e8p-4", "0xf.f3p-4", "0xf.f0e8p-4", "0xf.eebp-4",
"0xf.ec48p-4", "0xf.e9cp-4", "0xf.e71p-4", "0xf.e438p-4", "0xf.e138p-4", "0xf.de1p-4", "0xf.dacp-4", "0xf.d748p-4",
"0xf.d3bp-4", "0xf.cfe8p-4", "0xf.ccp-4", "0xf.c7fp-4", "0xf.c3b8p-4", "0xf.bf58p-4", "0xf.badp-4", "0xf.b62p-4",
"0xf.b15p-4", "0xf.ac5p-4", "0xf.a73p-4", "0xf.a1e8p-4", "0xf.9c8p-4", "0xf.96e8p-4", "0xf.9128p-4", "0xf.8b48p-4",
"0xf.854p-4", "0xf.7f1p-4", "0xf.78cp-4", "0xf.724p-4", "0xf.6bap-4", "0xf.64d8p-4", "0xf.5dfp-4", "0xf.56d8p-4",
"0xf.4fap-4", "0xf.4848p-4", "0xf.40cp-4", "0xf.3918p-4", "0xf.3148p-4", "0xf.295p-4", "0xf.2138p-4", "0xf.18f8p-4",
"0xf.109p-4", "0xf.0808p-4", "0xe.ff58p-4", "0xe.f688p-4", "0xe.ed9p-4", "0xe.e47p-4", "0xe.db28p-4", "0xe.d1c8p-4",
"0xe.c838p-4", "0xe.be88p-4", "0xe.b4bp-4", "0xe.aab8p-4", "0xe.a0ap-4", "0xe.9658p-4", "0xe.8bf8p-4", "0xe.817p-4",
"0xe.76cp-4", "0xe.6bfp-4", "0xe.60f8p-4", "0xe.55ep-4", "0xe.4aa8p-4", "0xe.3f48p-4", "0xe.33c8p-4", "0xe.282p-4",
"0xe.1c58p-4", "0xe.107p-4", "0xe.0468p-4", "0xd.f838p-4", "0xd.ebep-4", "0xd.df7p-4", "0xd.d2d8p-4", "0xd.c62p-4",
"0xd.b94p-4", "0xd.ac48p-4", "0xd.9f28p-4", "0xd.91e8p-4", "0xd.8488p-4", "0xd.7708p-4", "0xd.696p-4", "0xd.5b98p-4",
"0xd.4db8p-4", "0xd.3fbp-4", "0xd.3188p-4", "0xd.234p-4", "0xd.14d8p-4", "0xd.065p-4", "0xc.f7ap-4", "0xc.e8d8p-4",
"0xc.d9fp-4", "0xc.cae8p-4", "0xc.bbcp-4", "0xc.ac78p-4", "0xc.9d1p-4", "0xc.8d9p-4", "0xc.7de8p-4", "0xc.6e28p-4",
"0xc.5e4p-4", "0xc.4e4p-4", "0xc.3e2p-4", "0xc.2de8p-4", "0xc.1d88p-4", "0xc.0d1p-4", "0xb.fc78p-4", "0xb.ebcp-4",
"0xb.dafp-4", "0xb.cap-4", "0xb.b8f8p-4", "0xb.a7dp-4", "0xb.9688p-4", "0xb.852p-4", "0xb.73ap-4", "0xb.6208p-4",
"0xb.505p-4", "0xb.3e8p-4", "0xb.2c9p-4", "0xb.1a8p-4", "0xb.086p-4", "0xa.f618p-4", "0xa.e3cp-4", "0xa.d148p-4",
"0xa.beb8p-4", "0xa.ac08p-4", "0xa.994p-4", "0xa.866p-4", "0xa.7368p-4", "0xa.605p-4", "0xa.4d2p-4", "0xa.39ep-4",
"0xa.2678p-4", "0xa.13p-4", "0x9.ff7p-4", "0x9.ebcp-4", "0x9.d8p-4", "0x9.c42p-4", "0x9.b03p-4", "0x9.9c2p-4",
"0x9.88p-4", "0x9.73cp-4", "0x9.5f7p-4", "0x9.4bp-4", "0x9.368p-4", "0x9.21e8p-4", "0x9.0d4p-4", "0x8.f878p-4",
"0x8.e3ap-4", "0x8.cebp-4", "0x8.b9a8p-4", "0x8.a49p-4", "0x8.8f58p-4", "0x8.7a18p-4", "0x8.64b8p-4", "0x8.4f48p-4",
"0x8.39cp-4", "0x8.243p-4", "0x8.0e8p-4", "0x7.f8cp-4", "0x7.e2e8p-4", "0x7.cdp-4", "0x7.b708p-4", "0x7.a0f8p-4",
"0x7.8ad8p-4", "0x7.74a8p-4", "0x7.5e6p-4", "0x7.4808p-4", "0x7.31ap-4", "0x7.1b2p-4", "0x7.049p-4", "0x6.edfp-4",
"0x6.d74p-4", "0x6.c088p-4", "0x6.a9bp-4", "0x6.92dp-4", "0x6.7bep-4", "0x6.64ep-4", "0x6.4ddp-4", "0x6.36a8p-4",
"0x6.1f78p-4", "0x6.0838p-4", "0x5.f0e8p-4", "0x5.d99p-4", "0x5.c22p-4", "0x5.aaa8p-4", "0x5.932p-4", "0x5.7b88p-4",
"0x5.63e8p-4", "0x5.4c38p-4", "0x5.3478p-4", "0x5.1cbp-4", "0x5.04d8p-4", "0x4.ecfp-4", "0x4.d508p-4", "0x4.bd08p-4",
"0x4.a5p-4", "0x4.8cfp-4", "0x4.74dp-4", "0x4.5ca8p-4", "0x4.4478p-4", "0x4.2c38p-4", "0x4.13fp-4", "0x3.fbap-4",
"0x3.e34p-4", "0x3.cad8p-4", "0x3.b268p-4", "0x3.99fp-4", "0x3.817p-4", "0x3.68e8p-4", "0x3.5058p-4", "0x3.37b8p-4",
"0x3.1f18p-4", "0x3.067p-4", "0x2.edcp-4", "0x2.d5p-4", "0x2.bc4p-4", "0x2.a38p-4", "0x2.8abp-4", "0x2.71ep-4",
"0x2.59p-4", "0x2.402p-4", "0x2.274p-4", "0x2.0e5p-4", "0x1.f568p-4", "0x1.dc7p-4", "0x1.c378p-4", "0x1.aa8p-4",
"0x1.9178p-4", "0x1.7878p-4", "0x1.5f7p-4", "0x1.466p-4", "0x1.2d5p-4", "0x1.144p-4", "0xf.b28p-8", "0xe.218p-8",
"0xc.8f8p-8", "0xa.fep-8", "0x9.6cp-8", "0x7.da8p-8", "0x6.488p-8", "0x4.b68p-8", "0x3.24p-8", "0x1.92p-8",
};
//  K1  estimated  1  integer bits.
static const ap_fixed< 11 , 2 > sin_cos_K1 [ 256 ] = {
"-0x1.p-8", "-0x4.p-8", "-0x6.p-8", "-0x8.8p-8", "-0xb.p-8", "-0xe.p-8", "-0xf.8p-8", "-0x1.2p-4",
"-0x1.48p-4", "-0x1.7p-4", "-0x1.ap-4", "-0x1.c8p-4", "-0x1.e8p-4", "-0x2.18p-4", "-0x2.38p-4", "-0x2.68p-4",
"-0x2.88p-4", "-0x2.bp-4", "-0x2.ep-4", "-0x3.08p-4", "-0x3.28p-4", "-0x3.5p-4", "-0x3.78p-4", "-0x3.98p-4",
"-0x3.c8p-4", "-0x3.e8p-4", "-0x4.1p-4", "-0x4.38p-4", "-0x4.6p-4", "-0x4.88p-4", "-0x4.bp-4", "-0x4.dp-4",
"-0x5.p-4", "-0x5.2p-4", "-0x5.48p-4", "-0x5.68p-4", "-0x5.98p-4", "-0x5.cp-4", "-0x5.ep-4", "-0x6.08p-4",
"-0x6.28p-4", "-0x6.5p-4", "-0x6.8p-4", "-0x6.98p-4", "-0x6.cp-4", "-0x6.e8p-4", "-0x7.18p-4", "-0x7.3p-4",
"-0x7.58p-4", "-0x7.88p-4", "-0x7.a8p-4", "-0x7.dp-4", "-0x7.f8p-4", "-0x8.18p-4", "-0x8.4p-4", "-0x8.68p-4",
"-0x8.88p-4", "-0x8.bp-4", "-0x8.dp-4", "-0x9.p-4", "-0x9.2p-4", "-0x9.48p-4", "-0x9.6p-4", "-0x9.9p-4",
"-0x9.bp-4", "-0x9.d8p-4", "-0x9.f8p-4", "-0xa.18p-4", "-0xa.48p-4", "-0xa.6p-4", "-0xa.88p-4", "-0xa.bp-4",
"-0xa.dp-4", "-0xa.f8p-4", "-0xb.18p-4", "-0xb.38p-4", "-0xb.6p-4", "-0xb.8p-4", "-0xb.a8p-4", "-0xb.cp-4",
"-0xb.e8p-4", "-0xc.08p-4", "-0xc.38p-4", "-0xc.58p-4", "-0xc.7p-4", "-0xc.98p-4", "-0xc.b8p-4", "-0xc.ep-4",
"-0xc.f8p-4", "-0xd.2p-4", "-0xd.4p-4", "-0xd.6p-4", "-0xd.8p-4", "-0xd.a8p-4", "-0xd.c8p-4", "-0xd.ep-4",
"-0xe.08p-4", "-0xe.28p-4", "-0xe.48p-4", "-0xe.68p-4", "-0xe.88p-4", "-0xe.bp-4", "-0xe.cp-4", "-0xe.e8p-4",
"-0xf.08p-4", "-0xf.28p-4", "-0xf.48p-4", "-0xf.68p-4", "-0xf.8p-4", "-0xf.a8p-4", "-0xf.cp-4", "-0xf.e8p-4",
"-0x1.p0", "-0x1.02p0", "-0x1.038p0", "-0x1.06p0", "-0x1.078p0", "-0x1.098p0", "-0x1.0b8p0", "-0x1.0dp0",
"-0x1.0fp0", "-0x1.108p0", "-0x1.13p0", "-0x1.148p0", "-0x1.168p0", "-0x1.178p0", "-0x1.198p0", "-0x1.1b8p0",
"-0x1.1dp0", "-0x1.1fp0", "-0x1.21p0", "-0x1.22p0", "-0x1.248p0", "-0x1.258p0", "-0x1.278p0", "-0x1.29p0",
"-0x1.2bp0", "-0x1.2c8p0", "-0x1.2ep0", "-0x1.2f8p0", "-0x1.318p0", "-0x1.328p0", "-0x1.34p0", "-0x1.368p0",
"-0x1.378p0", "-0x1.39p0", "-0x1.3bp0", "-0x1.3cp0", "-0x1.3ep0", "-0x1.3fp0", "-0x1.41p0", "-0x1.42p0",
"-0x1.44p0", "-0x1.45p0", "-0x1.468p0", "-0x1.478p0", "-0x1.49p0", "-0x1.4a8p0", "-0x1.4c8p0", "-0x1.4d8p0",
"-0x1.4fp0", "-0x1.508p0", "-0x1.518p0", "-0x1.538p0", "-0x1.54p0", "-0x1.56p0", "-0x1.57p0", "-0x1.58p0",
"-0x1.59p0", "-0x1.5bp0", "-0x1.5cp0", "-0x1.5d8p0", "-0x1.5e8p0", "-0x1.5f8p0", "-0x1.61p0", "-0x1.62p0",
"-0x1.63p0", "-0x1.648p0", "-0x1.658p0", "-0x1.668p0", "-0x1.68p0", "-0x1.69p0", "-0x1.698p0", "-0x1.6a8p0",
"-0x1.6b8p0", "-0x1.6d8p0", "-0x1.6ep0", "-0x1.6fp0", "-0x1.7p0", "-0x1.718p0", "-0x1.728p0", "-0x1.73p0",
"-0x1.74p0", "-0x1.75p0", "-0x1.758p0", "-0x1.77p0", "-0x1.778p0", "-0x1.788p0", "-0x1.798p0", "-0x1.7ap0",
"-0x1.7bp0", "-0x1.7cp0", "-0x1.7c8p0", "-0x1.7d8p0", "-0x1.7ep0", "-0x1.7e8p0", "-0x1.8p0", "-0x1.808p0",
"-0x1.81p0", "-0x1.82p0", "-0x1.828p0", "-0x1.83p0", "-0x1.84p0", "-0x1.848p0", "-0x1.85p0", "-0x1.86p0",
"-0x1.868p0", "-0x1.87p0", "-0x1.878p0", "-0x1.88p0", "-0x1.888p0", "-0x1.89p0", "-0x1.8ap0", "-0x1.8ap0",
"-0x1.8a8p0", "-0x1.8b8p0", "-0x1.8cp0", "-0x1.8cp0", "-0x1.8cp0", "-0x1.8dp0", "-0x1.8d8p0", "-0x1.8ep0",
"-0x1.8ep0", "-0x1.8ep0", "-0x1.8e8p0", "-0x1.8e8p0", "-0x1.8f8p0", "-0x1.8f8p0", "-0x1.9p0", "-0x1.908p0",
"-0x1.9p0", "-0x1.908p0", "-0x1.91p0", "-0x1.91p0", "-0x1.91p0", "-0x1.918p0", "-0x1.91p0", "-0x1.92p0",
"-0x1.918p0", "-0x1.92p0", "-0x1.918p0", "-0x1.92p0", "-0x1.92p0", "-0x1.928p0", "-0x1.92p0", "-0x1.92p0",
};
}

// Tables for f= tanh(8 * x)
//  K0  estimated  0  integer bits.
static const ap_fixed< 31 , 1 > second_tanh_K0 [ 512 ] = {
"-0xa.p-28", "0x3.ffea08p-8", "0x7.ff54c4p-8", "0xb.fdbfep-8","0xf.faac2cp-8", "0x1.3f59b34p-4", "0x1.7ee0f88p-4", "0x1.be38ce8p-4",
"0x1.fd5989p-4", "0x2.3c3b974p-4", "0x2.7ad786p-4", "0x2.b926054p-4", "0x2.f71fe9p-4", "0x3.34be2fp-4", "0x3.71f9ffcp-4", "0x3.aeccb1cp-4",
"0x3.eb2fcdp-4", "0x4.271d0c4p-4", "0x4.628e604p-4", "0x4.9d7df18p-4", "0x4.d7e6218p-4", "0x5.11c18d8p-4", "0x5.4b0b0f8p-4", "0x5.83bdbecp-4",
"0x5.bbd4f24p-4", "0x5.f34c404p-4", "0x6.2a1f804p-4", "0x6.604aca4p-4", "0x6.95ca778p-4", "0x6.ca9b228p-4", "0x6.feb9a78p-4", "0x7.322323p-4",
"0x7.64d4f3p-4", "0x7.96ccb48p-4", "0x7.c808444p-4", "0x7.f885bd8p-4", "0x8.284378p-4", "0x8.5740084p-4", "0x8.857a3ep-4","0x8.b2f122p-4",
"0x8.dfa3f5p-4", "0x9.0b922ecp-4", "0x9.36bb7bcp-4", "0x9.611fbbcp-4", "0x9.8abfp-4", "0x9.b399894p-4", "0x9.dbafc7p-4", "0xa.0302538p-4",
"0xa.2991f4p-4", "0xa.4f5f96p-4", "0xa.746c4ccp-4", "0xa.98b95p-4", "0xa.bc47facp-4", "0xa.df19c74p-4", "0xb.01304fcp-4", "0xb.228d4a4p-4",
"0xb.4332888p-4", "0xb.6321f48p-4", "0xb.825d90cp-4", "0xb.a0e774p-4", "0xb.bec1ca4p-4", "0xb.dbeed08p-4", "0xb.f870d58p-4", "0xc.144a368p-4",
"0xc.2f7d5dcp-4", "0xc.4a0cc2cp-4", "0xc.63fae6cp-4", "0xc.7d4a548p-4", "0xc.95fd9fp-4", "0xc.ae175f8p-4", "0xc.c59a354p-4", "0xc.dc88c3cp-4",
"0xc.f2e5b14p-4", "0xd.08b3a74p-4", "0xd.1df54fcp-4", "0xd.32ad554p-4", "0xd.46de618p-4", "0xd.5a8b1dcp-4", "0xd.6db63p-4","0xd.80623bcp-4",
"0xd.9291e14p-4", "0xd.a447bcp-4", "0xd.b58662cp-4", "0xd.c650678p-4", "0xd.d6a855cp-4", "0xd.e690b24p-4", "0xd.f60bfc4p-4", "0xe.051caa4p-4",
"0xe.13c52c8p-4", "0xe.2207ea8p-4", "0xe.2fe743cp-4", "0xe.3d658fcp-4", "0xe.4a851c8p-4", "0xe.57483p-4", "0xe.63b1064p-4", "0xe.6fc1d2cp-4",
"0xe.7b7cbfp-4", "0xe.86e3eb8p-4", "0xe.91f96fp-4", "0xe.9cbf56cp-4", "0xe.a737a5cp-4", "0xe.b16455cp-4", "0xe.bb4756cp-4", "0xe.c4e28ecp-4",
"0xe.ce37da4p-4", "0xe.d7490cp-4", "0xe.e017ec8p-4", "0xe.e8a63b8p-4", "0xe.f0f5aecp-4", "0xe.f907f28p-4", "0xf.00dea98p-4", "0xf.087b6dp-4",
"0xf.0fdfcep-4", "0xf.170d53p-4", "0xf.1e057a4p-4", "0xf.24c9b9p-4", "0xf.2b5b7bcp-4", "0xf.31bc26p-4", "0xf.37ed13p-4","0xf.3def958p-4",
"0xf.43c4f8p-4", "0xf.496e7ccp-4", "0xf.4eed5e4p-4", "0xf.5442ce8p-4", "0xf.596ff88p-4", "0xf.5e75ff4p-4", "0xf.6355fe4p-4", "0xf.68110a4p-4",
"0xf.6ca8308p-4", "0xf.711c768p-4", "0xf.756edc4p-4", "0xf.79a05a4p-4", "0xf.7db1e24p-4", "0xf.81a45fcp-4", "0xf.8578b88p-4", "0xf.892fcbp-4",
"0xf.8cca70cp-4", "0xf.90497ccp-4", "0xf.93adbccp-4", "0xf.96f7f8p-4", "0xf.9a28f14p-4", "0xf.9d41654p-4", "0xf.a0420cp-4","0xf.a32b98p-4",
"0xf.a5feb7p-4", "0xf.a8bc118p-4", "0xf.ab644c4p-4", "0xf.adf806p-4", "0xf.b077da4p-4", "0xf.b2e45f4p-4", "0xf.b53e278p-4", "0xf.b785c1p-4",
"0xf.b9bbb64p-4", "0xf.bbe08dp-4", "0xf.bdf4c8p-4", "0xf.bff8e54p-4", "0xf.c1ed604p-4", "0xf.c3d2bp-4", "0xf.c5a9488p-4", "0xf.c7719acp-4",
"0xf.c92c138p-4", "0xf.cad91d4p-4", "0xf.cc791fp-4", "0xf.ce0c7ccp-4", "0xf.cf93978p-4", "0xf.d10ecdcp-4", "0xf.d27e7bp-4","0xf.d3e2f8p-4",
"0xf.d53c9acp-4", "0xf.d68bb74p-4", "0xf.d7d09ecp-4", "0xf.d90b9fcp-4", "0xf.da3d074p-4", "0xf.db651ecp-4", "0xf.dc842fp-4","0xf.dd9a7d4p-4",
"0xf.dea84dcp-4", "0xf.dfade24p-4", "0xf.e0ab7a4p-4", "0xf.e1a154p-4", "0xf.e28fab8p-4", "0xf.e376bb4p-4", "0xf.e456bb4p-4", "0xf.e52fe3p-4",
"0xf.e602674p-4", "0xf.e6ce7bcp-4", "0xf.e794528p-4", "0xf.e8541c4p-4", "0xf.e90e08p-4", "0xf.e9c2438p-4", "0xf.ea70fbp-4","0xf.eb1a598p-4",
"0xf.ebbe88cp-4", "0xf.ec5db1p-4", "0xf.ecf7f9cp-4", "0xf.ed8d89p-4", "0xf.ee1e834p-4", "0xf.eeab0c8p-4", "0xf.ef33478p-4", "0xf.efb756p-4",
"0xf.f037584p-4", "0xf.f0b36e4p-4", "0xf.f12bb68p-4", "0xf.f1a04ecp-4", "0xf.f21153cp-4", "0xf.f27ee18p-4", "0xf.f2e9134p-4", "0xf.f350034p-4",
"0xf.f3b3cbp-4", "0xf.f414834p-4", "0xf.f47243cp-4", "0xf.f4cd23cp-4", "0xf.f5253ap-4", "0xf.f57a9c8p-4", "0xf.f5cd6p-4","0xf.f61d994p-4",
"0xf.f66b5cp-4", "0xf.f6b6bbcp-4", "0xf.f6ffcb4p-4", "0xf.f7469c8p-4", "0xf.f78b414p-4", "0xf.f7cdca4p-4", "0xf.f80e488p-4", "0xf.f84ccb8p-4",
"0xf.f889634p-4", "0xf.f8c41e8p-4", "0xf.f8fd0cp-4", "0xf.f93439cp-4", "0xf.f969b5cp-4", "0xf.f99d8dp-4", "0xf.f9cfcccp-4", "0xf.fa00814p-4",
"0xf.fa2fb6cp-4", "0xf.fa5d78cp-4", "0xf.fa89d3p-4", "0xf.fab4d04p-4", "0xf.fade7b8p-4", "0xf.fb06decp-4", "0xf.fb2e048p-4", "0xf.fb53f64p-4",
"0xf.fb78bd4p-4", "0xf.fb9c63p-4", "0xf.fbbef04p-4", "0xf.fbe06dcp-4", "0xf.fc00e3cp-4", "0xf.fc205a4p-4", "0xf.fc3ed94p-4", "0xf.fc5c68p-4",
"0xf.fc790e8p-4", "0xf.fc94d34p-4", "0xf.fcafbdcp-4", "0xf.fcc9d44p-4", "0xf.fce31d8p-4", "0xf.fcfb9f8p-4", "0xf.fd1361p-4","0xf.fd2a674p-4",
"0xf.fd40b84p-4", "0xf.fd5659cp-4", "0xf.fd6b51p-4", "0xf.fd7fa3p-4", "0xf.fd93554p-4", "0xf.fda66c8p-4", "0xf.fdb8ed4p-4", "0xf.fdcadc8p-4",
"0xf.fddc3e8p-4", "0xf.fded17cp-4", "0xf.fdfd6c4p-4", "0xf.fe0d404p-4", "0xf.fe1c97cp-4", "0xf.fe2b764p-4", "0xf.fe39dfcp-4", "0xf.fe47d8p-4",
"0xf.fe5562p-4", "0xf.fe62818p-4", "0xf.fe6f39cp-4", "0xf.fe7b8dcp-4", "0xf.fe8780cp-4", "0xf.fe93158p-4", "0xf.fe9e4f4p-4", "0xf.fea9308p-4",
"0xf.feb3bc4p-4", "0xf.febdf4cp-4", "0xf.fec7ddp-4", "0xf.fed177p-4", "0xf.fedac58p-4", "0xf.fee3cacp-4", "0xf.feec89p-4","0xf.fef5028p-4",
"0xf.fefd39p-4", "0xf.ff052fp-4", "0xf.ff0ce64p-4", "0xf.ff1460cp-4", "0xf.ff1ba08p-4", "0xf.ff22a7p-4", "0xf.ff29764p-4", "0xf.ff300fcp-4",
"0xf.ff36758p-4", "0xf.ff3ca8cp-4", "0xf.ff42abp-4", "0xf.ff487e4p-4", "0xf.ff4e238p-4", "0xf.ff539c4p-4", "0xf.ff58eap-4","0xf.ff5e0dcp-4",
"0xf.ff63094p-4", "0xf.ff67dd8p-4", "0xf.ff6c8b8p-4", "0xf.ff7115p-4", "0xf.ff757a8p-4", "0xf.ff79bd8p-4", "0xf.ff7ddfp-4","0xf.ff81dfcp-4",
"0xf.ff85c1p-4", "0xf.ff8984p-4", "0xf.ff8d29p-4", "0xf.ff90b18p-4", "0xf.ff941e4p-4", "0xf.ff976fcp-4", "0xf.ff9aa74p-4", "0xf.ff9dc58p-4",
"0xf.ffa0cb4p-4", "0xf.ffa3b9p-4", "0xf.ffa68fcp-4", "0xf.ffa9504p-4", "0xf.ffabfbp-4", "0xf.ffae90cp-4", "0xf.ffb112p-4","0xf.ffb37fcp-4",
"0xf.ffb5da4p-4", "0xf.ffb8224p-4", "0xf.ffba584p-4", "0xf.ffbc7ccp-4", "0xf.ffbe908p-4", "0xf.ffc094p-4", "0xf.ffc2878p-4", "0xf.ffc46bcp-4",
"0xf.ffc641p-4", "0xf.ffc807cp-4", "0xf.ffc9c08p-4", "0xf.ffcb6bcp-4", "0xf.ffcd0ap-4", "0xf.ffce9b4p-4", "0xf.ffd0204p-4", "0xf.ffd1994p-4",
"0xf.ffd306cp-4", "0xf.ffd469p-4", "0xf.ffd5c04p-4", "0xf.ffd70dp-4", "0xf.ffd84fcp-4", "0xf.ffd9884p-4", "0xf.ffdab74p-4", "0xf.ffdbdccp-4",
"0xf.ffdcf98p-4", "0xf.ffde0d4p-4", "0xf.ffdf18cp-4", "0xf.ffe01cp-4", "0xf.ffe117p-4", "0xf.ffe20a8p-4", "0xf.ffe2f68p-4", "0xf.ffe3db4p-4",
"0xf.ffe4b8cp-4", "0xf.ffe58fcp-4", "0xf.ffe66p-4", "0xf.ffe729cp-4", "0xf.ffe7ed8p-4", "0xf.ffe8abp-4", "0xf.ffe962cp-4", "0xf.ffea14cp-4",
"0xf.ffeac18p-4", "0xf.ffeb68cp-4", "0xf.ffec0bp-4", "0xf.ffeca84p-4", "0xf.ffed408p-4", "0xf.ffedd44p-4", "0xf.ffee634p-4", "0xf.ffeeeep-4",
"0xf.ffef748p-4", "0xf.ffeff6cp-4", "0xf.fff075p-4", "0xf.fff0ef8p-4", "0xf.fff1664p-4", "0xf.fff1d94p-4", "0xf.fff248cp-4", "0xf.fff2b4cp-4",
"0xf.fff31d4p-4", "0xf.fff382cp-4", "0xf.fff3e54p-4", "0xf.fff4448p-4", "0xf.fff4a1p-4", "0xf.fff4fa8p-4", "0xf.fff5514p-4", "0xf.fff5a58p-4",
"0xf.fff5f7p-4", "0xf.fff646p-4", "0xf.fff692cp-4", "0xf.fff6ddp-4", "0xf.fff725p-4", "0xf.fff76acp-4", "0xf.fff7ae4p-4", "0xf.fff7efcp-4",
"0xf.fff82f4p-4", "0xf.fff86ccp-4", "0xf.fff8a88p-4", "0xf.fff8e24p-4", "0xf.fff91a4p-4", "0xf.fff950cp-4", "0xf.fff9854p-4", "0xf.fff9b84p-4",
"0xf.fff9e9cp-4", "0xf.fffa19cp-4", "0xf.fffa484p-4", "0xf.fffa754p-4", "0xf.fffaa1p-4", "0xf.fffacb4p-4", "0xf.fffaf44p-4", "0xf.fffb1cp-4",
"0xf.fffb428p-4", "0xf.fffb67cp-4", "0xf.fffb8cp-4", "0xf.fffbafp-4", "0xf.fffbd1p-4", "0xf.fffbf2p-4", "0xf.fffc12p-4","0xf.fffc31p-4",
"0xf.fffc4fp-4", "0xf.fffc6cp-4", "0xf.fffc884p-4", "0xf.fffca38p-4", "0xf.fffcbep-4", "0xf.fffcd7cp-4", "0xf.fffcf08p-4", "0xf.fffd088p-4",
"0xf.fffd2p-4", "0xf.fffd368p-4", "0xf.fffd4c8p-4", "0xf.fffd61cp-4", "0xf.fffd768p-4", "0xf.fffd8a8p-4", "0xf.fffd9dcp-4", "0xf.fffdb08p-4",
"0xf.fffdc2cp-4", "0xf.fffdd48p-4", "0xf.fffde58p-4", "0xf.fffdf6p-4", "0xf.fffe064p-4", "0xf.fffe15cp-4", "0xf.fffe24cp-4", "0xf.fffe338p-4",
"0xf.fffe418p-4", "0xf.fffe4f4p-4", "0xf.fffe5c8p-4", "0xf.fffe698p-4", "0xf.fffe76p-4", "0xf.fffe824p-4", "0xf.fffe8ep-4","0xf.fffe994p-4",
"0xf.fffea44p-4", "0xf.fffeafp-4", "0xf.fffeb98p-4", "0xf.fffec38p-4", "0xf.fffecd4p-4", "0xf.fffed68p-4", "0xf.fffedfcp-4", "0xf.fffee8cp-4",
"0xf.fffef14p-4", "0xf.fffef98p-4", "0xf.ffff01cp-4", "0xf.ffff098p-4", "0xf.ffff11p-4", "0xf.ffff188p-4", "0xf.ffff1f8p-4", "0xf.ffff268p-4",
"0xf.ffff2dp-4", "0xf.ffff338p-4", "0xf.ffff3ap-4", "0xf.ffff4p-4", "0xf.ffff46p-4", "0xf.ffff4bcp-4", "0xf.ffff514p-4", "0xf.ffff568p-4",
"0xf.ffff5bcp-4", "0xf.ffff60cp-4", "0xf.ffff65cp-4", "0xf.ffff6a8p-4", "0xf.ffff6fp-4", "0xf.ffff738p-4", "0xf.ffff77cp-4", "0xf.ffff7cp-4",
"0xf.ffff8p-4", "0xf.ffff84p-4", "0xf.ffff87cp-4", "0xf.ffff8b8p-4", "0xf.ffff8f4p-4", "0xf.ffff928p-4", "0xf.ffff96p-4", "0xf.ffff994p-4",
"0xf.ffff9c8p-4", "0xf.ffff9f8p-4", "0xf.ffffa28p-4", "0xf.ffffa54p-4", "0xf.ffffa8p-4", "0xf.ffffaacp-4", "0xf.ffffad8p-4", "0xf.ffffbp-4",
"0xf.ffffb28p-4", "0xf.ffffb4cp-4", "0xf.ffffb7p-4", "0xf.ffffb94p-4", "0xf.ffffbb8p-4", "0xf.ffffbdcp-4", "0xf.ffffbfcp-4", "0xf.ffffc1cp-4",
};
//  K1  estimated  4  integer bits.
static const ap_fixed< 26 , 5 > second_tanh_K1 [ 512 ] = {
"0x8.001758p0", "0x7.ff978p0", "0x7.fe17b8p0", "0x7.fb98f8p0", "0x7.f81c68p0","0x7.f3a3fp0", "0x7.ee3188p0", "0x7.e7c808p0",
"0x7.e06abp0", "0x7.d81cd8p0", "0x7.cee2d8p0", "0x7.c4c0cp0", "0x7.b9bcp0", "0x7.add948p0", "0x7.a11e7p0", "0x7.93918p0",
"0x7.85389p0", "0x7.761a58p0", "0x7.663da8p0", "0x7.55a97p0", "0x7.446538p0","0x7.327858p0", "0x7.1fea78p0", "0x7.0cc388p0",
"0x6.f90b5p0", "0x6.e4ca18p0", "0x6.d007b8p0", "0x6.bacc6p0", "0x6.a5205p0", "0x6.8f0bb8p0", "0x6.7896ap0", "0x6.61c95p0",
"0x6.4aab9p0", "0x6.33459p0", "0x6.1b9f08p0", "0x6.03bf98p0", "0x5.ebaf28p0","0x5.d37518p0", "0x5.bb187p0", "0x5.a2a068p0",
"0x5.8a141p0", "0x5.717ap0", "0x5.58d8cp0", "0x5.403698p0", "0x5.2799bp0", "0x5.0f07fp0", "0x4.f686ap0", "0x4.de1b8p0",
"0x4.c5cbap0", "0x4.ad9bcp0", "0x4.9590bp0", "0x4.7daefp0", "0x4.65fa6p0", "0x4.4e7768p0", "0x4.372958p0", "0x4.2013ep0",
"0x4.093a2p0", "0x3.f29f58p0", "0x3.dc4608p0", "0x3.c63128p0", "0x3.b062bp0", "0x3.9add38p0", "0x3.85a268p0", "0x3.70b418p0",
"0x3.5c1418p0", "0x3.47c38p0", "0x3.33c3cp0", "0x3.2015f8p0", "0x3.0cbafp0", "0x2.f9b38p0", "0x2.e70048p0", "0x2.d4a198p0",
"0x2.c2981p0", "0x2.b0e3b8p0", "0x2.9f84a8p0", "0x2.8e7ae8p0", "0x2.7dc678p0","0x2.6d66d8p0", "0x2.5d5bfp0", "0x2.4da548p0",
"0x2.3e4258p0", "0x2.2f3298p0", "0x2.207588p0", "0x2.120a2p0", "0x2.03efc8p0","0x1.f625ep0", "0x1.e8ab1p0", "0x1.db7efp0",
"0x1.cea02p0", "0x1.c20ddp0", "0x1.b5c718p0", "0x1.a9ca88p0", "0x1.9e1758p0","0x1.92ac28p0", "0x1.878808p0", "0x1.7ca9a8p0",
"0x1.72101p0", "0x1.67b9d8p0", "0x1.5da5e8p0", "0x1.53d2dp0", "0x1.4a3fa8p0","0x1.40eb28p0", "0x1.37d3f8p0", "0x1.2ef8f8p0",
"0x1.2658ep0", "0x1.1df268p0", "0x1.15c4a8p0", "0x1.0dce28p0", "0x1.060dcp0", "0xf.e823p-4", "0xf.72a8p-4", "0xf.0058p-4",
"0xe.911dp-4", "0xe.24e8p-4", "0xd.bba78p-4", "0xd.5548p-4", "0xc.f1b7p-4", "0xc.90e6p-4", "0xc.32c28p-4", "0xb.d73c8p-4",
"0xb.7e43p-4", "0xb.27c58p-4", "0xa.d3b38p-4", "0xa.82008p-4", "0xa.329bp-4", "0x9.e574p-4", "0x9.9a7fp-4", "0x9.51a9p-4",
"0x9.0ae5p-4", "0x8.c62a8p-4", "0x8.8365p-4", "0x8.42898p-4", "0x8.038c8p-4","0x7.c662p-4", "0x7.8af88p-4", "0x7.514ap-4",
"0x7.1946p-4", "0x6.e2e4p-4", "0x6.ae14p-4", "0x6.7ad18p-4", "0x6.490c8p-4","0x6.18bd8p-4", "0x5.e9d78p-4", "0x5.bc52p-4",
"0x5.90228p-4", "0x5.65428p-4", "0x5.3ba2p-4", "0x5.133fp-4", "0x4.ec0bp-4", "0x4.c602p-4", "0x4.a1188p-4", "0x4.7d498p-4",
"0x4.5a878p-4", "0x4.38dp-4", "0x4.1817p-4", "0x3.f8598p-4", "0x3.d98d8p-4","0x3.bbadp-4", "0x3.9eb28p-4", "0x3.82928p-4",
"0x3.674dp-4", "0x3.4cd7p-4", "0x3.332c8p-4", "0x3.1a47p-4", "0x3.02218p-4","0x2.eab5p-4", "0x2.d3fc8p-4", "0x2.bdf28p-4",
"0x2.a895p-4", "0x2.93dbp-4", "0x2.7fc08p-4", "0x2.6c428p-4", "0x2.59588p-4","0x2.47038p-4", "0x2.353a8p-4", "0x2.23fdp-4",
"0x2.13438p-4", "0x2.030bp-4", "0x1.f3528p-4", "0x1.e413p-4", "0x1.d54a8p-4","0x1.c6f2p-4", "0x1.b90c8p-4", "0x1.ab9p-4",
"0x1.9e7dp-4", "0x1.91d1p-4", "0x1.85878p-4", "0x1.799d8p-4", "0x1.6e1p-4", "0x1.62dc8p-4", "0x1.58008p-4", "0x1.4d79p-4",
"0x1.4343p-4", "0x1.395d8p-4", "0x1.2fc5p-4", "0x1.2676p-4", "0x1.1d71p-4", "0x1.14b3p-4", "0x1.0c39p-4", "0x1.04008p-4",
"0xf.c09p-8", "0xf.44e8p-8", "0xe.cd1p-8", "0xe.58ep-8", "0xd.e85p-8", "0xd.7b3p-8", "0xd.1158p-8", "0xc.aab8p-8",
"0xc.473p-8", "0xb.e6b8p-8", "0xb.8948p-8", "0xb.2ebp-8", "0xa.d6ep-8", "0xa.81a8p-8", "0xa.2f2p-8", "0x9.df2p-8",
"0x9.919p-8", "0x9.4668p-8", "0x8.fd8p-8", "0x8.b6ep-8", "0x8.725p-8", "0x8.3p-8", "0x7.ef88p-8", "0x7.b138p-8",
"0x7.74bp-8", "0x7.3a1p-8", "0x7.013p-8", "0x6.ca3p-8", "0x6.94cp-8", "0x6.6118p-8", "0x6.2eep-8", "0x5.fe4p-8",
"0x5.cf08p-8", "0x5.a17p-8", "0x5.7518p-8", "0x5.4a4p-8", "0x5.209p-8", "0x4.f85p-8", "0x4.d12p-8", "0x4.ab3p-8",
"0x4.8688p-8", "0x4.62fp-8", "0x4.407p-8", "0x4.1ef8p-8", "0x3.fe8p-8", "0x3.df18p-8", "0x3.c098p-8", "0x3.a33p-8",
"0x3.8678p-8", "0x3.6ac8p-8", "0x3.4fc8p-8", "0x3.35c8p-8", "0x3.1c78p-8", "0x3.041p-8", "0x2.ec38p-8", "0x2.d54p-8",
"0x2.bfp-8", "0x2.a96p-8", "0x2.946p-8", "0x2.802p-8", "0x2.6c78p-8", "0x2.595p-8", "0x2.46ep-8", "0x2.34fp-8",
"0x2.239p-8", "0x2.12b8p-8", "0x2.0268p-8", "0x1.f2ap-8", "0x1.e338p-8", "0x1.d468p-8", "0x1.c608p-8", "0x1.b7f8p-8",
"0x1.aa78p-8", "0x1.9d58p-8", "0x1.9098p-8", "0x1.8448p-8", "0x1.786p-8", "0x1.6cd8p-8", "0x1.61ap-8", "0x1.56cp-8",
"0x1.4c3p-8", "0x1.42p-8", "0x1.381p-8", "0x1.2e88p-8", "0x1.2538p-8", "0x1.1c3p-8", "0x1.1368p-8", "0x1.0ae8p-8",
"0x1.02cp-8", "0xf.ac8p-12", "0xf.31p-12", "0xe.b98p-12", "0xe.448p-12", "0xd.d48p-12", "0xd.678p-12", "0xc.fe8p-12",
"0xc.97p-12", "0xc.348p-12", "0xb.d5p-12", "0xb.77p-12", "0xb.1c8p-12", "0xa.c5p-12", "0xa.7p-12", "0xa.1fp-12",
"0x9.ce8p-12", "0x9.818p-12", "0x9.378p-12", "0x8.eep-12", "0x8.a8p-12", "0x8.638p-12", "0x8.21p-12", "0x7.e28p-12",
"0x7.a5p-12", "0x7.67p-12", "0x7.2ep-12", "0x6.f48p-12", "0x6.bd8p-12", "0x6.8ap-12", "0x6.568p-12", "0x6.24p-12",
"0x5.f3p-12", "0x5.c5p-12", "0x5.97p-12", "0x5.6a8p-12", "0x5.4p-12", "0x5.17p-12", "0x4.ef8p-12", "0x4.c8p-12",
"0x4.a28p-12", "0x4.7d8p-12", "0x4.5bp-12", "0x4.398p-12", "0x4.178p-12", "0x3.f68p-12", "0x3.d7p-12", "0x3.b8p-12",
"0x3.9bp-12", "0x3.7fp-12", "0x3.64p-12", "0x3.49p-12", "0x3.2e8p-12", "0x3.168p-12", "0x2.ffp-12", "0x2.e78p-12",
"0x2.dp-12", "0x2.bap-12", "0x2.a5p-12", "0x2.908p-12", "0x2.7ap-12", "0x2.67p-12", "0x2.54p-12", "0x2.43p-12",
"0x2.308p-12", "0x2.2p-12", "0x2.0ep-12", "0x1.fd8p-12", "0x1.efp-12", "0x1.df8p-12", "0x1.dp-12", "0x1.c2p-12",
"0x1.b5p-12", "0x1.a68p-12", "0x1.998p-12", "0x1.8dp-12", "0x1.8p-12", "0x1.75p-12", "0x1.6ap-12", "0x1.5f8p-12",
"0x1.54p-12", "0x1.4ap-12", "0x1.3fp-12", "0x1.35p-12", "0x1.2cp-12", "0x1.228p-12", "0x1.1a8p-12", "0x1.118p-12",
"0x1.088p-12", "0x1.01p-12", "0xf.98p-16", "0xf.1p-16", "0xe.88p-16", "0xe.18p-16", "0xd.a8p-16", "0xd.38p-16",
"0xc.f8p-16", "0xc.88p-16", "0xc.18p-16", "0xb.cp-16", "0xb.6p-16", "0xb.1p-16", "0xa.b8p-16", "0xa.58p-16",
"0xa.1p-16", "0x9.cp-16", "0x9.6p-16", "0x9.1p-16", "0x8.c8p-16", "0x8.88p-16", "0x8.5p-16", "0x8.1p-16",
"0x7.d8p-16", "0x7.ap-16", "0x7.58p-16", "0x7.28p-16", "0x6.fp-16", "0x6.bp-16", "0x6.88p-16", "0x6.58p-16",
"0x6.2p-16", "0x5.e8p-16", "0x5.b8p-16", "0x5.88p-16", "0x5.58p-16", "0x5.3p-16", "0x5.08p-16", "0x4.ep-16",
"0x4.cp-16", "0x4.ap-16", "0x4.78p-16", "0x4.6p-16", "0x4.38p-16", "0x4.1p-16", "0x3.e8p-16", "0x3.cp-16",
"0x3.a8p-16", "0x3.9p-16", "0x3.7p-16", "0x3.58p-16", "0x3.38p-16", "0x3.18p-16", "0x3.18p-16", "0x3.p-16",
"0x2.ep-16", "0x2.d8p-16", "0x2.cp-16", "0x2.a8p-16", "0x2.8p-16", "0x2.7p-16", "0x2.7p-16", "0x2.58p-16",
"0x2.4p-16", "0x2.2p-16", "0x2.2p-16", "0x2.18p-16", "0x1.e8p-16", "0x1.e8p-16", "0x1.d8p-16", "0x1.c8p-16",
"0x1.c8p-16", "0x1.cp-16", "0x1.bp-16", "0x1.98p-16", "0x1.88p-16", "0x1.7p-16", "0x1.68p-16", "0x1.7p-16",
"0x1.68p-16", "0x1.5p-16", "0x1.38p-16", "0x1.3p-16", "0x1.2p-16", "0x1.38p-16", "0x1.2p-16", "0x1.08p-16",
"0x1.1p-16", "0x1.18p-16", "0xf.p-20", "0xf.8p-20", "0xf.p-20", "0xe.p-20", "0xe.p-20", "0xc.8p-20",
"0xe.8p-20", "0xd.8p-20", "0xb.8p-20", "0xb.8p-20", "0xa.8p-20", "0xa.p-20", "0xa.8p-20", "0xb.p-20",
"0xa.8p-20", "0xa.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.8p-20", "0x9.p-20",
"0x9.p-20", "0x8.8p-20", "0x8.8p-20", "0x8.p-20", "0x6.8p-20", "0x7.8p-20", "0x6.8p-20", "0x6.p-20",
"0x5.8p-20", "0x5.8p-20", "0x5.8p-20", "0x6.8p-20", "0x6.8p-20", "0x5.8p-20", "0x4.8p-20", "0x4.8p-20",
"0x4.8p-20", "0x5.8p-20", "0x6.p-20", "0x5.8p-20", "0x4.p-20", "0x3.p-20", "0x3.8p-20", "0x3.8p-20",
};
//  K2  estimated  5  integer bits.
static const ap_fixed< 18 , 6 > second_tanh_K2 [ 512 ] = {
"-0x7.ebp-4", "-0x1.7ecp0", "-0x2.7dbp0", "-0x3.7b8p0", "-0x4.777p0", "-0x5.717p0", "-0x6.688p0", "-0x7.5c6p0",
"-0x8.4cep0", "-0x9.392p0", "-0xa.213p0", "-0xb.03ep0", "-0xb.e2p0", "-0xc.bap0", "-0xd.8c2p0", "-0xe.582p0",
"-0xf.1d6p0", "-0xf.dbep0", "-0x1.0936p4", "-0x1.1436p4", "-0x1.1ec1p4", "-0x1.28dp4", "-0x1.3262p4", "-0x1.3b76p4",
"-0x1.4406p4", "-0x1.4c1ap4", "-0x1.53a9p4", "-0x1.5ab4p4", "-0x1.613ep4", "-0x1.6746p4", "-0x1.6ccbp4", "-0x1.71d2p4",
"-0x1.7656p4", "-0x1.7a6p4", "-0x1.7decp4", "-0x1.80fbp4", "-0x1.8398p4", "-0x1.85c3p4", "-0x1.8778p4", "-0x1.88bdp4",
"-0x1.8999p4", "-0x1.8a0cp4", "-0x1.8a1ap4", "-0x1.89c6p4", "-0x1.8916p4", "-0x1.880fp4", "-0x1.86abp4", "-0x1.84f8p4",
"-0x1.82f8p4", "-0x1.80abp4", "-0x1.7e18p4", "-0x1.7b44p4", "-0x1.782bp4", "-0x1.74dep4", "-0x1.7155p4", "-0x1.6d98p4",
"-0x1.69a9p4", "-0x1.6591p4", "-0x1.614bp4", "-0x1.5ce5p4", "-0x1.5855p4", "-0x1.53acp4", "-0x1.4ee3p4", "-0x1.4ap4",
"-0x1.450ap4", "-0x1.3ffbp4", "-0x1.3adcp4", "-0x1.35b1p4", "-0x1.3078p4", "-0x1.2b35p4", "-0x1.25ecp4", "-0x1.2099p4",
"-0x1.1b46p4", "-0x1.15f2p4", "-0x1.109cp4", "-0x1.0b48p4", "-0x1.05fap4", "-0x1.00aep4", "-0xf.b6bp0", "-0xf.62fp0",
"-0xf.0fcp0", "-0xe.bd3p0", "-0xe.6b9p0", "-0xe.1a6p0", "-0xd.ca1p0", "-0xd.7afp0", "-0xd.2c3p0", "-0xc.defp0",
"-0xc.925p0", "-0xc.46dp0", "-0xb.fccp0", "-0xb.b36p0", "-0xb.6b5p0", "-0xb.243p0", "-0xa.de6p0", "-0xa.99ap0",
"-0xa.566p0", "-0xa.142p0", "-0x9.d34p0", "-0x9.933p0", "-0x9.549p0", "-0x9.175p0", "-0x8.db2p0", "-0x8.a04p0",
"-0x8.668p0", "-0x8.2ddp0", "-0x7.f6bp0", "-0x7.c0ap0", "-0x7.8bbp0", "-0x7.57bp0", "-0x7.252p0", "-0x6.f3cp0",
"-0x6.c36p0", "-0x6.942p0", "-0x6.663p0", "-0x6.394p0", "-0x6.0d3p0", "-0x5.e26p0", "-0x5.b88p0", "-0x5.8fcp0",
"-0x5.68p0", "-0x5.412p0", "-0x5.1b2p0", "-0x4.f65p0", "-0x4.d27p0", "-0x4.af7p0", "-0x4.8d9p0", "-0x4.6c4p0",
"-0x4.4bcp0", "-0x4.2c8p0", "-0x4.0dcp0", "-0x3.efdp0", "-0x3.d2cp0", "-0x3.b6bp0", "-0x3.9bp0", "-0x3.806p0",
"-0x3.664p0", "-0x3.4d1p0", "-0x3.343p0", "-0x3.1c6p0", "-0x3.05p0", "-0x2.ee7p0", "-0x2.d86p0", "-0x2.c2fp0",
"-0x2.ae1p0", "-0x2.9a1p0", "-0x2.863p0", "-0x2.734p0", "-0x2.608p0", "-0x2.4e9p0", "-0x2.3dp0", "-0x2.2c4p0",
"-0x2.1b9p0", "-0x2.0bap0", "-0x1.fbep0", "-0x1.eccp0", "-0x1.de1p0", "-0x1.cfcp0", "-0x1.c21p0", "-0x1.b46p0",
"-0x1.a77p0", "-0x1.9abp0", "-0x1.8e6p0", "-0x1.827p0", "-0x1.76ep0", "-0x1.6b9p0", "-0x1.609p0", "-0x1.55dp0",
"-0x1.4bbp0", "-0x1.41bp0", "-0x1.38p0", "-0x1.2ebp0", "-0x1.256p0", "-0x1.1c9p0", "-0x1.13fp0", "-0x1.0bbp0",
"-0x1.038p0", "-0xf.b8p-4", "-0xf.4p-4", "-0xe.cap-4", "-0xe.59p-4", "-0xd.e6p-4", "-0xd.7dp-4", "-0xd.12p-4",
"-0xc.aap-4", "-0xc.49p-4", "-0xb.eap-4", "-0xb.8ep-4", "-0xb.34p-4", "-0xa.ddp-4", "-0xa.89p-4", "-0xa.37p-4",
"-0x9.e6p-4", "-0x9.99p-4", "-0x9.4fp-4", "-0x9.05p-4", "-0x8.bep-4", "-0x8.7bp-4", "-0x8.39p-4", "-0x7.f9p-4",
"-0x7.bbp-4", "-0x7.7dp-4", "-0x7.42p-4", "-0x7.09p-4", "-0x6.d4p-4", "-0x6.ap-4", "-0x6.6cp-4", "-0x6.39p-4",
"-0x6.06p-4", "-0x5.d6p-4", "-0x5.aap-4", "-0x5.7dp-4", "-0x5.53p-4", "-0x5.28p-4", "-0x5.p-4", "-0x4.dap-4",
"-0x4.b3p-4", "-0x4.8fp-4", "-0x4.6bp-4", "-0x4.4ap-4", "-0x4.26p-4", "-0x4.08p-4", "-0x3.e5p-4", "-0x3.c9p-4",
"-0x3.aap-4", "-0x3.8dp-4", "-0x3.6fp-4", "-0x3.57p-4", "-0x3.3bp-4", "-0x3.25p-4", "-0x3.0bp-4", "-0x2.f3p-4",
"-0x2.d9p-4", "-0x2.c6p-4", "-0x2.aep-4", "-0x2.9cp-4", "-0x2.85p-4", "-0x2.74p-4", "-0x2.5ep-4", "-0x2.4ap-4",
"-0x2.3ap-4", "-0x2.29p-4", "-0x2.18p-4", "-0x2.07p-4", "-0x1.f6p-4", "-0x1.e8p-4", "-0x1.d8p-4", "-0x1.cdp-4",
"-0x1.bcp-4", "-0x1.bp-4", "-0x1.9fp-4", "-0x1.95p-4", "-0x1.87p-4", "-0x1.7dp-4", "-0x1.6ep-4", "-0x1.64p-4",
"-0x1.5ap-4", "-0x1.5p-4", "-0x1.44p-4", "-0x1.3bp-4", "-0x1.33p-4", "-0x1.27p-4", "-0x1.1fp-4", "-0x1.16p-4",
"-0x1.0dp-4", "-0x1.05p-4", "-0xf.dp-8", "-0xf.7p-8", "-0xe.dp-8", "-0xe.7p-8", "-0xe.1p-8", "-0xd.7p-8",
"-0xd.1p-8", "-0xc.ap-8", "-0xc.3p-8", "-0xb.dp-8", "-0xb.9p-8", "-0xb.4p-8", "-0xa.fp-8", "-0xa.9p-8",
"-0xa.4p-8", "-0x9.fp-8", "-0x9.ap-8", "-0x9.7p-8", "-0x9.2p-8", "-0x8.dp-8", "-0x8.7p-8", "-0x8.3p-8",
"-0x8.p-8", "-0x7.cp-8", "-0x7.8p-8", "-0x7.4p-8", "-0x6.fp-8", "-0x6.cp-8", "-0x6.9p-8", "-0x6.6p-8",
"-0x6.1p-8", "-0x6.p-8", "-0x5.dp-8", "-0x5.9p-8", "-0x5.6p-8", "-0x5.3p-8", "-0x5.1p-8", "-0x5.p-8",
"-0x4.cp-8", "-0x4.bp-8", "-0x4.9p-8", "-0x4.6p-8", "-0x4.4p-8", "-0x4.1p-8", "-0x3.fp-8", "-0x4.p-8",
"-0x3.fp-8", "-0x3.ap-8", "-0x3.ap-8", "-0x3.6p-8", "-0x3.5p-8", "-0x3.6p-8", "-0x3.4p-8", "-0x3.1p-8",
"-0x2.fp-8", "-0x2.fp-8", "-0x2.cp-8", "-0x2.ap-8", "-0x2.9p-8", "-0x2.9p-8", "-0x2.8p-8", "-0x2.6p-8",
"-0x2.5p-8", "-0x2.3p-8", "-0x2.4p-8", "-0x2.4p-8", "-0x2.1p-8", "-0x1.fp-8", "-0x1.dp-8", "-0x1.bp-8",
"-0x1.bp-8", "-0x1.bp-8", "-0x1.bp-8", "-0x1.9p-8", "-0x1.8p-8", "-0x1.9p-8", "-0x1.ap-8", "-0x1.9p-8",
"-0x1.7p-8", "-0x1.7p-8", "-0x1.7p-8", "-0x1.7p-8", "-0x1.2p-8", "-0x1.2p-8", "-0x1.1p-8", "-0x1.3p-8",
"-0x1.2p-8", "-0x1.2p-8", "-0xf.p-12", "-0xf.p-12", "-0x1.p-8", "-0xf.p-12", "-0xd.p-12", "-0xe.p-12",
"-0xe.p-12", "-0xc.p-12", "-0xc.p-12", "-0xb.p-12", "-0xa.p-12", "-0xb.p-12", "-0xc.p-12", "-0xc.p-12",
"-0xb.p-12", "-0xb.p-12", "-0x9.p-12", "-0x9.p-12", "-0x9.p-12", "-0x9.p-12", "-0xa.p-12", "-0x9.p-12",
"-0x8.p-12", "-0x9.p-12", "-0x9.p-12", "-0x7.p-12", "-0x5.p-12", "-0x5.p-12", "-0x5.p-12", "-0x4.p-12",
"-0x9.p-12", "-0x7.p-12", "-0x6.p-12", "-0x6.p-12", "-0x6.p-12", "-0x7.p-12", "-0x6.p-12", "-0x5.p-12",
"-0x6.p-12", "-0x5.p-12", "-0x3.p-12", "-0x2.p-12", "-0x2.p-12", "-0x3.p-12", "-0x4.p-12", "-0x4.p-12",
"-0x5.p-12", "-0x5.p-12", "-0x4.p-12", "-0x5.p-12", "-0x4.p-12", "-0x4.p-12", "-0x5.p-12", "-0x5.p-12",
"-0x4.p-12", "-0x3.p-12", "-0x3.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12",
"-0x3.p-12", "-0x3.p-12", "-0x3.p-12", "-0x4.p-12", "-0x3.p-12", "-0x2.p-12", "-0x1.p-12", "0",
"-0x1.p-12", "-0x1.p-12", "-0x1.p-12", "-0x1.p-12", "0", "0", "-0x3.p-12", "-0x2.p-12",
"-0x2.p-12", "-0x3.p-12", "-0x3.p-12", "-0x2.p-12", "0", "-0x1.p-12", "-0x3.p-12", "-0x2.p-12",
"-0x1.p-12", "0", "-0x2.p-12", "-0x3.p-12", "0x1.p-12", "-0x1.p-12", "0", "-0x1.p-12",
"-0x2.p-12", "-0x3.p-12", "-0x2.p-12", "-0x1.p-12", "0", "0x1.p-12", "0", "-0x2.p-12",
"-0x2.p-12", "0", "0x1.p-12", "0x1.p-12", "0x2.p-12", "-0x2.p-12", "0", "0x1.p-12",
"-0x1.p-12", "-0x3.p-12", "0x1.p-12", "-0x1.p-12", "0", "0", "0", "0x2.p-12",
"-0x3.p-12", "-0x1.p-12", "0x1.p-12", "0x1.p-12", "0x2.p-12", "0x2.p-12", "0", "-0x1.p-12",
"-0x1.p-12", "-0x1.p-12", "0", "-0x1.p-12", "-0x1.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12",
"-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "-0x2.p-12", "0", "-0x1.p-12", "0", "0x1.p-12",
"0x1.p-12", "0x1.p-12", "0", "-0x2.p-12", "-0x2.p-12", "0", "0x1.p-12", "0x1.p-12",
"0", "-0x2.p-12", "-0x3.p-12", "-0x2.p-12", "0x1.p-12", "0x2.p-12", "0x1.p-12", "0",
};



// Tables for f= atanh(x)
//  K0  estimated  3  integer bits.
static const ap_fixed< 32 , 4 > second_atanh_K0 [ 256 ] = {
"0", "0x1.00005p-8", "0x2.0002bp-8", "0x3.0009p-8", "0x4.00156p-8", "0x5.0029bp-8", "0x6.00481p-8", "0x7.00726p-8",
"0x8.00aacp-8", "0x9.00f33p-8", "0xa.014dap-8", "0xb.01bc3p-8", "0xc.0240cp-8", "0xd.02dd8p-8", "0xe.03945p-8", "0xf.04675p-8",
"0x1.005589p-4", "0x1.1066ap-4", "0x1.2079ddp-4", "0x1.308f5fp-4", "0x1.40a748p-4", "0x1.50c1b9p-4", "0x1.60ded2p-4", "0x1.70feb7p-4",
"0x1.812187p-4", "0x1.914766p-4", "0x1.a17073p-4", "0x1.b19cd2p-4", "0x1.c1cca5p-4", "0x1.d2000ep-4", "0x1.e2372ep-4", "0x1.f2722ap-4",
"0x2.02b124p-4", "0x2.12f43ep-4", "0x2.233b9cp-4", "0x2.338762p-4", "0x2.43d7b3p-4", "0x2.542cb3p-4", "0x2.648686p-4", "0x2.74e55p-4",
"0x2.854936p-4", "0x2.95b25ep-4", "0x2.a620ebp-4", "0x2.b69504p-4", "0x2.c70ecdp-4", "0x2.d78e6ep-4", "0x2.e8140cp-4", "0x2.f89fcep-4",
"0x3.0931dbp-4", "0x3.19ca5ap-4", "0x3.2a6972p-4", "0x3.3b0f4cp-4", "0x3.4bbc0fp-4", "0x3.5c6fe5p-4", "0x3.6d2af7p-4", "0x3.7ded6cp-4",
"0x3.8eb771p-4", "0x3.9f892ep-4", "0x3.b062cep-4", "0x3.c1447dp-4", "0x3.d22e65p-4", "0x3.e320b4p-4", "0x3.f41b94p-4", "0x4.051f33p-4",
"0x4.162bbfp-4", "0x4.274165p-4", "0x4.386053p-4", "0x4.4988b9p-4", "0x4.5abac6p-4", "0x4.6bf6aap-4", "0x4.7d3c95p-4", "0x4.8e8cb9p-4",
"0x4.9fe748p-4", "0x4.b14c73p-4", "0x4.c2bc6fp-4", "0x4.d4376ep-4", "0x4.e5bda4p-4", "0x4.f74f48p-4", "0x5.08ec8ep-4", "0x5.1a95aep-4",
"0x5.2c4addp-4", "0x5.3e0c55p-4", "0x5.4fda4ep-4", "0x5.61b501p-4", "0x5.739ca8p-4", "0x5.85918p-4", "0x5.9793c3p-4", "0x5.a9a3afp-4",
"0x5.bbc182p-4", "0x5.cded7ap-4", "0x5.e027d7p-4", "0x5.f270dap-4", "0x6.04c8c4p-4", "0x6.172fd8p-4", "0x6.29a65ap-4", "0x6.3c2c8fp-4",
"0x6.4ec2bcp-4", "0x6.616929p-4", "0x6.74201ep-4", "0x6.86e7e4p-4", "0x6.99c0c7p-4", "0x6.acab12p-4", "0x6.bfa713p-4", "0x6.d2b518p-4",
"0x6.e5d571p-4", "0x6.f9087p-4", "0x7.0c4e68p-4", "0x7.1fa7adp-4", "0x7.331495p-4", "0x7.469577p-4", "0x7.5a2aaep-4", "0x7.6dd493p-4",
"0x7.819384p-4", "0x7.9567dep-4", "0x7.a95202p-4", "0x7.bd5253p-4", "0x7.d16933p-4", "0x7.e5970ap-4", "0x7.f9dc3fp-4", "0x8.0e393cp-4",
"0x8.22ae6ep-4", "0x8.373c44p-4", "0x8.4be32dp-4", "0x8.60a39fp-4", "0x8.757e0ep-4", "0x8.8a72f2p-4", "0x8.9f82c8p-4", "0x8.b4ae0cp-4",
"0x8.c9f53ep-4", "0x8.df58e3p-4", "0x8.f4d97fp-4", "0x9.0a779ep-4", "0x9.2033cap-4", "0x9.360e94p-4", "0x9.4c088fp-4", "0x9.622252p-4",
"0x9.785c76p-4", "0x9.8eb799p-4", "0x9.a5345ep-4", "0x9.bbd36ap-4", "0x9.d29567p-4", "0x9.e97b03p-4", "0xa.0084f1p-4", "0xa.17b3e7p-4",
"0xa.2f08a2p-4", "0xa.4683e2p-4", "0xa.5e266dp-4", "0xa.75f10fp-4", "0xa.8de497p-4", "0xa.a601ddp-4", "0xa.be49bcp-4", "0xa.d6bd17p-4",
"0xa.ef5cd5p-4", "0xb.0829e8p-4", "0xb.212544p-4", "0xb.3a4fe6p-4", "0xb.53aad4p-4", "0xb.6d371ap-4", "0xb.86f5ccp-4", "0xb.a0e807p-4",
"0xb.bb0eefp-4", "0xb.d56bb5p-4", "0xb.efff9p-4", "0xc.0acbc1p-4", "0xc.25d194p-4", "0xc.411262p-4", "0xc.5c8f8bp-4", "0xc.784a7dp-4",
"0xc.9444b3p-4", "0xc.b07fb3p-4", "0xc.ccfd12p-4", "0xc.e9be72p-4", "0xd.06c583p-4", "0xd.241408p-4", "0xd.41abcfp-4", "0xd.5f8ebbp-4",
"0xd.7dbebfp-4", "0xd.9c3de1p-4", "0xd.bb0e3ap-4", "0xd.da31fap-4", "0xd.f9ab63p-4", "0xe.197cd2p-4", "0xe.39a8b9p-4", "0xe.5a31a5p-4",
"0xe.7b1a3dp-4", "0xe.9c6545p-4", "0xe.be159ep-4", "0xe.e02e4bp-4", "0xf.02b26ep-4", "0xf.25a54ep-4", "0xf.490a56p-4", "0xf.6ce51cp-4",
"0xf.91395dp-4", "0xf.b60b05p-4", "0xf.db5e3p-4", "0x1.001372dp0", "0x1.0279a82p0", "0x1.04e8cedp0", "0x1.076136dp0", "0x1.09e3343p0",
"0x1.0c6f1f4p0", "0x1.0f05557p0", "0x1.11a638fp0", "0x1.145231bp0", "0x1.1709ad9p0", "0x1.19cd20ap0", "0x1.1c9d05fp0", "0x1.1f79e02p0",
"0x1.226439bp0", "0x1.255ca6p0", "0x1.2863c1dp0", "0x1.2b7a346p0", "0x1.2ea0affp0", "0x1.31d7f35p0", "0x1.3520cabp0", "0x1.387c10dp0",
"0x1.3beab0ep0", "0x1.3f6da7dp0", "0x1.4306065p0", "0x1.46b4f2cp0", "0x1.4a7babep0", "0x1.4e5b8b2p0", "0x1.5256082p0", "0x1.566cbc4p0",
"0x1.5aa1666p0", "0x1.5ef5f02p0", "0x1.636c734p0", "0x1.6807403p0", "0x1.6cc8e5bp0", "0x1.71b43ap0", "0x1.76cc65bp0", "0x1.7c14f05p0",
"0x1.8191d04p0", "0x1.87477d4p0", "0x1.8d3b07ep0", "0x1.9372359p0", "0x1.99f3a42p0", "0x1.a0c6f63p0", "0x1.a7f50b9p0", "0x1.af884a1p0",
"0x1.b78cfbdp0", "0x1.c011ccdp0", "0x1.c928734p0", "0x1.d2e696dp0", "0x1.dd67145p0", "0x1.e8cbcefp0", "0x1.f5405fep0", "0x2.02fe319p0",
"0x2.125309ep0", "0x2.23abf9ap0", "0x2.37a8ce5p0", "0x2.4f417dp0", "0x2.6c16345p0", "0x2.9137576p0", "0x2.c5b1cb6p0", "0x6.5c82b7bp0",
};
//  K1  estimated  8  integer bits.
static const ap_fixed< 29 , 9 > second_atanh_K1 [ 256 ] = {
"0xf.fffep-4", "0x1.0001p0", "0x1.0003cp0", "0x1.0008ep0", "0x1.000fbp0", "0x1.0018dp0", "0x1.0023cp0", "0x1.0030fp0",
"0x1.003ffp0", "0x1.0050fp0", "0x1.00641p0", "0x1.0078fp0", "0x1.00904p0", "0x1.00a92p0", "0x1.00c47p0", "0x1.00e1bp0",
"0x1.0100dp0", "0x1.01224p0", "0x1.01455p0", "0x1.016adp0", "0x1.01924p0", "0x1.01bbbp0", "0x1.01e79p0", "0x1.02152p0",
"0x1.02451p0", "0x1.0276cp0", "0x1.02aafp0", "0x1.02e11p0", "0x1.03196p0", "0x1.0353bp0", "0x1.03907p0", "0x1.03cf3p0",
"0x1.040ffp0", "0x1.04533p0", "0x1.0498ap0", "0x1.04e02p0", "0x1.052ap0", "0x1.0576p0", "0x1.05c44p0", "0x1.0614fp0",
"0x1.0667fp0", "0x1.06bcfp0", "0x1.07149p0", "0x1.076e6p0", "0x1.07cacp0", "0x1.08296p0", "0x1.088a7p0", "0x1.08eddp0",
"0x1.0953cp0", "0x1.09bcp0", "0x1.0a26fp0", "0x1.0a944p0", "0x1.0b044p0", "0x1.0b76ap0", "0x1.0beb7p0", "0x1.0c634p0",
"0x1.0cdd6p0", "0x1.0d5a3p0", "0x1.0dd9ep0", "0x1.0e5cp0", "0x1.0ee12p0", "0x1.0f689p0", "0x1.0ff33p0", "0x1.1080bp0",
"0x1.1110dp0", "0x1.11a3cp0", "0x1.1239ep0", "0x1.12d2dp0", "0x1.136edp0", "0x1.140dap0", "0x1.14afcp0", "0x1.1554fp0",
"0x1.15fdp0", "0x1.16a88p0", "0x1.1756fp0", "0x1.1808cp0", "0x1.18be2p0", "0x1.19767p0", "0x1.1a326p0", "0x1.1af17p0",
"0x1.1bb46p0", "0x1.1c7a9p0", "0x1.1d445p0", "0x1.1e11bp0", "0x1.1ee31p0", "0x1.1fb7dp0", "0x1.20907p0", "0x1.216d1p0",
"0x1.224d5p0", "0x1.2331bp0", "0x1.241ap0", "0x1.25065p0", "0x1.25f6ep0", "0x1.26ebap0", "0x1.27e49p0", "0x1.28e1ep0",
"0x1.29e3ap0", "0x1.2ae9ep0", "0x1.2bf4ap0", "0x1.2d043p0", "0x1.2e185p0", "0x1.2f313p0", "0x1.304eep0", "0x1.3171ap0",
"0x1.32997p0", "0x1.33c65p0", "0x1.34f86p0", "0x1.362fep0", "0x1.376cdp0", "0x1.38af5p0", "0x1.39f75p0", "0x1.3b452p0",
"0x1.3c98bp0", "0x1.3df27p0", "0x1.3f522p0", "0x1.40b7ep0", "0x1.42242p0", "0x1.4396ap0", "0x1.450fdp0", "0x1.468fcp0",
"0x1.48168p0", "0x1.49a41p0", "0x1.4b39p0", "0x1.4cd5p0", "0x1.4e78ap0", "0x1.5023fp0", "0x1.51d6bp0", "0x1.53917p0",
"0x1.55549p0", "0x1.571fbp0", "0x1.58f3bp0", "0x1.5acfep0", "0x1.5cb55p0", "0x1.5ea3bp0", "0x1.609b7p0", "0x1.629c9p0",
"0x1.64a79p0", "0x1.66bcap0", "0x1.68dbdp0", "0x1.6b05ap0", "0x1.6d3ap0", "0x1.6f796p0", "0x1.71c41p0", "0x1.741a7p0",
"0x1.767cap0", "0x1.78eb1p0", "0x1.7b661p0", "0x1.7deddp0", "0x1.8082fp0", "0x1.83257p0", "0x1.85d61p0", "0x1.8894dp0",
"0x1.8b62bp0", "0x1.8e3f5p0", "0x1.912b9p0", "0x1.94284p0", "0x1.97353p0", "0x1.9a532p0", "0x1.9d82bp0", "0x1.a0c43p0",
"0x1.a4189p0", "0x1.a77fep0", "0x1.aafafp0", "0x1.ae8a9p0", "0x1.b22f7p0", "0x1.b5e9bp0", "0x1.b9babp0", "0x1.bda2ep0",
"0x1.c1a31p0", "0x1.c5bc4p0", "0x1.c9eefp0", "0x1.ce3c4p0", "0x1.d2a55p0", "0x1.d72a9p0", "0x1.dbcd9p0", "0x1.e08f3p0",
"0x1.e5708p0", "0x1.ea72dp0", "0x1.ef979p0", "0x1.f4df8p0", "0x1.fa4ccp0", "0x1.ffe03p0", "0x2.059bbp0", "0x2.0b80bp0",
"0x2.11911p0", "0x2.17ceap0", "0x2.1e3b6p0", "0x2.24d92p0", "0x2.2baa2p0", "0x2.32b09p0", "0x2.39ef3p0", "0x2.4168p0",
"0x2.491e5p0", "0x2.5114fp0", "0x2.594ecp0", "0x2.61cf2p0", "0x2.6a997p0", "0x2.73b1fp0", "0x2.7d1c3p0", "0x2.86dc4p0",
"0x2.90f79p0", "0x2.9b724p0", "0x2.a6521p0", "0x2.b19ccp0", "0x2.bd57fp0", "0x2.c98aep0", "0x2.d63c9p0", "0x2.e3746p0",
"0x2.f13b2p0", "0x2.ff998p0", "0x3.0e99ep0", "0x3.1e468p0", "0x3.2eabbp0", "0x3.3fd5dp0", "0x3.51d2fp0", "0x3.64b2fp0",
"0x3.78867p0", "0x3.8d603p0", "0x3.a354cp0", "0x3.ba7b7p0", "0x3.d2ed1p0", "0x3.ecc6bp0", "0x4.0827dp0", "0x4.2533ap0",
"0x4.44126p0", "0x4.64f15p0", "0x4.88035p0", "0x4.ad82cp0", "0x4.d5b22p0", "0x5.00dddp0", "0x5.2f5dap0", "0x5.6197ep0",
"0x5.98037p0", "0x5.d32c9p0", "0x6.13b81p0", "0x6.5a6a8p0", "0x6.a82f9p0", "0x6.fe24bp0", "0x7.5da66p0", "0x7.c8626p0",
"0x8.40722p0", "0x8.c87d6p0", "0x9.63ed6p0", "0xa.17358p0", "0xa.e8432p0", "0xb.df25dp0", "0xd.071d8p0", "0xe.70589p0",
"0x1.032f6cp4", "0x1.2748a2p4", "0x1.572d2cp4", "0x1.99a52dp4", "0x1.fba102p4", "0x2.97f084p4", "0x3.9b3891p4", "0xf.a9c012p4",
};
//  K2  estimated  16  integer bits.
static const ap_fixed< 29 , 17 > second_atanh_K2 [ 256 ] = {
"0x7.p-12", "0x1.5p-8", "0x2.9p-8", "0x3.7p-8", "0x4.ap-8", "0x5.8p-8", "0x6.9p-8", "0x7.7p-8",
"0x8.8p-8", "0x9.8p-8", "0xa.7p-8", "0xb.ap-8", "0xc.7p-8", "0xd.bp-8", "0xe.9p-8", "0xf.8p-8",
"0x1.0ap-4", "0x1.18p-4", "0x1.2dp-4", "0x1.3bp-4", "0x1.4cp-4", "0x1.5ep-4", "0x1.6bp-4", "0x1.7ep-4",
"0x1.8dp-4", "0x1.a1p-4", "0x1.bp-4", "0x1.c2p-4", "0x1.d2p-4", "0x1.e5p-4", "0x1.f5p-4", "0x2.06p-4",
"0x2.1bp-4", "0x2.2bp-4", "0x2.3cp-4", "0x2.4fp-4", "0x2.5fp-4", "0x2.72p-4", "0x2.86p-4", "0x2.97p-4",
"0x2.a8p-4", "0x2.bep-4", "0x2.cfp-4", "0x2.e3p-4", "0x2.f5p-4", "0x3.08p-4", "0x3.1bp-4", "0x3.3p-4",
"0x3.42p-4", "0x3.58p-4", "0x3.6bp-4", "0x3.7fp-4", "0x3.92p-4", "0x3.a7p-4", "0x3.bep-4", "0x3.dp-4",
"0x3.e6p-4", "0x3.fdp-4", "0x4.1p-4", "0x4.28p-4", "0x4.3cp-4", "0x4.57p-4", "0x4.6cp-4", "0x4.8p-4",
"0x4.98p-4", "0x4.b2p-4", "0x4.c8p-4", "0x4.ep-4", "0x4.f6p-4", "0x5.11p-4", "0x5.28p-4", "0x5.3fp-4",
"0x5.5bp-4", "0x5.73p-4", "0x5.8fp-4", "0x5.aap-4", "0x5.c1p-4", "0x5.dfp-4", "0x5.f9p-4", "0x6.18p-4",
"0x6.31p-4", "0x6.4fp-4", "0x6.6dp-4", "0x6.8cp-4", "0x6.a6p-4", "0x6.c5p-4", "0x6.e5p-4", "0x7.01p-4",
"0x7.22p-4", "0x7.41p-4", "0x7.62p-4", "0x7.84p-4", "0x7.a5p-4", "0x7.c7p-4", "0x7.ebp-4", "0x8.0ep-4",
"0x8.32p-4", "0x8.56p-4", "0x8.7cp-4", "0x8.9fp-4", "0x8.c5p-4", "0x8.edp-4", "0x9.16p-4", "0x9.3ep-4",
"0x9.67p-4", "0x9.92p-4", "0x9.bep-4", "0x9.e9p-4", "0xa.14p-4", "0xa.41p-4", "0xa.6fp-4", "0xa.9ep-4",
"0xa.cep-4", "0xa.fcp-4", "0xb.2ep-4", "0xb.61p-4", "0xb.94p-4", "0xb.cap-4", "0xb.ffp-4", "0xc.35p-4",
"0xc.6cp-4", "0xc.a7p-4", "0xc.e1p-4", "0xd.1ep-4", "0xd.59p-4", "0xd.95p-4", "0xd.d7p-4", "0xe.1ap-4",
"0xe.5ap-4", "0xe.ap-4", "0xe.e2p-4", "0xf.2dp-4", "0xf.74p-4", "0xf.bfp-4", "0x1.00ap0", "0x1.059p0",
"0x1.0a9p0", "0x1.0fap0", "0x1.14ep0", "0x1.1a1p0", "0x1.1fap0", "0x1.256p0", "0x1.2b3p0", "0x1.312p0",
"0x1.374p0", "0x1.3d8p0", "0x1.43fp0", "0x1.4a9p0", "0x1.515p0", "0x1.586p0", "0x1.5f7p0", "0x1.66fp0",
"0x1.6e5p0", "0x1.764p0", "0x1.7e7p0", "0x1.867p0", "0x1.8fp0", "0x1.97dp0", "0x1.a0cp0", "0x1.aa2p0",
"0x1.b3ap0", "0x1.bd9p0", "0x1.c7ep0", "0x1.d27p0", "0x1.dd3p0", "0x1.e8ap0", "0x1.f43p0", "0x2.004p0",
"0x2.0cbp0", "0x2.196p0", "0x2.26cp0", "0x2.349p0", "0x2.42bp0", "0x2.519p0", "0x2.60ep0", "0x2.70bp0",
"0x2.814p0", "0x2.926p0", "0x2.a4p0", "0x2.b6bp0", "0x2.c9cp0", "0x2.dddp0", "0x2.f29p0", "0x3.085p0",
"0x3.1efp0", "0x3.367p0", "0x3.4efp0", "0x3.688p0", "0x3.834p0", "0x3.9f5p0", "0x3.bc8p0", "0x3.db6p0",
"0x3.fb8p0", "0x4.1dp0", "0x4.405p0", "0x4.656p0", "0x4.8c7p0", "0x4.b53p0", "0x4.e03p0", "0x5.0dep0",
"0x5.3d9p0", "0x5.702p0", "0x5.a59p0", "0x5.ddep0", "0x6.19dp0", "0x6.591p0", "0x6.9c2p0", "0x6.e3ap0",
"0x7.2f8p0", "0x7.809p0", "0x7.d6cp0", "0x8.33p0", "0x8.958p0", "0x8.ff3p0", "0x9.70ap0", "0x9.ea6p0",
"0xa.6d9p0", "0xa.fb2p0", "0xb.944p0", "0xc.39ep0", "0xc.ee1p0", "0xd.b1ep0", "0xe.877p0", "0xf.712p0",
"0x1.0718p4", "0x1.18b5p4", "0x1.2c27p4", "0x1.41acp4", "0x1.5995p4", "0x1.743fp4", "0x1.921dp4", "0x1.b3b6p4",
"0x1.d9b3p4", "0x2.04dap4", "0x2.362bp4", "0x2.6ee2p4", "0x2.b08fp4", "0x2.fd2ap4", "0x3.5746p4", "0x3.c247p4",
"0x4.42acp4", "0x4.de8fp4", "0x5.9e5fp4", "0x6.8e1dp4", "0x7.bf29p4", "0x9.4b9bp4", "0xb.5bffp4", "0xe.3225p4",
"0x1.23eb8p8", "0x1.84fe8p8", "0x2.200d3p8", "0x3.2ea37p8", "0x5.48ee9p8", "0xa.7a499p8", "0x1.e65acdp12", "0xb.1690a4p12",
};

// Tables for f= tanh(8 * x)
//  K0  estimated  0  integer bits.
static const ap_fixed< 29 , 1 > first_tanh_K0 [ 512 ] = {
"0x3.dp-24", "0x3.fff61p-8", "0x7.ff687p-8", "0xb.fddb3p-8", "0xf.facf2p-8","0x1.3f5c5dp-4", "0x1.7ee41bp-4", "0x1.be3c69p-4",
"0x1.fd5d9ap-4", "0x2.3c401cp-4", "0x2.7adc7ep-4", "0x2.b92b6dp-4", "0x2.f725bfp-4", "0x3.34c47p-4", "0x3.7200a9p-4", "0x3.aed3c1p-4",
"0x3.eb373ep-4", "0x4.2724dcp-4", "0x4.62968cp-4", "0x4.9d8675p-4", "0x4.d7eef9p-4", "0x5.11cab6p-4", "0x5.4b1484p-4","0x5.83c77cp-4",
"0x5.bbdef4p-4", "0x5.f35683p-4", "0x6.2a2ap-4", "0x6.605582p-4","0x6.95d564p-4", "0x6.caa64p-4", "0x6.fec4f1p-4", "0x7.322e95p-4",
"0x7.64e08ap-4", "0x7.96d86cp-4", "0x7.c81419p-4", "0x7.f891abp-4", "0x8.284f7bp-4", "0x8.574c1dp-4", "0x8.858661p-4","0x8.b2fd4fp-4",
"0x8.dfb02ap-4", "0x9.0b9e67p-4", "0x9.36c7b5p-4", "0x9.612bf3p-4", "0x9.8acb32p-4", "0x9.b3a5b4p-4", "0x9.dbbbe7p-4","0xa.030e67p-4",
"0xa.299df8p-4", "0xa.4f6b88p-4", "0xa.74782ap-4", "0xa.98c518p-4", "0xa.bc53aap-4", "0xa.df255dp-4", "0xb.013bc9p-4","0xb.2298a6p-4",
"0xb.433dc6p-4", "0xb.632d11p-4", "0xb.82688cp-4", "0xb.a0f24cp-4", "0xb.becc7ep-4", "0xb.dbf96p-4", "0xb.f87b3fp-4", "0xc.145479p-4",
"0xc.2f8779p-4", "0xc.4a16b6p-4", "0xc.6404b2p-4", "0xc.7d53f6p-4", "0xc.960717p-4", "0xc.ae20aep-4", "0xc.c5a35ap-4","0xc.dc91bep-4",
"0xc.f2ee82p-4", "0xd.08bc4dp-4", "0xd.1dfdcbp-4", "0xd.32b5a6p-4", "0xd.46e689p-4", "0xd.5a931bp-4", "0xd.6dbe03p-4","0xd.8069e5p-4",
"0xd.929961p-4", "0xd.a44f13p-4", "0xd.b58d91p-4", "0xd.c6576ep-4", "0xd.d6af34p-4", "0xd.e69769p-4", "0xd.f6128cp-4","0xe.052314p-4",
"0xe.13cb7p-4", "0xe.220e08p-4", "0xe.2fed3dp-4", "0xe.3d6b64p-4","0xe.4a8acdp-4", "0xe.574dbdp-4", "0xe.63b671p-4", "0xe.6fc71bp-4",
"0xe.7b81e6p-4", "0xe.86e8f1p-4", "0xe.91fe54p-4", "0xe.9cc41cp-4", "0xe.a73c4cp-4", "0xe.b168dep-4", "0xe.bb4bc1p-4","0xe.c4e6dbp-4",
"0xe.ce3c0ap-4", "0xe.d74d1fp-4", "0xe.e01be5p-4", "0xe.e8aa19p-4", "0xe.f0f971p-4", "0xe.f90b9bp-4", "0xf.00e239p-4","0xf.087ee4p-4",
"0xf.0fe32dp-4", "0xf.17109ap-4", "0xf.1e08abp-4", "0xf.24ccd3p-4", "0xf.2b5e8p-4", "0xf.31bf15p-4", "0xf.37efedp-4", "0xf.3df25bp-4",
"0xf.43c7aap-4", "0xf.49711bp-4", "0xf.4eefeap-4", "0xf.544548p-4", "0xf.59726p-4", "0xf.5e7855p-4", "0xf.635843p-4", "0xf.68133fp-4",
"0xf.6caa55p-4", "0xf.711e8bp-4", "0xf.7570e2p-4", "0xf.79a251p-4", "0xf.7db3cap-4", "0xf.81a63ap-4", "0xf.857a85p-4","0xf.89318ap-4",
"0xf.8ccc23p-4", "0xf.904b22p-4", "0xf.93af56p-4", "0xf.96f985p-4", "0xf.9a2a73p-4", "0xf.9d42dbp-4", "0xf.a04377p-4","0xf.a32cf9p-4",
"0xf.a6000dp-4", "0xf.a8bd5ep-4", "0xf.ab658ep-4", "0xf.adf93fp-4", "0xf.b0790ap-4", "0xf.b2e586p-4", "0xf.b53f45p-4","0xf.b786d6p-4",
"0xf.b9bcc3p-4", "0xf.bbe192p-4", "0xf.bdf5c5p-4", "0xf.bff9dbp-4", "0xf.c1ee4fp-4", "0xf.c3d397p-4", "0xf.c5aa29p-4","0xf.c77274p-4",
"0xf.c92ce7p-4", "0xf.cad9eap-4", "0xf.cc79e6p-4", "0xf.ce0d3dp-4", "0xf.cf9452p-4", "0xf.d10f83p-4", "0xf.d27f2bp-4","0xf.d3e3a2p-4",
"0xf.d53d4p-4", "0xf.d68c58p-4", "0xf.d7d13ap-4", "0xf.d90c37p-4","0xf.da3d99p-4", "0xf.db65adp-4", "0xf.dc84b9p-4", "0xf.dd9b03p-4",
"0xf.dea8cfp-4", "0xf.dfae6p-4", "0xf.e0abf4p-4", "0xf.e1a1cap-4","0xf.e2901ep-4", "0xf.e3772ap-4", "0xf.e45727p-4", "0xf.e5304bp-4",
"0xf.e602ccp-4", "0xf.e6cedep-4", "0xf.e794b2p-4", "0xf.e85478p-4", "0xf.e90e61p-4", "0xf.e9c29ap-4", "0xf.ea714fp-4","0xf.eb1aabp-4",
"0xf.ebbed8p-4", "0xf.ec5dfep-4", "0xf.ecf844p-4", "0xf.ed8dd1p-4", "0xf.ee1ec9p-4", "0xf.eeab5p-4", "0xf.ef3389p-4", "0xf.efb796p-4",
"0xf.f03796p-4", "0xf.f0b3aap-4", "0xf.f12bfp-4", "0xf.f1a087p-4","0xf.f2118ap-4", "0xf.f27f16p-4", "0xf.f2e947p-4", "0xf.f35035p-4",
"0xf.f3b3fbp-4", "0xf.f414b2p-4", "0xf.f47271p-4", "0xf.f4cd5p-4", "0xf.f52565p-4", "0xf.f57ac6p-4", "0xf.f5cd88p-4", "0xf.f61dcp-4",
"0xf.f66b82p-4", "0xf.f6b6ep-4", "0xf.f6ffefp-4", "0xf.f746bfp-4","0xf.f78b62p-4", "0xf.f7cdeap-4", "0xf.f80e68p-4", "0xf.f84ceap-4",
"0xf.f8898p-4", "0xf.f8c43bp-4", "0xf.f8fd27p-4", "0xf.f93454p-4","0xf.f969dp-4", "0xf.f99da6p-4", "0xf.f9cfe5p-4", "0xf.fa0099p-4",
"0xf.fa2fcdp-4", "0xf.fa5d8fp-4", "0xf.fa89e8p-4", "0xf.fab4e5p-4", "0xf.fade9p-4", "0xf.fb06f2p-4", "0xf.fb2e17p-4", "0xf.fb5408p-4",
"0xf.fb78cfp-4", "0xf.fb9c74p-4", "0xf.fbbf01p-4", "0xf.fbe07ep-4", "0xf.fc00f3p-4", "0xf.fc2069p-4", "0xf.fc3ee8p-4","0xf.fc5c76p-4",
"0xf.fc791cp-4", "0xf.fc94e1p-4", "0xf.fcafcbp-4", "0xf.fcc9e1p-4", "0xf.fce32ap-4", "0xf.fcfbabp-4", "0xf.fd136cp-4","0xf.fd2a72p-4",
"0xf.fd40c3p-4", "0xf.fd5664p-4", "0xf.fd6b5bp-4", "0xf.fd7fadp-4", "0xf.fd935fp-4", "0xf.fda676p-4", "0xf.fdb8f6p-4","0xf.fdcae5p-4",
"0xf.fddc47p-4", "0xf.fded2p-4", "0xf.fdfd74p-4", "0xf.fe0d48p-4","0xf.fe1c9fp-4", "0xf.fe2b7dp-4", "0xf.fe39e7p-4", "0xf.fe47dfp-4",
"0xf.fe5569p-4", "0xf.fe6288p-4", "0xf.fe6f4p-4", "0xf.fe7b94p-4","0xf.fe8786p-4", "0xf.fe931bp-4", "0xf.fe9e55p-4", "0xf.fea936p-4",
"0xf.feb3c1p-4", "0xf.febdfap-4", "0xf.fec7e2p-4", "0xf.fed17cp-4", "0xf.fedacap-4", "0xf.fee3cfp-4", "0xf.feec8dp-4","0xf.fef507p-4",
"0xf.fefd3dp-4", "0xf.ff0533p-4", "0xf.ff0ceap-4", "0xf.ff1464p-4", "0xf.ff1ba4p-4", "0xf.ff22aap-4", "0xf.ff2979p-4","0xf.ff3013p-4",
"0xf.ff3679p-4", "0xf.ff3cacp-4", "0xf.ff42aep-4", "0xf.ff4881p-4", "0xf.ff4e26p-4", "0xf.ff539fp-4", "0xf.ff58ecp-4","0xf.ff5e1p-4",
"0xf.ff630cp-4", "0xf.ff67ep-4", "0xf.ff6c8ep-4", "0xf.ff7117p-4","0xf.ff757dp-4", "0xf.ff79cp-4", "0xf.ff7de1p-4", "0xf.ff81e2p-4",
"0xf.ff85c3p-4", "0xf.ff8986p-4", "0xf.ff8d2bp-4", "0xf.ff90b3p-4", "0xf.ff942p-4", "0xf.ff9771p-4", "0xf.ff9aa9p-4", "0xf.ff9dc7p-4",
"0xf.ffa0cdp-4", "0xf.ffa3bap-4", "0xf.ffa691p-4", "0xf.ffa952p-4", "0xf.ffabfcp-4", "0xf.ffae92p-4", "0xf.ffb113p-4","0xf.ffb381p-4",
"0xf.ffb5dbp-4", "0xf.ffb823p-4", "0xf.ffba59p-4", "0xf.ffbc7ep-4", "0xf.ffbe92p-4", "0xf.ffc095p-4", "0xf.ffc288p-4","0xf.ffc46dp-4",
"0xf.ffc642p-4", "0xf.ffc809p-4", "0xf.ffc9c1p-4", "0xf.ffcb6dp-4", "0xf.ffcd0bp-4", "0xf.ffce9cp-4", "0xf.ffd021p-4","0xf.ffd19ap-4",
"0xf.ffd308p-4", "0xf.ffd46ap-4", "0xf.ffd5c1p-4", "0xf.ffd70ep-4", "0xf.ffd85p-4", "0xf.ffd989p-4", "0xf.ffdab8p-4", "0xf.ffdbddp-4",
"0xf.ffdcfap-4", "0xf.ffde0ep-4", "0xf.ffdf19p-4", "0xf.ffe01cp-4", "0xf.ffe118p-4", "0xf.ffe20bp-4", "0xf.ffe2f7p-4","0xf.ffe3dcp-4",
"0xf.ffe4b9p-4", "0xf.ffe59p-4", "0xf.ffe66p-4", "0xf.ffe72ap-4", "0xf.ffe7eep-4", "0xf.ffe8abp-4", "0xf.ffe963p-4", "0xf.ffea15p-4",
"0xf.ffeac2p-4", "0xf.ffeb69p-4", "0xf.ffec0bp-4", "0xf.ffeca8p-4", "0xf.ffed41p-4", "0xf.ffedd4p-4", "0xf.ffee64p-4","0xf.ffeeeep-4",
"0xf.ffef75p-4", "0xf.ffeff7p-4", "0xf.fff075p-4", "0xf.fff0fp-4", "0xf.fff166p-4", "0xf.fff1d9p-4", "0xf.fff249p-4", "0xf.fff2b5p-4",
"0xf.fff31ep-4", "0xf.fff383p-4", "0xf.fff3e5p-4", "0xf.fff445p-4", "0xf.fff4a1p-4", "0xf.fff4fbp-4", "0xf.fff552p-4","0xf.fff5a6p-4",
"0xf.fff5f7p-4", "0xf.fff646p-4", "0xf.fff693p-4", "0xf.fff6ddp-4", "0xf.fff725p-4", "0xf.fff76bp-4", "0xf.fff7aep-4","0xf.fff7fp-4",
"0xf.fff82fp-4", "0xf.fff86dp-4", "0xf.fff8a9p-4", "0xf.fff8e2p-4", "0xf.fff91ap-4", "0xf.fff951p-4", "0xf.fff985p-4","0xf.fff9b8p-4",
"0xf.fff9eap-4", "0xf.fffa1ap-4", "0xf.fffa48p-4", "0xf.fffa75p-4", "0xf.fffaa1p-4", "0xf.fffacbp-4", "0xf.fffaf4p-4","0xf.fffb1cp-4",
"0xf.fffb43p-4", "0xf.fffb68p-4", "0xf.fffb8cp-4", "0xf.fffbafp-4", "0xf.fffbd1p-4", "0xf.fffbf2p-4", "0xf.fffc12p-4","0xf.fffc31p-4",
"0xf.fffc4fp-4", "0xf.fffc6cp-4", "0xf.fffc88p-4", "0xf.fffca4p-4", "0xf.fffcbep-4", "0xf.fffcd8p-4", "0xf.fffcf1p-4","0xf.fffd09p-4",
"0xf.fffd2p-4", "0xf.fffd37p-4", "0xf.fffd4dp-4", "0xf.fffd62p-4","0xf.fffd76p-4", "0xf.fffd8ap-4", "0xf.fffd9ep-4", "0xf.fffdb1p-4",
"0xf.fffdc3p-4", "0xf.fffdd4p-4", "0xf.fffde6p-4", "0xf.fffdf6p-4", "0xf.fffe06p-4", "0xf.fffe16p-4", "0xf.fffe25p-4","0xf.fffe33p-4",
"0xf.fffe42p-4", "0xf.fffe4fp-4", "0xf.fffe5dp-4", "0xf.fffe6ap-4", "0xf.fffe76p-4", "0xf.fffe82p-4", "0xf.fffe8ep-4","0xf.fffe99p-4",
"0xf.fffea4p-4", "0xf.fffeafp-4", "0xf.fffeb9p-4", "0xf.fffec3p-4", "0xf.fffecdp-4", "0xf.fffed7p-4", "0xf.fffeep-4","0xf.fffee9p-4",
"0xf.fffef1p-4", "0xf.fffefap-4", "0xf.ffff02p-4", "0xf.ffff09p-4", "0xf.ffff11p-4", "0xf.ffff18p-4", "0xf.ffff2p-4","0xf.ffff26p-4",
"0xf.ffff2dp-4", "0xf.ffff34p-4", "0xf.ffff3ap-4", "0xf.ffff4p-4", "0xf.ffff46p-4", "0xf.ffff4cp-4", "0xf.ffff51p-4", "0xf.ffff57p-4",
"0xf.ffff5cp-4", "0xf.ffff61p-4", "0xf.ffff66p-4", "0xf.ffff6ap-4", "0xf.ffff6fp-4", "0xf.ffff74p-4", "0xf.ffff78p-4","0xf.ffff7cp-4",
"0xf.ffff8p-4", "0xf.ffff84p-4", "0xf.ffff88p-4", "0xf.ffff8cp-4","0xf.ffff8fp-4", "0xf.ffff93p-4", "0xf.ffff96p-4", "0xf.ffff99p-4",
"0xf.ffff9cp-4", "0xf.ffff9fp-4", "0xf.ffffa2p-4", "0xf.ffffa5p-4", "0xf.ffffa8p-4", "0xf.ffffabp-4", "0xf.ffffadp-4","0xf.ffffbp-4",
"0xf.ffffb2p-4", "0xf.ffffb5p-4", "0xf.ffffb7p-4", "0xf.ffffb9p-4", "0xf.ffffbcp-4", "0xf.ffffbep-4", "0xf.ffffcp-4","0xf.ffffc2p-4",
};
//  K1  estimated  3  integer bits.
static const ap_fixed< 23 , 4 > first_tanh_K1 [ 512 ] = {
"0x7.ffd66p0", "0x7.fed7ep0", "0x7.fcd9ep0", "0x7.f9dd6p0", "0x7.f5e3cp0", "0x7.f0efp0", "0x7.eb01cp0", "0x7.e41ecp0",
"0x7.dc49ap0", "0x7.d3864p0", "0x7.c9d86p0", "0x7.bf456p0", "0x7.b3d1cp0", "0x7.a7834p0", "0x7.9a5f8p0", "0x7.8c6cap0",
"0x7.7db14p0", "0x7.6e33ep0", "0x7.5dfb8p0", "0x7.4d0f6p0", "0x7.3b76cp0", "0x7.29396p0", "0x7.165fp0", "0x7.02ef8p0",
"0x6.eef2cp0", "0x6.da70cp0", "0x6.c571ep0", "0x6.affe4p0", "0x6.9a1dcp0", "0x6.83d8cp0", "0x6.6d378p0", "0x6.5641ep0",
"0x6.3effep0", "0x6.27798p0", "0x6.0fb66p0", "0x5.f7be6p0", "0x5.df98ep0", "0x5.c74d6p0", "0x5.aee2ep0", "0x5.9660cp0",
"0x5.7dcd4p0", "0x5.652fap0", "0x5.4c8dcp0", "0x5.33ee2p0", "0x5.1b56ap0", "0x5.02ccep0", "0x4.ea56ap0", "0x4.d1f8ep0",
"0x4.b9b8ep0", "0x4.a19b4p0", "0x4.89a4cp0", "0x4.71d96p0", "0x4.5a3d8p0", "0x4.42d4cp0", "0x4.2ba3p0", "0x4.14ab6p0",
"0x3.fdf0ep0", "0x3.e776cp0", "0x3.d13f8p0", "0x3.bb4dcp0", "0x3.a5a3cp0", "0x3.90436p0", "0x3.7b2ecp0", "0x3.66678p0",
"0x3.51efp0", "0x3.3dc6cp0", "0x3.29efep0", "0x3.166b6p0", "0x3.033a2p0", "0x2.f05cap0", "0x2.ddd3ap0", "0x2.cb9f6p0",
"0x2.b9c04p0", "0x2.a836ap0", "0x2.97022p0", "0x2.8623p0", "0x2.7598cp0", "0x2.65638p0", "0x2.5582ap0", "0x2.45f5ep0",
"0x2.36bc8p0", "0x2.27d5ep0", "0x2.1941ap0", "0x2.0afeap0", "0x1.fd0c8p0", "0x1.ef6a2p0", "0x1.e2168p0", "0x1.d511p0",
"0x1.c8586p0", "0x1.bbebep0", "0x1.afcap0", "0x1.a3f24p0", "0x1.9863p0", "0x1.8d1b6p0", "0x1.821ap0", "0x1.775ep0",
"0x1.6ce6p0", "0x1.62b0ep0", "0x1.58bd6p0", "0x1.4f0a4p0", "0x1.45966p0", "0x1.3c606p0", "0x1.33674p0", "0x1.2aa9cp0",
"0x1.22268p0", "0x1.19dc6p0", "0x1.11ca2p0", "0x1.09eeap0", "0x1.0248cp0", "0xf.ad72p-4", "0xf.398cp-4", "0xe.c8c6p-4",
"0xe.5b0cp-4", "0xd.f052p-4", "0xd.888p-4", "0xd.2388p-4", "0xc.c156p-4", "0xc.61dcp-4", "0xc.0508p-4", "0xb.aac8p-4",
"0xb.530cp-4", "0xa.fdc6p-4", "0xa.aae2p-4", "0xa.5a54p-4", "0xa.0c0ep-4", "0x9.cp-4", "0x9.761ap-4", "0x9.2e4cp-4",
"0x8.e88cp-4", "0x8.a4cep-4", "0x8.62fcp-4", "0x8.231p-4", "0x7.e4fcp-4", "0x7.a8b2p-4", "0x7.6e26p-4", "0x7.354cp-4",
"0x6.fe18p-4", "0x6.c88p-4", "0x6.9476p-4", "0x6.61f4p-4", "0x6.30e8p-4", "0x6.015p-4", "0x5.d31ap-4", "0x5.a63ep-4",
"0x5.7ab6p-4", "0x5.5074p-4", "0x5.2776p-4", "0x4.ffa8p-4", "0x4.d90ap-4", "0x4.b39p-4", "0x4.8f34p-4", "0x4.6becp-4",
"0x4.49aep-4", "0x4.2876p-4", "0x4.083cp-4", "0x3.e8f6p-4", "0x3.ca9ep-4", "0x3.ad32p-4", "0x3.90a4p-4", "0x3.74f2p-4",
"0x3.5a12p-4", "0x3.4004p-4", "0x3.26bap-4", "0x3.0e36p-4", "0x2.f66ep-4", "0x2.df5ap-4", "0x2.c8fap-4", "0x2.b348p-4",
"0x2.9e3ap-4", "0x2.89cep-4", "0x2.7604p-4", "0x2.62cep-4", "0x2.503p-4", "0x2.3e2p-4", "0x2.2c9cp-4", "0x2.1bap-4",
"0x2.0b2ap-4", "0x1.fb3p-4", "0x1.ebb4p-4", "0x1.dcbp-4", "0x1.ce2p-4", "0x1.cp-4", "0x1.b24ep-4", "0x1.a50ap-4",
"0x1.982ap-4", "0x1.8bacp-4", "0x1.7f92p-4", "0x1.73d8p-4", "0x1.6878p-4", "0x1.5d7p-4", "0x1.52bep-4", "0x1.485ep-4",
"0x1.3e5p-4", "0x1.349p-4", "0x1.2b1ep-4", "0x1.21f4p-4", "0x1.1912p-4", "0x1.1076p-4", "0x1.081ep-4", "0x1.0004p-4",
"0xf.82cp-8", "0xf.09p-8", "0xe.932p-8", "0xe.20ap-8", "0xd.b1cp-8", "0xd.464p-8", "0xc.ddep-8", "0xc.79p-8",
"0xc.17p-8", "0xb.b8p-8", "0xb.5cp-8", "0xb.02cp-8", "0xa.ac4p-8", "0xa.586p-8", "0xa.072p-8", "0x9.b86p-8",
"0x9.6bep-8", "0x9.22p-8", "0x8.da2p-8", "0x8.948p-8", "0x8.514p-8", "0x8.0fep-8", "0x7.d06p-8", "0x7.92ep-8",
"0x7.578p-8", "0x7.1dap-8", "0x6.e5cp-8", "0x6.af8p-8", "0x6.7aep-8", "0x6.48p-8", "0x6.168p-8", "0x5.e6ap-8",
"0x5.b86p-8", "0x5.8b4p-8", "0x5.5fcp-8", "0x5.356p-8", "0x5.0c6p-8", "0x4.e4cp-8", "0x4.be4p-8", "0x4.99p-8",
"0x4.74cp-8", "0x4.51cp-8", "0x4.2fcp-8", "0x4.0ecp-8", "0x3.eeep-8", "0x3.dp-8", "0x3.b1ep-8", "0x3.94ep-8",
"0x3.78ap-8", "0x3.5d4p-8", "0x3.42cp-8", "0x3.292p-8", "0x3.104p-8", "0x2.f84p-8", "0x2.e0ep-8", "0x2.ca4p-8",
"0x2.b44p-8", "0x2.9eep-8", "0x2.8a4p-8", "0x2.764p-8", "0x2.62ep-8", "0x2.5p-8", "0x2.3ep-8", "0x2.2c4p-8",
"0x2.1b2p-8", "0x2.0a8p-8", "0x1.fa8p-8", "0x1.eaep-8", "0x1.dbep-8", "0x1.cd4p-8", "0x1.bfp-8", "0x1.b14p-8",
"0x1.a3ep-8", "0x1.97p-8", "0x1.8a8p-8", "0x1.7e6p-8", "0x1.72ap-8", "0x1.674p-8", "0x1.5c2p-8", "0x1.516p-8",
"0x1.472p-8", "0x1.3dp-8", "0x1.334p-8", "0x1.29cp-8", "0x1.20ap-8", "0x1.17cp-8", "0x1.0f4p-8", "0x1.06cp-8",
"0xf.ecp-12", "0xf.6ep-12", "0xe.f6p-12", "0xe.8p-12", "0xe.0cp-12", "0xd.ap-12", "0xd.34p-12", "0xc.ccp-12",
"0xc.66p-12", "0xc.04p-12", "0xb.a6p-12", "0xb.4ap-12", "0xa.f2p-12", "0xa.9ap-12", "0xa.4ap-12", "0x9.f8p-12",
"0x9.a8p-12", "0x9.5cp-12", "0x9.12p-12", "0x8.ccp-12", "0x8.86p-12", "0x8.42p-12", "0x8.02p-12", "0x7.c2p-12",
"0x7.86p-12", "0x7.4ap-12", "0x7.1p-12", "0x6.dap-12", "0x6.a2p-12", "0x6.7p-12", "0x6.3cp-12", "0x6.0cp-12",
"0x5.dap-12", "0x5.aep-12", "0x5.82p-12", "0x5.54p-12", "0x5.2cp-12", "0x5.02p-12", "0x4.dcp-12", "0x4.b4p-12",
"0x4.92p-12", "0x4.6cp-12", "0x4.4ap-12", "0x4.28p-12", "0x4.06p-12", "0x3.e6p-12", "0x3.cap-12", "0x3.aap-12",
"0x3.8ep-12", "0x3.7p-12", "0x3.58p-12", "0x3.3cp-12", "0x3.22p-12", "0x3.0ap-12", "0x2.f2p-12", "0x2.dcp-12",
"0x2.c4p-12", "0x2.aep-12", "0x2.9ap-12", "0x2.84p-12", "0x2.72p-12", "0x2.5ep-12", "0x2.4ap-12", "0x2.3ap-12",
"0x2.28p-12", "0x2.16p-12", "0x2.06p-12", "0x1.f8p-12", "0x1.e6p-12", "0x1.d8p-12", "0x1.cap-12", "0x1.bap-12",
"0x1.aep-12", "0x1.ap-12", "0x1.94p-12", "0x1.88p-12", "0x1.7ap-12", "0x1.7p-12", "0x1.64p-12", "0x1.5ap-12",
"0x1.4ep-12", "0x1.44p-12", "0x1.3cp-12", "0x1.32p-12", "0x1.26p-12", "0x1.2p-12", "0x1.14p-12", "0x1.0ep-12",
"0x1.04p-12", "0xf.cp-16", "0xf.6p-16", "0xe.cp-16", "0xe.8p-16", "0xe.p-16", "0xd.8p-16", "0xd.2p-16",
"0xc.ap-16", "0xc.4p-16", "0xc.p-16", "0xb.8p-16", "0xb.4p-16", "0xa.cp-16", "0xa.6p-16", "0xa.2p-16",
"0x9.ep-16", "0x9.ap-16", "0x9.4p-16", "0x9.p-16", "0x8.cp-16", "0x8.6p-16", "0x8.4p-16", "0x7.ep-16",
"0x7.cp-16", "0x7.8p-16", "0x7.2p-16", "0x7.2p-16", "0x6.ep-16", "0x6.8p-16", "0x6.8p-16", "0x6.4p-16",
"0x6.p-16", "0x5.cp-16", "0x5.ap-16", "0x5.8p-16", "0x5.4p-16", "0x5.2p-16", "0x5.p-16", "0x4.ep-16",
"0x4.ap-16", "0x4.8p-16", "0x4.6p-16", "0x4.4p-16", "0x4.2p-16", "0x4.p-16", "0x3.ep-16", "0x3.cp-16",
"0x3.ap-16", "0x3.8p-16", "0x3.8p-16", "0x3.4p-16", "0x3.4p-16", "0x3.p-16", "0x3.p-16", "0x2.ep-16",
"0x2.ep-16", "0x2.ap-16", "0x2.ap-16", "0x2.8p-16", "0x2.ap-16", "0x2.8p-16", "0x2.6p-16", "0x2.4p-16",
"0x2.2p-16", "0x2.4p-16", "0x2.p-16", "0x2.p-16", "0x2.p-16", "0x1.ep-16", "0x1.cp-16", "0x1.ep-16",
"0x1.ap-16", "0x1.cp-16", "0x1.8p-16", "0x1.8p-16", "0x1.8p-16", "0x1.8p-16", "0x1.6p-16", "0x1.6p-16",
"0x1.6p-16", "0x1.4p-16", "0x1.6p-16", "0x1.4p-16", "0x1.4p-16", "0x1.2p-16", "0x1.2p-16", "0x1.p-16",
"0x1.2p-16", "0x1.p-16", "0xe.p-20", "0x1.p-16", "0xe.p-20", "0x1.p-16", "0xc.p-20", "0xe.p-20",
"0xe.p-20", "0xc.p-20", "0xc.p-20", "0xc.p-20", "0xc.p-20", "0xa.p-20", "0xc.p-20", "0xa.p-20",
"0xa.p-20", "0xa.p-20", "0x8.p-20", "0xa.p-20", "0xa.p-20", "0x8.p-20", "0x8.p-20", "0x8.p-20",
"0x8.p-20", "0x8.p-20", "0x8.p-20", "0x6.p-20", "0x8.p-20", "0x6.p-20", "0x6.p-20", "0x6.p-20",
"0x8.p-20", "0x8.p-20", "0x6.p-20", "0x6.p-20", "0x6.p-20", "0x4.p-20", "0x6.p-20", "0x4.p-20",
"0x6.p-20", "0x4.p-20", "0x4.p-20", "0x6.p-20", "0x2.p-20", "0x4.p-20", "0x4.p-20", "0x2.p-20",
};
// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 55 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h" 2

template<class T>
struct value_list{
};

template<>
struct value_list<double>{
    typedef double T;
 static const int g = 10; // guard bits during core approx
 static const int p1 = 61; // padding bits during range reduction
 static const int alpha = 7;
    // The number of bits of B that are not used in the K1 computation
 static const int beta1 = 0;
    // The number of bits of B that are not used in the K2 computation
 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<double>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 81 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_op_SpecResource(fourth_order_double::sin_cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_cos_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_cos_K3, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_cos_K4, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
        ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
        ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis; // cos and sin are concatentated.

        ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
        ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
        ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
        ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
        ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
# 123 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> Mx,
                              ap_int<fp_struct<double>::EXP_BITS> Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
_ssdm_op_SpecResource(fourth_order_double::cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::cos_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::cos_K3, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::cos_K4, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_K3, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(fourth_order_double::sin_K4, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
        ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
        ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

        ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
        ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
        ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
        ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
        ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
        cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

        ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
        ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
        ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
        ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
        sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
# 185 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 }

public :
inline __attribute__((always_inline)) value_list<double>() { _ssdm_SpecConstant(&g); _ssdm_SpecConstant(&p1); _ssdm_SpecConstant(&alpha); _ssdm_SpecConstant(&beta1); _ssdm_SpecConstant(&beta2); _ssdm_SpecConstant(&W_dout); _ssdm_SpecConstant(&W_Mx); }
# 186 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
};


template<>
struct value_list<float> {
    typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
    // The number of bits of B that are not used in the K1 computation
 static const int beta1 = 0; //beta1 <= 0
    // The number of bits of B that are not used in the K2 computation
 static const int beta2 = 7; //beta2 <= alpha

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    //    typedef first_order_float TABLES;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<float>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 212 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_op_SpecResource(second_order_float::sin_cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::sin_cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::sin_cos_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis; // cos and sin are concatentated.

        ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
        ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
        ap_ufixed<Wx, 1> result =
            (t1+t2+t3) * Mx;
# 245 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> &Mx,
                              ap_int<fp_struct<float>::EXP_BITS> &Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
_ssdm_op_SpecResource(second_order_float::cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::cos_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::sin_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::sin_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_order_float::sin_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
        ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
        ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

        //   TABLES tables;
        ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
        ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
        ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
        cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

        ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
        ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
        sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
# 298 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 }


public :
inline __attribute__((always_inline)) value_list<float>() { _ssdm_SpecConstant(&g); _ssdm_SpecConstant(&p1); _ssdm_SpecConstant(&alpha); _ssdm_SpecConstant(&beta1); _ssdm_SpecConstant(&beta2); _ssdm_SpecConstant(&W_dout); _ssdm_SpecConstant(&W_Mx); }
# 300 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
};

template<>
struct value_list<half>{
    typedef half T;
 static const int g = 4;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<3> &k,
                                               ap_ufixed<Wx, 0> &x,
                                               ap_ufixed<Wr, 0> &Mx,
                                               ap_int<fp_struct<half>::EXP_BITS> &Ex){

        const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 320 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_op_SpecResource(first_order_half::sin_cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_order_half::sin_cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;

        bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
        A[alpha] = sin_basis; // cos and sin are concatentated.

        ap_fixed<Wx, 1> t1 = first_order_half::sin_cos_K0[A];
        ap_fixed<Wx, 1> t2 = B*first_order_half::sin_cos_K1[A];
        ap_ufixed<Wx, 1> result =
            (t1+t2) * Mx;
# 345 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
    }
    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
                              ap_ufixed<Wx, 0> &x,
                              ap_ufixed<Wr, 0> Mx,
                              ap_int<fp_struct<half>::EXP_BITS> Ex,
                              ap_ufixed<Wr, 1> &sin_result,
                              ap_ufixed<Wr, 1> &cos_result
                              ) {
_ssdm_op_SpecResource(first_order_half::cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_order_half::cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_order_half::sin_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_order_half::sin_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
                             x.wl()-x.iwl()-alpha);
        ap_ufixed<Wx-alpha-beta1, -alpha> B = x;

        ap_ufixed<Wx, 1> cos_t1 = first_order_half::cos_K0[A];
        ap_ufixed<Wx, 1> cos_t2 = B*first_order_half::cos_K1[A];
        cos_result = 1 - (cos_t1 + cos_t2);

        ap_fixed<Wx, 1> sin_t1 = first_order_half::sin_K0[A];
        ap_fixed<Wx, 1> sin_t2 = B*first_order_half::sin_K1[A];
        sin_result = Mx * (sin_t1 + sin_t2);
# 385 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 }
};

template<class T>
void generic_sincos(T t_in, T *s, T *c)
{

    const int g = value_list<T>::g;
    const int p1 = value_list<T>::p1;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 395 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 396 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
_ssdm_SpecConstant(neg_cos_table);
# 397 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_sin_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_cos_table, 1, "COMPLETE", 0, "");
// #pragma HLS RESOURCE variable=swap_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_sin_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_cos_table core=ROM_1P_LUTRAM

    fp_struct<T> din(t_in);





    ap_uint<3> k;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> x;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex;

    range_redux_payne_hanek_hotbm<p1,T>(t_in,k,x,Mx,Ex);

    ap_ufixed<value_list<T>::W_dout, 1> sin_result, cos_result;
    value_list<T>::sincos_approximation(k,x,Mx,Ex,sin_result,cos_result);

    T sin_resultf, cos_resultf;
    scaled_fixed2ieee(cos_result, cos_resultf, 0);
    scaled_fixed2ieee(sin_result, sin_resultf, -Ex);

    // Negate and swap the results, based on which quadrant we're in.
    // This decision is done using some tables.  We use the second
    // half of each table if the result is negative, which means
    // everything is quadrant swapped.

    ap_uint<4> index = k;
    index[3] = din.sign;
    fp_struct<T> sin_results(sin_resultf);
    fp_struct<T> cos_results(cos_resultf);

    if(neg_sin_table[index]) { sin_results.sign = 1; }
    if(neg_cos_table[index]) { cos_results.sign = 1; }

    T s_out, c_out;
    if(din.exp == 0 && din.sig == 0) { // t_in == 0.0
        sin_results.sign = din.sign;
        sin_results.exp = 0;
        sin_results.sig = 0;
        cos_results.sign = 0;
        cos_results.exp = fp_struct<T>::EXP_BIAS;
        cos_results.sig = 0;
    } else if(din.exp == fp_struct<T>::EXP_INFNAN) { // +inf, -inf, nan
        sin_results.sign = 0;
        sin_results.exp = -1; // all ones
        sin_results.sig = -1; // all ones
        cos_results.sign = 0;
        cos_results.exp = -1; // all ones
        cos_results.sig = -1; // all ones
    }

    if(swap_table[k]) {
        s_out = cos_results.to_ieee();
        c_out = sin_results.to_ieee();
    } else {
        s_out = sin_results.to_ieee();
        c_out = cos_results.to_ieee();
    }

    *s = s_out;
    *c = c_out;
}


template<class T>
T sin_or_cos(T t_in, bool do_cos, bool do_pi)
{

    const int g = value_list<T>::g;
    const int p1 = value_list<T>::p1;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 475 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 476 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
_ssdm_SpecConstant(neg_cos_table);
# 477 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"


_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_sin_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_cos_table, 1, "COMPLETE", 0, "");

    fp_struct<T> din(t_in);






    ap_uint<3> k;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> x;
    ap_ufixed<fp_struct<T>::SIG_BITS+1+g, 0> Mx;
    ap_int<fp_struct<T>::EXP_BITS> Ex;

    int exactly_pi_over_2 = 0;
    if(do_pi) {
        range_redux_payne_hanek_hotbm_pi<p1,T>(t_in,k,x,Mx,Ex,exactly_pi_over_2);
    } else {
        range_redux_payne_hanek_hotbm<p1,T>(t_in,k,x,Mx,Ex);
    }

    bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
    if(cos_basis) {
        // In this case, we are using cos() as the basis, so we don't
        // multiply by Mx*2^Ex.
        Mx = ap_ufixed<value_list<T>::W_dout, 0, SC_RND, SC_SAT>(1);
        Ex = 0;
    }

    ap_ufixed<value_list<T>::W_dout, 1> result = value_list<T>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);
    T resultf;
    scaled_fixed2ieee(result, resultf, -Ex);

    //bool sin_basis = do_cos? swap_table[k]:!swap_table[k];

    if(exactly_pi_over_2) {
        resultf = 0.7071067811865475244008443;
    }
 fp_struct<T> results(resultf);

    // Negate and swap the results, based on which quadrant we're in.
    // This decision is done using some tables.  We use the second
    // half of each table if the result is negative, which means
    // everything is quadrant swapped.
    ap_uint<4> index = k;
    index[3] = din.sign;
    if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
        results.sign = 1;
    }

    if(din.exp == 0 && (do_pi ? 1 : din.sig == 0)) { // t_in == 0.0
        // Note that handling subnormals correctly for sinpif/cospif is harder
        // than sinf/cosf.  So for cospif and sinpif, we do flush-to-zero
        // for all subnormals.
        results.sign = din.sign;
        results.exp = 0;
        results.sig = 0;
        if(do_cos) {
            results.sign = 0;
            results.exp = fp_struct<T>::EXP_BIAS;
        }
    } else if(din.exp == fp_struct<T>::EXP_INFNAN) { // +inf, -inf, nan
        results.sign = 0;
        results.exp = -1; // all ones
        results.sig = -1; // all ones
    }
    return results.to_ieee();
}

template<int W, int I>
ap_fixed<W,2> // Result has same number of fractional bits as the input.
sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi, typename enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
{
    const int WO = W;
    const int g = 3;

    const bool swap_table[8] = {0,1,1,0,0,1,1,0};
_ssdm_SpecConstant(swap_table);
# 557 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 558 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
_ssdm_SpecConstant(neg_cos_table);
# 559 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( swap_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_sin_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_cos_table, 1, "COMPLETE", 0, "");
// #pragma HLS RESOURCE variable=swap_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_sin_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_cos_table core=ROM_1P_LUTRAM





    ap_uint<3> k;
    ap_ufixed<WO+1+g, 0> x;
    ap_ufixed<WO+1+g, 0> Mx;
    ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

    int exactly_pi_over_4 = 0;
    bool is_negative = t_in[t_in.wl()-1];
    ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

    if(do_pi) {
        k = din*4;
        x = din*4;
        ap_ufixed<W, 1> Mx_bits_extended = din*4;



        exactly_pi_over_4 = (Mx_bits_extended == 1);
    } else {
        ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846 /* pi */);
        k = Wx;
        x = Wx;
    }



    // If we're in an odd quadrant, then the base functions need to be flipped.
    if(k[0] == 1) {
        x = 1-x;
    }
    Mx = x;

    bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
    if(cos_basis) {
        // In this case, we are using cos() as the basis, so we don't
        // multiply by Mx*2^Ex.
        Mx = ap_ufixed<value_list<float>::W_dout, 0, SC_RND, SC_SAT>(1);
        Ex = 0;
    }

    ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

    if(exactly_pi_over_4) {
        result = 0.7071067811865475244008443;
    }

    // Negate and swap the results, based on which quadrant we're in.
    // This decision is done using some tables.  We use the second
    // half of each table if the result is negative, which means
    // everything is quadrant swapped.

    ap_uint<4> index = k;
    index[3] = is_negative;





    if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
        return -result;
    } else {
        return result;
    }
}

    struct sin_cos_fixed_16 {
    typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

    template <int W_dout>
    static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
                                               ap_uint<2> &k,
                                               ap_ufixed<W_dout, 0> &x){

_ssdm_op_SpecResource(first_order_fixed_16::sin_cos_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_order_fixed_16::sin_cos_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

        ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
        ap_ufixed<W_dout-alpha-beta1, -alpha> B = x;

        ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
        ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
        ap_ufixed<W_dout, 1> result = (t1+t2);
# 665 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
    }

public :
inline __attribute__((always_inline)) sin_cos_fixed_16() { _ssdm_SpecConstant(&g); _ssdm_SpecConstant(&p1); _ssdm_SpecConstant(&alpha); _ssdm_SpecConstant(&beta1); }
# 667 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
};


/*
 * The Quadrants k for positive numbers:
 *  1 0
 *  2 3
 * The Quadrants k for negative numbers:
 *  2 3
 *  1 0
 */
template<int W, int I>
ap_fixed<W,2> // Result has same number of fractional bits as the input.
sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi, typename enable_if<W <= 16, bool>::type dummy = true)
{
    const int WO = W;
    const int g = 4;

    const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
_ssdm_SpecConstant(neg_sin_table);
# 685 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

    const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
_ssdm_SpecConstant(neg_cos_table);
# 686 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

_ssdm_SpecArrayPartition( neg_sin_table, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( neg_cos_table, 1, "COMPLETE", 0, "");
// #pragma HLS RESOURCE variable=swap_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_sin_table core=ROM_1P_LUTRAM
// #pragma HLS RESOURCE variable=neg_cos_table core=ROM_1P_LUTRAM





    ap_uint<2> k;
    ap_ufixed<WO+1+g, 0> x;

    bool is_negative = t_in[t_in.wl()-1];
    ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

    if(do_pi) {
        k = din*2;
        x = din*2;
        ap_ufixed<W, 1> Mx_bits_extended = din*2;



    } else {
        ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846 /* pi */);
        k = Wx;
        x = Wx;
    }



    bool is_special_case = false;
    // If we're in an odd quadrant, then the base functions need to be flipped.
    if((k[0] == 1) ^ !do_cos) {
        // The approximation is designed on the interval [0,1), and x has no integer bits.
        // If x == 0, then 1-x = 1 and we treat it as a special case later.
        ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
        x = Wx;
        is_special_case = (Wx[Wx.wl()-1] == 1);
    }

    ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

    if(is_special_case) {
        ap_uint<3> index = k;
        index[2] = do_cos;
        const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
_ssdm_SpecConstant(special_case_table);
# 733 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"

        result(result.wl()-2,0) = 0;
        result[result.wl()-1] = special_case_table[index];
    }

    // Negate and swap the results, based on which quadrant we're in.
    // This decision is done using some tables.  We use the second
    // half of each table if the result is negative, which means
    // everything is quadrant swapped.

    {
        ap_uint<3> index = k;
        index[2] = is_negative;



        if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
            return -result;
        } else {
            return result;
        }
    }
}

template<class T> ap_ufixed<31,1> tanh_approximation(ap_ufixed<31, 0> &dout)
{
     const int g = value_list<T>::g;
 const int alpha = 9;
 const int beta1 = 0;
        const int beta2 = 0;
_ssdm_op_SpecResource(second_tanh_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_tanh_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(second_tanh_K2, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

    ap_uint<alpha> A = dout(dout.wl()-dout.iwl()-1,dout.wl()-dout.iwl()-alpha);

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta1, -alpha> B = dout;

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta2, -alpha> B_trunc = B;
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t1 = second_tanh_K0[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t2 = B*second_tanh_K1[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t3 = B_squared*second_tanh_K2[A];
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1, 1> result =t1+t2+t3;
# 796 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
}

template<class T> ap_ufixed<15,1> tanh_approximation(ap_ufixed<15, 0> &dout)
{
     const int g = value_list<T>::g;
 const int alpha = 9;
 const int beta1 = 0;
_ssdm_op_SpecResource(first_tanh_K0, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");
_ssdm_op_SpecResource(first_tanh_K1, "", "ROM_1P_LUTRAM", "", -1, "", "", "", "", "");

    ap_uint<alpha> A = dout(dout.wl()-dout.iwl()-1,dout.wl()-dout.iwl()-alpha);

    ap_ufixed<fp_struct<T>::SIG_BITS+g+1-alpha-beta1, -alpha> B = dout;
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t1 = second_tanh_K0[A];
    ap_fixed<fp_struct<T>::SIG_BITS+g+1, 1> t2 = B*second_tanh_K1[A];
    ap_ufixed<fp_struct<T>::SIG_BITS+g+1, 1> result =t1+t2;
# 826 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_hotbm.h"
 return result;
}


static
float
cosf(float t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
float
sinf(float t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
float
cospif(float t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
float
sinpif(float t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

static
half
half_cos(half t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
half
half_sin(half t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
half
half_cospi(half t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
half
half_sinpi(half t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

static
double
cos(double t_in)
{
    return sin_or_cos(t_in, 1, 0);
}

static
double
sin(double t_in)
{
    return sin_or_cos(t_in, 0, 0);
}

static
double
cospi(double t_in)
{
    return sin_or_cos(t_in, 1, 1);
}

static
double
sinpi(double t_in)
{
    return sin_or_cos(t_in, 0, 1);
}

template<int W, int I>
ap_fixed<W, 2> cosf(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 1, 0);
}
template<int W, int I>
ap_fixed<W, 2> sinf(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 0, 0);
}

template<int W, int I>
ap_fixed<W, 2> cospif(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 1, 1);
}
template<int W, int I>
ap_fixed<W, 2> sinpif(ap_fixed<W, I> t_in)
{
    return sinf_or_cosf<W>(t_in, 0, 1);
}

static void sincos(double t_in, double *s, double *c) {
    generic_sincos(t_in, s, c);
}
static void sincosf(float t_in, float *s, float *c) {
    generic_sincos(t_in, s, c);
}
static void half_sincos(half t_in, half *s, half *c) {
    generic_sincos(t_in, s, c);
}

}


/* @}*/




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 301 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

// sin
static double sin(double t_in)
{
    return hotbm::sin(t_in);
}
static float sin(float t_in)
{
    return hotbm::sinf(t_in);
}
static float sinf(float t_in)
{
    return hotbm::sinf(t_in);
}
static half half_sin(half t_in)
{
    return hotbm::half_sin(t_in);
}
static half sin(half t_in)
{
    return ::hls::half_sin(t_in);
}

// cos
static double cos(double t_in)
{
    return hotbm::cos(t_in);
}
static float cos(float t_in)
{
    return hotbm::cosf(t_in);
}
static float cosf(float t_in)
{
    return hotbm::cosf(t_in);
}
static half half_cos(half t_in)
{
    return hotbm::half_cos(t_in);
}
static half cos(half t_in)
{
    return ::hls::half_cos(t_in);
}

//fixed-point version
template<int W, int I>
ap_fixed<W, 2> cosf(ap_fixed<W, I> t_in)
{
    return hotbm::cosf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinf(ap_fixed<W, I> t_in)
{
    return hotbm::sinf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> cos(ap_fixed<W, I> t_in)
{
    return hotbm::cosf(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sin(ap_fixed<W, I> t_in)
{
    return hotbm::sinf(t_in);
}

//opencl built-in functions
//sinpi
static double sinpi(double t_in)
{
    return hotbm::sinpi(t_in);
}
static float sinpif(float t_in)
{
    return hotbm::sinpif(t_in);
}
static half half_sinpi(half t_in)
{
    return hotbm::half_sinpi(t_in);
}

//cospi
static double cospi(double t_in)
{
    return hotbm::cospi(t_in);
}
static float cospif(float t_in)
{
    return hotbm::cospif(t_in);
}
static half half_cospi(half t_in)
{
    return hotbm::half_cospi(t_in);
}

//fixed-point version
template<int W, int I>
ap_fixed<W, 2> cospif(ap_fixed<W, I> t_in)
{
    return hotbm::cospif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinpif(ap_fixed<W, I> t_in)
{
    return hotbm::sinpif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> cospi(ap_fixed<W, I> t_in)
{
    return hotbm::cospif(t_in);
}
template<int W, int I>
ap_fixed<W, 2> sinpi(ap_fixed<W, I> t_in)
{
    return hotbm::sinpif(t_in);
}

//sincos
static void sincos(double x, double *sin, double *cos)
{
    hotbm::sincos(x, sin, cos);
}
static void sincosf(float x, float *sin, float *cos)
{
    hotbm::sincosf(x, sin, cos);
}
static void half_sincos(half x, half *sin, half *cos)
{
    hotbm::half_sincos(x, sin, cos);
}

static double atan(double t_in)
{
 return cordic::atan(t_in);
}

static float atanf(float t_in)
{
 return cordic::atanf(t_in);
}

static half half_atan(half t_in)
{
 return cordic::half_atan(t_in);
}

static double atan2(double y_in, double x_in)
{
 return cordic::atan2(y_in, x_in);
}

static float atan2f(float y_in, float x_in)
{
 return cordic::atan2f(y_in, x_in);
}

static half half_atan2(half y_in, half x_in)
{
 return cordic::half_atan2(y_in, x_in);
}

static double sinh(double t_in)
{
 return cordic::sinh(t_in);
}
static float sinhf(float t_in)
{
 return cordic::sinhf(t_in);
}
static half half_sinh(half t_in)
{
 return cordic::half_sinh(t_in);
}

static double cosh(double t_in)
{
 return cordic::cosh(t_in);
}
static float coshf(float t_in)
{
 return cordic::coshf(t_in);
}
static half half_cosh(half t_in)
{
 return cordic::half_cosh(t_in);
}

}





extern "C" {

    double _ssdm_op_DRecip(double) __attribute__ ((nothrow));
    float _ssdm_op_FRecip(float) __attribute__ ((nothrow));
    double _ssdm_op_DRSqrt(double) __attribute__ ((nothrow));
    float _ssdm_op_FRSqrt(float) __attribute__ ((nothrow));

}



namespace hls {

static float tanf(float t_in)
{
 float s_out, c_out;
    fp_struct<float> fs = t_in;
    if(fs.exp <= 0x1) {
        //subnormal or zero or small number
        return t_in;
    } else {
        ::hls::sincosf(t_in, &s_out, &c_out);
        return ((s_out)/(c_out));
    }
}

static double tan(double t_in)
{
 double s_out, c_out;
    fp_struct<double> fs = t_in;
    if(fs.exp <= 0x1) {
        //subnormal or zero or small number
        return t_in;
    } else {
        ::hls::sincos(t_in, &s_out, &c_out);
        return ((s_out)/(c_out));
    }
}
static half half_tan(half t_in)
{
 half s_out, c_out;
    fp_struct<half> fs = t_in;
    if(fs.exp <= 0x1) {
        //subnormal or zero or small number
        return t_in;
    } else {
        ::hls::half_sincos(t_in, &s_out, &c_out);
        return s_out/c_out;
    }
}
static half tan(half t_in)
{
    return ::hls::half_tan(t_in);
}

static float logf(float x)
{
    return ::logf(x);
    //return hls::log_reduce::logf(x);
}
static float log2f(float x)
{
    //return HLS_FPO_MULF(logf(x), 1.442695040888963407359924681001892137426645954153f);
    return hls::log_reduce::log2f(x);
}
static float log10f(float x)
{
    return ((logf(x)) * (0.434294481903251827651128918916605082294397005f));
    //return hls::log_reduce::log10f(x);
}
static float logbf(float x)
{
    return hls::log_reduce::logbf(x);
}

static double log(double x)
{
    return ::log(x);
    //return hls::log_reduce::log(x);
}
static float log(float x)
{
    return ::logf(x);
    //return hls::log_reduce::log(x);
}
static half log(half x)
{
    return hls::log_reduce::log(x);
}
static double log2(double x)
{
    //return HLS_FPO_MUL(log(x), 1.442695040888963407359924681001892137426645954153);
    return hls::log_reduce::log2(x);
}
static float log2(float x)
{
    return hls::log_reduce::log2(x);
}
static half log2(half x)
{
    return hls::log_reduce::log2(x);
}
static double log10(double x)
{
    return ((log(x)) * (0.434294481903251827651128918916605082294397005));
    //return hls::log_reduce::log10(x);
}
static float log10(float x)
{
    return ((logf(x)) * (0.434294481903251827651128918916605082294397005f));
    //return hls::log_reduce::log10(x);
}
static half log10(half x)
{
    return hls::log_reduce::log10(x);
}
static double logb(double x)
{
    return hls::log_reduce::logb(x);
}
static float logb(float x)
{
    return hls::log_reduce::logb(x);
}
static half logb(half x)
{
    return hls::log_reduce::logb(x);
}

static half half_log(half x) {
    return hls::log_reduce::half_log(x);
}
static half half_log10(half x) {
    return hls::log_reduce::half_log10(x);
}
static half half_log2(half x) {
    return hls::log_reduce::half_log2(x);
}
static half half_logb(half x) {
    return hls::log_reduce::half_logb(x);
}

static double log1p(double x) {
    return hls::log_reduce::log1p(x);
}
static float log1p(float x) {
    return hls::log_reduce::log1p(x);
}
static half log1p(half x) {
    return hls::log_reduce::log1p(x);
}
static half half_log1p(half x) {
    return hls::log_reduce::log1p(x);
}
static float log1pf(float x) {
    return hls::log_reduce::log1p(x);
}

static half pow(half x, half y) {
 return hls::pow_reduce::pow(x,y);
}
static float pow(float x, float y) {
        return hls::pow_reduce::pow(x,y);
}
static double pow(double x, double y) {
        return hls::pow_reduce::pow(x,y);
}
static float powf(float x, float y) {
        return hls::pow_reduce::pow(x,y);
}
static half half_pow(half x, half y) {
        return hls::pow_reduce::pow(x,y);
}

static half powr(half x, half y) {
        return hls::pow_reduce::powr(x,y);
}
static float powr(float x, float y) {
        return hls::pow_reduce::powr(x,y);
}
static double powr(double x, double y) {
        return hls::pow_reduce::powr(x,y);
}
static float powrf(float x, float y) {
        return hls::pow_reduce::powr(x,y);
}
static half half_powr(half x, half y) {
        return hls::pow_reduce::powr(x,y);
}

static half pown(half x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static float pown(float x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static double pown(double x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static float pownf(float x, int y) {
        return hls::pow_reduce::pown(x,y);
}
static half half_pown(half x, int y) {
        return hls::pow_reduce::pown(x,y);
}

static half rootn(half x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static float rootn(float x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static double rootn(double x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static float rootnf(float x, int y) {
        return hls::pow_reduce::rootn(x,y);
}
static half half_rootn(half x, int y) {
        return hls::pow_reduce::rootn(x,y);
}



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/
/* File: hls_rsr.h
 *
 * Description:
 *     reciprocal, square root and reciprocal square root functions based on algorithms introduced in 
 *     "Reciprocation, Square Root, Inverse Square Root, and 
 *     Some Elementary Functions Using Small Multipliers" by Milos D.Ercegovac et al.
 *
 */


namespace hls_rsr {



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr_tables.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/
/* File: hls_rsr_tables.h
 *
 * Description:
 *     looking up tables for reciprocal, square root and reciprocal square root functions 
 *		 the value of the key parameter k_bits is chosen to avoid TMD accrding to the book 
 *		 "Elementary Functions Algorithms and Implementation" by Jean-Michel Muller
 */



namespace {

 template<typename T> class Trait{};

 template<> class Trait<half>{
  public:

   // k_bits is the key parameter in this algorithm
   // it controls the size of LUTs, size of multipliers, etc.
   // the accuracy bit is 4*k_bits-4 for reciprocal 
   // 					4*k_bits-3 for both sqrt and rsqrt
   // for half precision k_bits=4 is enough for faithfull rounding
   // to avoid TMD, k_bits is chosen to 6 for correctness rounding
   const static int k_bits = 6;
   const static int n_bits = 4 * k_bits;

   typedef ap_ufixed<k_bits + 1, 0> LUT_RType;
   typedef ap_ufixed<n_bits + 1, 1> LUT_MType;
   const static int LUTsize = 1 << k_bits;
   const static ap_ufixed<1, -fp_struct<half>::SIG_BITS> RC;

 };

 const ap_ufixed<1, -fp_struct<half>::SIG_BITS> Trait<half>::RC = 0x0.002p0;


 template <typename R, typename T, int size> class RTable {};

 template<> class RTable<typename Trait<half>::LUT_RType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_RType arrayR[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_RType RTable<Trait<half>::LUT_RType,
    half, Trait<half>::LUTsize>::arrayR[Trait<half>::LUTsize] = {
     0x1,
     0x0.fcp0,
     0x0.f8p0,
     0x0.f4p0,
     0x0.f0p0,
     0x0.ecp0,
     0x0.eap0,
     0x0.e6p0,
     0x0.e2p0,
     0x0.e0p0,
     0x0.dcp0,
     0x0.dap0,
     0x0.d6p0,
     0x0.d4p0,
     0x0.d2p0,
     0x0.cep0,
     0x0.ccp0,
     0x0.cap0,
     0x0.c6p0,
     0x0.c4p0,
     0x0.c2p0,
     0x0.c0p0,
     0x0.bep0,
     0x0.bcp0,
     0x0.bap0,
     0x0.b8p0,
     0x0.b6p0,
     0x0.b4p0,
     0x0.b2p0,
     0x0.b0p0,
     0x0.aep0,
     0x0.acp0,
     0x0.aap0,
     0x0.a8p0,
     0x0.a6p0,
     0x0.a4p0,
     0x0.a2p0,
     0x0.a2p0,
     0x0.a0p0,
     0x0.9ep0,
     0x0.9cp0,
     0x0.9cp0,
     0x0.9ap0,
     0x0.98p0,
     0x0.96p0,
     0x0.96p0,
     0x0.94p0,
     0x0.92p0,
     0x0.92p0,
     0x0.90p0,
     0x0.8ep0,
     0x0.8ep0,
     0x0.8cp0,
     0x0.8cp0,
     0x0.8ap0,
     0x0.88p0,
     0x0.88p0,
     0x0.86p0,
     0x0.86p0,
     0x0.84p0,
     0x0.84p0,
     0x0.82p0,
     0x0.82p0,
     0x0.80p0
    };


 template <typename M, typename T, int size> class RecipMTable {};
 template <typename M, typename T, int size> class SqrtMTable {};
 template <typename M, typename T, int size> class RsqrtMTable {};
// 	template<> class RecipMTable<typename Trait<half>::LUT_RType,
// 		half, Trait<half>::LUTsize> {
// 			public:
// 				static const typename Trait<half>::LUT_RType *arrayM;
// 		};
// 	const Trait<half>::LUT_RType *RecipMTable<Trait<half>::LUT_RType,
// 				half, Trait<half>::LUTsize>::arrayM = RTable<Trait<half>::LUT_RType,
// 				half, Trait<half>::LUTsize>::arrayR;
 template<> class RsqrtMTable<typename Trait<half>::LUT_MType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_MType arrayM[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_MType RsqrtMTable<Trait<half>::LUT_MType,
    half, Trait<half>::LUTsize>::arrayM[Trait<half>::LUTsize] = {
     0x0,
     0x0.fdfdfb8p0,
     0x0.fbf7df0p0,
     0x0.f9ed908p0,
     0x0.f7def58p0,
     0x0.f5cbf20p0,
     0x0.f4c0c00p0,
     0x0.f2a6ea0p0,
     0x0.f088618p0,
     0x0.ef77508p0,
     0x0.ed517f0p0,
     0x0.ec3cb70p0,
     0x0.ea0f500p0,
     0x0.e8f6a90p0,
     0x0.e7dcad8p0,
     0x0.e5a4a88p0,
     0x0.e486948p0,
     0x0.e367190p0,
     0x0.e123d40p0,
     0x0.e000000p0,
     0x0.dedaad8p0,
     0x0.ddb3d70p0,
     0x0.dc8b768p0,
     0x0.db61858p0,
     0x0.da35fe0p0,
     0x0.d908d88p0,
     0x0.d7da0f8p0,
     0x0.d6a99b0p0,
     0x0.d577748p0,
     0x0.d443948p0,
     0x0.d30df30p0,
     0x0.d1d6890p0,
     0x0.d09d4e0p0,
     0x0.cf623a0p0,
     0x0.ce25448p0,
     0x0.cce6648p0,
     0x0.cba5918p0,
     0x0.cba5918p0,
     0x0.ca62c18p0,
     0x0.c91deb8p0,
     0x0.c7d7060p0,
     0x0.c7d7060p0,
     0x0.c68e058p0,
     0x0.c542e10p0,
     0x0.c3f58c8p0,
     0x0.c3f58c8p0,
     0x0.c2a5fd8p0,
     0x0.c154280p0,
     0x0.c154280p0,
     0x0.c000000p0,
     0x0.bea9790p0,
     0x0.bea9790p0,
     0x0.bd50868p0,
     0x0.bd50868p0,
     0x0.bbf51a8p0,
     0x0.ba97280p0,
     0x0.ba97280p0,
     0x0.b936a08p0,
     0x0.b936a08p0,
     0x0.b7d3750p0,
     0x0.b7d3750p0,
     0x0.b66d958p0,
     0x0.b66d958p0,
     0x0.b504f30p0
    };
 template<> class SqrtMTable<typename Trait<half>::LUT_MType,
  half, Trait<half>::LUTsize> {
   public:
    static const typename Trait<half>::LUT_MType arrayM[Trait<half>::LUTsize];
  };
 const Trait<half>::LUT_MType SqrtMTable<Trait<half>::LUT_MType,
    half, Trait<half>::LUTsize>::arrayM[Trait<half>::LUTsize] = {
     0x0,
     0x1.020614p0,
     0x1.0418a4p0,
     0x1.063833p0,
     0x1.08654ap0,
     0x1.0aa07bp0,
     0x1.0bc38ep0,
     0x1.0e150dp0,
     0x1.10763cp0,
     0x1.11aceep0,
     0x1.1426fap0,
     0x1.156a87p0,
     0x1.17ff2ep0,
     0x1.19507ep0,
     0x1.1aa69ep0,
     0x1.1d61c0p0,
     0x1.1ec701p0,
     0x1.20318cp0,
     0x1.23170dp0,
     0x1.249249p0,
     0x1.26135ep0,
     0x1.279a74p0,
     0x1.2927b2p0,
     0x1.2abb43p0,
     0x1.2c5552p0,
     0x1.2df60cp0,
     0x1.2f9d9fp0,
     0x1.314c3dp0,
     0x1.330218p0,
     0x1.34bf63p0,
     0x1.368457p0,
     0x1.38512bp0,
     0x1.3a261bp0,
     0x1.3c0365p0,
     0x1.3de948p0,
     0x1.3fd807p0,
     0x1.41cfe9p0,
     0x1.41cfe9p0,
     0x1.43d136p0,
     0x1.45dc3ap0,
     0x1.47f144p0,
     0x1.47f144p0,
     0x1.4a10a9p0,
     0x1.4c3abep0,
     0x1.4e6fdfp0,
     0x1.4e6fdfp0,
     0x1.50b06ap0,
     0x1.52fcc4p0,
     0x1.52fcc4p0,
     0x1.555555p0,
     0x1.57ba8bp0,
     0x1.57ba8bp0,
     0x1.5a2cd8p0,
     0x1.5a2cd8p0,
     0x1.5cacb7p0,
     0x1.5f3aa6p0,
     0x1.5f3aa6p0,
     0x1.61d72bp0,
     0x1.61d72bp0,
     0x1.6482d3p0,
     0x1.6482d3p0,
     0x1.673e32p0,
     0x1.673e32p0,
     0x1.6a09e6p0,
    };

}
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h" 2

 // fixed point number to float point number with correct rounding
 template <typename T, typename R>
  void fixed2Float(T in, int exponent, int sign, R &result) {
   fp_struct<R> out;
   out.sign = sign;
   out.exp = exponent;

   T ain = in - static_cast<T>(0x1.0p0);
   (((ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS) >= 0) ? static_cast<void> (0) : __assert_fail ("(ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS) >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h", 53, __PRETTY_FUNCTION__));
   ((ain.wl() - ain.iwl() - 2 >= 0) ? static_cast<void> (0) : __assert_fail ("ain.wl() - ain.iwl() - 2 >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h", 54, __PRETTY_FUNCTION__));
   int bits = ain.wl() - ain.iwl() - 2;
   // round to the nearesst, to even when tie
   if(bits >= fp_struct<R>::SIG_BITS) {
    ap_uint<1> Lb, Gb, Tb;
    Lb = ain[ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS];
    Gb = ain[ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS - 1];
    Tb = (ain(ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS - 2, 0) != 0)? 1: 0;
    if( Gb & (Lb | Tb) ) {
     ain += Trait<R>::RC;
    }
    if (ain >= static_cast<T>(0x1.0p0)){
     ain -= static_cast<T>(0x1.0p0);
     ++out.exp;
     ain >>= 1;
    }
   }
   out.sig = ain(ain.wl() - ain.iwl() - 1, ain.wl() - ain.iwl() - fp_struct<R>::SIG_BITS);

   result = out.to_ieee();
  }


 // Reciprocal functions
 template<typename T> class RecipTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits, 1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_RType TypeMT;
   typedef typename Trait<T>::LUT_RType TypeMM;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   typedef ap_uint<Trait<T>::k_bits * 2 + 1> TypeS;
   static const int C_A22 = 1, C_A23 = 1, C_A222 = 1;
   static const int C_SHIFT = 0, A_SHIFT = 0;
   // when x = inf, return 0
   static bool f_procInf(const T & x, T & result) {
    result = ::hls::copysign(static_cast<T>(0), x);
    return true;
   }

   // when x = 0, return inf
   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(fp_struct<T>::infinity(), x);
    return true;
   }

   // when input is too too large, return zero
   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if((xg.exp == (1 << fp_struct<T>::EXP_BITS) - 2) ||
      ((xg.exp == (1 << fp_struct<T>::EXP_BITS) - 3) && xg.sig != 0)) {
     result = ::hls::copysign(static_cast<T>(0), x);
     return true;
    }
    return false;
   }

   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS - xg.expv(), xg.sign, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = yA - A0;
   }
   static void f_getM(int indexM, TypeMM &M0) {
    M0 = RTable<TypeMM, half, Trait<T>::LUTsize>::arrayR[indexM];

   }

   // yR is the inverse of 1.Fx, in range of 0.5<= yR <1
   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    yR <<= 1;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS - xg.expv() - 1, xg.sign, result);
   }

public :
inline __attribute__((always_inline)) RecipTrait() { _ssdm_SpecConstant(&C_A22); _ssdm_SpecConstant(&C_A23); _ssdm_SpecConstant(&C_A222); _ssdm_SpecConstant(&C_SHIFT); _ssdm_SpecConstant(&A_SHIFT); }
# 136 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h"
};

 // Square root functions
 template<typename T> class SqrtTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits,
       1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_MType TypeMM;
   typedef ap_ufixed<3 * Trait<T>::k_bits + 2, 1> TypeMT;
   typedef ap_uint<Trait<T>::k_bits * 2 + 1> TypeS;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   static const int C_A22 = 1, C_A23 = 1, C_A222 = 1;
   static const int C_SHIFT = 1, A_SHIFT = 3;
   static const TypeRe SQRT2;// 1.4142135623730950488016887242097;
   // when x = inf, return 0
   static bool f_procInf(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign)
     return false;
    result = fp_struct<T>::infinity();
    return true;
   }
   // when x = 0, return inf
   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(static_cast<T>(0), x);
    return true;
   }
   // when input is negative except -0, return nan
   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign && xg.exp){
     result = ::hls::nan("");
     return true;
    }
    return false;
   }
   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     fixed2Float(SQRT2, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
    else
     fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = (A0 >> 1) - yA;
   }
   static void f_getM(int indexM, TypeMM &M0) {
    M0 = SqrtMTable<typename Trait<T>::LUT_MType,
      T, Trait<T>::LUTsize>::arrayM[indexM];
   }

   // yR is the sqrt of 1.Fx, in range of 1<= yR <SQRT2
   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     yR *= SQRT2;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS + (xg.expv() >> 1), 0, result);
   }

public :
inline __attribute__((always_inline)) SqrtTrait() { _ssdm_SpecConstant(&C_A22); _ssdm_SpecConstant(&C_A23); _ssdm_SpecConstant(&C_A222); _ssdm_SpecConstant(&C_SHIFT); _ssdm_SpecConstant(&A_SHIFT); _ssdm_SpecConstant(&SQRT2); }
# 202 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h"
};

 template<typename T> const ap_ufixed<1 + Trait<T>::n_bits, 1> SqrtTrait<T>::SQRT2 = 1.4142135623730950488016887242097;


 // Reciprocal square root function
 template<typename T> class RsqrtTrait {
  public:
   typedef ap_ufixed<fp_struct<T>::SIG_BITS + 1, 1> FxType;
   typedef ap_fixed<Trait<T>::n_bits - Trait<T>::k_bits + 1,
       -Trait<T>::k_bits + 1> TypeA;
   typedef ap_uint<Trait<T>::k_bits * 2 + 3> TypeP;
   typedef ap_fixed<1 + Trait<T>::n_bits - 2 * Trait<T>::k_bits,
       1 - 2 * Trait<T>::k_bits> TypeY;
   typedef typename Trait<T>::LUT_RType TypeR;
   typedef typename Trait<T>::LUT_MType TypeMM;
   typedef ap_ufixed<3 * Trait<T>::k_bits + 2, 1> TypeMT;
   typedef ap_uint<Trait<T>::k_bits * 2 + 3> TypeS;
   typedef ap_ufixed<1 + Trait<T>::n_bits, 1> TypeRe;

   static const int C_A22 = 3, C_A23 = 3, C_A222 = 5;
   static const int C_SHIFT = 1, A_SHIFT = 3;
   static const TypeRe SQRT2;// = 1.4142135623730950488016887242097;
   // when x = inf, return 0
   static bool f_procInf(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign)
     return false;
    result = 0.0;
    return true;
   }
   // when x = 0, return inf
   static bool f_procZero(const T & x, T & result) {
    result = ::hls::copysign(fp_struct<T>::infinity(), x);
    return true;
   }
   // when input is negative except -0, return nan 
   static bool f_preProc(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.sign && xg.exp){
     result = ::hls::nan("");
     return true;
    }
    return false;
   }
   static bool f_procOne(const T & x, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     fixed2Float(SQRT2, fp_struct<T>::EXP_BIAS - (xg.expv() >> 1) - 1, 0, result);
    else
     fixed2Float<FxType, T>(1, fp_struct<T>::EXP_BIAS - (xg.expv() >> 1), 0, result);
    return true;
   }

   static void f_evalueA(TypeY yA, TypeA & A0) {
    A0 = yA - (A0 >> 1);
   }

   static void f_getM(int indexM, TypeMM & M0) {
    M0 = RsqrtMTable<typename Trait<T>::LUT_MType,
      T, Trait<T>::LUTsize>::arrayM[indexM];
   }

   // yR is the rsqrt of 1.Fx, in range of inv(SQRT2)<= yR <1
   static void f_postProc(const T & x, TypeRe yR, T & result) {
    fp_struct<T> xg(x);
    if(xg.expv() & 0x01)
     yR *= SQRT2;
    else
     yR <<= 1;
    fixed2Float(yR, fp_struct<T>::EXP_BIAS - ((xg.expv() + 2) >> 1), 0, result);
   }

public :
inline __attribute__((always_inline)) RsqrtTrait() { _ssdm_SpecConstant(&C_A22); _ssdm_SpecConstant(&C_A23); _ssdm_SpecConstant(&C_A222); _ssdm_SpecConstant(&C_SHIFT); _ssdm_SpecConstant(&A_SHIFT); _ssdm_SpecConstant(&SQRT2); }
# 274 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_rsr.h"
};


 template<typename T> const ap_ufixed<1 + Trait<T>::n_bits, 1> RsqrtTrait<T>::SQRT2 = 1.4142135623730950488016887242097;

 template<typename T, typename FUN>
  T proc_generic(T x) {
   fp_struct<T> xg(x);
   T result;
   // if x = nan
   if (::hls::__isnan(x)) {
    return ::hls::nan("");
   }
   // if x = inf
   if(::hls::__isinf(x) && FUN::f_procInf(x, result)) {
    return result;
   }
   // if x = 0
   if (xg.exp == 0 && FUN::f_procZero(x, result)) {
    return result;
   }
   // if x is special for the function
   if(FUN::f_preProc(x, result))
    return result;
   // if x's mantissa part is one
   if (xg.sig == 0 && FUN::f_procOne(x, result)) {
    return result;
   }

   // y is x's mantissa
   typename FUN::FxType y = 0;
   y[y.wl() - y.iwl()] = 1;
   y(y.wl() - 1 - y.iwl(), y.wl() - y.iwl() - fp_struct<T>::SIG_BITS) = xg.sig;

   // indexR depends on first k_bits of y
   int indexR = y(y.wl() - y.iwl() - 1, y.wl() - y.iwl() - Trait<T>::k_bits);
   typename FUN::TypeR R0 = RTable<typename FUN::TypeR,
        T, Trait<T>::LUTsize>::arrayR[indexR];

   // A0 is less than 2^ -k_bits
   typename FUN::TypeA A0, Ap;
   if (indexR == 0) {
    A0 = y - 1;
   } else
    A0 = y * R0 - 1;

   bool sign_bit = false;
   if (A0[A0.wl() - 1]) {
    Ap = -A0;
    sign_bit = true;
   } else
    Ap = A0;
   ap_uint<Trait<T>::k_bits> A2, A3;
   A2=Ap(Ap.wl() - 2, Ap.wl() - Trait<T>::k_bits - 1);
   A3=Ap(Ap.wl() - Trait<T>::k_bits - 2, Ap.wl() - Trait<T>::k_bits * 2 - 1);
   typename FUN::TypeP A22 = A2 * A2, A23 = A2 * A3,
        A222 = static_cast<ap_uint<Trait<T>::k_bits> >(A22 >> Trait<T>::k_bits) * A2;

   A22 *= FUN::C_A22;
   A23 *= FUN::C_A23;
   A222 *= FUN::C_A222;

   typename FUN::TypeS Asum;
   if (sign_bit) {
    Asum = A22 + (A23 >> (Trait<T>::k_bits - 1)) + (A222 >> (Trait<T>::k_bits + FUN::C_SHIFT));
   } else {
    Asum = A22 + (A23 >> (Trait<T>::k_bits - 1)) - (A222 >> (Trait<T>::k_bits + FUN::C_SHIFT));
   }
   typename FUN::TypeY yA = 0;
   yA(Trait<T>::k_bits * 2, 0) = Asum >> FUN::A_SHIFT;
   FUN::f_evalueA(yA, A0);

   typename FUN::TypeMM M0 = R0;
   typename FUN::TypeRe yR;
   if(indexR == 0)
    yR = A0 + 1;
   else {
    FUN::f_getM(indexR, M0);
    yR = A0 * static_cast<typename FUN::TypeMT>(M0);
    yR += M0;
   }

   FUN::f_postProc(x, yR, result);
   return result;
  }


 template<typename T> static T recip(T x) {
  return proc_generic<T, RecipTrait<T> >(x);
 }
 static half half_recip(half x) {
  return recip<half>(x);
 }

 template<typename T> static T sqrt(T x) {
  return proc_generic<T, SqrtTrait<T> >(x);
 }
 static half half_sqrt(half x) {
  return sqrt<half>(x);
 }

 template<typename T> static T rsqrt(T x) {
  return proc_generic<T, RsqrtTrait<T> >(x);
 }
 static half half_rsqrt(half x) {
  return rsqrt<half>(x);
 }

 // TODO support to float and double
}
# 718 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/


/**
 * @file hls_sqrt.h
 */



template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
ap_ufixed<W,I> sqrt(ap_ufixed<W,I, _AP_Q, _AP_O> x) {
    ((I >= 0 && "Number of integer bits for sqrt() must be greater than zero") ? static_cast<void> (0) : __assert_fail ("I >= 0 && \"Number of integer bits for sqrt() must be greater than zero\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 41, __PRETTY_FUNCTION__));
    ((W >= I && "Number of integer bits for sqrt() must be less than or equal to total width") ? static_cast<void> (0) : __assert_fail ("W >= I && \"Number of integer bits for sqrt() must be less than or equal to total width\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 42, __PRETTY_FUNCTION__));
    ap_ufixed<W+1,I> factor = 0;
    int offset;
    // Since input bits are handled in pairs, the
    // start condition for even and odd integer widths
    // are handled slightly differently.
    if(I%2 == 0) {
        offset = 1;
    } else {
        offset = 0;
    }
    factor[W+1 -1-offset] = 1;
    ap_ufixed<W+1 +1,I+1> result = 0;
    ap_ufixed<W+1 +2,I+2> x2 = x;
    for(int i = W+1 -offset; i > (I-1)/2; i -= 1 ) {

        ap_ufixed<W+2+1,I+2> t = (result << 1) + factor;
        //        std::cout << x2.to_string(2) << " " << t.to_string(2) << " " << result.to_string(2) << " " << factor.to_string(2) << "\n";
        ap_ufixed<W+1,I> thisfactor = 0;
        if(x2 >= t) {
            x2 -= t;
            thisfactor = factor;
        }
        result = result + thisfactor;
        factor >>= 1;
        x2 <<= 1;
    }
    //    std::cout << W << " " << I << " " << offset << ((I-1) >> 1) << " " << x2.to_string(2) << " " << result.to_string(2) << " " << factor.to_string(2) << "\n";
    return result >> ((I-1) >> 1);
    //I <= 0 ? (I-2)/2 : (I-1)/2);
}

template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
ap_fixed<W,I> sqrt(ap_fixed<W,I, _AP_Q, _AP_O> x) {
    ap_ufixed<W-1,I-1> x2 = x;
    if(x < 0) return 0; else return ::hls::sqrt(x2);
}


template <typename T>
class cbrt_traits {};

template <> class cbrt_traits<half>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<5> &exp ) { // we = 5 for half
        // ceil((x-15)/3)+15 = ceil(x/3)+10

 // each bit of exp has a remainder of { 1, 2, 1, 2, ... }
 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
 ap_uint<3> r_l = r_0 + r_1 + r_2 + r_3 + r_4; // sum the remainders of all bits of exp

 // calculate
 // exp_r = r_l / 3
 // r = r_l % 3
 ap_uint<2> exp_r;
 ap_uint<2> r;
 exp_r[1] = ( r_l[2] & r_l[1] ); // 11x
 exp_r[0] = ( r_l[1] & r_l[0] ) | ( r_l[2] & ~r_l[1] ); // x11, 10x
     r[1] = ( ~r_l[2] & ~r_l[0] ) | ( r_l[2] & r_l[0] ); // 0x0, 1x1
     r[0] = ( ~r_l[2] & ~r_l[1] ) | ( ~r_l[1] & ~r_l[0] ); // 00x, x00
 ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 107, __PRETTY_FUNCTION__));
 ((r_l = exp_r * 3 + r) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 108, __PRETTY_FUNCTION__));

 // each bit of exp / 3 = { 0, 0, 1, 2, 5 }
        ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
        ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}

 // sum to return
 exp = exp_r + exp_2 + exp_3 + exp_4 + 10;

 return r;
    }
};

template <> class cbrt_traits<float>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<8> &exp ) { // we = 8 for float
        // ceil((x-127)/3)+127 = ceil((x-126-1)/3)+127 = ceil(x-1/3)+85

 // each bit of exp has a remainder of { 1, 2, 1, 2, ... }
 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
        ap_uint<2> r_5; {r_5 = (exp[5]) ? 2 : 0;}
        ap_uint<1> r_6; {r_6 = (exp[6]) ? 1 : 0;}
        ap_uint<2> r_7; {r_7 = (exp[7]) ? 2 : 0;}
 ap_uint<4> r_l = r_0 + r_1 + r_2 + r_3 + r_4 + r_5 + r_6 + r_7; // sum the remainders of all bits of exp

 // calculate
 // exp_r = (r_l-1) / 3
 // r = (r_l-1) % 3
 ap_uint<2> exp_r;
 ap_uint<2> r;
 exp_r[1] = ( r_l[2] & r_l[1] & r_l[0] ) | ( r_l[3] ); // x111, 1xxx
 exp_r[0] = ( r_l[2] & ~r_l[1] ) | ( r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[1] ); // x10x, x110, 1x1x
     r[1] = ( ~r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & ~r_l[1] & r_l[0] ); // 0011, x110, 1x01
     r[0] = ( ~r_l[3] & ~r_l[2] & ~r_l[0] ) | ( r_l[2] & ~r_l[1] & r_l[0] ) | ( ~r_l[2] & ~r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[1] & r_l[0] ); // 00x0, x101, x000, 1x11

 ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 149, __PRETTY_FUNCTION__));
        ((r_l = exp_r * 3 + r + 1) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r + 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 150, __PRETTY_FUNCTION__));

 // each bit of exp / 3 = { 0, 0, 1, 2, 5, 10, 21, 42 }
 ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
 ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
 ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}
        ap_uint<4> exp_5; {exp_5 = (exp[5]) ? 10 : 0;}
        ap_uint<5> exp_6; {exp_6 = (exp[6]) ? 21 : 0;}
        ap_uint<6> exp_7; {exp_7 = (exp[7]) ? 42 : 0;}

 // sum to return
 exp = exp_r + exp_2 + exp_3 + exp_4 + exp_5 + exp_6 + exp_7 + 85;

 return r;
    }
};

template <> class cbrt_traits<double>
{
public:
    static ap_uint<2> exp_cbrt ( ap_uint<11> &exp ) { // we = 11 for double
        // ceil((x-1023)/3)+1023 = ceil(x/3)+682

 // each bit of exp has a remainder of { 1, 2, 1, 2, ... }
 ap_uint<1> r_0; {r_0 = (exp[0]) ? 1 : 0;}
        ap_uint<2> r_1; {r_1 = (exp[1]) ? 2 : 0;}
        ap_uint<1> r_2; {r_2 = (exp[2]) ? 1 : 0;}
        ap_uint<2> r_3; {r_3 = (exp[3]) ? 2 : 0;}
        ap_uint<1> r_4; {r_4 = (exp[4]) ? 1 : 0;}
        ap_uint<2> r_5; {r_5 = (exp[5]) ? 2 : 0;}
        ap_uint<1> r_6; {r_6 = (exp[6]) ? 1 : 0;}
        ap_uint<2> r_7; {r_7 = (exp[7]) ? 2 : 0;}
        ap_uint<1> r_8; {r_8 = (exp[8]) ? 1 : 0;}
        ap_uint<2> r_9; {r_9 = (exp[9]) ? 2 : 0;}
        ap_uint<1> r_10; {r_10 = (exp[10]) ? 1 : 0;}
 ap_uint<4> r_l = r_0 + r_1 + r_2 + r_3 + r_4 + r_5 + r_6 + r_7 + r_8 + r_9 + r_10; // sum the remainders of all bits of exp

 // calculate
 // exp_r = r_l / 3
 // r = r_l-1 % 3
 ap_uint<3> exp_r;
 ap_uint<2> r;
 exp_r[2] = ( r_l[3] & r_l[2] ); // 11xx
 exp_r[1] = ( ~r_l[3] & r_l[2] & r_l[1] ) | ( r_l[3] & ~r_l[2] ); // 011x, 10xx
 exp_r[0] = ( ~r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( ~r_l[3] & r_l[2] & ~r_l[1] ) | ( r_l[3] & ~r_l[2] & ~r_l[1] & r_l[0] ) | ( r_l[3] & ~r_l[2] & r_l[1] ) | ( r_l[3] & r_l[2] & r_l[1] & r_l[0] ); // 0011, 010x, 1001, 101x, 1111

     r[1] = ( ~r_l[3] & ~r_l[2] & ~r_l[0] ) | ( ~r_l[3] & r_l[2] & ~r_l[1] & r_l[0] ) | ( ~r_l[2] & ~r_l[1] & ~r_l[0] ) | ( r_l[3] & ~r_l[2] & r_l[1] & r_l[0] ) | ( r_l[3] & r_l[2] & r_l[1] & ~r_l[0] ); // 00x0, 0101, x000, 1011, 1110

     r[0] = ( ~r_l[3] & ~r_l[2] & ~r_l[1] ) | ( ~r_l[3] & ~r_l[1] & ~r_l[0] ) | ( ~r_l[3] & r_l[2] & r_l[1] & r_l[0] ) | ( r_l[3] & ~r_l[2] & r_l[1] & ~r_l[0] ) | ( r_l[3] & r_l[2] & ~r_l[1] & r_l[0] ); // 000x, 0x00, 0111, 1010, 1101

        ((r < 3) ? static_cast<void> (0) : __assert_fail ("r < 3", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 200, __PRETTY_FUNCTION__));
        ((r_l = exp_r * 3 + r) ? static_cast<void> (0) : __assert_fail ("r_l = exp_r * 3 + r", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 201, __PRETTY_FUNCTION__));

 // each bit of exp / 3 = { 0, 0, 1, 2, 5, 10, 21, 42 }
 ap_uint<1> exp_2; {exp_2 = (exp[2]) ? 1 : 0;}
 ap_uint<2> exp_3; {exp_3 = (exp[3]) ? 2 : 0;}
 ap_uint<3> exp_4; {exp_4 = (exp[4]) ? 5 : 0;}
        ap_uint<4> exp_5; {exp_5 = (exp[5]) ? 10 : 0;}
        ap_uint<5> exp_6; {exp_6 = (exp[6]) ? 21 : 0;}
        ap_uint<6> exp_7; {exp_7 = (exp[7]) ? 42 : 0;}
        ap_uint<7> exp_8; {exp_8 = (exp[8]) ? 85 : 0;}
        ap_uint<8> exp_9; {exp_9 = (exp[9]) ? 170 : 0;}
        ap_uint<9> exp_10; {exp_10 = (exp[10]) ? 341 : 0;}

 // sum to return
 exp = exp_r + exp_2 + exp_3 + exp_4 + exp_5 + exp_6 + exp_7 + exp_8 + exp_9 + exp_10 + 682;

 return r;
    }
};

template <typename T>
T cbrt_generic(T x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

        fp_struct<T> xs(x);

//	x	|	0	|	inf	|	NaN	|	normal
// =============================================================================
// 	cbrt(x)	|	0	|	inf	|	NaN
//
    if ( xs.exp == 0 ) xs.sig = 0;
    if ( ( xs.exp == 0 ) || ( xs.exp == fp_struct<T>::EXP_INFNAN ) ) return xs.to_ieee();


        const static int we = fp_struct<T>::EXP_BITS;
_ssdm_SpecConstant(&we);
# 236 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h"

        const static int wf = fp_struct<T>::SIG_BITS;
_ssdm_SpecConstant(&wf);
# 237 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h"


        fp_struct<T> out;
        out.sign[0] = xs.sign[0];

    ap_uint<we> x_exp = xs.exp; // bias will be removed by exp_cbrt()
    ap_uint<2> r = cbrt_traits<T>::exp_cbrt(x_exp);
    const static int prcs = (wf+1)*3;
_ssdm_SpecConstant(&prcs);
# 244 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h"
 // max precision
    ap_ufixed<4 + prcs, 4> x_frac = 0; // = sigificant << r
    x_frac[x_frac.wl()-x_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    x_frac(x_frac.wl()-x_frac.iwl()-1,x_frac.wl()-x_frac.iwl()-wf) = xs.sig(wf-1,0);
    if (r[1] | r[0]) x_frac <<= 1;
    if (r[1]) x_frac <<= 1;

    ap_ufixed<3,3> x_frac_i;
    x_frac_i ( 2 , 0 ) = x_frac ( x_frac.wl()-2 , x_frac.wl()-x_frac.iwl() );
    x_frac_i -= 1;
    x_frac ( x_frac.wl()-2 , x_frac.wl()-x_frac.iwl() ) = x_frac_i ( 2 , 0 );

    ap_ufixed<1 + prcs, 1> res = 1; // result to return
    ap_ufixed<2 + prcs, 2> resq = 1; // sqare of result
#pragma unroll
 // each iteration calculate 1 bit of result, starting from MSB
    // bit is used to store the current bit under calculation
    // if accepted bit will be added to result
    for ( int pos = -1; pos >= -wf-1; pos-- ) {
 ap_ufixed<2 + prcs, 2> mul1a = 0; // 2 * resq * bit
 ap_ufixed<1 + prcs, 1> mul1b = 0; // 1 * resq * bit
 ((resq(pos*2 +1 +prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("resq(pos*2+1+prcs,0)==0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 265, __PRETTY_FUNCTION__));
 mul1a ( pos+2 + prcs , pos*3+3 + prcs ) = resq ( 1 + prcs , pos*2+2 + prcs );
 mul1b ( pos+1 + prcs , pos*3+2 + prcs ) = resq ( 1 + prcs , pos*2+2 + prcs );

 ap_ufixed< 0 + prcs, 0> mul2a = 0; // 2 * res * bit^2
 ap_ufixed<-1 + prcs, -1> mul2b = 0; // 1 * res * bit^2
 ((res(pos+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("res(pos+prcs,0)==0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 271, __PRETTY_FUNCTION__));
 mul2a ( pos*2+1 + prcs , pos*3+2 + prcs ) = res ( 0 + prcs , pos+1 + prcs );
 mul2b ( pos*2 + prcs , pos*3+1 + prcs ) = res ( 0 + prcs , pos+1 + prcs );

 //ap_ufixed<3 + prcs, 3> mul = 0;
 /*mul ( pos+3 + prcs , pos*3+1 + prcs ) = mul1a ( pos+2   + prcs , pos*3+1 + prcs ) + mul1b ( pos+1 + prcs , pos*3+1 + prcs ) + \
						mul2a ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul2b ( pos*2 + prcs , pos*3+1 + prcs ); // must align the last bit*/
 //assert ( mul == mul1a + mul1b + mul2a + mul2b );
 //mul [ pos*3 + prcs ] = 1;

        ap_ufixed<3 + prcs, 3> mulH = 0;
        ap_ufixed<3 + prcs, 3> mulL = 0;
 mulL ( pos*2+3 + prcs , pos*3+1 + prcs ) = mul1a ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul1b ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul2a ( pos*2+1 + prcs , pos*3+1 + prcs ) + mul2b ( pos*2 + prcs , pos*3+1 + prcs ); // must align the last bit

 mulH ( pos +3 + prcs , pos*2+2 + prcs ) = mul1a ( pos +2 + prcs , pos*2+2 + prcs ) + mul1b ( pos +1 + prcs , pos*2+2 + prcs ) + mulL ( pos*2+3 + prcs , pos*2+2 + prcs ); // must align the last bit

 //mulL [ pos*2+3 + prcs ] = 0; // just for assert
 //mulL [ pos*2+2 + prcs ] = 0; // just for assert
 //assert ( mulH + mulL == mul1a + mul1b + mul2a + mul2b );
 mulL [ pos*3 + prcs ] = 1;

 (((pos>=-2) || (x_frac(2 +prcs,pos+5 +prcs)==0)) ? static_cast<void> (0) : __assert_fail ("(pos>=-2) || (x_frac(2+prcs,pos+5+prcs)==0)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 292, __PRETTY_FUNCTION__));
 bool cond1 = ( x_frac ( pos +4 + prcs , pos*2+2 + prcs ) > mulH ( pos +3 + prcs, pos*2+2 + prcs ) );
 bool cond2 = ( x_frac ( pos +4 + prcs , pos*2+2 + prcs ) == mulH ( pos +3 + prcs, pos*2+2 + prcs ) );
 bool cond3 = ( x_frac ( pos*2+1 + prcs , pos*3 + prcs ) >= mulL ( pos*2+1 + prcs, pos*3 + prcs ) );
 //if ( x_frac ( pos+4 + prcs , pos*3 + prcs ) >= mul ( pos+3 + prcs, pos*3 + prcs ) ) {
 if ( cond1 | ( cond2 & cond3 ) ) {
     //assert ( x_frac >= mulH + mulL );
     //ap_ufixed<4 + prcs, 4> x_frac_ = x_frac; // just for assert
     //x_frac   ( pos  +4 + prcs , pos*3   + prcs ) =   ( x_frac ( pos+4 + prcs , pos*3 + prcs ) - mul ( pos+3 + prcs , pos*3 + prcs ) );
     //assert ( x_frac == x_frac_ - mul );
     ap_ufixed<4 + prcs, 4> x_frac_L = 0;
     x_frac_L ( pos*2+1 + prcs , pos*3 + prcs ) = x_frac ( pos*2+1 + prcs , pos*3 + prcs );
     x_frac_L [ pos*2+2 + prcs ] = cond3 ? 0 : 1;
     x_frac ( pos+4 + prcs , pos*2+2 + prcs ) = x_frac ( pos +4 + prcs , pos*2+2 + prcs ) - mulH ( pos +3 + prcs , pos*2+2 + prcs ) - x_frac_L ( pos*2+2 + prcs , pos*2+2 + prcs );


     x_frac ( pos*2+1 + prcs , pos*3 + prcs ) = x_frac_L ( pos*2+2 + prcs , pos*3 + prcs ) - mulL ( pos*2+1 + prcs , pos*3 + prcs );

     //assert ( x_frac == x_frac_ - mulH - mulL );

     ap_ufixed<1 + prcs, 1> mul3 = 0; // 2 * res * bit
     ((res(pos+prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("res(pos+prcs,0)==0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 313, __PRETTY_FUNCTION__));
     ((resq(pos*2 +1 +prcs,0)==0) ? static_cast<void> (0) : __assert_fail ("resq(pos*2+1+prcs,0)==0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_sqrt.h", 314, __PRETTY_FUNCTION__));
     mul3 ( pos+1 + prcs , pos*2+2 + prcs ) = res ( 0 + prcs , pos+1 + prcs );
            //resq ( 1 + prcs , pos*2+2 + prcs ) = resq ( 1 + prcs , pos*2+2 + prcs ) + mul3 ( pos+1 + prcs , pos*2+2 + prcs );
     ap_ufixed<2 + prcs, 2> resq_L = 0;
     resq_L ( pos+2 + prcs , pos*2+2 + prcs ) = resq ( pos+1 + prcs , pos*2+2 + prcs ) + mul3 ( pos+1 + prcs , pos*2+2 + prcs );
     resq ( pos+1 + prcs , pos*2+2 + prcs ) = resq_L ( pos+1 + prcs , pos*2+2 + prcs );
     resq ( 1 + prcs , pos +2 + prcs ) = resq ( 1 + prcs , pos +2 + prcs ) + resq_L ( pos+2 + prcs , pos +2 + prcs );
     resq [ pos*2 + prcs ] = 1;
            res [ pos + prcs ] = 1;
 }
    }

    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+1, 2> res_s = res;
    res_s += delta;

    if ( res_s[res_s.wl()-1] == 1 ) {
        x_exp++;
 res_s >>= 1;
    }

    out.exp = x_exp;
    out.sig(wf-1,0) = res_s(res_s.wl()-res_s.iwl()-1,res_s.wl()-res_s.iwl()-wf);
    return out.to_ieee();

}

static double hypot(double x, double y) {
    if ( ::hls::__isinf(x) )
 return fabs(x);
    if ( ::hls::__isinf(y) )
 return fabs(y);
    return ::sqrt(x*x+y*y);
}
static float hypotf(float x, float y) {
    if ( ::hls::__isinf(x) )
        return fabs(x);
    if ( ::hls::__isinf(y) )
        return fabs(y);
    double xd = x;
    double yd = y;
    return ::sqrt(xd*xd+yd*yd);
}
static half half_hypot(half x, half y) {
    if ( ::hls::__isinf(x) )
        return fabs(x);
    if ( ::hls::__isinf(y) )
        return fabs(y);
    float xf = x;
    float yf = y;
    return ::sqrtf(xf*xf+yf*yf);
}

// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 719 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
static double sqrt(double x) {
    return ::sqrt(x);
}
static float sqrtf(float x) {
    return ::sqrtf(x);
}
static half half_sqrt(half x) {
    return hls::hls_rsr::half_sqrt(x);
}


static half half_recip(half x) {
    return hls::hls_rsr::half_recip(x);
}
static half half_rsqrt(half x) {
    return hls::hls_rsr::half_rsqrt(x);
}

static half cbrt(half x) {
 return hls::cbrt_generic(x);
}
static float cbrt(float x) {
 return hls::cbrt_generic(x);
}
static double cbrt(double x) {
 return hls::cbrt_generic(x);
}
static float cbrtf(float x) {
 return hls::cbrt_generic(x);
}
static half half_cbrt(half x) {
 return hls::cbrt_generic(x);
}

static half hypot(half x, half y) {
        return hls::half_hypot(x,y);
}
static float hypot(float x, float y) {
        return hls::hypotf(x,y);
}


static double recip(double x)
{
    return _ssdm_op_DRecip(x);
}

static float recipf(float x)
{
    return _ssdm_op_FRecip(x);
}

static double rsqrt(double x)
{
    return _ssdm_op_DRSqrt(x);
}

static float rsqrtf(float x)
{
    return _ssdm_op_FRSqrt(x);
}
# 804 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h"
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h" 1
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * @file hls_asin_acos.h
 * This file contains arcsine and arccos functions, mainly based on ieee754/ implementation
 * except some optimization for fpga. This implementation will occupy huge logic
 * when doesn't share double operations (multi, add, div), this need further optimize
 * or adopt new approximation method suite to fpga, like hotbm
 */
# 27 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"
namespace asin_acos_approx{
static float asin(float x)
{
    static const float
    one = 1.0000000000e+00, /* 0x3F800000 */
    huge = 1.000e+30,

    pio2_hi = 1.57079637050628662109375f,
    pio2_lo = -4.37113900018624283e-8f,
    pio4_hi = 0.785398185253143310546875f,

    /* asin x = x + x^3 p(x^2)
       -0.5 <= x <= 0.5;
       Peak relative error 4.8e-9 */
    p0 = 1.666675248e-1f,
    p1 = 7.495297643e-2f,
    p2 = 4.547037598e-2f,
    p3 = 2.417951451e-2f,
    p4 = 4.216630880e-2f;
_ssdm_SpecConstant(&p4);
# 45 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&p3);
# 44 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&p2);
# 43 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&p1);
# 42 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&p0);
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pio4_hi);
# 36 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pio2_lo);
# 35 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pio2_hi);
# 34 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&huge);
# 32 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&one);
# 31 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


    // flush subnormal
    if(fpclassify(x) == FP_SUBNORMAL)
        x = 0.0f;

 float t,w,p,q,c,r,s;
 int32_t hx,ix;
 //GET_FLOAT_WORD(hx,x);
    fp_struct<float> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(31,0);
    hx = tmp.to_int();
 ix = hx&0x7fffffff;
 if(ix==0x3f800000) {
  /* asin(1)=+-pi/2 with inexact */
     return x*pio2_hi+x*pio2_lo;
 } else if(ix> 0x3f800000) { /* |x|>= 1 */
     return (x-x)/(x-x); /* asin(|x|>1) is NaN */
 } else if (ix<0x3f000000) { /* |x|<0.5 */
     if(ix<0x32000000) { /* if |x| < 2**-27 */
  if(huge+x>one) return x;/* return x with inexact if x!=0*/
     } else {
  t = x*x;
  w = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));
  return x+x*w;
     }
 }
 /* 1> |x|>= 0.5 */
 w = one-fabsf(x);
 t = w*0.5f;
 p = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));
 //s = __ieee754_sqrtf(t);
 s = sqrtf(t);
 if(ix>=0x3F79999A) { /* if |x| > 0.975 */
     t = pio2_hi-(2.0f*(s+s*p)-pio2_lo);
 } else {
     //int32_t iw;
     w = s;
     //GET_FLOAT_WORD(iw,w);
     //SET_FLOAT_WORD(w,iw&0xfffff000);
        fp_struct<float> fp_w(w);
        ap_uint<Type_BitWidth<float>::Value> data = fp_w.data() & 0xfffff000;
        fp_struct<float> fp_w_new(data);
        w = fp_w_new.to_ieee();
     c = (t-w*w)/(s+w);
     r = p;
     p = 2.0f*s*r-(pio2_lo-2.0f*c);
     q = pio4_hi-2.0f*w;
     t = pio4_hi-(p-q);
 }
 if(hx>0) return t; else return -t;
}

static float acos(float x)
{
    static const float
    one = 1.0000000000e+00, /* 0x3F800000 */
    pi = 3.1415925026e+00, /* 0x40490fda */
    pio2_hi = 1.5707962513e+00, /* 0x3fc90fda */
    pio2_lo = 7.5497894159e-08, /* 0x33a22168 */
    pS0 = 1.6666667163e-01, /* 0x3e2aaaab */
    pS1 = -3.2556581497e-01, /* 0xbea6b090 */
    pS2 = 2.0121252537e-01, /* 0x3e4e0aa8 */
    pS3 = -4.0055535734e-02, /* 0xbd241146 */
    pS4 = 7.9153501429e-04, /* 0x3a4f7f04 */
    pS5 = 3.4793309169e-05, /* 0x3811ef08 */
    qS1 = -2.4033949375e+00, /* 0xc019d139 */
    qS2 = 2.0209457874e+00, /* 0x4001572d */
    qS3 = -6.8828397989e-01, /* 0xbf303361 */
    qS4 = 7.7038154006e-02;
_ssdm_SpecConstant(&qS4);
# 114 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&qS3);
# 113 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&qS2);
# 112 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&qS1);
# 111 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS5);
# 110 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS4);
# 109 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS3);
# 108 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS2);
# 107 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS1);
# 106 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pS0);
# 105 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pio2_lo);
# 104 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pio2_hi);
# 103 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&pi);
# 102 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&one);
# 101 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"
 /* 0x3d9dc62e */

 float z,p,q,r,w,s,c,df;
 int32_t hx,ix;
 //GET_FLOAT_WORD(hx,x);
    fp_struct<float> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(31,0);
    hx = tmp.to_int();
 ix = hx&0x7fffffff;
 if(ix==0x3f800000) { /* |x|==1 */
     if(hx>0) return 0.0; /* acos(1) = 0  */
     else return pi+(float)2.0*pio2_lo; /* acos(-1)= pi */
 } else if(ix>0x3f800000) { /* |x| >= 1 */
     return (x-x)/(x-x); /* acos(|x|>1) is NaN */
 }
 if(ix<0x3f000000) { /* |x| < 0.5 */
     if(ix<=0x23000000) return pio2_hi+pio2_lo;/*if|x|<2**-57*/
     z = x*x;
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     r = p/q;
     return pio2_hi - (x - (pio2_lo-x*r));
 } else if (hx<0) { /* x < -0.5 */
     z = (one+x)*(float)0.5;
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     s = sqrtf(z);
     r = p/q;
     w = r*s-pio2_lo;
     return pi - (float)2.0*(s+w);
 } else { /* x > 0.5 */
     //int32_t idf;
     z = (one-x)*(float)0.5;
     s = sqrtf(z);
     df = s;
     //GET_FLOAT_WORD(idf,df);
     //SET_FLOAT_WORD(df,idf&0xfffff000);
        fp_struct<float> fp_df(df);
        ap_uint<Type_BitWidth<float>::Value> data = fp_df.data() & 0xfffff000;
        fp_struct<float> fp_df_new(data);
        df = fp_df_new.to_ieee();
     c = (z-df*df)/(s+df);
     p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
     q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
     r = p/q;
     w = r*s+c;
     return (float)2.0*(df+w);
 }
}

// asin(double) and acos(double) based Apple opensoure libm
// https://opensource.apple.com/source/Libm/Libm-2026/
static volatile const double Infinity = (__builtin_inff());
static volatile const double Tiny = 0x1p-1022;
// double2 represents a number equal to d0 + d1, with |d1| <= 1/2 ULP(d0).
typedef struct { double d0, d1; } double2;

// Return a * b, given |a|, |b| < 2**970.
static inline double2 Mul112(double a, double b)
{
 static const double c = 0x1p27 + 1;
_ssdm_SpecConstant(&c);
# 174 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double
  ap = a * c, bp = b * c,
  a0 = (a-ap)+ap, b0 = (b-bp)+bp,
  a1 = a - a0, b1 = b - b0,
  d0 = a * b,
  d1 = a0*b0 - d0 + a0*b1 + a1*b0 + a1*b1;
 return (double2) { d0, d1 };
}


// Return a + b with relative error below 2**-103 given |b| < |a|.
static inline double2 Add212RightSmaller(double2 a, double b)
{
 double
  c0 = a.d0 + b,
  c1 = a.d0 - c0 + b + a.d1,
  d0 = c0 + c1,
  d1 = c0 - d0 + c1;
 return (double2) { d0, d1 };
}


/*	Return a + b with relative error below 2**-103 and then rounded to
	double given |b| < |a|.
*/
static inline double Add221RightSmaller(double2 a, double2 b)
{
 double
  c0 = a.d0 + b.d0,
  c1 = a.d0 - c0 + b.d0 + b.d1 + a.d1,
  d0 = c0 + c1;
 return d0;
}


/*	Return approximately a * b - 1 given |a|, |b| < 2**970 and a * b is
	very near 1.
*/
static inline double Mul121Special(double a, double2 b)
{
 static const double c = 0x1p27 + 1;
_ssdm_SpecConstant(&c);
# 216 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double
  ap = a * c, bp = b.d0 * c,
  a0 = (a-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a - a0, b1 = b.d0 - b0,
  m1 = a0*b0 - 1 + a0*b1 + a1*b0 + a1*b1 + a*b.d1;
 return m1;
}


// Return a * b with relative error below 2**-102 given |a|, |b| < 2**970.
static inline double2 Mul222(double2 a, double2 b)
{
 static const double c = 0x1p27 + 1;
_ssdm_SpecConstant(&c);
# 230 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double
  ap = a.d0 * c, bp = b.d0 * c,
  a0 = (a.d0-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a.d0 - a0, b1 = b.d0 - b0,
  m0 = a.d0 * b.d0,
  m1 = a0*b0 - m0 + a0*b1 + a1*b0 + a1*b1 + (a.d0*b.d1 + a.d1*b.d0),
  d0 = m0 + m1,
  d1 = m0 - d0 + m1;
 return (double2) { d0, d1 };
}

// for acos
// Return a + b given |b| < |a|.
static inline double2 Add112RightSmaller(double a, double b)
{
 double d0 = a + b, d1 = b - (d0 - a);
 return (double2) { d0, d1 };
}


/*	Return a - b with relative error below 2**-103 and then rounded to a
	double given |b| < |a|.
*/
static inline double Sub211RightSmaller(double2 a, double b)
{
 double
  c0 = a.d0 - b,
  c1 = a.d0 - c0 - b + a.d1,
  d0 = c0 + c1;
 return d0;
}


/*	Return a - b with relative error below 2**-103 and then rounded to
	double given |b| < |a|.
*/
static inline double Sub221RightSmaller(double2 a, double2 b)
{
 double
  c0 = a.d0 - b.d0,
  c1 = a.d0 - c0 - b.d0 - b.d1 + a.d1,
  d0 = c0 + c1;
 return d0;
}


// Return approximately a * b given |a|, |b| < 2**970.
static inline double Mul221(double2 a, double2 b)
{
 static const double c = 0x1p27 + 1;
_ssdm_SpecConstant(&c);
# 281 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double
  ap = a.d0 * c, bp = b.d0 * c,
  a0 = (a.d0-ap)+ap, b0 = (b.d0-bp)+bp,
  a1 = a.d0 - a0, b1 = b.d0 - b0,
  m0 = a.d0 * b.d0,
  m1 = a0*b0 - m0 + a0*b1 + a1*b0 + a1*b1 + (a.d0*b.d1 + a.d1*b.d0),
  d0 = m0 + m1;
 return d0;
}
// for acos end

// Return arcsine(x) given |x| <= .5, with the same properties as asin.
static double Center(double x)
{
 if (-0x1.7137449123ef5p-26 <= x && x <= +0x1.7137449123ef5p-26)
  return -0x1p-1022 < x && x < +0x1p-1022
   // Generate underflow and inexact and return x.
   ? x - x*x
   // Generate inexact and return x.
   : x * (Tiny + 1);

 static const double p03 = 0.1666666666666558995379880;
_ssdm_SpecConstant(&p03);
# 304 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = 0.0750000000029696112392353;
_ssdm_SpecConstant(&p05);
# 305 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = 0.0446428568582815922683933;
_ssdm_SpecConstant(&p07);
# 306 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = 0.0303819580081956423799529;
_ssdm_SpecConstant(&p09);
# 307 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = 0.0223717830666671020710108;
_ssdm_SpecConstant(&p11);
# 308 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p13 = 0.0173593516996479249428647;
_ssdm_SpecConstant(&p13);
# 309 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p15 = 0.0138885410156894774969889;
_ssdm_SpecConstant(&p15);
# 310 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p17 = 0.0121483892822292648695383;
_ssdm_SpecConstant(&p17);
# 311 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p19 = 0.0066153165197009078340075;
_ssdm_SpecConstant(&p19);
# 312 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p21 = 0.0192942786775238654913582;
_ssdm_SpecConstant(&p21);
# 313 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p23 = -0.0158620440988475212803145;
_ssdm_SpecConstant(&p23);
# 314 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p25 = 0.0316658385792867081040808;
_ssdm_SpecConstant(&p25);
# 315 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 // Square x.
 double x2 = x * x;

 return ((((((((((((
  + p25) * x2
  + p23) * x2
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x + x;
}


// Return arcsine(x) given .5 < x, with the same properties as asin.
static double Tail(double x)
{
 if (1 <= x)
  return 1 == x
   // If x is 1, generate inexact and return Pi/2 rounded down.
   ? 0x3.243f6a8885a308d313198a2e03707344ap-1 + Tiny
   // If x is outside the domain, generate invalid and return NaN.
   : Infinity - Infinity;

 static const double p01 = 0.2145993335526539017488949;
_ssdm_SpecConstant(&p01);
# 346 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p02 = -0.0890259194305537131666744;
_ssdm_SpecConstant(&p02);
# 347 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p03 = 0.0506659694457588602631748;
_ssdm_SpecConstant(&p03);
# 348 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p04 = -0.0331919619444009606270380;
_ssdm_SpecConstant(&p04);
# 349 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = 0.0229883479552557203133368;
_ssdm_SpecConstant(&p05);
# 350 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p06 = -0.0156746038587246716524035;
_ssdm_SpecConstant(&p06);
# 351 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = 0.0097868293573384001221447;
_ssdm_SpecConstant(&p07);
# 352 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p08 = -0.0052049731575223952626203;
_ssdm_SpecConstant(&p08);
# 353 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = 0.0021912255981979442677477;
_ssdm_SpecConstant(&p09);
# 354 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p10 = -0.0006702485124770180942917;
_ssdm_SpecConstant(&p10);
# 355 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = 0.0001307564187657962919394;
_ssdm_SpecConstant(&p11);
# 356 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p12 = -0.0000121189820098929624806;
_ssdm_SpecConstant(&p12);
# 357 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double polynomial = ((((((((((((
  + p12) * x
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x;

  static const double2
   HalfPi = { 0x1.921fb54442d18p+0, 0x1.1a62633145c07p-54 },
   p00 = { -0x1.921fb31e97d96p0, +0x1.eab77149ad27cp-54 };
_ssdm_SpecConstant(&p00);
# 375 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

_ssdm_SpecConstant(&HalfPi);
# 374 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


  // Estimate 1 / sqrt(1-x).
  double e = 1 / sqrt(1-x);

  double2 ex = Mul112(e, 1-x); // e * x.
  double e2x = Mul121Special(e, ex); // e**2 * x - 1.

  // Set t0 to an improved approximation of sqrt(1-x) with Newton-Raphson.
  double2 t0 = Add212RightSmaller(ex, ex.d0 * -.5 * e2x);

  // Calculate pi/2 + sqrt(1-x) * p(x).
  return Add221RightSmaller(HalfPi, Mul222(
   t0,
   Add212RightSmaller(p00, polynomial)));
}

// Return arccosine(x) given |x| <= .4, with the same properties as acos.
static double Center_acos(double x)
{
 static const double
  HalfPi = 0x3.243f6a8885a308d313198a2e03707344ap-1;
_ssdm_SpecConstant(&HalfPi);
# 396 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 /*	If x is small, generate inexact and return pi/2.  We must do this
		for very small x to avoid underflow when x is squared.
	*/
 if (-0x1.8d313198a2e03p-53 <= x && x <= +0x1.8d313198a2e03p-53)
  return HalfPi + Tiny;

 static const double p03 = + .1666666666666251331848183;
_ssdm_SpecConstant(&p03);
# 404 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = + .7500000000967090522908427e-1;
_ssdm_SpecConstant(&p05);
# 405 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = + .4464285630020156622713320e-1;
_ssdm_SpecConstant(&p07);
# 406 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = + .3038198238851575770651788e-1;
_ssdm_SpecConstant(&p09);
# 407 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = + .2237115216935265224962544e-1;
_ssdm_SpecConstant(&p11);
# 408 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p13 = + .1736953298172084894468665e-1;
_ssdm_SpecConstant(&p13);
# 409 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p15 = + .1378527665685754961528021e-1;
_ssdm_SpecConstant(&p15);
# 410 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p17 = + .1277870997666947910124296e-1;
_ssdm_SpecConstant(&p17);
# 411 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p19 = + .4673473145155259234911049e-2;
_ssdm_SpecConstant(&p19);
# 412 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p21 = + .1951350766744288383625404e-1;
_ssdm_SpecConstant(&p21);
# 413 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 // Square x.
 double x2 = x * x;

 return HalfPi - (((((((((((
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x + x);
}


// Return arccosine(x) given .4 <= |x| <= .6, with the same properties as acos.
static double Gap_acos(double x)
{
 static const double p03 = + .1666666544260252354339083;
_ssdm_SpecConstant(&p03);
# 435 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = + .7500058936188719422797382e-1;
_ssdm_SpecConstant(&p05);
# 436 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = + .4462999611462664666589096e-1;
_ssdm_SpecConstant(&p07);
# 437 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = + .3054999576148835435598555e-1;
_ssdm_SpecConstant(&p09);
# 438 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = + .2090953485621966528477317e-1;
_ssdm_SpecConstant(&p11);
# 439 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p13 = + .2626916834046217573905021e-1;
_ssdm_SpecConstant(&p13);
# 440 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p15 = - .2496419961469848084029243e-1;
_ssdm_SpecConstant(&p15);
# 441 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p17 = + .1336320190979444903198404;
_ssdm_SpecConstant(&p17);
# 442 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p19 = - .2609082745402891409913617;
_ssdm_SpecConstant(&p19);
# 443 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p21 = + .4154485118940996442799104;
_ssdm_SpecConstant(&p21);
# 444 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p23 = - .3718481677216955169129325;
_ssdm_SpecConstant(&p23);
# 445 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p25 = + .1791132167840254903934055;
_ssdm_SpecConstant(&p25);
# 446 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 // Square x.
 double x2 = x * x;

 double poly = ((((((((((((
  + p25) * x2
  + p23) * x2
  + p21) * x2
  + p19) * x2
  + p17) * x2
  + p15) * x2
  + p13) * x2
  + p11) * x2
  + p09) * x2
  + p07) * x2
  + p05) * x2
  + p03) * x2 * x;

  static const double2
   HalfPi = { 0x1.921fb54442d18p+0, 0x1.1a62633145c07p-54 };
_ssdm_SpecConstant(&HalfPi);
# 466 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

  return Sub221RightSmaller(HalfPi, Add112RightSmaller(x, poly));
}


// Return arccosine(x) given +.6 < x, with the same properties as acos.
static double pTail_acos(double x)
{
 if (1 <= x)
  return 1 == x
   // If x is 1, return zero.
   ? 0
   // If x is outside the domain, generate invalid and return NaN.
   : Infinity - Infinity;

 static const double p01 = - .2145900291823555067724496;
_ssdm_SpecConstant(&p01);
# 481 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p02 = + .8895931658903454714161991e-1;
_ssdm_SpecConstant(&p02);
# 482 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p03 = - .5037781062999805015401690e-1;
_ssdm_SpecConstant(&p03);
# 483 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p04 = + .3235271184788013959507217e-1;
_ssdm_SpecConstant(&p04);
# 484 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = - .2125492340970560944012545e-1;
_ssdm_SpecConstant(&p05);
# 485 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p06 = + .1307107321829037349021838e-1;
_ssdm_SpecConstant(&p06);
# 486 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = - .6921689208385164161272068e-2;
_ssdm_SpecConstant(&p07);
# 487 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p08 = + .2912114685670939037614086e-2;
_ssdm_SpecConstant(&p08);
# 488 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = - .8899459104279910976564839e-3;
_ssdm_SpecConstant(&p09);
# 489 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p10 = + .1730883544880830573920551e-3;
_ssdm_SpecConstant(&p10);
# 490 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = - .1594866672026418356538789e-4;
_ssdm_SpecConstant(&p11);
# 491 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double t0 = (((((((((((
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x;

  static const double2
   p00 = { 0x1.921fa926d2f24p0, +0x1.b4a23d0ecbb40p-59 };
_ssdm_SpecConstant(&p00);
# 507 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

   /*	p00.d1 might not be needed.  However, omitting it brings the
				sampled error to .872 ULP.  We would need to prove this is okay.
			*/

  // Estimate square root to double precision.
  double e = 1 / sqrt(1-x);

  // Refine estimate using Newton-Raphson.
  double2 ex = Mul112(e, 1-x);
  double e2x = Mul121Special(e, ex);
  double2 t1 = Add212RightSmaller(ex, ex.d0 * -.5 * e2x);

  // Return sqrt(1-x) * (t0 + p00).
  return Mul221(t1, Add212RightSmaller(p00, t0));
}


// Return arccosine(x) given x < -.6, with the same properties as acos.
static double nTail_acos(double x)
{
 if (x <= -1)
  return -1 == x
   // If x is -1, generate inexact and return pi rounded toward zero.
   ? 0x3.243f6a8885a308d313198a2e03707344ap0 + Tiny
   // If x is outside the domain, generate invalid and return NaN.
   : Infinity - Infinity;

 static const double p00 = +1.5707956513160834076561054;
_ssdm_SpecConstant(&p00);
# 535 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p01 = + .2145907003920708442108238;
_ssdm_SpecConstant(&p01);
# 536 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p02 = + .8896369437915166409934895e-1;
_ssdm_SpecConstant(&p02);
# 537 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p03 = + .5039488847935731213671556e-1;
_ssdm_SpecConstant(&p03);
# 538 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p04 = + .3239698582040400391437898e-1;
_ssdm_SpecConstant(&p04);
# 539 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p05 = + .2133501549935443220662813e-1;
_ssdm_SpecConstant(&p05);
# 540 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p06 = + .1317423797769298396461497e-1;
_ssdm_SpecConstant(&p06);
# 541 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p07 = + .7016307696008088925432394e-2;
_ssdm_SpecConstant(&p07);
# 542 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p08 = + .2972670140131377611481662e-2;
_ssdm_SpecConstant(&p08);
# 543 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p09 = + .9157019394367251664320071e-3;
_ssdm_SpecConstant(&p09);
# 544 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p10 = + .1796407754831532447333023e-3;
_ssdm_SpecConstant(&p10);
# 545 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

 static const double p11 = + .1670402962434266380655447e-4;
_ssdm_SpecConstant(&p11);
# 546 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"


 double poly = sqrt(1+x) * ((((((((((((
  + p11) * x
  + p10) * x
  + p09) * x
  + p08) * x
  + p07) * x
  + p06) * x
  + p05) * x
  + p04) * x
  + p03) * x
  + p02) * x
  + p01) * x
  + p00);

  static const double2
   Pi = { 0x1.921fb54442d18p+1, 0x1.1a62633145c07p-53 };
_ssdm_SpecConstant(&Pi);
# 563 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asin_acos.h"

  return Sub211RightSmaller(Pi, poly);
}

static double asin(double x)
{
    // flush subnormalnormal
    if(fpclassify(x) == FP_SUBNORMAL)
        x = 0.0;

    if ((x <= 0.5) && (x >= -0.5)) {
  return Center(x);
    } else {
        double x1;
        if (x < 0)
            x1 = -x;
        else
            x1 = x;
        double r = Tail(x1);
        if (x < 0)
            r = -r;

        return r;
    }
}

// See documentation above.
static double acos(double x)
{
 if (x < -.4)
  if (x < -.6)
   return nTail_acos(x);
  else
   return Gap_acos(x);
 else if (x <= +.4)
  return Center_acos(x);
 else
  if (x <= +.6)
   return Gap_acos(x);
  else
   return pTail_acos(x);
}

static half asin(half x)
{
    return asin((float)x);
}

static half acos(half x)
{
    return acos((float)x);
}

static float asinf(float x)
{
    return asin(x);
}

static float acosf(float x)
{
    return acos(x);
}

} // namespace asin_acos_approx
# 805 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
static double asin(double x)
{
    return asin_acos_approx::asin(x);
}
static double acos(double x)
{
    return asin_acos_approx::acos(x);
}
static float asin(float x)
{
    return asin_acos_approx::asin(x);
}
static float acos(float x)
{
    return asin_acos_approx::acos(x);
}
static half asin(half x)
{
    return asin_acos_approx::asin(x);
}
static half acos(half x)
{
    return asin_acos_approx::acos(x);
}
static half half_asin(half x)
{
    return asin_acos_approx::asin(x);
}
static half half_acos(half x)
{
    return asin_acos_approx::acos(x);
}
static float asinf(float x)
{
    return asin_acos_approx::asinf(x);
}
static float acosf(float x)
{
    return asin_acos_approx::acosf(x);
}



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_exp.h
 *
 * see: J.Detrey and F.d.Dinechin, "A parameterized floating-point exponential function for FPGA"
 */
namespace exp_reduce_ {



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_tables_.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/ap_fixed.h" 1



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 33 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_tables_.h" 2
namespace {

// =============================================== exp_Z1 tables for exp() ==========================
template <typename T> class table_exp_Z1 {};

// w_Z1 = 9 for half
template <> class table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<14, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};

// w_Z1 = 9 for float
template <> class table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [512];};
const ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<27, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [512] = {
"0x1.0000000p0",
"0x1.0080200p0",
"0x1.0100802p0",
"0x1.0181209p0",
"0x1.0202015p0",
"0x1.0283229p0",
"0x1.0304848p0",
"0x1.0386272p0",
"0x1.04080ABp0",
"0x1.048A2F4p0",
"0x1.050C94Ep0",
"0x1.058F3BEp0",
"0x1.0612243p0",
"0x1.06954E1p0",
"0x1.0718B98p0",
"0x1.079C66Dp0",
"0x1.0820560p0",
"0x1.08A4873p0",
"0x1.0928FA9p0",
"0x1.09ADB03p0",
"0x1.0A32A84p0",
"0x1.0AB7E2Ep0",
"0x1.0B3D603p0",
"0x1.0BC3205p0",
"0x1.0C49236p0",
"0x1.0CCF698p0",
"0x1.0D55F2Dp0",
"0x1.0DDCBF8p0",
"0x1.0E63CFAp0",
"0x1.0EEB236p0",
"0x1.0F72BADp0",
"0x1.0FFA962p0",
"0x1.1082B57p0",
"0x1.110B18Ep0",
"0x1.1193C09p0",
"0x1.121CACBp0",
"0x1.12A5DD5p0",
"0x1.132F529p0",
"0x1.13B90CBp0",
"0x1.14430BBp0",
"0x1.14CD4FCp0",
"0x1.1557D91p0",
"0x1.15E2A7Ap0",
"0x1.166DBBCp0",
"0x1.16F9157p0",
"0x1.1784B4Ep0",
"0x1.18109A3p0",
"0x1.189CC58p0",
"0x1.1929370p0",
"0x1.19B5EECp0",
"0x1.1A42ED0p0",
"0x1.1AD031Cp0",
"0x1.1B5DBD3p0",
"0x1.1BEB8F8p0",
"0x1.1C79A8Dp0",
"0x1.1D08094p0",
"0x1.1D96B0Ep0",
"0x1.1E25A00p0",
"0x1.1EB4D69p0",
"0x1.1F4454Ep0",
"0x1.1FD41AFp0",
"0x1.2064290p0",
"0x1.20F47F3p0",
"0x1.21851D9p0",
"0x1.2216045p0",
"0x1.22A733Ap0",
"0x1.2338AB9p0",
"0x1.23CA6C5p0",
"0x1.245C761p0",
"0x1.24EEC8Ep0",
"0x1.258164Ep0",
"0x1.26144A5p0",
"0x1.26A7793p0",
"0x1.273AF1Dp0",
"0x1.27CEB43p0",
"0x1.2862C09p0",
"0x1.28F7170p0",
"0x1.298BB7Bp0",
"0x1.2A20A2Cp0",
"0x1.2AB5D86p0",
"0x1.2B4B58Bp0",
"0x1.2BE123Cp0",
"0x1.2C7739Ep0",
"0x1.2D0D9B1p0",
"0x1.2DA4478p0",
"0x1.2E3B3F6p0",
"0x1.2ED282Dp0",
"0x1.2F6A11Fp0",
"0x1.3001ECFp0",
"0x1.309A13Fp0",
"0x1.3132871p0",
"0x1.31CB468p0",
"0x1.3264526p0",
"0x1.32FDAAEp0",
"0x1.3397502p0",
"0x1.3431424p0",
"0x1.34CB817p0",
"0x1.35660DDp0",
"0x1.3600E78p0",
"0x1.369C0ECp0",
"0x1.373783Ap0",
"0x1.37D3465p0",
"0x1.386F56Fp0",
"0x1.390BB5Bp0",
"0x1.39A862Bp0",
"0x1.3A455E2p0",
"0x1.3AE2A82p0",
"0x1.3B8040Dp0",
"0x1.3C1E287p0",
"0x1.3CBC5F1p0",
"0x1.3D5AE4Ep0",
"0x1.3DF9BA0p0",
"0x1.3E98DEAp0",
"0x1.3F3852Fp0",
"0x1.3FD8170p0",
"0x1.40782B1p0",
"0x1.41188F4p0",
"0x1.41B943Bp0",
"0x1.425A489p0",
"0x1.42FB9E0p0",
"0x1.439D443p0",
"0x1.443F3B5p0",
"0x1.44E1838p0",
"0x1.45841CEp0",
"0x1.462707Bp0",
"0x1.46CA440p0",
"0x1.476DD20p0",
"0x1.4811B1Ep0",
"0x1.48B5E3Cp0",
"0x1.495A67Dp0",
"0x1.49FF3E3p0",
"0x1.4AA4671p0",
"0x1.4B49E2Ap0",
"0x1.4BEFB10p0",
"0x1.4C95D26p0",
"0x1.4D3C46Fp0",
"0x1.4DE30ECp0",
"0x1.4E8A2A0p0",
"0x1.4F3198Fp0",
"0x1.4FD95BBp0",
"0x1.5081726p0",
"0x1.5129DD3p0",
"0x1.51D29C4p0",
"0x1.527BAFDp0",
"0x1.5325180p0",
"0x1.53CED50p0",
"0x1.5478E6Fp0",
"0x1.55234DFp0",
"0x1.55CE0A4p0",
"0x1.56791C1p0",
"0x1.5724837p0",
"0x1.57D040Ap0",
"0x1.587C53Cp0",
"0x1.5928BD0p0",
"0x1.59D57C9p0",
"0x1.5A82929p0",
"0x1.5B2FFF3p0",
"0x1.5BDDC29p0",
"0x1.5C8BDD0p0",
"0x1.5D3A4E8p0",
"0x1.5DE9176p0",
"0x1.5E9837Bp0",
"0x1.5F47AFAp0",
"0x1.5FF77F6p0",
"0x1.60A7A73p0",
"0x1.6158272p0",
"0x1.6208FF6p0",
"0x1.62BA303p0",
"0x1.636BB9Ap0",
"0x1.641D9BFp0",
"0x1.64CFD75p0",
"0x1.65826BEp0",
"0x1.663559Cp0",
"0x1.66E8A14p0",
"0x1.679C427p0",
"0x1.68503D9p0",
"0x1.690492Cp0",
"0x1.69B9423p0",
"0x1.6A6E4C1p0",
"0x1.6B23B09p0",
"0x1.6BD96FDp0",
"0x1.6C8F8A1p0",
"0x1.6D45FF7p0",
"0x1.6DFCD02p0",
"0x1.6EB3FC5p0",
"0x1.6F6B843p0",
"0x1.702367Ep0",
"0x1.70DBA7Ap0",
"0x1.719443Ap0",
"0x1.724D3BFp0",
"0x1.730690Ep0",
"0x1.73C0429p0",
"0x1.747A513p0",
"0x1.7534BCFp0",
"0x1.75EF860p0",
"0x1.76AAAC9p0",
"0x1.776630Cp0",
"0x1.782212Dp0",
"0x1.78DE52Ep0",
"0x1.799AF13p0",
"0x1.7A57EDEp0",
"0x1.7B15493p0",
"0x1.7BD3034p0",
"0x1.7C911C4p0",
"0x1.7D4F946p0",
"0x1.7E0E6BEp0",
"0x1.7ECDA2Ep0",
"0x1.7F8D399p0",
"0x1.804D303p0",
"0x1.810D86Dp0",
"0x1.81CE3DCp0",
"0x1.828F552p0",
"0x1.8350CD3p0",
"0x1.8412A60p0",
"0x1.84D4DFEp0",
"0x1.85977AFp0",
"0x1.865A777p0",
"0x1.871DD58p0",
"0x1.87E1955p0",
"0x1.88A5B72p0",
"0x1.896A3B1p0",
"0x1.8A2F217p0",
"0x1.8AF46A5p0",
"0x1.8BBA15Ep0",
"0x1.8C80247p0",
"0x1.8D46962p0",
"0x1.8E0D6B1p0",
"0x1.8ED4A39p0",
"0x1.8F9C3FDp0",
"0x1.90643FEp0",
"0x1.912CA42p0",
"0x1.91F56CAp0",
"0x1.92BE99Ap0",
"0x1.93882B4p0",
"0x1.945221Dp0",
"0x1.951C7D8p0",
"0x1.95E73E6p0",
"0x1.96B264Cp0",
"0x1.977DF0Ep0",
"0x1.9849E2Dp0",
"0x1.99163ADp0",
"0x1.99E2F91p0",
"0x1.9AB01DDp0",
"0x1.9B7DA94p0",
"0x1.9C4B9B9p0",
"0x1.9D19F4Fp0",
"0x1.9DE8B59p0",
"0x1.9EB7DDCp0",
"0x1.9F876D8p0",
"0x1.A057653p0",
"0x1.A127C50p0",
"0x1.A1F88D1p0",
"0x1.A2C9BDAp0",
"0x1.A39B56Ep0",
"0x1.A46D590p0",
"0x1.A53FC44p0",
"0x0.9B4597Ep0",
"0x0.9B934E1p0",
"0x0.9BE12B3p0",
"0x0.9C2F2F4p0",
"0x0.9C7D5A6p0",
"0x0.9CCBACAp0",
"0x0.9D1A262p0",
"0x0.9D68C6Dp0",
"0x0.9DB78EEp0",
"0x0.9E067E7p0",
"0x0.9E55957p0",
"0x0.9EA4D40p0",
"0x0.9EF43A4p0",
"0x0.9F43C84p0",
"0x0.9F937E1p0",
"0x0.9FE35BDp0",
"0x0.A033617p0",
"0x0.A0838F3p0",
"0x0.A0D3E51p0",
"0x0.A124632p0",
"0x0.A175097p0",
"0x0.A1C5D83p0",
"0x0.A216CF5p0",
"0x0.A267EF0p0",
"0x0.A2B9375p0",
"0x0.A30AA84p0",
"0x0.A35C420p0",
"0x0.A3AE049p0",
"0x0.A3FFF00p0",
"0x0.A452048p0",
"0x0.A4A4421p0",
"0x0.A4F6A8Dp0",
"0x0.A54938Cp0",
"0x0.A59BF21p0",
"0x0.A5EED4Cp0",
"0x0.A641E0Ep0",
"0x0.A69516Ap0",
"0x0.A6E8760p0",
"0x0.A73BFF2p0",
"0x0.A78FB21p0",
"0x0.A7E38EEp0",
"0x0.A83795Ap0",
"0x0.A88BC67p0",
"0x0.A8E0217p0",
"0x0.A934A6Ap0",
"0x0.A989562p0",
"0x0.A9DE300p0",
"0x0.AA33345p0",
"0x0.AA88633p0",
"0x0.AADDBCCp0",
"0x0.AB33410p0",
"0x0.AB88F00p0",
"0x0.ABDEC9Fp0",
"0x0.AC34CEDp0",
"0x0.AC8AFECp0",
"0x0.ACE159Ep0",
"0x0.AD37E03p0",
"0x0.AD8E91Cp0",
"0x0.ADE56ECp0",
"0x0.AE3C774p0",
"0x0.AE93AB4p0",
"0x0.AEEB0AFp0",
"0x0.AF42965p0",
"0x0.AF9A4D9p0",
"0x0.AFF230Ap0",
"0x0.B04A3FCp0",
"0x0.B0A27AFp0",
"0x0.B0FAE24p0",
"0x0.B15375Ep0",
"0x0.B1AC35Cp0",
"0x0.B205221p0",
"0x0.B25E3AFp0",
"0x0.B2B7805p0",
"0x0.B310F27p0",
"0x0.B36A915p0",
"0x0.B3C45D1p0",
"0x0.B41E55Bp0",
"0x0.B4787B7p0",
"0x0.B4D2CE4p0",
"0x0.B52D4E4p0",
"0x0.B587FB9p0",
"0x0.B5E2D64p0",
"0x0.B63DDE7p0",
"0x0.B699142p0",
"0x0.B6F4779p0",
"0x0.B75008Ap0",
"0x0.B7ABC7Ap0",
"0x0.B807B47p0",
"0x0.B863CF5p0",
"0x0.B8C0185p0",
"0x0.B91C8F7p0",
"0x0.B97934Ep0",
"0x0.B9D608Bp0",
"0x0.BA330AFp0",
"0x0.BA903BCp0",
"0x0.BAED9B4p0",
"0x0.BB4B296p0",
"0x0.BBA8E67p0",
"0x0.BC06D25p0",
"0x0.BC64ED4p0",
"0x0.BCC3375p0",
"0x0.BD21B08p0",
"0x0.BD80590p0",
"0x0.BDDF30Ep0",
"0x0.BE3E384p0",
"0x0.BE9D6F2p0",
"0x0.BEFCD5Bp0",
"0x0.BF5C6C0p0",
"0x0.BFBC322p0",
"0x0.C01C284p0",
"0x0.C07C4E5p0",
"0x0.C0DCA49p0",
"0x0.C13D2B0p0",
"0x0.C19DE1Cp0",
"0x0.C1FEC8Fp0",
"0x0.C25FE09p0",
"0x0.C2C128Dp0",
"0x0.C322A1Cp0",
"0x0.C3844B8p0",
"0x0.C3E6262p0",
"0x0.C44831Bp0",
"0x0.C4AA6E5p0",
"0x0.C50CDC2p0",
"0x0.C56F7B4p0",
"0x0.C5D24BBp0",
"0x0.C6354D9p0",
"0x0.C698810p0",
"0x0.C6FBE61p0",
"0x0.C75F7CFp0",
"0x0.C7C345Ap0",
"0x0.C827404p0",
"0x0.C88B6CEp0",
"0x0.C8EFCBBp0",
"0x0.C9545CCp0",
"0x0.C9B9201p0",
"0x0.CA1E15Ep0",
"0x0.CA833E3p0",
"0x0.CAE8992p0",
"0x0.CB4E26Dp0",
"0x0.CBB3E75p0",
"0x0.CC19DACp0",
"0x0.CC80014p0",
"0x0.CCE65ADp0",
"0x0.CD4CE7Ap0",
"0x0.CDB3A7Cp0",
"0x0.CE1A9B5p0",
"0x0.CE81C26p0",
"0x0.CEE91D2p0",
"0x0.CF50AB9p0",
"0x0.CFB86DDp0",
"0x0.D020640p0",
"0x0.D0888E4p0",
"0x0.D0F0EC9p0",
"0x0.D1597F3p0",
"0x0.D1C2462p0",
"0x0.D22B418p0",
"0x0.D294717p0",
"0x0.D2FDD60p0",
"0x0.D3676F4p0",
"0x0.D3D13D7p0",
"0x0.D43B409p0",
"0x0.D4A578Cp0",
"0x0.D50FE61p0",
"0x0.D57A88Bp0",
"0x0.D5E560Ap0",
"0x0.D6506E1p0",
"0x0.D6BBB12p0",
"0x0.D72729Dp0",
"0x0.D792D85p0",
"0x0.D7FEBCBp0",
"0x0.D86AD71p0",
"0x0.D8D7279p0",
"0x0.D943AE4p0",
"0x0.D9B06B4p0",
"0x0.DA1D5EBp0",
"0x0.DA8A88Bp0",
"0x0.DAF7E94p0",
"0x0.DB6580Ap0",
"0x0.DBD34EDp0",
"0x0.DC4153Fp0",
"0x0.DCAF903p0",
"0x0.DD1E039p0",
"0x0.DD8CAE4p0",
"0x0.DDFB905p0",
"0x0.DE6AA9Dp0",
"0x0.DED9FB0p0",
"0x0.DF4983Ep0",
"0x0.DFB9449p0",
"0x0.E0293D2p0",
"0x0.E0996DDp0",
"0x0.E109D6Ap0",
"0x0.E17A77Bp0",
"0x0.E1EB512p0",
"0x0.E25C631p0",
"0x0.E2CDAD9p0",
"0x0.E33F30Cp0",
"0x0.E3B0ECCp0",
"0x0.E422E1Bp0",
"0x0.E4950FBp0",
"0x0.E50776Dp0",
"0x0.E57A173p0",
"0x0.E5ECF0Fp0",
"0x0.E660043p0",
"0x0.E6D3510p0",
"0x0.E746D78p0",
"0x0.E7BA97Ep0",
"0x0.E82E923p0",
"0x0.E8A2C68p0",
"0x0.E917350p0",
"0x0.E98BDDCp0",
"0x0.EA00C0Ep0",
"0x0.EA75DE8p0",
"0x0.EAEB36Dp0",
"0x0.EB60C9Cp0",
"0x0.EBD697Ap0",
"0x0.EC4CA06p0",
"0x0.ECC2E44p0",
"0x0.ED39635p0",
"0x0.EDB01DBp0",
"0x0.EE27138p0",
"0x0.EE9E44Dp0",
"0x0.EF15B1Dp0",
"0x0.EF8D5A9p0",
"0x0.F0053F3p0",
"0x0.F07D5FDp0",
"0x0.F0F5BCAp0",
"0x0.F16E55Ap0",
"0x0.F1E72B0p0",
"0x0.F2603CDp0",
"0x0.F2D98B4p0",
"0x0.F353166p0",
"0x0.F3CCDE6p0",
"0x0.F446E35p0",
"0x0.F4C1255p0",
"0x0.F53BA48p0",
"0x0.F5B6610p0",
"0x0.F6315AFp0",
"0x0.F6AC926p0",
"0x0.F728078p0",
"0x0.F7A3BA7p0",
"0x0.F81FAB5p0",
"0x0.F89BDA3p0",
"0x0.F918473p0",
"0x0.F994F28p0",
"0x0.FA11DC3p0",
"0x0.FA8F046p0",
"0x0.FB0C6B4p0",
"0x0.FB8A10Ep0",
"0x0.FC07F55p0",
"0x0.FC8618Ep0",
"0x0.FD047B8p0",
"0x0.FD831D6p0",
"0x0.FE01FEAp0",
"0x0.FE811F7p0",
"0x0.FF007FDp0",
"0x0.FF801FFp0",
};

// w_Z1 = 8 for double
template <> class table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_Z1 < ap_ufixed<58, 1, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x1.000000000000000p0",
"0x1.0100802AB55777Dp0",
"0x1.0202015600445B0p0",
"0x1.0304848362076A0p0",
"0x1.04080AB55DE3917p0",
"0x1.050C94EF7A206DCp0",
"0x1.06122436410DD14p0",
"0x1.0718B98F42084EFp0",
"0x1.08205601127EC98p0",
"0x1.0928FA934EF9093p0",
"0x1.0A32A84E9C1F581p0",
"0x1.0B3D603CA7C3273p0",
"0x1.0C49236829E8BC2p0",
"0x1.0D55F2DCE5D1E96p0",
"0x1.0E63CFA7AB09D17p0",
"0x1.0F72BAD65671B69p0",
"0x1.1082B577D34ED7Dp0",
"0x1.1193C09C1C595C4p0",
"0x1.12A5DD543CCC4DDp0",
"0x1.13B90CB25176A4Cp0",
"0x1.14CD4FC989CD645p0",
"0x1.15E2A7AE28FECA6p0",
"0x1.16F91575870692Fp0",
"0x1.18109A3611C34FBp0",
"0x1.192937074E0CD68p0",
"0x1.1A42ED01D8CBC61p0",
"0x1.1B5DBD3F6812230p0",
"0x1.1C79A8DACC350DEp0",
"0x1.1D96B0EFF0E793Dp0",
"0x1.1EB4D69BDE569A3p0",
"0x1.1FD41AFCBA45E6Ep0",
"0x1.20F47F31C92E464p0",
"0x1.2216045B6F5CCF9p0",
"0x1.2338AB9B3213497p0",
"0x1.245C7613B8A9AF2p0",
"0x1.258164E8CDB0D82p0",
"0x1.26A7793F601642Bp0",
"0x1.27CEB43D844902Fp0",
"0x1.28F7170A755FD75p0",
"0x1.2A20A2CE964063Dp0",
"0x1.2B4B58B372C7950p0",
"0x1.2C7739E3C0F32BDp0",
"0x1.2DA4478B620C73Ep0",
"0x1.2ED282D763D424Dp0",
"0x1.3001ECF601AF700p0",
"0x1.31328716A5D63C2p0",
"0x1.32645269EA828F9p0",
"0x1.339750219B212A8p0",
"0x1.34CB8170B58352Dp0",
"0x1.3600E78B6B11D19p0",
"0x1.373783A7220124Fp0",
"0x1.386F56FA7686E62p0",
"0x1.39A862BD3C1065Fp0",
"0x1.3AE2A8287E7A804p0",
"0x1.3C1E2876834AA7Fp0",
"0x1.3D5AE4E2CAE92C8p0",
"0x1.3E98DEAA11DCBAAp0",
"0x1.3FD8170A520718Bp0",
"0x1.41188F42C3E320Fp0",
"0x1.425A4893DFC3F9Ep0",
"0x1.439D443F5F158EEp0",
"0x1.44E183883D9E498p0",
"0x1.462707B2BAC20DBp0",
"0x1.476DD2045AC678Dp0",
"0x1.48B5E3C3E818667p0",
"0x1.49FF3E397492BACp0",
"0x1.4B49E2AE5AC6746p0",
"0x1.4C95D26D3F44074p0",
"0x1.4DE30EC211E6013p0",
"0x1.4F3198FA0F1CF9Ep0",
"0x1.50817263C13CCF5p0",
"0x1.51D29C4F01CB308p0",
"0x1.5325180CFACF76Cp0",
"0x1.5478E6F02823D02p0",
"0x1.55CE0A4C58C7BB2p0",
"0x1.57248376B033D61p0",
"0x1.587C53C5A7AF027p0",
"0x1.59D57C910FA4DE7p0",
"0x1.5B2FFF3210FD957p0",
"0x1.5C8BDD032E7708Fp0",
"0x1.5DE9176045FF53Bp0",
"0x1.5F47AFA69210A75p0",
"0x1.60A7A734AB0E875p0",
"0x1.6208FF6A88A4614p0",
"0x1.636BB9A9832584Dp0",
"0x1.64CFD75454EE7BFp0",
"0x1.663559CF1BC7C5Ap0",
"0x1.679C427F5A49F39p0",
"0x1.690492CBF9432CFp0",
"0x1.6A6E4C1D491E179p0",
"0x1.6BD96FDD034A27Fp0",
"0x1.6D45FF764BA55B5p0",
"0x1.6EB3FC55B1E75B4p0",
"0x1.702367E9330E0DDp0",
"0x1.719443A03ACB928p0",
"0x1.730690EBA4F5ADFp0",
"0x1.747A513DBEF6A62p0",
"0x1.75EF860A493F8FBp0",
"0x1.776630C678BC0EDp0",
"0x1.78DE52E8F8478BBp0",
"0x1.7A57EDE9EA23DE3p0",
"0x1.7BD30342E9716FBp0",
"0x1.7D4F946F0BA8D6Ap0",
"0x1.7ECDA2EAE215EBFp0",
"0x1.804D30347B545CBp0",
"0x1.81CE3DCB64CDB88p0",
"0x1.8350CD30AC38FF6p0",
"0x1.84D4DFE6E11BAF5p0",
"0x1.865A7772164C541p0",
"0x1.87E19557E3769A2p0",
"0x1.896A3B1F66A0E69p0",
"0x1.8AF46A5145B3750p0",
"0x1.8C802477B000FDCp0",
"0x1.8E0D6B1E5FD0E54p0",
"0x1.8F9C3FD29BEAF6Bp0",
"0x1.912CA4233924AA7p0",
"0x1.92BE99A09BEFFB7p0",
"0x1.945221DCB9EBCBAp0",
"0x1.95E73E6B1B75D9Bp0",
"0x1.977DF0E0DD3E499p0",
"0x1.99163AD4B1DCC13p0",
"0x1.9AB01DDEE3671B6p0",
"0x1.9C4B9B995509B1Fp0",
"0x1.9DE8B59F84A1410p0",
"0x1.9F876D8E8C56650p0",
"0x1.A127C505243AB4Fp0",
"0x1.A2C9BDA3A3E77AAp0",
"0x1.A46D590C041E0A9p0",
"0x0.9B4597E37CB04FFp0",
"0x0.9BE12B381386EBAp0",
"0x0.9C7D5A6DE293099p0",
"0x0.9D1A262119177CBp0",
"0x0.9DB78EEE82D48C8p0",
"0x0.9E55957388A4C0Ep0",
"0x0.9EF43A4E311A4ACp0",
"0x0.9F937E1D211D0B1p0",
"0x0.A033617F9C89377p0",
"0x0.A0D3E51586CE9E3p0",
"0x0.A175097F63908A0p0",
"0x0.A216CF5E5746455p0",
"0x0.A2B9375427DC3EFp0",
"0x0.A35C42033D55D02p0",
"0x0.A3FFF00EA26FA4Ap0",
"0x0.A4A4421A0542C56p0",
"0x0.A54938C9B7E846Bp0",
"0x0.A5EED4C2B11D9A6p0",
"0x0.A69516AA8CE986Cp0",
"0x0.A73BFF278D41C26p0",
"0x0.A7E38EE09AB1365p0",
"0x0.A88BC67D44FEE6Bp0",
"0x0.A934A6A5C3D5825p0",
"0x0.A9DE3002F76B9AEp0",
"0x0.AA88633E692C84Ap0",
"0x0.AB3341024C61E05p0",
"0x0.ABDEC9F97EDDCE4p0",
"0x0.AC8AFECF89A5CC7p0",
"0x0.AD37E030A19E3F4p0",
"0x0.ADE56EC9A836A6Ep0",
"0x0.AE93AB482C16806p0",
"0x0.AF42965A69CAD4Cp0",
"0x0.AFF230AF4C74755p0",
"0x0.B0A27AF66E76E6Dp0",
"0x0.B15375E01A27FC3p0",
"0x0.B205221D4A8020Cp0",
"0x0.B2B7805FABCB532p0",
"0x0.B36A91599C5AD1Dp0",
"0x0.B41E55BE2D37798p0",
"0x0.B4D2CE4122D4D60p0",
"0x0.B587FB96F5C4E71p0",
"0x0.B63DDE74D36C98Bp0",
"0x0.B6F477909EB8F0Cp0",
"0x0.B7ABC7A0F0D4F20p0",
"0x0.B863CF5D19E0354p0",
"0x0.B91C8F7D21A6399p0",
"0x0.B9D608B9C8566BFp0",
"0x0.BA903BCC873CE7Ep0",
"0x0.BB4B296F917BF09p0",
"0x0.BC06D25DD4C6241p0",
"0x0.BCC33752FA19691p0",
"0x0.BD80590B667A97Fp0",
"0x0.BE3E38443BB1DFEp0",
"0x0.BEFCD5BB5907E8Dp0",
"0x0.BFBC322F5C03B26p0",
"0x0.C07C4E5FA129321p0",
"0x0.C13D2B0C44B8AF4p0",
"0x0.C1FEC8F6236EE00p0",
"0x0.C2C128DEDB45C57p0",
"0x0.C3844B88CC364A2p0",
"0x0.C44831B718FAA1Dp0",
"0x0.C50CDC2DA7D16C9p0",
"0x0.C5D24BB123419CAp0",
"0x0.C6988106FADF218p0",
"0x0.C75F7CF56410574p0",
"0x0.C82740435AD43C0p0",
"0x0.C8EFCBB8A2896C2p0",
"0x0.C9B9201DC6B5E5Bp0",
"0x0.CA833E3C1BCF93Ep0",
"0x0.CB4E26DDC005A3Ap0",
"0x0.CC19DACD9C0AA1Dp0",
"0x0.CCE65AD763DF644p0",
"0x0.CDB3A7C7979EBD5p0",
"0x0.CE81C26B8449FC9p0",
"0x0.CF50AB9144963B9p0",
"0x0.D0206407C1BA78Bp0",
"0x0.D0F0EC9EB43E807p0",
"0x0.D1C24626A4CAA61p0",
"0x0.D2947170ECF84C4p0",
"0x0.D3676F4FB8233EDp0",
"0x0.D43B4096043BDE0p0",
"0x0.D50FE617A29A1CBp0",
"0x0.D5E560A938D151Dp0",
"0x0.D6BBB1204184DDBp0",
"0x0.D792D8530D3DA53p0",
"0x0.D86AD718C34061Dp0",
"0x0.D943AE496264C99p0",
"0x0.DA1D5EBDC1ED8D8p0",
"0x0.DAF7E94F9261313p0",
"0x0.DBD34ED95E63BB6p0",
"0x0.DCAF90368B91406p0",
"0x0.DD8CAE435B59485p0",
"0x0.DE6AA9DCEBDB100p0",
"0x0.DF4983E138C2A7Bp0",
"0x0.E0293D2F1C26EE7p0",
"0x0.E109D6A64F686C6p0",
"0x0.E1EB51276C110C3p0",
"0x0.E2CDAD93ECB4B4Ep0",
"0x0.E3B0ECCE2DD2C3Fp0",
"0x0.E4950FB96EB86A9p0",
"0x0.E57A1739D263EC9p0",
"0x0.E66004346068C38p0",
"0x0.E746D78F05D4A68p0",
"0x0.E82E92309615774p0",
"0x0.E9173500CBE0159p0",
"0x0.EA00C0E84A181A3p0",
"0x0.EAEB36D09CB879Ap0",
"0x0.EBD697A439BD105p0",
"0x0.ECC2E44E820D18Cp0",
"0x0.EDB01DBBC2668C3p0",
"0x0.EE9E44D9344A6FEp0",
"0x0.EF8D5A94FEEA0E4p0",
"0x0.F07D5FDE38151E7p0",
"0x0.F16E55A4E528DA0p0",
"0x0.F2603CD9FC00028p0",
"0x0.F353166F63E3D78p0",
"0x0.F446E357F67DFD8p0",
"0x0.F53BA48780CB586p0",
"0x0.F6315AF2C40FD7Bp0",
"0x0.F728078F76CB38Cp0",
"0x0.F81FAB5445AEBC8p0",
"0x0.F9184738D493D4Fp0",
"0x0.FA11DC35BF73C89p0",
"0x0.FB0C6B449B604ECp0",
"0x0.FC07F55FF77D249p0",
"0x0.FD047B835DFA9C5p0",
"0x0.FE01FEAB551127Cp0",
"0x0.FF007FD55FFDDE3p0",
};

// =============================================== f_Z2 tables for exp() ==========================
// f_Z2 tables
template <typename T> class table_f_Z2 {};

// w_Z2_ind = 5 for float
template <> class table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [32];};
const ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<27, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [32] = {
"0x0",
"0x0.0000000p0",
"0x0.0000002p0",
"0x0.0000004p0",
"0x0.0000008p0",
"0x0.000000Cp0",
"0x0.0000012p0",
"0x0.0000018p0",
"0x0.0000020p0",
"0x0.0000028p0",
"0x0.0000032p0",
"0x0.000003Cp0",
"0x0.0000048p0",
"0x0.0000054p0",
"0x0.0000062p0",
"0x0.0000070p0",
"0x0.0000080p0",
"0x0.0000090p0",
"0x0.00000A2p0",
"0x0.00000B4p0",
"0x0.00000C8p0",
"0x0.00000DCp0",
"0x0.00000F2p0",
"0x0.0000108p0",
"0x0.0000120p0",
"0x0.0000138p0",
"0x0.0000152p0",
"0x0.000016Cp0",
"0x0.0000188p0",
"0x0.00001A4p0",
"0x0.00001C2p0",
"0x0.00001E0p0",
};

// w_Z2 = 8 for double
template <> class table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z2 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.0000000080002AAp0",
"0x0.000000020001555p0",
"0x0.000000048004800p0",
"0x0.00000008000AAABp0",
"0x0.0000000C8014D56p0",
"0x0.000000120024003p0",
"0x0.0000001880392B0p0",
"0x0.000000200055560p0",
"0x0.000000288079811p0",
"0x0.0000003200A6AC4p0",
"0x0.0000003C80DDD7Bp0",
"0x0.000000480120036p0",
"0x0.00000054816E2F5p0",
"0x0.0000006201C95B9p0",
"0x0.000000708232883p0",
"0x0.0000008002AAB55p0",
"0x0.000000908332E2Ep0",
"0x0.000000A203CC111p0",
"0x0.000000B484773FEp0",
"0x0.000000C805356F6p0",
"0x0.000000DC86079FAp0",
"0x0.000000F206EED0Cp0",
"0x0.0000010887EC02Ep0",
"0x0.000001200900360p0",
"0x0.000001388A2C6A3p0",
"0x0.000001520B719FBp0",
"0x0.0000016C8CD0D68p0",
"0x0.000001880E4B0EBp0",
"0x0.000001A48FE1487p0",
"0x0.000001C2119483Dp0",
"0x0.000001E09365C0Fp0",
"0x0.000002001556000p0",
"0x0.000002209766410p0",
"0x0.000002421997843p0",
"0x0.000002649BEAC99p0",
"0x0.000002881E61116p0",
"0x0.000002ACA0FB5BBp0",
"0x0.000002D223BAA8Cp0",
"0x0.000002F8A69FF89p0",
"0x0.0000032029AC4B6p0",
"0x0.00000348ACE0A15p0",
"0x0.00000372303DFA8p0",
"0x0.0000039CB3C5572p0",
"0x0.000003C83777B77p0",
"0x0.000003F4BB561B8p0",
"0x0.000004223F61838p0",
"0x0.00000450C39AEFAp0",
"0x0.000004804803602p0",
"0x0.000004B0CC9BD51p0",
"0x0.000004E251654EBp0",
"0x0.00000514D660CD4p0",
"0x0.000005485B8F50Ep0",
"0x0.0000057CE0F1D9Cp0",
"0x0.000005B26689683p0",
"0x0.000005E8EC56FC4p0",
"0x0.00000620725B964p0",
"0x0.00000658F898366p0",
"0x0.000006927F0DDCDp0",
"0x0.000006CD05BD89Ep0",
"0x0.000007088CA83DCp0",
"0x0.0000074513CEF8Ap0",
"0x0.000007829B32BACp0",
"0x0.000007C122D4847p0",
"0x0.00000800AAB555Dp0",
"0x0.0000084132D62F4p0",
"0x0.00000882BB3810Fp0",
"0x0.000008C543DBFB2p0",
"0x0.00000908CCC2EE1p0",
"0x0.0000094D55EDEA1p0",
"0x0.00000992DF5DEF6p0",
"0x0.000009D96913FE3p0",
"0x0.00000A20F31116Fp0",
"0x0.00000A697D5639Cp0",
"0x0.00000AB307E4671p0",
"0x0.00000AFD92BC9F0p0",
"0x0.00000B491DDFE1Fp0",
"0x0.00000B95A94F303p0",
"0x0.00000BE3350B8A0p0",
"0x0.00000C31C115EFBp0",
"0x0.00000C814D6F61Ap0",
"0x0.00000CD1DA18E00p0",
"0x0.00000D2367136B4p0",
"0x0.00000D75F46003Ap0",
"0x0.00000DC981FFA97p0",
"0x0.00000E1E0FF35D1p0",
"0x0.00000E739E3C1ECp0",
"0x0.00000ECA2CDAEEFp0",
"0x0.00000F21BBD0CDFp0",
"0x0.00000F7A4B1EBC0p0",
"0x0.00000FD3DAC5B9Ap0",
"0x0.0000102E6AC6C70p0",
"0x0.00001089FB22E4Ap0",
"0x0.000010E68BDB12Cp0",
"0x0.000011441CF051Dp0",
"0x0.000011A2AE63A21p0",
"0x0.000012024036040p0",
"0x0.00001262D26877Fp0",
"0x0.000012C464FBFE5p0",
"0x0.00001326F7F1976p0",
"0x0.0000138A8B4A43Ap0",
"0x0.000013EF1F07037p0",
"0x0.00001454B328D73p0",
"0x0.000014BB47B0BF4p0",
"0x0.00001522DC9FBC0p0",
"0x0.0000158B71F6CDFp0",
"0x0.000015F507B6F57p0",
"0x0.0000165F9DE132Dp0",
"0x0.000016CB347686Ap0",
"0x0.00001737CB77F14p0",
"0x0.000017A562E6731p0",
"0x0.00001813FAC30C8p0",
"0x0.00001883930EBE1p0",
"0x0.000018F42BCA882p0",
"0x0.00001965C4F76B2p0",
"0x0.000019D85E96678p0",
"0x0.00001A4BF8A87DCp0",
"0x0.00001AC0932EAE5p0",
"0x0.00001B362E29F9Ap0",
"0x0.00001BACC99B602p0",
"0x0.00001C246583E25p0",
"0x0.00001C9D01E480Bp0",
"0x0.00001D169EBE3BAp0",
"0x0.00001D913C1213Ap0",
"0x0.00001E0CD9E1094p0",
"0x0.00001E89782C1CEp0",
"0x0.00001F0716F44F1p0",
"0x0.00001F85B63AA05p0",
"0x0.000020055600111p0",
"0x0.00002085F645A1Dp0",
"0x0.00002107970C531p0",
"0x0.0000218A3855256p0",
"0x0.0000220DDA21194p0",
"0x0.000022927C712F3p0",
"0x0.000023181F4667Ap0",
"0x0.0000239EC2A1C34p0",
"0x0.000024266684427p0",
"0x0.000024AF0AEEE5Cp0",
"0x0.00002538AFE2ADDp0",
"0x0.000025C355609B1p0",
"0x0.0000264EFB69AE1p0",
"0x0.000026DBA1FEE76p0",
"0x0.000027694921479p0",
"0x0.000027F7F0D1CF3p0",
"0x0.0000288799117ECp0",
"0x0.0000291841E156Dp0",
"0x0.000029A9EB42580p0",
"0x0.00002A3C953582Ep0",
"0x0.00002AD03FBBD7Fp0",
"0x0.00002B64EAD657Ep0",
"0x0.00002BFA9686033p0",
"0x0.00002C9142CBDA7p0",
"0x0.00002D28EFA8DE5p0",
"0x0.00002DC19D1E0F5p0",
"0x0.00002E5B4B2C6E1p0",
"0x0.00002EF5F9D4FB3p0",
"0x0.00002F91A918B74p0",
"0x0.0000302E58F8A2Ep0",
"0x0.000030CC0975BECp0",
"0x0.0000316ABA910B6p0",
"0x0.0000320A6C4B897p0",
"0x0.000032AB1EA6398p0",
"0x0.0000334CD1A21C4p0",
"0x0.000033EF8540325p0",
"0x0.0000349339817C5p0",
"0x0.00003537EE66FAEp0",
"0x0.000035DDA3F1AEAp0",
"0x0.000036845A22985p0",
"0x0.0000372C10FAB88p0",
"0x0.000037D4C87B0FDp0",
"0x0.0000387E80A49F0p0",
"0x0.00003929397866Ap0",
"0x0.000039D4F2F7678p0",
"0x0.00003A81AD22A22p0",
"0x0.00003B2F67FB175p0",
"0x0.00003BDE2381C7Bp0",
"0x0.00003C8DDFB7B3Ep0",
"0x0.00003D3E9C9DDCBp0",
"0x0.00003DF05A3542Bp0",
"0x0.00003EA3187EE6Ap0",
"0x0.00003F56D77BC94p0",
"0x0.0000400B972CEB3p0",
"0x0.000040C157934D3p0",
"0x0.0000417818AFEFEp0",
"0x0.0000422FDA83D42p0",
"0x0.000042E89D0FFA8p0",
"0x0.000043A2605563Dp0",
"0x0.0000445D245510Cp0",
"0x0.00004518E910021p0",
"0x0.000045D5AE87387p0",
"0x0.0000469374BBB4Bp0",
"0x0.000047523BAE778p0",
"0x0.00004812036081Ap0",
"0x0.000048D2CBD2D3Dp0",
"0x0.0000499495066EEp0",
"0x0.00004A575EFC538p0",
"0x0.00004B1B29B5827p0",
"0x0.00004BDFF532FC8p0",
"0x0.00004CA5C175C27p0",
"0x0.00004D6C8E7ED50p0",
"0x0.00004E345C4F350p0",
"0x0.00004EFD2AE7E33p0",
"0x0.00004FC6FA49E06p0",
"0x0.00005091CA762D6p0",
"0x0.0000515D9B6DCAFp0",
"0x0.0000522A6D31B9Dp0",
"0x0.000052F83FC2FAFp0",
"0x0.000053C713228EFp0",
"0x0.00005496E75176Dp0",
"0x0.00005567BC50B33p0",
"0x0.000056399221450p0",
"0x0.0000570C68C42D1p0",
"0x0.000057E0403A6C3p0",
"0x0.000058B51885032p0",
"0x0.0000598AF1A4F2Dp0",
"0x0.00005A61CB9B3C1p0",
"0x0.00005B39A668DFAp0",
"0x0.00005C12820EDE8p0",
"0x0.00005CEC5E8E396p0",
"0x0.00005DC73BE7F13p0",
"0x0.00005EA31A1D06Dp0",
"0x0.00005F7FF92E7B1p0",
"0x0.0000605DD91D4EDp0",
"0x0.0000613CB9EA82Ep0",
"0x0.0000621C9B97184p0",
"0x0.000062FD7E240FBp0",
"0x0.000063DF61926A2p0",
"0x0.000064C245E3288p0",
"0x0.000065A62B174B9p0",
"0x0.0000668B112FD45p0",
"0x0.00006770F82DC39p0",
"0x0.00006857E0121A4p0",
"0x0.0000693FC8DDD95p0",
"0x0.00006A28B29201Ap0",
"0x0.00006B129D2F942p0",
"0x0.00006BFD88B791Bp0",
"0x0.00006CE9752AFB3p0",
"0x0.00006DD6628AD1Ap0",
"0x0.00006EC450D815Fp0",
"0x0.00006FB34013C8Fp0",
"0x0.000070A3303EEBBp0",
"0x0.00007194215A7F2p0",
"0x0.000072861367841p0",
"0x0.000073790666FB9p0",
"0x0.0000746CFA59E68p0",
"0x0.00007561EF4145Fp0",
"0x0.00007657E51E1ABp0",
"0x0.0000774EDBF165Dp0",
"0x0.00007846D3BC284p0",
"0x0.0000793FCC7F62Fp0",
"0x0.00007A39C63C16Ep0",
"0x0.00007B34C0F3451p0",
"0x0.00007C30BCA5EE7p0",
"0x0.00007D2DB955140p0",
"0x0.00007E2BB701B6Cp0",
"0x0.00007F2AB5ACD7Bp0",
};

// =============================================== f_Z3 table for exp() ==========================
// f_Z3 table
template <typename T> class table_f_Z3 {};

// w_Z3 = 8 for double
template <> class table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > { public:
table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ();
static const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array [256];};
const ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_Z3 < ap_ufixed<59, 0, (ap_q_mode)5, (ap_o_mode)3, 0> > ::array [256] = {
"0x0",
"0x0.000000000000800p0",
"0x0.000000000002000p0",
"0x0.000000000004800p0",
"0x0.000000000008000p0",
"0x0.00000000000C800p0",
"0x0.000000000012000p0",
"0x0.000000000018800p0",
"0x0.000000000020000p0",
"0x0.000000000028800p0",
"0x0.000000000032000p0",
"0x0.00000000003C800p0",
"0x0.000000000048000p0",
"0x0.000000000054800p0",
"0x0.000000000062000p0",
"0x0.000000000070800p0",
"0x0.000000000080000p0",
"0x0.000000000090800p0",
"0x0.0000000000A2000p0",
"0x0.0000000000B4800p0",
"0x0.0000000000C8000p0",
"0x0.0000000000DC800p0",
"0x0.0000000000F2000p0",
"0x0.000000000108800p0",
"0x0.000000000120000p0",
"0x0.000000000138800p0",
"0x0.000000000152000p0",
"0x0.00000000016C800p0",
"0x0.000000000188000p0",
"0x0.0000000001A4800p0",
"0x0.0000000001C2001p0",
"0x0.0000000001E0801p0",
"0x0.000000000200001p0",
"0x0.000000000220801p0",
"0x0.000000000242001p0",
"0x0.000000000264801p0",
"0x0.000000000288001p0",
"0x0.0000000002AC802p0",
"0x0.0000000002D2002p0",
"0x0.0000000002F8802p0",
"0x0.000000000320002p0",
"0x0.000000000348802p0",
"0x0.000000000372003p0",
"0x0.00000000039C803p0",
"0x0.0000000003C8003p0",
"0x0.0000000003F4803p0",
"0x0.000000000422003p0",
"0x0.000000000450804p0",
"0x0.000000000480004p0",
"0x0.0000000004B0804p0",
"0x0.0000000004E2005p0",
"0x0.000000000514805p0",
"0x0.000000000548005p0",
"0x0.00000000057C806p0",
"0x0.0000000005B2006p0",
"0x0.0000000005E8806p0",
"0x0.000000000620007p0",
"0x0.000000000658807p0",
"0x0.000000000692007p0",
"0x0.0000000006CC808p0",
"0x0.000000000708008p0",
"0x0.000000000744809p0",
"0x0.000000000782009p0",
"0x0.0000000007C080Ap0",
"0x0.00000000080000Ap0",
"0x0.00000000084080Bp0",
"0x0.00000000088200Bp0",
"0x0.0000000008C480Cp0",
"0x0.00000000090800Cp0",
"0x0.00000000094C80Dp0",
"0x0.00000000099200Dp0",
"0x0.0000000009D880Ep0",
"0x0.000000000A2000Fp0",
"0x0.000000000A6880Fp0",
"0x0.000000000AB2010p0",
"0x0.000000000AFC811p0",
"0x0.000000000B48011p0",
"0x0.000000000B94812p0",
"0x0.000000000BE2013p0",
"0x0.000000000C30814p0",
"0x0.000000000C80014p0",
"0x0.000000000CD0815p0",
"0x0.000000000D22016p0",
"0x0.000000000D74817p0",
"0x0.000000000DC8018p0",
"0x0.000000000E1C818p0",
"0x0.000000000E72019p0",
"0x0.000000000EC881Ap0",
"0x0.000000000F2001Bp0",
"0x0.000000000F7881Cp0",
"0x0.000000000FD201Dp0",
"0x0.00000000102C81Ep0",
"0x0.00000000108801Fp0",
"0x0.0000000010E4820p0",
"0x0.000000001142021p0",
"0x0.0000000011A0822p0",
"0x0.000000001200024p0",
"0x0.000000001260825p0",
"0x0.0000000012C2026p0",
"0x0.000000001324827p0",
"0x0.000000001388028p0",
"0x0.0000000013EC829p0",
"0x0.00000000145202Bp0",
"0x0.0000000014B882Cp0",
"0x0.00000000152002Dp0",
"0x0.00000000158882Fp0",
"0x0.0000000015F2030p0",
"0x0.00000000165C831p0",
"0x0.0000000016C8033p0",
"0x0.000000001734834p0",
"0x0.0000000017A2036p0",
"0x0.000000001810837p0",
"0x0.000000001880039p0",
"0x0.0000000018F083Ap0",
"0x0.00000000196203Cp0",
"0x0.0000000019D483Dp0",
"0x0.000000001A4803Fp0",
"0x0.000000001ABC841p0",
"0x0.000000001B32042p0",
"0x0.000000001BA8844p0",
"0x0.000000001C20046p0",
"0x0.000000001C98848p0",
"0x0.000000001D12049p0",
"0x0.000000001D8C84Bp0",
"0x0.000000001E0804Dp0",
"0x0.000000001E8484Fp0",
"0x0.000000001F02051p0",
"0x0.000000001F80853p0",
"0x0.000000002000055p0",
"0x0.000000002080857p0",
"0x0.000000002102059p0",
"0x0.00000000218485Bp0",
"0x0.00000000220805Dp0",
"0x0.00000000228C85Fp0",
"0x0.000000002312061p0",
"0x0.000000002398864p0",
"0x0.000000002420066p0",
"0x0.0000000024A8868p0",
"0x0.00000000253206Ap0",
"0x0.0000000025BC86Dp0",
"0x0.00000000264806Fp0",
"0x0.0000000026D4872p0",
"0x0.000000002762074p0",
"0x0.0000000027F0876p0",
"0x0.000000002880079p0",
"0x0.00000000291087Cp0",
"0x0.0000000029A207Ep0",
"0x0.000000002A34881p0",
"0x0.000000002AC8083p0",
"0x0.000000002B5C886p0",
"0x0.000000002BF2089p0",
"0x0.000000002C8888Cp0",
"0x0.000000002D2008Ep0",
"0x0.000000002DB8891p0",
"0x0.000000002E52094p0",
"0x0.000000002EEC897p0",
"0x0.000000002F8809Ap0",
"0x0.00000000302489Dp0",
"0x0.0000000030C20A0p0",
"0x0.0000000031608A3p0",
"0x0.0000000032000A6p0",
"0x0.0000000032A08A9p0",
"0x0.0000000033420ACp0",
"0x0.0000000033E48B0p0",
"0x0.0000000034880B3p0",
"0x0.00000000352C8B6p0",
"0x0.0000000035D20BAp0",
"0x0.0000000036788BDp0",
"0x0.0000000037200C0p0",
"0x0.0000000037C88C4p0",
"0x0.0000000038720C7p0",
"0x0.00000000391C8CBp0",
"0x0.0000000039C80CFp0",
"0x0.000000003A748D2p0",
"0x0.000000003B220D6p0",
"0x0.000000003BD08DAp0",
"0x0.000000003C800DDp0",
"0x0.000000003D308E1p0",
"0x0.000000003DE20E5p0",
"0x0.000000003E948E9p0",
"0x0.000000003F480EDp0",
"0x0.000000003FFC8F1p0",
"0x0.0000000040B20F5p0",
"0x0.0000000041688F9p0",
"0x0.0000000042200FDp0",
"0x0.0000000042D8901p0",
"0x0.000000004392105p0",
"0x0.00000000444C90Ap0",
"0x0.00000000450810Ep0",
"0x0.0000000045C4912p0",
"0x0.000000004682117p0",
"0x0.00000000474091Bp0",
"0x0.000000004800120p0",
"0x0.0000000048C0924p0",
"0x0.000000004982129p0",
"0x0.000000004A4492Dp0",
"0x0.000000004B08132p0",
"0x0.000000004BCC937p0",
"0x0.000000004C9213Bp0",
"0x0.000000004D58940p0",
"0x0.000000004E20145p0",
"0x0.000000004EE894Ap0",
"0x0.000000004FB214Fp0",
"0x0.00000000507C954p0",
"0x0.000000005148159p0",
"0x0.00000000521495Ep0",
"0x0.0000000052E2163p0",
"0x0.0000000053B0968p0",
"0x0.00000000548016Ep0",
"0x0.000000005550973p0",
"0x0.000000005622178p0",
"0x0.0000000056F497Ep0",
"0x0.0000000057C8183p0",
"0x0.00000000589C989p0",
"0x0.00000000597218Ep0",
"0x0.000000005A48994p0",
"0x0.000000005B2019Ap0",
"0x0.000000005BF899Fp0",
"0x0.000000005CD21A5p0",
"0x0.000000005DAC9ABp0",
"0x0.000000005E881B1p0",
"0x0.000000005F649B7p0",
"0x0.0000000060421BDp0",
"0x0.0000000061209C3p0",
"0x0.0000000062001C9p0",
"0x0.0000000062E09CFp0",
"0x0.0000000063C21D5p0",
"0x0.0000000064A49DBp0",
"0x0.0000000065881E2p0",
"0x0.00000000666C9E8p0",
"0x0.0000000067521EFp0",
"0x0.0000000068389F5p0",
"0x0.0000000069201FCp0",
"0x0.000000006A08A02p0",
"0x0.000000006AF2209p0",
"0x0.000000006BDCA10p0",
"0x0.000000006CC8216p0",
"0x0.000000006DB4A1Dp0",
"0x0.000000006EA2224p0",
"0x0.000000006F90A2Bp0",
"0x0.000000007080232p0",
"0x0.000000007170A39p0",
"0x0.000000007262240p0",
"0x0.000000007354A47p0",
"0x0.00000000744824Fp0",
"0x0.00000000753CA56p0",
"0x0.00000000763225Dp0",
"0x0.000000007728A65p0",
"0x0.00000000782026Cp0",
"0x0.000000007918A74p0",
"0x0.000000007A1227Bp0",
"0x0.000000007B0CA83p0",
"0x0.000000007C0828Bp0",
"0x0.000000007D04A92p0",
"0x0.000000007E0229Ap0",
"0x0.000000007F00AA2p0",
};

// =============================================== tables for ap_fixed<16, 8> ==========================
// for ap_fixed<16,8>
// x = x_hi + x_lo
// table_exp_x_hi stores exp(x_hi)
// table_f_x_lo stores exp(x_lo)-1-x_lo
//
// x_hi is a signed number
// and the arrays store the same value of exp(x_hi)
//
class table_exp_x_hi { public:
table_exp_x_hi ();
static const ap_ufixed<7, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array_0[64];
static const ap_ufixed<8, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array_1[64];
static const ap_ufixed<7, -8, (ap_q_mode)5, (ap_o_mode)3, 0> array_2[64];};

 const ap_ufixed<7, 7, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_0[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };

        const ap_ufixed<8, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_1[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };

        const ap_ufixed<7, -8, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x_hi::array_2[64] = {
"0x1.000000000000000000000000000000000000000000p0",
"0x1.48B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.A61298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x2.1DF3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.B7E151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x3.7D871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x4.7B4FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x5.C12DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x7.63992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x9.7CDC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xC.2EB7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xF.A48385EDF47E967751198A5B272F75C260F29691A0p0",
"0x14.15E5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x19.CA53B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x21.1D8E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x2A.8565A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x36.99205C4E74B0CF1ADA77FB727B72DA0594D50C2E86p0",
"0x46.1AFC4DB59E7474902055DF28644F442A9E0E994CD9p0",
"0x5A.0462B7877AA8B7CEC5D7D5D435D47F34F294DB9976p0",
"0x73.9593ABB7D46EB9BDC798BC724FEBAA13D9797916DDp0",
"0x94.69C4CB819C78FB37D56C91AD5F3A152E3863B69195p0",
"0xBE.90F6F83E92793E9812DE9B67AC4A0B67794FB0BF86p0",
"0xF4.B122790DDFB1298C834010B3969829412DCF5ADBBDp0",
"0x13A.30CF1CCBB3DD712D7E9F020974648E01F6E6ABB52Fp0",
"0x193.6DC5690C08F37A9AE51F9733225FFE391C8FE46235p0",
"0x206.03487A3B1C6DA37FE8832776A513F4B5E522768CE1p0",
"0x299.2442102D91286ADC35D9242DDF710888D666CC2896p0",
"0x356.0F0B0F980D1FA20F84DF9C2A4663472077AFD94C45p0",
"0x448.A216ABB76A9BC7E802A24DEB83C19118812A5379BBp0",
"0x580.1AD754FA363912642E45D1489452EA303073266BD3p0",
"0x710.0ADBAC7DAB4A4E2FEA0200F7CF3314DB6D466A8026p0",
"0x911.9289C3923DC4E45FBB198DFFF31B92274CCCDD528Cp0",
"0x0.0015FC21041027ACBBFCD46780FEE71EAD23FBCB7Fp0",
"0x0.001C3AA91FF0D49824E2426C56E9E14E76FFA0E0C7p0",
"0x0.00243F37481E63A93106235D10A5837F9B9068603Bp0",
"0x0.002E8ABFC647F5FAA77574769EE917008332DB845Bp0",
"0x0.003BC2D73849531D57332EFD57EF4A2B8A392CD9A6p0",
"0x0.004CBC19ADC92D737A7FBD319DF8B3BE9114673693p0",
"0x0.006287862A553FE97980EF7971AC049D26841D52CDp0",
"0x0.007E83A561ABAF1AE4E699A1D49FF332750B364376p0",
"0x0.00A2728F889EA6AEC05D023E000435E6089AC958E5p0",
"0x0.00D096336E6CAE8354C436134E24EB0959BB119FD9p0",
"0x0.010BD4A5ACA7728750451FE402CA590BE5BD2A53EFp0",
"0x0.0157E6BFE8DE51A99D4DFD8E6A27B702C0BD655748p0",
"0x0.01B993FE00D53761C45C249149A5B95DC61840D80Dp0",
"0x0.0236FF5BF3CE1321EC22F9DF29C343B308525032B9p0",
"0x0.02D80A08D2B882E7A4347E73A3CAF88BBF8604675Ap0",
"0x0.03A6D2222442EA3BCB888D8C3D446984C6E9229055p0",
"0x0.04B0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0605424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.07BB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.09ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.0CBED86667585764A4130191C84086803A08AE39CCp0",
"0x0.105D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.150385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1AFB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.22A555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2C7C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.391F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.495860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.5E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.78ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.9B4597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.C75F7CF564105743415CBC9D6368F3B96071095ABEp0",
        };

// x_lo is an unsigned number
// and the array store the value of exp(x_lo)-1-x_lo
//
class table_f_x_lo { public:
table_f_x_lo ();
static const ap_ufixed<11, -4, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};
        const ap_ufixed<11, -4, (ap_q_mode)5, (ap_o_mode)3, 0> table_f_x_lo::array[64] = {
"0x0",
"0x0.0000802AB55777D28A2A42D26AA9EE67BCF00C930Bp0",
"0x0.0002015600445B0C326382BC73689D326F63923DD8p0",
"0x0.0004848362076A08D9411A1CEE76CA2D65B11DB813p0",
"0x0.00080AB55DE3917AB864B3E9044E6B456F21041F46p0",
"0x0.000C94EF7A206DC2DA1F7B86DE3F8E864EF6A65A2Dp0",
"0x0.00122436410DD14E5659D75E95B76E1A857A4E668Ap0",
"0x0.0018B98F42084EFBDB328B919E6909847EC98C185Dp0",
"0x0.00205601127EC98E0BD083ABA80C97A6AA50178521p0",
"0x0.0028FA934EF9093044EF6E13ADF7CD6EBA2F758725p0",
"0x0.0032A84E9C1F58145CC1CF959B1B11093F5F980F92p0",
"0x0.003D603CA7C32730FADC469F215FD20BF82FEA5810p0",
"0x0.0049236829E8BC292CFE63D64B295EA1DA758B4607p0",
"0x0.0055F2DCE5D1E966E6B6D0A6A8E24E20C45FA36580p0",
"0x0.0063CFA7AB09D17324137D6C341C1D5CFB16053CCDp0",
"0x0.0072BAD65671B69772CC4A342D0E03A3DEEF5AF201p0",
"0x0.0082B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x0.0093C09C1C595C43E2F28C2BB379A6D086B8952F77p0",
"0x0.00A5DD543CCC4DDAFE1CC4A63C84ADEC1A44CA37FEp0",
"0x0.00B90CB25176A4C8BA56BA7452D24FE356F4915E61p0",
"0x0.00CD4FC989CD64555EA19C6E279C5E0A6409A56A48p0",
"0x0.00E2A7AE28FECA6FB3AFF16E11359ED08C61A07628p0",
"0x0.00F91575870692F2476E554B0595C0F3EDC574BF3Ep0",
"0x0.01109A3611C34FB645891BA5A60F3530346EEFC88Bp0",
"0x0.012937074E0CD6893D18CDBA80EABC29E7B47B51D4p0",
"0x0.0142ED01D8CBC61C41827CBB47DD2F852164B039D4p0",
"0x0.015DBD3F68122303EB9254A401DDB5572ACEE779B1p0",
"0x0.0179A8DACC350DE1D7E7D3123D7FE102B8BC392562p0",
"0x0.0196B0EFF0E793D158F49A640D8602BEEC5365B4D2p0",
"0x0.01B4D69BDE569A322D12247CD011F69D2E03754848p0",
"0x0.01D41AFCBA45E6ED2490B441CC4BF7EB8AFB05311Bp0",
"0x0.01F47F31C92E464FC01BEC8EC5D88F84D69100B065p0",
"0x0.0216045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x0.0238AB9B3213497226D3BF43B81CF0C2FE0D1C3784p0",
"0x0.025C7613B8A9AF215A71E40ABAEFAE6577D7D2A116p0",
"0x0.028164E8CDB0D8211DFD9B442823E2E014E19AABBFp0",
"0x0.02A7793F601642B5D730C0089A0E0B24CEC78FD0C5p0",
"0x0.02CEB43D844902F7A3480A58247D40B3B00D34F43Dp0",
"0x0.02F7170A755FD759ECCFE9CE012E333515097AB7F3p0",
"0x0.0320A2CE964063DAC45AA7526D44A178FE71EDC1ADp0",
"0x0.034B58B372C795013767C0C59D7D934A6542EC445Ep0",
"0x0.037739E3C0F32BD3089388767EC6CB651FFE523747p0",
"0x0.03A4478B620C73EB551D8C3F85A23D53879A9974FDp0",
"0x0.03D282D763D424DCDDF54E52AAFD9DBF745B1F8C05p0",
"0x0.0401ECF601AF700BD5C89634FFF557C6E8B1333EEAp0",
"0x0.04328716A5D63C2C42063E75D0BF952B219E8089E3p0",
"0x0.04645269EA828F932A6D0FC4D8CD212A227168671Ap0",
"0x0.049750219B212A8A019121D35445577E130E744FEFp0",
"0x0.04CB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x0.0500E78B6B11D19D6303225E84933F8D304B642D12p0",
"0x0.053783A7220124F51CE5A01C8187E7260077A5FEDFp0",
"0x0.056F56FA7686E623E3387F2344843C33967EA3C152p0",
"0x0.05A862BD3C1065F7469E72F43F0775514CC9BA2094p0",
"0x0.05E2A8287E7A8049E0A7F3D2D1427DACBD29348AB4p0",
"0x0.061E2876834AA7FA46011E98ABEADF76922C682878p0",
"0x0.065AE4E2CAE92C8AA9C6F26FE20BB71E4D971A328Ap0",
"0x0.0698DEAA11DCBAA377BDC040C05156D7577607601Fp0",
"0x0.06D8170A520718B46605B0C04672B6E2E3712843E6p0",
"0x0.07188F42C3E320F0BB08D7E21627BED4718E9B2C2Dp0",
"0x0.075A4893DFC3F9E4C1B99B1C7DBAB7A71F673EAE51p0",
"0x0.079D443F5F158EE3A4D178CA5BD3E80FE90C7BF9CFp0",
"0x0.07E183883D9E498E2998C09E5A0A5A8A0AEB9ED2FBp0",
"0x0.082707B2BAC20DB403D8C766005B3819B00D2918D6p0",
"0x0.086DD2045AC678D2BEF4D46281F716045167644BD9p0",
        };

// =============================================== tables for ap_fixed<8, 4> ==========================
// for ap_fixed<8,4>
// table_exp_x stores exp(x)
//
// x is a signed number
// and the arrays store the same value of exp(x)
//

class table_exp_x { public:
table_exp_x ();
static const ap_ufixed<3, 3, (ap_q_mode)5, (ap_o_mode)3, 0> array_0[128];
static const ap_ufixed<4, 0, (ap_q_mode)5, (ap_o_mode)3, 0> array_1[128];};

        const ap_ufixed<3, 3, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x::array_0[128] = {
"0x1.080000000000000000000000000000000000000000p0",
"0x1.1882B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x1.2A16045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x1.3CCB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x1.50B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.65E9176045FF53B513246531754403C29DB2C2F00Cp0",
"0x1.7C7A513DBEF6A623478B659B092405C578FA421F32p0",
"0x1.94802477B000FDC24DB40ED853110BEF137E20CF0Ap0",
"0x1.AE1298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x1.C94B4312564464432AA513BA422005EB74C2FFC3E4p0",
"0x1.E6455DF80E3C05CA897B072F6DAA5BC5942E1EE808p0",
"0x2.051DE6182F8C89D2C3B6D08C6597224224E114F55Ap0",
"0x2.25F3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.48E7A7E37AA2FFF223A7861B5865C559CC5920068Ep0",
"0x2.6E1CB0F6C564F38443FEAF672143A7EACCA15D6A42p0",
"0x2.95B809E9CA6704A25BFD953414F0F56C5439D7AA17p0",
"0x2.BFE151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x2.ECC2B42C0E5311F75A0A1AE923D4C04A68DA878226p0",
"0x3.1C891766B0ED0E3E661D5353DE3B7439677194BA13p0",
"0x3.4F64457102470C378267B1384AD9BC964CAF5D84D5p0",
"0x3.85871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x3.BF27C7915B29EC086E39B73B1905D65ADAB3D23565p0",
"0x3.FC7FE87A1D5F19A0D2DAC7AD2963D6DE6729BA390Bp0",
"0x4.3DCCDDAE27C89E47DCA21D8366EEA56A459715E270p0",
"0x4.834FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x4.CD4EC5127E2CC7E5CE59DD8C683540F9C5A8043103p0",
"0x5.1C134520127F660EE92DC97A97881578C14F21D2F9p0",
"0x5.6FEC44CD53E1D8103FDD848ED5EFCD994CAC5EA776p0",
"0x5.C92DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x6.2830ABCC7EBFE38D76963C6F0D9C0D6D434443A528p0",
"0x6.8D5466E0F306C77840907E7A69B2500F3CE65D86E8p0",
"0x6.F8FE017D49522BB3EB958EB5FEA9C3818259AFF22Ap0",
"0x7.6B992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x7.E59891C2B5263E4C74F8D3C24507F1751B727B44FCp0",
"0x8.677635B44463F17EFA0E17757F51A71C4857889976p0",
"0x8.F1B40280AB62E9EF755B858E49CA33771E8D70C830p0",
"0x9.84DC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xA.21822723BCCBF221C19AE0BEB2159249E7CA141876p0",
"0xA.C8426671100D96B2B37571D71915ACD425F0B4EEC6p0",
"0xB.79C3CD87578A85080EE6C10CC7D647BC947C530F21p0",
"0xC.36B7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xC.FFDBC7847516AD91A6FCAA504E5DF4422FF1B0F652p0",
"0xD.D5F892E85D2E8CB0206BB684F2DA5279F20EF41393p0",
"0xE.B9E47D68606FA157CCD6F76473055969133DEE3080p0",
"0xF.AC8385EDF47E967751198A5B272F75C260F29691A0p0",
"0x10.AEC85FBA36DADF507672125F699093D1DAE6913AB7p0",
"0x11.C1B5652D684392AF6521A8C41433F1502819A62959p0",
"0x12.E65D9A36D537EA6A7FCC5F658281D4A6436EB3458Cp0",
"0x14.1DE5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x15.698576F41530240D56EB5B6AE25A81C41120FE0855p0",
"0x16.CA887C1F169185A6DA92E2A3396F3877B58A5D45B9p0",
"0x18.424FEF61C650B5933FB79C08B46FF0B430A9D3608Dp0",
"0x19.D253B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x1B.7C23F99BD9475B0139A2A70CF9A29228932F866B75p0",
"0x1D.416AA9716D628E255DFA13F7B666F420F17A6D6916p0",
"0x1F.23ED3378C98744EA28E250B177BBD69D288C69504Bp0",
"0x21.258E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x23.484FA23D6B2ED9FD781B133D4E6B87157609DB32FDp0",
"0x25.8E5441C9F0A90028DC4FF65D5CA0725172591CAD95p0",
"0x27.F9E25639F534250CE816C34E3E5B0D1C21A7368507p0",
"0x2A.8D65A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x2D.4B71DD2CF5EA28AF5B2B91180451A25943D46F2C8Ep0",
"0x30.36C550B14DF3D5527158A5BC3CD7C207ACA19A6927p0",
"0x33.524B8D8E6206082357267EECCFB29182F42CD0B199p0",
"0x0.0CB0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0CFDBFA328F1B34A802A5024FBC337B0034E46CBFCp0",
"0x0.0D5028026AECB880451ECA0B595FC35DE4D10BBED2p0",
"0x0.0DA7E0FB0BC4D2D7FCE9051B77BE93AE64D0B84171p0",
"0x0.0E05424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.0E68A9625D8EB6A6F81B6A947F2837271A845A71E0p0",
"0x0.0ED279A9870EAA507BC020D1582BB0CCE72AED0E15p0",
"0x0.0F431CFBE91328DB6897AF05354B214C23CC0BD7A9p0",
"0x0.0FBB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.103AA6B98025B4B192724A53EE4DB3B8DDED61AD3Bp0",
"0x0.10C284C3144AAB3179BAAD3EF63F2F1AA34FC71EF7p0",
"0x0.1153260C52244DEAA4CBB664911EBF842811ED3EF9p0",
"0x0.11ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.1290FE67DB5155FD3C187CA8C3C60C9A3EA642A50Ap0",
"0x0.133F736CFFC23DC7E4182AEFE0C42733347CEB3F82p0",
"0x0.13F928D58D7BBDBAAA611045EF878892C954C1CF70p0",
"0x0.14BED86667585764A4130191C84086803A08AE39CCp0",
"0x0.159147DF980A8FA4110B923D1A7D4753312F2EA76Ap0",
"0x0.167149C222A2D95BEEFD44C6578E12FFC68DE20E2Ap0",
"0x0.175FBE22951DFBDBFAEA0C0A8EC44F7CCE920B7C99p0",
"0x0.185D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.196BC7E08095FED37B29FD5115086885BE66B95D4Cp0",
"0x0.1A8B6973646D8276ED2A35B2B25E379666F604AD85p0",
"0x0.1BBD97FB66F892E685E2829F35E912A08799530ECEp0",
"0x0.1D0385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1E5E78CBDD9BC0CA47DC2ED2F3C2FBC368CDD4D771p0",
"0x0.1FCFCC2D36C51196CF1FFF5217148DF1815FE0A94Dp0",
"0x0.2158F156C9C2AE2DD48183AEB708FF5B16863E4479p0",
"0x0.22FB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.24B8EF777F6DC635771D7602B129B513DB93332163p0",
"0x0.269328B4C50F6BEC0E3B76BC62AE6740870784571Ep0",
"0x0.288BF7A71898E505A0CEC7E946DBF6AF88D95B240Dp0",
"0x0.2AA555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2CE15B206201726FC504969004226BDF4AC2473927p0",
"0x0.2F4245674733A988F3F11726FB27DD9AE00B90CB29p0",
"0x0.31CA753935610B35ED6FCDBE21196A6BE7F827965Fp0",
"0x0.347C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.375AF0E6F85D04AFCCE5548E7EFEEFF31781F9D195p0",
"0x0.3A68CDB533DCC75F0F737009CB549F6E361916E0ADp0",
"0x0.3DA91784AEE38ED3932C7B8462E1F57E1513B17A91p0",
"0x0.411F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.44CE2A16225603BB465BB3430136F9098F44B96ADCp0",
"0x0.48BA18831D80B0FA9E97D677851A1386BC8A49851Ap0",
"0x0.4CE6C66DA13121ACB7530B5B6AB2714BEDC56F447Dp0",
"0x0.515860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.561359C97520CCB54CC51183E6D91A57BD94B4ADBEp0",
"0x0.5B1C6C91DEAC7F580C378A03213ED3B40E479C6D31p0",
"0x0.6078A2B41E3DFB5C3E632789C6C48259A4FAF6C0B3p0",
"0x0.662D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.6C40442F81A5D8382985CFA3934786E77794E54459p0",
"0x0.72B7782576B52D00953B6EA1C5FEC2B4F0CCAC5732p0",
"0x0.79996C787C78341066BFC732C2072F8F5D17386676p0",
"0x0.80ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.88B991FEC8010361182AA185169DE382A3EF78F891p0",
"0x0.9106E49A4C9F3D5958A5D1795C6AF854435B3A38CBp0",
"0x0.99DD49860AB457FE49ECBC03DE5C559D7E5D1F1536p0",
"0x0.A34597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.AD4938C9B7E846B122756D14A7C2C4BBB56E395688p0",
"0x0.B7F230AF4C747553D8DB804C224277431FE89589FAp0",
"0x0.C34B296F917BF09A22FBAA27077B854A35098FBF2Ap0",
"0x0.CF5F7CF564105743415CBC9D6368F3B96071095ABEp0",
"0x0.DC3B4096043BDE02C9DD90522BBE5C1ED729F2E882p0",
"0x0.E9EB51276C110C3C3EB1269F2F5D4AFABD8029F1B7p0",
"0x0.F87D5FDE38151E72F18FF03049AC5D7EA18E816731p0",
        };

        const ap_ufixed<4, 0, (ap_q_mode)5, (ap_o_mode)3, 0> table_exp_x::array_1[128] = {
"0x1.080000000000000000000000000000000000000000p0",
"0x1.1882B577D34ED7D5B1A019E225C9A951BA29557586p0",
"0x1.2A16045B6F5CCF9CED688384E06B8D4278BF0C84A8p0",
"0x1.3CCB8170B58352D4E0C48CB7C664934508E6B0A712p0",
"0x1.50B5E3C3E81866767BC3B69BAABE534EC43887164Ap0",
"0x1.65E9176045FF53B513246531754403C29DB2C2F00Cp0",
"0x1.7C7A513DBEF6A623478B659B092405C578FA421F32p0",
"0x1.94802477B000FDC24DB40ED853110BEF137E20CF0Ap0",
"0x1.AE1298E1E069BC972DFEFAB6DF33F9B1F651F16C10p0",
"0x1.C94B4312564464432AA513BA422005EB74C2FFC3E4p0",
"0x1.E6455DF80E3C05CA897B072F6DAA5BC5942E1EE808p0",
"0x2.051DE6182F8C89D2C3B6D08C6597224224E114F55Ap0",
"0x2.25F3B68CFB9EF7A986ADDC7DCEE21F256208D5AAA6p0",
"0x2.48E7A7E37AA2FFF223A7861B5865C559CC5920068Ep0",
"0x2.6E1CB0F6C564F38443FEAF672143A7EACCA15D6A42p0",
"0x2.95B809E9CA6704A25BFD953414F0F56C5439D7AA17p0",
"0x2.BFE151628AED2A6ABF7158809CF4F3C762E7160F35p0",
"0x2.ECC2B42C0E5311F75A0A1AE923D4C04A68DA878226p0",
"0x3.1C891766B0ED0E3E661D5353DE3B7439677194BA13p0",
"0x3.4F64457102470C378267B1384AD9BC964CAF5D84D5p0",
"0x3.85871DB61F5DFCAEA9E08A299CCB1E2E2B1B9C96CEp0",
"0x3.BF27C7915B29EC086E39B73B1905D65ADAB3D23565p0",
"0x3.FC7FE87A1D5F19A0D2DAC7AD2963D6DE6729BA390Bp0",
"0x4.3DCCDDAE27C89E47DCA21D8366EEA56A459715E270p0",
"0x4.834FF993F15055F6E4658D43E9DE43D063C9D08D67p0",
"0x4.CD4EC5127E2CC7E5CE59DD8C683540F9C5A8043103p0",
"0x5.1C134520127F660EE92DC97A97881578C14F21D2F9p0",
"0x5.6FEC44CD53E1D8103FDD848ED5EFCD994CAC5EA776p0",
"0x5.C92DA416EB2FAB7E8026F762A8662E91715276012Bp0",
"0x6.2830ABCC7EBFE38D76963C6F0D9C0D6D434443A528p0",
"0x6.8D5466E0F306C77840907E7A69B2500F3CE65D86E8p0",
"0x6.F8FE017D49522BB3EB958EB5FEA9C3818259AFF22Ap0",
"0x7.6B992E35376B730CE8EE881ADA2AEEA11EB9EBD939p0",
"0x7.E59891C2B5263E4C74F8D3C24507F1751B727B44FCp0",
"0x8.677635B44463F17EFA0E17757F51A71C4857889976p0",
"0x8.F1B40280AB62E9EF755B858E49CA33771E8D70C830p0",
"0x9.84DC417A3F405A65732B338B50F59F27FF6F0614A5p0",
"0xA.21822723BCCBF221C19AE0BEB2159249E7CA141876p0",
"0xA.C8426671100D96B2B37571D71915ACD425F0B4EEC6p0",
"0xB.79C3CD87578A85080EE6C10CC7D647BC947C530F21p0",
"0xC.36B7EC98F05D8EA6F61A6F424FCA73B0C7428E7DF9p0",
"0xC.FFDBC7847516AD91A6FCAA504E5DF4422FF1B0F652p0",
"0xD.D5F892E85D2E8CB0206BB684F2DA5279F20EF41393p0",
"0xE.B9E47D68606FA157CCD6F76473055969133DEE3080p0",
"0xF.AC8385EDF47E967751198A5B272F75C260F29691A0p0",
"0x10.AEC85FBA36DADF507672125F699093D1DAE6913AB7p0",
"0x11.C1B5652D684392AF6521A8C41433F1502819A62959p0",
"0x12.E65D9A36D537EA6A7FCC5F658281D4A6436EB3458Cp0",
"0x14.1DE5BF6FB105F2D4BDFC53744C3A390585839728AAp0",
"0x15.698576F41530240D56EB5B6AE25A81C41120FE0855p0",
"0x16.CA887C1F169185A6DA92E2A3396F3877B58A5D45B9p0",
"0x18.424FEF61C650B5933FB79C08B46FF0B430A9D3608Dp0",
"0x19.D253B781114AF16DE4A35A3E7984BB0CCFB66ECFA4p0",
"0x1B.7C23F99BD9475B0139A2A70CF9A29228932F866B75p0",
"0x1D.416AA9716D628E255DFA13F7B666F420F17A6D6916p0",
"0x1F.23ED3378C98744EA28E250B177BBD69D288C69504Bp0",
"0x21.258E4272D7B6A1AA6135943AECDCDABE62D8E19399p0",
"0x23.484FA23D6B2ED9FD781B133D4E6B87157609DB32FDp0",
"0x25.8E5441C9F0A90028DC4FF65D5CA0725172591CAD95p0",
"0x27.F9E25639F534250CE816C34E3E5B0D1C21A7368507p0",
"0x2A.8D65A144CDCDE8AC7A4D34BB87CCCB1DD8B2E21B7Ap0",
"0x2D.4B71DD2CF5EA28AF5B2B91180451A25943D46F2C8Ep0",
"0x30.36C550B14DF3D5527158A5BC3CD7C207ACA19A6927p0",
"0x33.524B8D8E6206082357267EECCFB29182F42CD0B199p0",
"0x0.0CB0556E084F3D1DFA2BC04CB0AB88F528F9435385p0",
"0x0.0CFDBFA328F1B34A802A5024FBC337B0034E46CBFCp0",
"0x0.0D5028026AECB880451ECA0B595FC35DE4D10BBED2p0",
"0x0.0DA7E0FB0BC4D2D7FCE9051B77BE93AE64D0B84171p0",
"0x0.0E05424D53C34A575DB52F89074253144DAEB04F5Fp0",
"0x0.0E68A9625D8EB6A6F81B6A947F2837271A845A71E0p0",
"0x0.0ED279A9870EAA507BC020D1582BB0CCE72AED0E15p0",
"0x0.0F431CFBE91328DB6897AF05354B214C23CC0BD7A9p0",
"0x0.0FBB0406393FD97DA56BD480D6949B8F64595CCE02p0",
"0x0.103AA6B98025B4B192724A53EE4DB3B8DDED61AD3Bp0",
"0x0.10C284C3144AAB3179BAAD3EF63F2F1AA34FC71EF7p0",
"0x0.1153260C52244DEAA4CBB664911EBF842811ED3EF9p0",
"0x0.11ED1B4290C8169517478690BCDDDAE60C5203586Fp0",
"0x0.1290FE67DB5155FD3C187CA8C3C60C9A3EA642A50Ap0",
"0x0.133F736CFFC23DC7E4182AEFE0C42733347CEB3F82p0",
"0x0.13F928D58D7BBDBAAA611045EF878892C954C1CF70p0",
"0x0.14BED86667585764A4130191C84086803A08AE39CCp0",
"0x0.159147DF980A8FA4110B923D1A7D4753312F2EA76Ap0",
"0x0.167149C222A2D95BEEFD44C6578E12FFC68DE20E2Ap0",
"0x0.175FBE22951DFBDBFAEA0C0A8EC44F7CCE920B7C99p0",
"0x0.185D93892FA0102DD1C4E6E46CBCE8C74FC85EB25Ep0",
"0x0.196BC7E08095FED37B29FD5115086885BE66B95D4Cp0",
"0x0.1A8B6973646D8276ED2A35B2B25E379666F604AD85p0",
"0x0.1BBD97FB66F892E685E2829F35E912A08799530ECEp0",
"0x0.1D0385C094F424A75E4834ABD70284000799197B51p0",
"0x0.1E5E78CBDD9BC0CA47DC2ED2F3C2FBC368CDD4D771p0",
"0x0.1FCFCC2D36C51196CF1FFF5217148DF1815FE0A94Dp0",
"0x0.2158F156C9C2AE2DD48183AEB708FF5B16863E4479p0",
"0x0.22FB718E8457F74E7FB8DCC8FE74370420022ED674p0",
"0x0.24B8EF777F6DC635771D7602B129B513DB93332163p0",
"0x0.269328B4C50F6BEC0E3B76BC62AE6740870784571Ep0",
"0x0.288BF7A71898E505A0CEC7E946DBF6AF88D95B240Dp0",
"0x0.2AA555477F03973FB6EDD5C25A052AE3F0DD961DA0p0",
"0x0.2CE15B206201726FC504969004226BDF4AC2473927p0",
"0x0.2F4245674733A988F3F11726FB27DD9AE00B90CB29p0",
"0x0.31CA753935610B35ED6FCDBE21196A6BE7F827965Fp0",
"0x0.347C72FC0440E5103405A65E3274B45917739F5246p0",
"0x0.375AF0E6F85D04AFCCE5548E7EFEEFF31781F9D195p0",
"0x0.3A68CDB533DCC75F0F737009CB549F6E361916E0ADp0",
"0x0.3DA91784AEE38ED3932C7B8462E1F57E1513B17A91p0",
"0x0.411F0EE496B83AC8D7D24BEE20B169DF7AF174A60Ep0",
"0x0.44CE2A16225603BB465BB3430136F9098F44B96ADCp0",
"0x0.48BA18831D80B0FA9E97D677851A1386BC8A49851Ap0",
"0x0.4CE6C66DA13121ACB7530B5B6AB2714BEDC56F447Dp0",
"0x0.515860DCA9613C9C6CDD86DA0B8D4B379A85E21DECp0",
"0x0.561359C97520CCB54CC51183E6D91A57BD94B4ADBEp0",
"0x0.5B1C6C91DEAC7F580C378A03213ED3B40E479C6D31p0",
"0x0.6078A2B41E3DFB5C3E632789C6C48259A4FAF6C0B3p0",
"0x0.662D58D8B3BCDF1ABADEC7829054F90DDA9805AAB2p0",
"0x0.6C40442F81A5D8382985CFA3934786E77794E54459p0",
"0x0.72B7782576B52D00953B6EA1C5FEC2B4F0CCAC5732p0",
"0x0.79996C787C78341066BFC732C2072F8F5D17386676p0",
"0x0.80ED03AFBF35F94BBF0F4CFFC582346F76C4FA5A57p0",
"0x0.88B991FEC8010361182AA185169DE382A3EF78F891p0",
"0x0.9106E49A4C9F3D5958A5D1795C6AF854435B3A38CBp0",
"0x0.99DD49860AB457FE49ECBC03DE5C559D7E5D1F1536p0",
"0x0.A34597E37CB04FF3D675A35530CDD767E347BF8ACEp0",
"0x0.AD4938C9B7E846B122756D14A7C2C4BBB56E395688p0",
"0x0.B7F230AF4C747553D8DB804C224277431FE89589FAp0",
"0x0.C34B296F917BF09A22FBAA27077B854A35098FBF2Ap0",
"0x0.CF5F7CF564105743415CBC9D6368F3B96071095ABEp0",
"0x0.DC3B4096043BDE02C9DD90522BBE5C1ED729F2E882p0",
"0x0.E9EB51276C110C3C3EB1269F2F5D4AFABD8029F1B7p0",
"0x0.F87D5FDE38151E72F18FF03049AC5D7EA18E816731p0",
        };

}
# 40 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h" 2

template<typename T>
class exp_traits {};

template <> class exp_traits<half>
{
public:
    const static int we = fp_struct<half>::EXP_BITS;
    const static int wf = fp_struct<half>::SIG_BITS; // 10

    const static int gbits = 3;
    const static int gbits_Z2 = 3;
    const static int w_Z1 = 9;

    // input ap_ufixed < 4, -9 >
    // output ap_uifxed < 5, -8 >
    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> Z1P_l = Z1P;
        return Z1P_l;
    }
};

template <> class exp_traits<float>
{
public:
    const static int we = fp_struct<float>::EXP_BITS;
    const static int wf = fp_struct<float>::SIG_BITS; // 23

    const static int gbits = 4;
    const static int gbits_Z2 = 3;
    const static int w_Z1 = 9;

    // input ap_ufixed < 18, -9 >
    // output ap_ufixed < 18, -8 >
    // Z = Z1 + Z1P = Z1 + Z2
    // e^Z1P - 1 = Z1P + Z2^2/2 = Z1P + f(Z2)
    // w_Z2_ind = w - w/2 - w1 = 5
    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2_ind = 5;
_ssdm_SpecConstant(&w_Z2_ind);
# 78 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        ap_uint<w_Z2_ind> Z2_ind = Z1P ( Z1P.wl()-1 , Z1P.wl()-w_Z2_ind );
        ap_ufixed<wf+gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<wf+gbits,0> >::array [ Z2_ind ]; // < 8, -19 >
        ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = Z1P + f_Z2;
        return exp_Z1P_m_1;
    }

public :
inline __attribute__((always_inline)) exp_traits<float>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&gbits); _ssdm_SpecConstant(&gbits_Z2); _ssdm_SpecConstant(&w_Z1); }
# 84 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
};

template <> class exp_traits<double>
{
public:
    const static int we = fp_struct<double>::EXP_BITS;
    const static int wf = fp_struct<double>::SIG_BITS; // 52

    // guard bits should be 7bit
    // but to reduce size of multiplier
    // use 7bit for exp_Z3_m_1 * exp_Z4_m_1 and exp_Z2_m_1 * exp_Z2P_m_1
    // use 5bit for exp_Z1 * exp_Z1P_m_1
    const static int gbits = 7;
    const static int gbits_Z2 = 5;
    const static int w_Z1 = 8;

    // input ap_ufixed < 51, -8 >
    // output ap_ufixed < 50, -7 >
    // Z = Z1 + Z2 + Z3 + Z4, w = 59, w1 = 8, w2 = 8, w3 = 8, w4 = 35
    static ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 ( ap_ufixed<wf+gbits-w_Z1,-w_Z1> Z1P ) {
        const static int w_Z2 = 8;
_ssdm_SpecConstant(&w_Z2);
# 104 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

 const static int w_Z2P = 43;
_ssdm_SpecConstant(&w_Z2P);
# 105 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        const static int w_Z3 = 8;
_ssdm_SpecConstant(&w_Z3);
# 106 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        const static int w_Z4 = 35;
_ssdm_SpecConstant(&w_Z4);
# 107 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"


 ap_ufixed < w_Z2 , -w_Z1 > Z2 = Z1P; // Z1P [ 50 .. 43 ]
 ap_ufixed < w_Z2P , -w_Z1-w_Z2 > Z2P = Z1P; // Z1P [ 42 ..  0 ]
 ap_ufixed < w_Z3 , -w_Z1-w_Z2 > Z3 = Z1P; // Z1P [ 42 .. 35 ]
 ap_ufixed < w_Z4 , -w_Z1-w_Z2-w_Z3 > Z4 = Z1P; // Z1P [ 34 ..  0 ]

 // e^Z = e^Z1 * e^Z2 * e^Z3 * e^Z4
 //     = e^Z1 * ( 1 + Z2 + f(Z2) ) * ( 1 + Z3 + f(Z3) ) * ( 1 + Z4 + f(Z4) )
 //
 // 1. let's start from
 //   e^Z2P - 1
 // = ( 1 + Z3 + f(Z3) ) * ( 1 + Z4 + f(Z4) ) - 1
 // = ( Z3 + f(Z3) ) + ( Z4 + f(Z4) ) + ( Z3 + f(Z3) ) * ( Z4 + f(Z4) )
 //
 // 1.1 Z4 + f(Z4)
 // w_Z4_ind = w4 - w/2 = 6
 // instead of using a f_Z4 table, we reuse f_Z3 table for f_Z4
        const static int w_Z4_ind = w_Z3;
_ssdm_SpecConstant(&w_Z4_ind);
# 125 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

 ap_uint<w_Z4_ind> Z4_ind = Z4 ( Z4.wl()-1 , Z4.wl()-w_Z4_ind );
 ap_ufixed<wf+gbits-2*(w_Z1+w_Z2+w_Z3)-1,-2*(w_Z1+w_Z2+w_Z3)-1> f_Z4 = table_f_Z3< ap_ufixed<wf+gbits,0> >::array [ Z4_ind ] >> ( 2*w_Z3 ); // < 10, -49 >
 ap_ufixed<wf+gbits-w_Z1-w_Z2-w_Z3+1,-w_Z1-w_Z2-w_Z3+1> exp_Z4_m_1 = Z4 + f_Z4; // < 36, -23 >

 // 1.2 Z3 + f(Z3)
 ap_uint<w_Z3> Z3_ind = Z3 ( Z3.wl()-1, 0 );
        ap_ufixed<wf+gbits-2*(w_Z1+w_Z2)-1,-2*(w_Z1+w_Z2)-1> f_Z3 = table_f_Z3< ap_ufixed<wf+gbits,0> >::array [ Z3_ind ]; // < 26, -33 >
        ap_ufixed<wf+gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z3_m_1 = Z3 + f_Z3; // < 44, -15 >

 // 1.3 ( Z3 + f(Z3) ) * ( Z4 + f(Z4) )
 ap_ufixed<wf+gbits-2*(w_Z1+w_Z2)-w_Z3+2,-2*(w_Z1+w_Z2)-w_Z3+2> exp_Z2P_m_1_lo = exp_Z3_m_1 * exp_Z4_m_1; // < 21, -38 >

        // 1.4 e^Z2P - 1
 ap_ufixed<wf+gbits-w_Z1-w_Z2+2,-w_Z1-w_Z2+2> exp_Z2P_m_1_l = exp_Z3_m_1 + exp_Z4_m_1 + exp_Z2P_m_1_lo; // < 45, -14 >
 ((exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z2P_m_1_l[exp_Z2P_m_1_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 140, __PRETTY_FUNCTION__));
 ap_ufixed<wf+gbits-w_Z1-w_Z2+1,-w_Z1-w_Z2+1> exp_Z2P_m_1 = exp_Z2P_m_1_l; // < 44, -15 >

 // 2. e^Z1P - 1
 //  = ( 1 + Z2 + f(Z2) ) * ( 1 + ( e^Z2P - 1 ) ) - 1
 //  = ( Z2 + f(Z2) ) + ( e^Z2P - 1 ) + ( Z2 + f(Z2) ) * ( e^Z2P - 1 )
 //
 // 2.1 Z2 + f(Z2)
        ap_uint<w_Z2> Z2_ind = Z2 ( Z2.wl()-1, 0 );
        ap_ufixed<wf+gbits-2*w_Z1-1,-2*w_Z1-1> f_Z2 = table_f_Z2< ap_ufixed<wf+gbits,0> >::array [ Z2_ind ]; // < 42, -17 >
 ap_ufixed<wf+gbits-w_Z1+1 -2,-w_Z1+1> exp_Z2_m_1 = Z2 + f_Z2; // < 52, -7 > -> < 50, -7> to save multipliers

 // 2.2 ( Z2 + f(Z2) ) * ( e^Z2P - 1 )
 ap_ufixed<wf+gbits-2*w_Z1-w_Z2+2,-2*w_Z1-w_Z2+2> exp_Z1P_m_1_lo = exp_Z2_m_1 * exp_Z2P_m_1; // < 37, -22 >

 // 2.3 e^Z1P - 1
        ap_ufixed<wf+gbits-w_Z1+2,-w_Z1+2> exp_Z1P_m_1_l = exp_Z2_m_1 + exp_Z2P_m_1 + exp_Z1P_m_1_lo; // < 53, -6 >
        ((exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Z1P_m_1_l[exp_Z1P_m_1_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 157, __PRETTY_FUNCTION__));
        ap_ufixed<wf+gbits_Z2-w_Z1+1,-w_Z1+1> exp_Z1P_m_1 = exp_Z1P_m_1_l; // < 50, -7 >

 return exp_Z1P_m_1;
    }

public :
inline __attribute__((always_inline)) exp_traits<double>() { _ssdm_SpecConstant(&we); _ssdm_SpecConstant(&wf); _ssdm_SpecConstant(&gbits); _ssdm_SpecConstant(&gbits_Z2); _ssdm_SpecConstant(&w_Z1); }
# 162 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
};

template<typename T>
T exp_generic(T x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
_ssdm_SpecConstant(&we);
# 170 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        const static int wf = exp_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 171 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

// special cases include:
// y = 0, +inf, -inf, NaN
//
//      x	|       +inf	|	-inf	|       NaN     
// =============================================================
// 	exp(x)	|	+inf	|	0	|	NaN	
//
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
# 230 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
_ssdm_SpecConstant(&gbits);
# 235 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp; // used for overflow checking only
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<1 + we + 4, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<1 + we+3, 1> LOG2R = 1.4426950408889634073599246810019;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix_hi * LOG2R + delta1;

    const ap_ufixed<wf+gbits+we+1, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+gbits, 1 + we+1> m_fix_a = r_exp * LOG2;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 260, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 261, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = m_fix - m_fix_a;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = exp_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 291 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
_ssdm_SpecConstant(&gbits_Z2);
# 298 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 305, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = 0
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}

// exp() for fixed point data type ap_fixed<16,8>
// input x is divided into x_hi and x_lo
// x_hi consists the most significant bits
// and x_lo consists the least significant bits
// exp(x) = exp(x_hi+x_lo) = exp(x_hi) * exp(x_lo)
// x_hi and x_lo are used as indexes to look up their exponential values
//
// to save memory, exp(x_lo) = 1 + x_lo + f(x_lo), 
// only f(x_lo) is stored in the table
//
static ap_fixed<16, 8> exp_generic(ap_fixed<16, 8> x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 const static int W_ = 16;
_ssdm_SpecConstant(&W_);
# 360 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // total bit width
 const static int I_ = 8;
_ssdm_SpecConstant(&I_);
# 361 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // width of integer, including sign bit
 const static int F_ = 8;
_ssdm_SpecConstant(&F_);
# 362 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // width of fraction bits
 const static int w_hi = 6;
_ssdm_SpecConstant(&w_hi);
# 363 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // width of x_hi
 const static int w_lo = 6;
_ssdm_SpecConstant(&w_lo);
# 364 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // width of x_lo

 const static int gbits = 7;
_ssdm_SpecConstant(&gbits);
# 366 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"


 ap_uint<w_hi> x_hi_ind;
 x_hi_ind [ w_hi-1 ] = x [ W_-1 ];
 x_hi_ind ( w_hi-2 , 0 ) = x ( w_hi+w_lo-2 , w_lo );
 ap_uint<w_lo> x_lo_ind = x ( w_lo-1 , 0 );

 ap_ufixed<W_-1+gbits,I_-1> exp_x_hi;// = exp_x_hi_array [ x_hi_ind ];
 exp_x_hi ( W_-1+gbits-1 , F_+gbits ) = table_exp_x_hi::array_0[x_hi_ind];
 exp_x_hi ( F_+gbits-1 , gbits ) = table_exp_x_hi::array_1[x_hi_ind];
 exp_x_hi ( gbits-1 , 0 ) = table_exp_x_hi::array_2[x_hi_ind];

 ap_ufixed<F_+(w_lo-F_)*2+gbits,(w_lo-F_)*2> f_x_lo = table_f_x_lo::array [ x_lo_ind ];

        ap_ufixed<w_lo,w_lo-F_> x_lo = x;
 ap_ufixed<w_lo+1+gbits,w_lo-F_+1> exp_x_lo_m_1 = x_lo + f_x_lo;
 ap_ufixed<w_lo+1+gbits,I_-1> exp_x_hi_hi = exp_x_hi;
 ap_ufixed<1,-F_> delta; // for rounding to nearest
 delta[0] = 1;
 ap_ufixed<W_-1+gbits,I_-1> exp_x_l = ( exp_x_hi + delta ) + exp_x_hi_hi * exp_x_lo_m_1;

 ap_fixed<W_,I_> exp_x = exp_x_l;

 if ( x > 4.8515625 ) exp_x = 127.99609375;
 if ( x < -6 ) exp_x = 0;

 return exp_x;
}

// exp() for fixed point data type ap_fixed<8,4>
// input x is used as index to look up the exponential value
//
static ap_fixed<8, 4> exp_generic(ap_fixed<8, 4> x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

        const static int W_ = 8;
_ssdm_SpecConstant(&W_);
# 402 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // total bit width
        const static int I_ = 4;
_ssdm_SpecConstant(&I_);
# 403 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 // width of integer, including sign bit

 ap_uint<W_-1> x_ind;
 x_ind ( W_-2, 0 ) = x ( W_-2, 0 );

 ap_fixed<W_,I_> exp_x;
 exp_x[7] = 0;
 exp_x(6,4) = table_exp_x::array_0[x_ind];
 exp_x(3,0) = table_exp_x::array_1[x_ind];

 if ( x >= 2.125 ) exp_x = 7.9375;
        if ( x < -3 ) exp_x = 0;

        return exp_x;
}

static half exp(half x)
{
 return exp_generic(x);
}
static float exp(float x)
{
 return exp_generic(x);
}
static double exp(double x)
{
 return exp_generic(x);
}
static ap_fixed<16, 8> exp(ap_fixed<16, 8> x)
{
 return exp_generic(x);
}
static ap_fixed<8, 4> exp(ap_fixed<8, 4> x)
{
        return exp_generic(x);
}

static float expf(float x)
{
 return exp_generic(x);
}

static half half_exp(half x)
{
 return exp_generic(x);
}


template<typename T>
T exp2_generic(T x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
_ssdm_SpecConstant(&we);
# 457 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        const static int wf = exp_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 458 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

// special cases include:
// y = 0, +inf, -inf, NaN
//
//      x	|       +inf	|	-inf	|       NaN     
// =============================================================
// 	exp(x)	|	+inf	|	0	|	NaN	
//
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
# 517 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
_ssdm_SpecConstant(&gbits);
# 522 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp; // used for overflow checking only
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+1> r_exp = m_fix + delta1;

    const ap_ufixed<wf+gbits+we+1, 0> LOG2_hi = 0.69314718055994517520446152047953;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2_lo = 0.60444058366692929317548838826088;
    const ap_ufixed<wf+gbits+we+1, 0> LOG2 = LOG2_hi + ( LOG2_lo >> 52 );

    ap_fixed<1 + we + wf+gbits, 1 + we+1> m_fix_a = r_exp;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 1)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 543, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -1)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 544, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 + wf+gbits, 1> m_diff_l = ( m_fix - m_fix_a ) * LOG2;

    (((m_fix_back != m_frac_l) || (m_diff_l < 0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_diff_l < 0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 547, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_diff_l > -0.5)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_diff_l > -0.5)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 548, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = m_diff_l;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = exp_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 578 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
_ssdm_SpecConstant(&gbits_Z2);
# 585 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 592, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = 0
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}

static half exp2(half x)
{
 return exp2_generic(x);
}
static float exp2(float x)
{
 return exp2_generic(x);
}
static double exp2(double x)
{
 return exp2_generic(x);
}

static float exp2f(float x)
{
 return exp2_generic(x);
}

static half half_exp2(half x)
{
 return exp2_generic(x);
}


template<typename T>
T exp10_generic(T x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<T> es(x);
        const static int we = exp_traits<T>::we;
_ssdm_SpecConstant(&we);
# 663 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

        const static int wf = exp_traits<T>::wf;
_ssdm_SpecConstant(&wf);
# 664 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"


        fp_struct<T> out;
 out.sign[0] = 0;
 out.sig = 0;

// special cases include:
// y = 0, +inf, -inf, NaN
//
//      x	|       +inf	|	-inf	|       NaN     
// =============================================================
// 	exp(x)	|	+inf	|	0	|	NaN	
//
    bool x_is_NaN = 0;
    bool x_is_inf = 0;
    bool x_is_pinf = 0;
    bool x_is_ninf = 0;

    if ( ::hls::__isnan(x) ) x_is_NaN = 1;
    if ( ::hls::__isinf(x) ) x_is_inf = 1;
    x_is_pinf = x_is_inf & ~es.sign[0];
    x_is_ninf = x_is_inf & es.sign[0];

    if (x_is_NaN) {
        // out = NaN
        //out.sign[0] = 0;
        out.sig = -1; // all 1's
        out.exp = fp_struct<T>::EXP_INFNAN;
        return out.to_ieee();
    }
    if (x_is_pinf) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
 out.exp = fp_struct<T>::EXP_INFNAN;
 return out.to_ieee();
    }
    if (x_is_ninf) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }


    int m_exp = es.expv();
    fp_struct<T> nes = es;
# 723 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"
 ap_fixed<1 + 1 + wf, 1 + 1> e_frac = 0;
    e_frac[e_frac.wl()-e_frac.iwl()] = 1; // The implicit '1' in IEEE format.
    e_frac(e_frac.wl()-e_frac.iwl()-1,0) = nes.sig(wf-1,0);
    if (nes.sign) e_frac = -e_frac;

    const static int gbits = exp_traits<T>::gbits;
_ssdm_SpecConstant(&gbits);
# 728 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_fixed<1 + we + wf+gbits, 1 + we> m_frac_l = e_frac;

    ap_fixed<1 + we + wf, 1 + we> m_fix_l = m_frac_l << m_exp; // used for overflow checking only
    ap_fixed<1 + we + wf, 1 + we> m_fix_back = m_fix_l >> m_exp;

    ap_fixed<1 + we + wf+gbits, 1 + we> m_fix;
    m_fix = m_frac_l << m_exp;

    ap_fixed<1 + we + 5, 1 + we> m_fix_hi = m_fix;

    const ap_ufixed<2 + we+3, 2> LOG2_10 = 3.3219280948873623478703194294894;

    ap_fixed<2, 1> delta1;
    delta1[1] = m_fix[m_fix.wl()-1];
    delta1[0] = 1;

    ap_int<1 + we+2> r_exp = m_fix_hi * LOG2_10 + delta1;

    const ap_ufixed< 2 + wf+gbits+we+1, 2> LOG10_hi = 2.302585092994045679049008867878;
    const ap_ufixed<-5 + wf+gbits+we+1, -5> LOG10_lo = 0.02237830812635162513896609861137;
    const ap_ufixed< 2 + wf+gbits+we+1, 2> LOG10 = LOG10_hi + ( LOG10_lo >> 52 );

    const ap_ufixed<-1 + wf+gbits+we+3, -1> LOG10_2_hi = 0.30102999566398103148401332873618;
    const ap_ufixed< wf+gbits+we+3, 0> LOG10_2_lo = 0.73737313104845853883700312679039;
    const ap_ufixed<-1 + wf+gbits+we+3, -1> LOG10_2 = LOG10_2_hi + ( LOG10_2_lo >> 52 );

    ap_fixed<1 + we+1 + wf+gbits, 1 + we+1> m_fix_a = r_exp * LOG10_2;// m_fix approximation

    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.25)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a < 0.25)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 757, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    (((m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.25)) ? static_cast<void> (0) : __assert_fail ("(m_fix_back != m_frac_l) || (m_fix - m_fix_a > -0.25)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 758, __PRETTY_FUNCTION__));// check r_exp zeros out integer and most significant fraction bits
    ap_fixed<1 -1 + wf+gbits, 1 -1> m_diff = ( m_fix - m_fix_a ) * LOG10;

    // e^Y = 1 + Y + Y^2/2 + ... + Y^n/n! + ...
    // term Y^n/n! can be eliminated when its MSB is less than 2^-(wf+g)
    // Y belongs to (-.5,.5)
    // w = wf+g
    // g = 3,4,7 for h,f,d
    // g_Z2 = 3,3,5 for h,f,d
    // Y = Z1 + Z1P
    //   = Z1 + Z2 + Z2P
    //   = ...
    //   = Z1 + Z2 + ... + Zk
    // wn is width of Zn, n = 1...k
    // T_Z1 = 2^w1*(w+1)
    // T_Z2 = 2^w2*(w+1-2*w1)
    // T_Z3 = 2^w3*(w+1-2*(w1+w2))
    // ...
    //
    //		|	h	|	f	|	d	
    //	========================================================
    //	wf	|	10	|	23	|	52	
    //	g	|	3	|	4	|	7	
    //	g_Z2    |       3       |       3       |       5
    //	w	|	13	|	27	|	59	
    //	k	|	2	|	2	|	4	
    //	wn	|	9,4	|	9,18	|    8,8,8,35	
    //	T_total	|	7k	|	<18k	| 14.5k+10.5k+6.5k
    //	Mult	|	5bit	|	1DSP	|	16DSP	

    const static int w_Z1 = exp_traits<T>::w_Z1;
_ssdm_SpecConstant(&w_Z1);
# 788 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    // Z1
    ap_uint<w_Z1> m_diff_hi = m_diff ( m_diff.wl()-1 , m_diff.wl()-w_Z1 );
    // Z1P = Z2 + ... + Zk
    ap_ufixed<wf+gbits-w_Z1, -w_Z1> m_diff_lo = m_diff; // ( m_diff.wl()-m_diff.iwl()-w_Z1-1 , 0 );

    // e^Z1 by table_exp_Z1
    const static int gbits_Z2 = exp_traits<T>::gbits_Z2;
_ssdm_SpecConstant(&gbits_Z2);
# 795 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h"

    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Z1 = table_exp_Z1< ap_ufixed<1 + wf+gbits_Z2, 1> >::array [ m_diff_hi ];
    ap_ufixed<wf+gbits_Z2-w_Z1+1, -w_Z1+1> exp_Z1P_m_1 = exp_traits<T>::exp_Z1P_m_1 ( m_diff_lo );
    ap_ufixed<1 + wf+gbits_Z2-w_Z1, 1> exp_Z1_hi = exp_Z1;
    ap_ufixed<1, -wf> delta;
    delta[0] = 1;
    ap_ufixed<2 + wf+gbits_Z2, 2> exp_Y_l = ( exp_Z1 + delta ) + exp_Z1_hi * exp_Z1P_m_1;
    ((exp_Y_l[exp_Y_l.wl()-1] == 0) ? static_cast<void> (0) : __assert_fail ("exp_Y_l[exp_Y_l.wl()-1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_exp_.h", 802, __PRETTY_FUNCTION__));
    ap_ufixed<1 + wf+gbits_Z2, 1> exp_Y = exp_Y_l;

    if ( exp_Y[exp_Y.wl()-1] == 0 ) {
        exp_Y = exp_Y << 1;
        r_exp = r_exp - 1;
    }

    // check overflow here
    if ( ( m_exp > 0 && m_fix_back != m_frac_l ) || ( r_exp > fp_struct<T>::EXP_BIAS ) ) {
 if ( ~m_frac_l[m_frac_l.wl()-1] ) {
 // out = +inf
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = fp_struct<T>::EXP_INFNAN;
            return out.to_ieee();
 } else {
 // out = 0
 //out.sign[0] = 0;
 //out.sig = 0;
            out.exp = 0;
            return out.to_ieee();
 }
    }

    // check underflow here
    if ( r_exp <= -fp_struct<T>::EXP_BIAS ) {
        // out = 0
        //out.sign[0] = 0;
        //out.sig = 0;
        out.exp = 0;
        return out.to_ieee();
    }

// let's output the result
    out.sig(wf-1,0) = exp_Y ( exp_Y.wl()-1-1 , exp_Y.wl()-1-wf );
    out.exp = fp_struct<T>::EXP_BIAS+r_exp;
    return out.to_ieee();

}

static half exp10(half x)
{
 return exp10_generic(x);
}
static float exp10(float x)
{
 return exp10_generic(x);
}
static double exp10(double x)
{
 return exp10_generic(x);
}

static float exp10f(float x)
{
 return exp10_generic(x);
}

static half half_exp10(half x)
{
 return exp10_generic(x);
}


static double expm1(double x)
{
        fp_struct<double> xs(x);
        if ( (xs.sign[0]==1) && (xs.exp<996) && (xs.exp!=0) ) return x;
 if ( (xs.sign[0]==0) && (xs.exp<=996) && (xs.exp!=0) ) return x;
 return exp_generic(x)-1;
}

static float expm1(float x)
{
        fp_struct<float> xs(x);
 if ( xs.exp == 0 ) return 0;
        if ( xs.exp < 96 ) return x;
 double xd = x;
 return exp_generic(xd)-1;
}

static half expm1(half x)
{
 float xf = x;
 return exp_generic(xf)-1;
}

}
# 847 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
static double exp(double x)
{
    return ::exp(x);
    //return hls::exp_reduce_::exp(x);
}
static float exp(float x)
{
    return ::expf(x);
    //return hls::exp_reduce_::exp(x);
}
static half exp(half x)
{
    return hls::exp_reduce_::exp(x);
}
static ap_fixed<16,8> exp(ap_fixed<16,8> x)
{
    return hls::exp_reduce_::exp(x);
}
static ap_fixed<8,4> exp(ap_fixed<8,4> x)
{
    return hls::exp_reduce_::exp(x);
}
static double exp2(double x)
{
    //return ::HLS_FPO_EXP(HLS_FPO_MUL(x, 0.69314718055994530941723212145817656807550013436024));
    return hls::exp_reduce_::exp2(x);
}
static float exp2(float x)
{
    return hls::exp_reduce_::exp2(x);
}
static half exp2(half x)
{
    return hls::exp_reduce_::exp2(x);
}
static double exp10(double x)
{
    //return ::HLS_FPO_EXP(HLS_FPO_MUL(x, 2.30258509299404568401799145468436420760110148862875));
    return hls::exp_reduce_::exp10(x);
}
static float exp10(float x)
{
    return hls::exp_reduce_::exp10(x);
}
static half exp10(half x)
{
    return hls::exp_reduce_::exp10(x);
}

static float expf(float x)
{
    //return ::HLS_FPO_EXPF(x);
    return hls::exp_reduce_::exp(x);
}
static float exp2f(float x)
{
    //return ::HLS_FPO_EXPF(HLS_FPO_MULF(x, 0.69314718055994530941723212145817656807550013436024f));
    return hls::exp_reduce_::exp2(x);
}
static float exp10f(float x)
{
    //return ::HLS_FPO_EXPF(HLS_FPO_MULF(x, 2.30258509299404568401799145468436420760110148862875f));
    return hls::exp_reduce_::exp10(x);
}
//#include "hls/hls_exp.h"
static half half_exp(half x) {
    return hls::exp_reduce_::half_exp(x);
}
static half half_exp2(half x) {
    return hls::exp_reduce_::half_exp2(x);
}
static half half_exp10(half x) {
    return hls::exp_reduce_::half_exp10(x);
}

static double expm1(double x) {
    return hls::exp_reduce_::expm1(x);
}
static float expm1(float x) {
    return hls::exp_reduce_::expm1(x);
}
static half expm1(half x) {
    return hls::exp_reduce_::expm1(x);
}
static float expm1f(float x) {
    return hls::exp_reduce_::expm1(x);
}
static half half_expm1(half x) {
    return hls::exp_reduce_::expm1(x);
}



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h" 1
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * @file hls_erf.h
 * This file contains error functions, mainly based on ieee754/ implementation
 * except some optimization for fpga. This implementation will occupy huge logic
 * when doesn't share double operations (multi, add, div), this need further optimize
 * or adopt new approximation method suite to fpga
 */
# 27 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
/* double erf(double x)
 * double erfc(double x)
 *			     x
 *		      2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *	 	   sqrt(pi) \|
 *			     0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that
 *		erf(-x) = -erf(x)
 *		erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *	1. For |x| in [0, 0.84375]
 *	    erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *	   where R = P/Q where P is an odd poly of degree 8 and
 *	   Q is an odd poly of degree 10.
 *						 -57.90
 *			| R - (erf(x)-x)/x | <= 2
 *
 *
 *	   Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *	   and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *	   is close to one. The interval is chosen because the fix
 *	   point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *	   near 0.6174), and by some experiment, 0.84375 is chosen to
 * 	   guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *         	erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *         	erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
 *			  1+(c+P1(s)/Q1(s))    if x < 0
 *         	|P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
 *	   Remark: here we use the taylor series expansion at x=1.
 *		erf(1+s) = erf(1) + s*Poly(s)
 *			 = 0.845.. + P1(s)/Q1(s)
 *	   That is, we use rational approximation to approximate
 *			erf(1+s) - (c = (single)0.84506291151)
 *	   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
 *	   where
 *		P1(s) = degree 6 poly in s
 *		Q1(s) = degree 6 poly in s
 *
 *      3. For x in [1.25,1/0.35(~2.857143)],
 *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
 *         	erf(x)  = 1 - erfc(x)
 *	   where
 *		R1(z) = degree 7 poly in z, (z=1/x^2)
 *		S1(z) = degree 8 poly in z
 *
 *      4. For x in [1/0.35,28]
 *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
 *			= 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
 *			= 2.0 - tiny		(if x <= -6)
 *         	erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
 *         	erf(x)  = sign(x)*(1.0 - tiny)
 *	   where
 *		R2(z) = degree 6 poly in z, (z=1/x^2)
 *		S2(z) = degree 7 poly in z
 *
 *      Note1:
 *	   To compute exp(-x*x-0.5625+R/S), let s be a single
 *	   precision number and s := x; then
 *		-x*x = -s*s + (s-x)*(s+x)
 *	        exp(-x*x-0.5626+R/S) =
 *			exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *	   Here 4 and 5 make use of the asymptotic series
 *			  exp(-x*x)
 *		erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *			  x*sqrt(pi)
 *	   We use rational approximation to approximate
 *      	g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
 *	   Here is the error bound for R1/S1 and R2/S2
 *      	|R1/S1 - f(x)|  < 2**(-62.57)
 *      	|R2/S2 - f(x)|  < 2**(-61.52)
 *
 *      5. For inf > x >= 28
 *         	erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *         	erfc(x) = tiny*tiny (raise underflow) if x > 0
 *			= 2 - tiny if x<0
 *
 *      7. Special case:
 *         	erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *         	erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
 *	   	erfc/erf(NaN) is NaN
 */



namespace erf_approx{

namespace {
template <typename T> class coeff { };
template <> class coeff<double> {
public:
    static const double tiny;
    static const double one_over_two;
    static const double one;
    static const double two;
    static const double erx;
    static const double efx;
    static const double efx8;
    static const double pp[5];
    static const double qq[6];
    static const double pa[7];
    static const double qa[7];
    static const double ra[8];
    static const double sa[9];
    static const double rb[7];
    static const double sb[8];

public :
inline __attribute__((always_inline)) coeff<double>() { _ssdm_SpecConstant(&tiny); _ssdm_SpecConstant(&one_over_two); _ssdm_SpecConstant(&one); _ssdm_SpecConstant(&two); _ssdm_SpecConstant(&erx); _ssdm_SpecConstant(&efx); _ssdm_SpecConstant(&efx8); _ssdm_SpecConstant(pp); _ssdm_SpecConstant(qq); _ssdm_SpecConstant(pa); _ssdm_SpecConstant(qa); _ssdm_SpecConstant(ra); _ssdm_SpecConstant(sa); _ssdm_SpecConstant(rb); _ssdm_SpecConstant(sb); }
# 144 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const double coeff<double>::tiny = 1e-300;
const double coeff<double>::one_over_two= 5.00000000000000000000e-01; /* 0x3FE00000, 0x00000000 */
const double coeff<double>::one = 1.00000000000000000000e+00; /* 0x3FF00000, 0x00000000 */
const double coeff<double>::two = 2.00000000000000000000e+00; /* 0x40000000, 0x00000000 */
/* c = (float)0.84506291151 */
const double coeff<double>::erx = 8.45062911510467529297e-01; /* 0x3FEB0AC1, 0x60000000 */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
const double coeff<double>::efx = 1.28379167095512586316e-01; /* 0x3FC06EBA, 0x8214DB69 */
const double coeff<double>::efx8= 1.02703333676410069053e+00; /* 0x3FF06EBA, 0x8214DB69 */
const double coeff<double>::pp[] =
{1.28379167095512558561e-01, /* 0x3FC06EBA, 0x8214DB68 */
 -3.25042107247001499370e-01, /* 0xBFD4CD7D, 0x691CB913 */
 -2.84817495755985104766e-02, /* 0xBF9D2A51, 0xDBD7194F */
 -5.77027029648944159157e-03, /* 0xBF77A291, 0x236668E4 */
 -2.37630166566501626084e-05}; /* 0xBEF8EAD6, 0x120016AC */
const double coeff<double>::qq[] =
{0.0, 3.97917223959155352819e-01, /* 0x3FD97779, 0xCDDADC09 */
  6.50222499887672944485e-02, /* 0x3FB0A54C, 0x5536CEBA */
  5.08130628187576562776e-03, /* 0x3F74D022, 0xC4D36B0F */
  1.32494738004321644526e-04, /* 0x3F215DC9, 0x221C1A10 */
 -3.96022827877536812320e-06}; /* 0xBED09C43, 0x42A26120 */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
const double coeff<double>::pa[] =
{-2.36211856075265944077e-03, /* 0xBF6359B8, 0xBEF77538 */
  4.14856118683748331666e-01, /* 0x3FDA8D00, 0xAD92B34D */
 -3.72207876035701323847e-01, /* 0xBFD7D240, 0xFBB8C3F1 */
  3.18346619901161753674e-01, /* 0x3FD45FCA, 0x805120E4 */
 -1.10894694282396677476e-01, /* 0xBFBC6398, 0x3D3E28EC */
  3.54783043256182359371e-02, /* 0x3FA22A36, 0x599795EB */
 -2.16637559486879084300e-03}; /* 0xBF61BF38, 0x0A96073F */
const double coeff<double>::qa[] =
{0.0, 1.06420880400844228286e-01, /* 0x3FBB3E66, 0x18EEE323 */
  5.40397917702171048937e-01, /* 0x3FE14AF0, 0x92EB6F33 */
  7.18286544141962662868e-02, /* 0x3FB2635C, 0xD99FE9A7 */
  1.26171219808761642112e-01, /* 0x3FC02660, 0xE763351F */
  1.36370839120290507362e-02, /* 0x3F8BEDC2, 0x6B51DD1C */
  1.19844998467991074170e-02}; /* 0x3F888B54, 0x5735151D */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
const double coeff<double>::ra[] =
{-9.86494403484714822705e-03, /* 0xBF843412, 0x600D6435 */
 -6.93858572707181764372e-01, /* 0xBFE63416, 0xE4BA7360 */
 -1.05586262253232909814e+01, /* 0xC0251E04, 0x41B0E726 */
 -6.23753324503260060396e+01, /* 0xC04F300A, 0xE4CBA38D */
 -1.62396669462573470355e+02, /* 0xC0644CB1, 0x84282266 */
 -1.84605092906711035994e+02, /* 0xC067135C, 0xEBCCABB2 */
 -8.12874355063065934246e+01, /* 0xC0545265, 0x57E4D2F2 */
 -9.81432934416914548592e+00}; /* 0xC023A0EF, 0xC69AC25C */
const double coeff<double>::sa[] =
{0.0,1.96512716674392571292e+01, /* 0x4033A6B9, 0xBD707687 */
  1.37657754143519042600e+02, /* 0x4061350C, 0x526AE721 */
  4.34565877475229228821e+02, /* 0x407B290D, 0xD58A1A71 */
  6.45387271733267880336e+02, /* 0x40842B19, 0x21EC2868 */
  4.29008140027567833386e+02, /* 0x407AD021, 0x57700314 */
  1.08635005541779435134e+02, /* 0x405B28A3, 0xEE48AE2C */
  6.57024977031928170135e+00, /* 0x401A47EF, 0x8E484A93 */
 -6.04244152148580987438e-02}; /* 0xBFAEEFF2, 0xEE749A62 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
const double coeff<double>::rb[] =
{-9.86494292470009928597e-03, /* 0xBF843412, 0x39E86F4A */
 -7.99283237680523006574e-01, /* 0xBFE993BA, 0x70C285DE */
 -1.77579549177547519889e+01, /* 0xC031C209, 0x555F995A */
 -1.60636384855821916062e+02, /* 0xC064145D, 0x43C5ED98 */
 -6.37566443368389627722e+02, /* 0xC083EC88, 0x1375F228 */
 -1.02509513161107724954e+03, /* 0xC0900461, 0x6A2E5992 */
 -4.83519191608651397019e+02}; /* 0xC07E384E, 0x9BDC383F */
const double coeff<double>::sb[] =
{0.0,3.03380607434824582924e+01, /* 0x403E568B, 0x261D5190 */
  3.25792512996573918826e+02, /* 0x40745CAE, 0x221B9F0A */
  1.53672958608443695994e+03, /* 0x409802EB, 0x189D5118 */
  3.19985821950859553908e+03, /* 0x40A8FFB7, 0x688C246A */
  2.55305040643316442583e+03, /* 0x40A3F219, 0xCEDF3BE6 */
  4.74528541206955367215e+02, /* 0x407DA874, 0xE79FE763 */
 -2.24409524465858183362e+01}; /* 0xC03670E2, 0x42712D62 */

template <> class coeff<float> {
public:
    static const float tiny;
    static const float one_over_two;
    static const float one;
    static const float two;
    static const float erx;
    static const float efx;
    static const float efx8;
    static const float pp[5];
    static const float qq[6];
    static const float pa[7];
    static const float qa[7];
    static const float ra[8];
    static const float sa[9];
    static const float rb[7];
    static const float sb[8];

public :
inline __attribute__((always_inline)) coeff<float>() { _ssdm_SpecConstant(&tiny); _ssdm_SpecConstant(&one_over_two); _ssdm_SpecConstant(&one); _ssdm_SpecConstant(&two); _ssdm_SpecConstant(&erx); _ssdm_SpecConstant(&efx); _ssdm_SpecConstant(&efx8); _ssdm_SpecConstant(pp); _ssdm_SpecConstant(qq); _ssdm_SpecConstant(pa); _ssdm_SpecConstant(qa); _ssdm_SpecConstant(ra); _ssdm_SpecConstant(sa); _ssdm_SpecConstant(rb); _ssdm_SpecConstant(sb); }
# 244 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const float coeff<float>::tiny = 1e-30;
const float coeff<float>::one_over_two= 5.0000000000e-01; /* 0x3F000000 */
const float coeff<float>::one = 1.0000000000e+00; /* 0x3F800000 */
const float coeff<float>::two = 2.0000000000e+00; /* 0x40000000 */
/* c = (float)0.84506291151 */
const float coeff<float>::erx = 8.4506291151e-01; /* 0x3f58560b */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
const float coeff<float>::efx = 1.2837916613e-01; /* 0x3e0375d4 */
const float coeff<float>::efx8= 1.0270333290e+00; /* 0x3f8375d4 */
const float coeff<float>::pp[] =
{1.2837916613e-01, /* 0x3e0375d4 */
-3.2504209876e-01, /* 0xbea66beb */
-2.8481749818e-02, /* 0xbce9528f */
-5.7702702470e-03, /* 0xbbbd1489 */
-2.3763017452e-05}; /* 0xb7c756b1 */
const float coeff<float>::qq[] =
{0.0, 3.9791721106e-01, /* 0x3ecbbbce */
 6.5022252500e-02, /* 0x3d852a63 */
 5.0813062117e-03, /* 0x3ba68116 */
 1.3249473704e-04, /* 0x390aee49 */
-3.9602282413e-06}; /* 0xb684e21a */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
const float coeff<float>::pa[] =
{-2.3621185683e-03, /* 0xbb1acdc6 */
 4.1485610604e-01, /* 0x3ed46805 */
-3.7220788002e-01, /* 0xbebe9208 */
 3.1834661961e-01, /* 0x3ea2fe54 */
-1.1089469492e-01, /* 0xbde31cc2 */
 3.5478305072e-02, /* 0x3d1151b3 */
-2.1663755178e-03}; /* 0xbb0df9c0 */
const float coeff<float>::qa[] =
{0.0, 1.0642088205e-01, /* 0x3dd9f331 */
 5.4039794207e-01, /* 0x3f0a5785 */
 7.1828655899e-02, /* 0x3d931ae7 */
 1.2617121637e-01, /* 0x3e013307 */
 1.3637083583e-02, /* 0x3c5f6e13 */
 1.1984500103e-02}; /* 0x3c445aa3 */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
const float coeff<float>::ra[] =
{-9.8649440333e-03, /* 0xbc21a093 */
-6.9385856390e-01, /* 0xbf31a0b7 */
-1.0558626175e+01, /* 0xc128f022 */
-6.2375331879e+01, /* 0xc2798057 */
-1.6239666748e+02, /* 0xc322658c */
-1.8460508728e+02, /* 0xc3389ae7 */
-8.1287437439e+01, /* 0xc2a2932b */
-9.8143291473e+00}; /* 0xc11d077e */
const float coeff<float>::sa[] =
{0.0, 1.9651271820e+01, /* 0x419d35ce */
 1.3765776062e+02, /* 0x4309a863 */
 4.3456588745e+02, /* 0x43d9486f */
 6.4538726807e+02, /* 0x442158c9 */
 4.2900814819e+02, /* 0x43d6810b */
 1.0863500214e+02, /* 0x42d9451f */
 6.5702495575e+00, /* 0x40d23f7c */
-6.0424413532e-02}; /* 0xbd777f97 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
const float coeff<float>::rb[] =
{-9.8649431020e-03, /* 0xbc21a092 */
-7.9928326607e-01, /* 0xbf4c9dd4 */
-1.7757955551e+01, /* 0xc18e104b */
-1.6063638306e+02, /* 0xc320a2ea */
-6.3756646729e+02, /* 0xc41f6441 */
-1.0250950928e+03, /* 0xc480230b */
-4.8351919556e+02}; /* 0xc3f1c275 */
const float coeff<float>::sb[] =
{0.0, 3.0338060379e+01, /* 0x41f2b459 */
 3.2579251099e+02, /* 0x43a2e571 */
 1.5367296143e+03, /* 0x44c01759 */
 3.1998581543e+03, /* 0x4547fdbb */
 2.5530502930e+03, /* 0x451f90ce */
 4.7452853394e+02, /* 0x43ed43a7 */
-2.2440952301e+01}; /* 0xc1b38712 */

template<typename T> class erf_traits{ };
template<> class erf_traits<float> {
public:
    static const uint32_t mask;
    static const uint32_t segment[10];

public :
inline __attribute__((always_inline)) erf_traits<float>() { _ssdm_SpecConstant(&mask); _ssdm_SpecConstant(segment); }
# 332 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const uint32_t erf_traits<float>::mask = 0xfffff000;
const uint32_t erf_traits<float>::segment[10] =
{
    0x7fffffff,
    0x7f800000,
    0x3f580000,
    0x31800000,
    0x04000000,
    0x3fa00000,
    0x40c00000,
    0x4036DB6E,
    31,
    0
};
template<> class erf_traits<double> {
public:
    static const uint64_t mask;
    static const uint32_t segment[10];

public :
inline __attribute__((always_inline)) erf_traits<double>() { _ssdm_SpecConstant(&mask); _ssdm_SpecConstant(segment); }
# 351 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
const uint32_t erf_traits<double>::segment[10] =
{
    0x7fffffff,
    0x7ff00000,
    0x3feb0000,
    0x3e300000,
    0x00800000,
    0x3ff40000,
    0x40180000,
    0x4006DB6E,
    63,
    32
};

template<typename T> class erfc_traits{};
template<> class erfc_traits<float>{
public:
    static const uint32_t segment[11];

public :
inline __attribute__((always_inline)) erfc_traits<float>() { _ssdm_SpecConstant(segment); }
# 371 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const uint32_t erfc_traits<float>::segment[11] =
{
    0x7fffffff,
    0x7f800000,
    0x3f580000,
    0x23800000,
    0x3e800000,
    0x3fa00000,
    0x41e00000,
    0x4036DB6D,
    0x40c00000,
    31,
    0
};
template<> class erfc_traits<double>{
public:
    static const uint32_t segment[11];

public :
inline __attribute__((always_inline)) erfc_traits<double>() { _ssdm_SpecConstant(segment); }
# 389 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
};
const uint32_t erfc_traits<double>::segment[11] =
{
    0x7fffffff,
    0x7ff00000,
    0x3feb0000,
    0x3c700000,
    0x3fd00000,
    0x3ff40000,
    0x403c0000,
    0x4006DB6D,
    0x40180000,
    63,
    32
};
} // anonymous namespace
# 425 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
template<typename T>
T generic_erf(T x)
{
 int32_t hx;
    uint32_t ix;
 T R,S,P,Q,s,y,z,r;
 //GET_HIGH_WORD(hx,x);
    fp_struct<T> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<T>::segment[8],erf_traits<T>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<T>::segment[0];

    if(FP_SUBNORMAL == ::hls::fpclassify(x)) {
        return 0;
    }

 if(ix>=erf_traits<T>::segment[1]) { /* erf(nan)=nan */
     //i = ((uint32_t)hx>>31)<<1;
        if(hx>0)
         return (T)1.0 +(coeff<T>::one)/x; /* erf(+-inf)=+-1 */
        else
         return (coeff<T>::one)/x-(T)1.0;
 }

 if(ix < erf_traits<T>::segment[2]) { /* |x|<0.84375 */
     T r1,r2,s1,s2,s3,z2,z4;
     if(ix < erf_traits<T>::segment[3]) { /* |x|<2**-28 */
         if (ix < erf_traits<T>::segment[2])
      return ((T)0.125)*((T)8.0*x+(coeff<T>::efx8)*x); /*avoid underflow */
  return x + (coeff<T>::efx)*x;
     }
     z = x*x;




     r1 = coeff<T>::pp[0]+z*coeff<T>::pp[1]; z2=z*z;
     r2 = coeff<T>::pp[2]+z*coeff<T>::pp[3]; z4=z2*z2;
     s1 = (coeff<T>::one)+z*coeff<T>::qq[1];
     s2 = coeff<T>::qq[2]+z*coeff<T>::qq[3];
     s3 = coeff<T>::qq[4]+z*coeff<T>::qq[5];
            r = r1 + z2*r2 + z4*coeff<T>::pp[4];
     s = s1 + z2*s2 + z4*s3;

     y = r/s;
     return x + x*y;
 }
 if(ix < erf_traits<T>::segment[5]) { /* 0.84375 <= |x| < 1.25 */
     T s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
     s = fabs(x)-(coeff<T>::one);




     P1 = coeff<T>::pa[0]+s*coeff<T>::pa[1]; s2=s*s;
     Q1 = (coeff<T>::one)+s*coeff<T>::qa[1]; s4=s2*s2;
     P2 = coeff<T>::pa[2]+s*coeff<T>::pa[3]; s6=s4*s2;
     Q2 = coeff<T>::qa[2]+s*coeff<T>::qa[3];
     P3 = coeff<T>::pa[4]+s*coeff<T>::pa[5];
     Q3 = coeff<T>::qa[4]+s*coeff<T>::qa[5];
     P4 = coeff<T>::pa[6];
     Q4 = coeff<T>::qa[6];
     P = P1 + s2*P2 + s4*P3 + s6*P4;
     Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

     if(hx>=0) return (coeff<T>::erx) + P/Q; else return -(coeff<T>::erx) - P/Q;
 }
 if (ix >= erf_traits<T>::segment[6]) { /* inf>|x|>=6 */
     if(hx>=0) return (coeff<T>::one)-(coeff<T>::tiny); else return (coeff<T>::tiny)-(coeff<T>::one);
 }
 x = fabs(x);
  s = (coeff<T>::one)/(x*x);
 if(ix< erf_traits<T>::segment[7]) { /* |x| < 1/0.35 */






     T R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<T>::ra[0]+s*coeff<T>::ra[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sa[1]; s4 = s2*s2;
     R2 = coeff<T>::ra[2]+s*coeff<T>::ra[3];s6 = s4*s2;
     S2 = coeff<T>::sa[2]+s*coeff<T>::sa[3];s8 = s4*s4;
     R3 = coeff<T>::ra[4]+s*coeff<T>::ra[5];
     S3 = coeff<T>::sa[4]+s*coeff<T>::sa[5];
     R4 = coeff<T>::ra[6]+s*coeff<T>::ra[7];
     S4 = coeff<T>::sa[6]+s*coeff<T>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<T>::sa[8];

 } else { /* |x| >= 1/0.35 */






     T R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
     R1 = coeff<T>::rb[0]+s*coeff<T>::rb[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sb[1]; s4 = s2*s2;
     R2 = coeff<T>::rb[2]+s*coeff<T>::rb[3];s6 = s4*s2;
     S2 = coeff<T>::sb[2]+s*coeff<T>::sb[3];
     R3 = coeff<T>::rb[4]+s*coeff<T>::rb[5];
     S3 = coeff<T>::sb[4]+s*coeff<T>::sb[5];
     S4 = coeff<T>::sb[6]+s*coeff<T>::sb[7];
     R = R1 + s2*R2 + s4*R3 + s6*coeff<T>::rb[6];
     S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;
 //SET_LOW_WORD(z,0);
    fp_struct<T> fp_z(z);
    ap_uint<Type_BitWidth<T>::Value> data = fp_z.data() & erf_traits<T>::mask;
    fp_struct<T> fp_z_new(data);
    z = fp_z_new.to_ieee();
 //r  =  __ieee754_exp(-z*z-0.5625)*__ieee754_exp((z-x)*(z+x)+R/S);
 r = ::hls::exp(-z*z-(T)0.5625)*::hls::exp((z-x)*(z+x)+R/S);
 //r  =  ::hls::exp(-x*x-(T)0.5625+R/S); // also work 
 if(hx>=0) return (coeff<T>::one)-r/x; else return r/x-(coeff<T>::one);
}

template<typename T>
T generic_erfc(T x)
{
 int32_t hx;
    uint32_t ix;
 T R,S,P,Q,s,y,z,r;
 //GET_HIGH_WORD(hx,x);
    fp_struct<T> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<T>::segment[9],erfc_traits<T>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<T>::segment[0];
 if(ix>=erfc_traits<T>::segment[1]) { /* erfc(nan)=nan */
      /* erfc(+-inf)=0,2 */
        if(hx>0)
         return (coeff<T>::one)/x;
        else
         return (coeff<T>::two) + (coeff<T>::one)/x;
     //return (T)(((uint32_t)hx>>31)<<1)+one/x;
 }

 if(ix < erfc_traits<T>::segment[2]) { /* |x|<0.84375 */
     T r1,r2,s1,s2,s3,z2,z4;
     if(ix < erfc_traits<T>::segment[3]) /* |x|<2**-56 */
  return (coeff<T>::one)-x;
     z = x*x;




     r1 = coeff<T>::pp[0]+z*coeff<T>::pp[1]; z2=z*z;
     r2 = coeff<T>::pp[2]+z*coeff<T>::pp[3]; z4=z2*z2;
     s1 = (coeff<T>::one)+z*coeff<T>::qq[1];
     s2 = coeff<T>::qq[2]+z*coeff<T>::qq[3];
     s3 = coeff<T>::qq[4]+z*coeff<T>::qq[5];
            r = r1 + z2*r2 + z4*coeff<T>::pp[4];
     s = s1 + z2*s2 + z4*s3;

     y = r/s;
     if(ix < erfc_traits<T>::segment[4]) { /* x<1/4 */
  return (coeff<T>::one)-(x+x*y);
     } else {
  r = x*y;
  r += (x-(coeff<T>::one_over_two));
         return (coeff<T>::one_over_two) - r ;
     }
 }
 if(ix < erfc_traits<T>::segment[5]) { /* 0.84375 <= |x| < 1.25 */
     T s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
     s = fabs(x)-(coeff<T>::one);




     P1 = coeff<T>::pa[0]+s*coeff<T>::pa[1]; s2=s*s;
     Q1 = (coeff<T>::one)+s*coeff<T>::qa[1]; s4=s2*s2;
     P2 = coeff<T>::pa[2]+s*coeff<T>::pa[3]; s6=s4*s2;
     Q2 = coeff<T>::qa[2]+s*coeff<T>::qa[3];
     P3 = coeff<T>::pa[4]+s*coeff<T>::pa[5];
     Q3 = coeff<T>::qa[4]+s*coeff<T>::qa[5];
     P4 = coeff<T>::pa[6];
     Q4 = coeff<T>::qa[6];
     P = P1 + s2*P2 + s4*P3 + s6*P4;
     Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

     if(hx>=0) {
         z = (coeff<T>::one)-(coeff<T>::erx); return z - P/Q;
     } else {
  z = (coeff<T>::erx)+P/Q; return (coeff<T>::one)+z;
     }
 }
 if (ix < erfc_traits<T>::segment[6]) { /* |x|<28 */
     x = fabs(x);
      s = (coeff<T>::one)/(x*x);
     if(ix< erfc_traits<T>::segment[7]) { /* |x| < 1/.35 ~ 2.857143*/






  T R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<T>::ra[0]+s*coeff<T>::ra[1];s2 = s*s;
     S1 = (coeff<T>::one)+s*coeff<T>::sa[1]; s4 = s2*s2;
     R2 = coeff<T>::ra[2]+s*coeff<T>::ra[3];s6 = s4*s2;
     S2 = coeff<T>::sa[2]+s*coeff<T>::sa[3];s8 = s4*s4;
     R3 = coeff<T>::ra[4]+s*coeff<T>::ra[5];
     S3 = coeff<T>::sa[4]+s*coeff<T>::sa[5];
     R4 = coeff<T>::ra[6]+s*coeff<T>::ra[7];
     S4 = coeff<T>::sa[6]+s*coeff<T>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<T>::sa[8];

     } else { /* |x| >= 1/.35 ~ 2.857143 */
  T R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<T>::segment[8]) return (coeff<T>::two)-(coeff<T>::tiny);/* x < -6 */






  R1 = coeff<T>::rb[0]+s*coeff<T>::rb[1];s2 = s*s;
  S1 = (coeff<T>::one)+s*coeff<T>::sb[1]; s4 = s2*s2;
  R2 = coeff<T>::rb[2]+s*coeff<T>::rb[3];s6 = s4*s2;
  S2 = coeff<T>::sb[2]+s*coeff<T>::sb[3];
  R3 = coeff<T>::rb[4]+s*coeff<T>::rb[5];
  S3 = coeff<T>::sb[4]+s*coeff<T>::sb[5];
  S4 = coeff<T>::sb[6]+s*coeff<T>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<T>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

     }
     z = x;
     //SET_LOW_WORD(z,0);
        fp_struct<T> fp_z(z);
        ap_uint<Type_BitWidth<T>::Value> data = fp_z.data() & erf_traits<T>::mask;
        fp_struct<T> fp_z_new(data);
        z = fp_z_new.to_ieee();
     //r  =  __ieee754_exp(-z*z-0.5625)*
  //	__ieee754_exp((z-x)*(z+x)+R/S);
     r = ::hls::exp(-z*z-(T)0.5625)*
   ::hls::exp((z-x)*(z+x)+R/S);
        T r_x = r/x;
     if(hx>0) {
            if(FP_SUBNORMAL == ::hls::fpclassify(r_x)) {
                return 0;
            }
            return r_x;
        } else
            return (coeff<T>::two)-r_x;
 } else {
     if(hx>0) return (coeff<T>::tiny)*(coeff<T>::tiny); else return (coeff<T>::two)-(coeff<T>::tiny);
 }
}
# 701 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_erf.h"
static double erf(double x)
{
    return generic_erf(x);
}

static float erf(float x)
{
    return generic_erf(x);
}

// TODO
// will give a half implementation later
static half erf(half x)
{
    return generic_erf((float)x);
}

static float erff(float x)
{
    return generic_erf(x);
}

static double erfc(double x)
{
    return generic_erfc(x);
}

static float erfc(float x)
{
    return generic_erfc(x);
}

// TODO
// will give a half implementation later
static half erfc(half x)
{
    return generic_erfc((float)x);
}

static float erfcf(float x)
{
    return generic_erfc(x);
}

} // namespace erf_approx
# 939 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
static double erf(double x)
{
    return erf_approx::erf(x);
}
static float erf(float x)
{
    return erf_approx::erf(x);
}
static half erf(half x)
{
    return erf_approx::erf(x);
}
static float erff(float x)
{
    return erf_approx::erff(x);
}
static double erfc(double x)
{
    return erf_approx::erfc(x);
}
static float erfc(float x)
{
    return erf_approx::erfc(x);
}
static half erfc(half x)
{
    return erf_approx::erfc(x);
}
static float erfcf(float x)
{
    return erf_approx::erfcf(x);
}



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2016 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_gamma.h
 *
 * pure software implementations
 */

static ap_ufixed<0 + 52, 0> lgamma_product (ap_ufixed<0 + 52, 0> t, ap_ufixed<5 + 52, 5> x, /*double x_eps, */ap_uint<2> n)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 //fp_struct<double> ts(t);
 //fp_struct<double> xs(x);
 //fp_struct<double> x_epss(x_eps);
 ap_ufixed<0 + 52, 0> ret[4] = {0};
 //ap_ufixed<0 + 52, 0> ret_eps[4] = {0};
 //double ret[4] = {0};
 //double ret_eps[4] = {0};
#pragma unroll
 for ( ap_uint<3> i = 1; i < 4; i++ )
 {
  //int x_exp = xs.expv();
  //ap_ufixed<64 + 64, 64> x_fix = 0;
  //x_fix[x_fix.wl()-x_fix.iwl()] = 1; // The implicit '1' in IEEE format.
  //x_fix(x_fix.wl()-x_fix.iwl()-1,x_fix.wl()-x_fix.iwl()-52) = xs.sig(51,0);
  //if (x_exp>0)	x_fix <<= x_exp;
  //else		x_fix >>= (-x_exp);
  //x_fix += i;

  ap_ufixed<5 + 52, 5> xi = x+i;
  //double xi = x+i;
  ap_ufixed<0 + 52, 0> quot = t/xi;
  //double quot = t/xi;
  //double m = quot*xi;
  //double quot_lo = quot*x_eps/xi;//(t-m)/xi-t*x_eps/(xi*xi);
  ap_ufixed<0 + 52, 0> r = ret[i-1]*quot;
  ap_ufixed<0 + 52, 0> rpq = ret[i-1]+quot;
  //double r = ret[i-1]*quot;
  //double rpq = ret[i-1]+quot;
  //double rpq_eps = (ret[i-1]-rpq)+quot;
  ret[i] = rpq+r;
  //ret_eps[i] = (rpq-ret[i])+r;
  //ret_eps[i] = ret_eps[i-1]+(rpq_eps+ret_eps[i]+ret_eps[i-1]*quot+quot_lo+quot_lo*(ret[i-1]+ret_eps[i-1]));
 }
 return ret[n]/*+ret_eps[n]*/;
}

static double lg_sinpi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 double xd1 = x;
 ap_fixed<1 - 1 + 52, 1 - 1> x2 = (ap_fixed<0 + 1, 0>)0.5 - x;
 double xd2 = x2;
 if ( x[x.wl()-1] | ~x[x.wl()-2] )
  return sin(3.14159265358979323846 /* pi */*xd1);
 else
  return cos(3.14159265358979323846 /* pi */*xd2);
}

static double lg_cospi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

        double xd1 = x;
        ap_fixed<1 - 1 + 52, 1 - 1> x2 = (ap_ufixed<0 + 1, 0>)0.5 - x;
        double xd2 = x2;
 if ( x[x.wl()-1] | ~x[x.wl()-2] )
  return cos(double(3.14159265358979323846 /* pi */)*xd1);
 else
  return sin(double(3.14159265358979323846 /* pi */)*xd2);
}

static double lg_cotpi (ap_fixed<1 - 1 + 52, 1 - 1> x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 return lg_cospi(x)/lg_sinpi(x);
}

static double lgamma_neg (double x, int *signgamp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 const ap_ufixed<5 + 52, 5> lgamma_zeros[52] =
   {
     /*{ -*/0x2.74ff92c01f0d8p+0,// -0x2.abec9f315f1ap-56 },
     /*{ -*/0x2.bf6821437b202p+0,// 0x6.866a5b4b9be14p-56 },
     /*{ -*/0x3.24c1b793cb35ep+0,// -0xf.b8be699ad3d98p-56 },
     /*{ -*/0x3.f48e2a8f85fcap+0,// -0x1.70d4561291237p-56 },
     /*{ -*/0x4.0a139e1665604p+0,// 0xf.3c60f4f21e7fp-56 },
     /*{ -*/0x4.fdd5de9bbabf4p+0,// 0xa.ef2f55bf89678p-56 },
     /*{ -*/0x5.021a95fc2db64p+0,// -0x3.2a4c56e595394p-56 },
     /*{ -*/0x5.ffa4bd647d034p+0,// -0x1.7dd4ed62cbd32p-52 },
     /*{ -*/0x6.005ac9625f234p+0,// 0x4.9f83d2692e9c8p-56 },
     /*{ -*/0x6.fff2fddae1bcp+0,// 0xc.29d949a3dc03p-60 },
     /*{ -*/0x7.000cff7b7f87cp+0,// 0x1.20bb7d2324678p-52 },
     /*{ -*/0x7.fffe5fe05673cp+0,// -0x3.ca9e82b522b0cp-56 },
     /*{ -*/0x8.0001a01459fc8p+0,// -0x1.f60cb3cec1cedp-52 },
     /*{ -*/0x8.ffffd1c425e8p+0,// -0xf.fc864e9574928p-56 },
     /*{ -*/0x9.00002e3bb47d8p+0,// -0x6.d6d843fedc35p-56 },
     /*{ -*/0x9.fffffb606bep+0,// 0x2.32f9d51885afap-52 },
     /*{ -*/0xa.0000049f93bb8p+0,// -0x1.927b45d95e154p-52 },
     /*{ -*/0xa.ffffff9466eap+0,// 0xe.4c92532d5243p-56 },
     /*{ -*/0xb.0000006b9915p+0,// -0x3.15d965a6ffea4p-52 },
     /*{ -*/0xb.fffffff708938p+0,// -0x7.387de41acc3d4p-56 },
     /*{ -*/0xc.00000008f76c8p+0,// 0x8.cea983f0fdafp-56 },
     /*{ -*/0xc.ffffffff4f6ep+0,// 0x3.09e80685a0038p-52 },
     /*{ -*/0xd.00000000b092p+0,// -0x3.09c06683dd1bap-52 },
     /*{ -*/0xd.fffffffff3638p+0,// 0x3.a5461e7b5c1f6p-52 },
     /*{ -*/0xe.000000000c9c8p+0,// -0x3.a545e94e75ec6p-52 },
     /*{ -*/0xe.ffffffffff29p+0,// 0x3.f9f399fb10cfcp-52 },
     /*{ -*/0xf.0000000000d7p+0,// -0x3.f9f399bd0e42p-52 },
     /*{ -*/0xf.fffffffffff28p+0,// -0xc.060c6621f513p-56 },
     /*{ -*/0x1.000000000000dp+4,// -0x7.3f9f399da1424p-52 },
     /*{ -*/0x1.0ffffffffffffp+4,// -0x3.569c47e7a93e2p-52 },
     /*{ -*/0x1.1000000000001p+4,// 0x3.569c47e7a9778p-52 },
     /*{ -*/0x1.2p+4,// 0xb.413c31dcbecdp-56 },
     /*{ -*/0x1.2p+4,// -0xb.413c31dcbeca8p-56 },
     /*{ -*/0x1.3p+4,// 0x9.7a4da340a0ab8p-60 },
     /*{ -*/0x1.3p+4,// -0x9.7a4da340a0ab8p-60 },
     /*{ -*/0x1.4p+4,// 0x7.950ae90080894p-64 },
     /*{ -*/0x1.4p+4,// -0x7.950ae90080894p-64 },
     /*{ -*/0x1.5p+4,// 0x5.c6e3bdb73d5c8p-68 },
     /*{ -*/0x1.5p+4,// -0x5.c6e3bdb73d5c8p-68 },
     /*{ -*/0x1.6p+4,// 0x4.338e5b6dfe14cp-72 },
     /*{ -*/0x1.6p+4,// -0x4.338e5b6dfe14cp-72 },
     /*{ -*/0x1.7p+4,// 0x2.ec368262c7034p-76 },
     /*{ -*/0x1.7p+4,// -0x2.ec368262c7034p-76 },
     /*{ -*/0x1.8p+4,// 0x1.f2cf01972f578p-80 },
     /*{ -*/0x1.8p+4,// -0x1.f2cf01972f578p-80 },
     /*{ -*/0x1.9p+4,// 0x1.3f3ccdd165fa9p-84 },
     /*{ -*/0x1.9p+4,// -0x1.3f3ccdd165fa9p-84 },
     /*{ -*/0x1.ap+4,// 0xc.4742fe35272dp-92 },
     /*{ -*/0x1.ap+4,// -0xc.4742fe35272dp-92 },
     /*{ -*/0x1.bp+4,// 0x7.46ac70b733a8cp-96 },
     /*{ -*/0x1.bp+4,// -0x7.46ac70b733a8cp-96 },
     /*{ -*/0x1.cp+4,// 0x4.2862898d42174p-100 },
   };
_ssdm_SpecConstant(lgamma_zeros);
# 169 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h"


 fp_struct<double> xs(x);
        fp_struct<double> out;
        out.sign[0] = 0;
        out.sig = -1;
        out.exp = fp_struct<double>::EXP_INFNAN;

 ap_ufixed<5 + 51, 5> x_fix = 0;
 x_fix[x_fix.wl()-x_fix.iwl()+1] = 1;
 x_fix(51,0) = xs.sig(51,0);
 if ( xs.exp[1] ) x_fix <<= 2;
 if ( xs.exp[0] ) x_fix <<= 1;

 ap_uint<6> i;
 i(5,0) = x_fix(x_fix.wl()-1,x_fix.wl()-x_fix.iwl()-1);
 //int i = floor((-x)<<1);
 //ap_int<3> i2 = i;
 if ( x_fix(x_fix.wl()-x_fix.iwl()-1,0)==0 )
 //if ( (i2[0]==0) && (i==((-x)<<1)) )
  return out.to_ieee();
 ap_uint<5> xn;
 xn(4,0) = i(5,1)+i[0];
 //double xn = (i2[0]==0) ? -i/2 : (-i-1)/2;
 i -= 4;
 *signgamp = (i[1]==0) ? -1 : 1;
 //*signgamp = (i2[1]==0) ? -1 : 1;
 ap_ufixed<5 + 52, 5> x0 = lgamma_zeros[i];
 //double x0_hi = lgamma_zeros[i][0];
 //double x0_lo = lgamma_zeros[i][1];
 ap_fixed<1 + 0 + 52, 1 + 0> xdiff = x0-x_fix;
 //double xdiff = x-x0_hi-x0_lo;
 if ( i<2 ) {
  const ap_uint<2> poly_deg[8] = { 0, 1, 2, 3, 3, 2, 1, 1, };
_ssdm_SpecConstant(poly_deg);
# 202 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h"

  //const ap_uint<4> poly_deg[8] = { 10, 11, 12, 13, 13, 12, 11, 11, };
  const ap_uint<7> poly_end[8] = { 10, 22, 35, 49, 63, 76, 88, 100, };
_ssdm_SpecConstant(poly_end);
# 204 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h"

  const ap_fixed<1 + 12 + 52, 1 + 12> poly_coeff[112] = { /* Interval [-2.125, -2] (polynomial degree 10).  */
          -0x1.0b71c5c54d42fp+0, -0xc.73a1dc05f3758p-4, -0x1.ec84140851911p-4, -0xe.37c9da23847e8p-4,
          -0x1.03cd87cdc0ac6p-4, -0xe.ae9aedce12eep-4, 0x9.b11a1780cfd48p-8, -0xe.f25fc460bdebp-4,
          0x2.6e984c61ca912p-4, -0xf.83fea1c6d35p-4, 0x4.760c8c8909758p-4,
          /* Interval [-2.25, -2.125] (polynomial degree 11).  */
          -0xf.2930890d7d678p-4, -0xc.a5cfde054eaa8p-4, 0x3.9c9e0fdebd99cp-4, -0x1.02a5ad35619d9p+0,
          0x9.6e9b1167c164p-4, -0x1.4d8332eba090ap+0, 0x1.1c0c94b1b2b6p+0, -0x1.c9a70d138c74ep+0,
          0x1.d7d9cf1d4c196p+0, -0x2.91fbf4cd6abacp+0, 0x2.f6751f74b8ff8p+0, -0x3.e1bb7b09e3e76p+0,
          /* Interval [-2.375, -2.25] (polynomial degree 12).  */
          -0xd.7d28d505d618p-4, -0xe.69649a3040958p-4, 0xb.0d74a2827cd6p-4, -0x1.924b09228a86ep+0,
          0x1.d49b12bcf6175p+0, -0x3.0898bb530d314p+0, 0x4.207a6be8fda4cp+0, -0x6.39eef56d4e9p+0,
          0x8.e2e42acbccec8p+0, -0xd.0d91c1e596a68p+0, 0x1.2e20d7099c585p+4, -0x1.c4eb6691b4ca9p+4,
          0x2.96a1a11fd85fep+4,
          /* Interval [-2.5, -2.375] (polynomial degree 13).  */
          -0xb.74ea1bcfff948p-4, -0x1.2a82bd590c376p+0, 0x1.88020f828b81p+0, -0x3.32279f040d7aep+0,
          0x5.57ac8252ce868p+0, -0x9.c2aedd093125p+0, 0x1.12c132716e94cp+4, -0x1.ea94dfa5c0a6dp+4,
          0x3.66b61abfe858cp+4, -0x6.0cfceb62a26e4p+4, 0xa.beeba09403bd8p+4, -0x1.3188d9b1b288cp+8,
          0x2.37f774dd14c44p+8, -0x3.fdf0a64cd7136p+8,
          /* Interval [-2.625, -2.5] (polynomial degree 13).  */
          -0x3.d10108c27ebbp-4, 0x1.cd557caff7d2fp+0, 0x3.819b4856d36cep+0, 0x6.8505cbacfc42p+0,
          0xb.c1b2e6567a4dp+0, 0x1.50a53a3ce6c73p+4, 0x2.57adffbb1ec0cp+4, 0x4.2b15549cf400cp+4,
          0x7.698cfd82b3e18p+4, 0xd.2decde217755p+4, 0x1.7699a624d07b9p+8, 0x2.98ecf617abbfcp+8,
          0x4.d5244d44d60b4p+8, 0x8.e962bf7395988p+8,
          /* Interval [-2.75, -2.625] (polynomial degree 12).  */
          -0x6.b5d252a56e8a8p-4, 0x1.28d60383da3a6p+0, 0x1.db6513ada89bep+0, 0x2.e217118fa8c02p+0,
          0x4.450112c651348p+0, 0x6.4af990f589b8cp+0, 0x9.2db5963d7a238p+0, 0xd.62c03647da19p+0,
          0x1.379f81f6416afp+4, 0x1.c5618b4fdb96p+4, 0x2.9342d0af2ac4ep+4, 0x3.d9cdf56d2b186p+4,
          0x5.ab9f91d5a27a4p+4,
          /* Interval [-2.875, -2.75] (polynomial degree 11).  */
          -0x8.a41b1e4f36ff8p-4, 0xc.da87d3b69dbe8p-4, 0x1.1474ad5c36709p+0, 0x1.761ecb90c8c5cp+0,
          0x1.d279bff588826p+0, 0x2.4e5d003fb36a8p+0, 0x2.d575575566842p+0, 0x3.85152b0d17756p+0,
          0x4.5213d921ca13p+0, 0x5.55da7dfcf69c4p+0, 0x6.acef729b9404p+0, 0x8.483cc21dd0668p+0,
          /* Interval [-3, -2.875] (polynomial degree 11).  */
          -0xa.046d667e468f8p-4, 0x9.70b88dcc006cp-4, 0xa.a8a39421c94dp-4, 0xd.2f4d1363f98ep-4,
          0xd.ca9aa19975b7p-4, 0xf.cf09c2f54404p-4, 0x1.04b1365a9adfcp+0, 0x1.22b54ef213798p+0,
          0x1.2c52c25206bf5p+0, 0x1.4aa3d798aace4p+0, 0x1.5c3f278b504e3p+0, 0x1.7e08292cc347bp+0,
      };
_ssdm_SpecConstant(poly_coeff);
# 241 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h"

  ap_uint<3> j;
  j(2,0) = x_fix(50,48);
  //int j = floor(-8*x)-16;
  ap_ufixed<-3 + 4, -3> xm = 0.0625;
  //double xm = (-33-2*j)*0.0625;
  ap_ufixed<-3 + 51, -3> x_fix_s = x_fix;
  ap_fixed<1 -3 + 51, 1 - 3> x_adj = xm-x_fix_s;
  //double x_adj = x-xm;
  ap_uint<2> deg = poly_deg[j];
  ap_uint<7> end = poly_end[j];
  ap_fixed<1 + 12 + 52, 1 + 12> g = poly_coeff[end];
#pragma unroll
 for ( ap_uint<4> j = 1; j <= 10; j++ )
   g = g*x_adj+poly_coeff[end-j];
  if ( deg[1] | deg[0] )
   g = g*x_adj+poly_coeff[end-11];
                if ( deg[1] )
                        g = g*x_adj+poly_coeff[end-12];
                if ( deg[1] & deg[0] )
                        g = g*x_adj+poly_coeff[end-13];
  ap_fixed<1 + 5 + 51, 1 + 5> x_fix_sign = x_fix;
  x_fix_sign = -x_fix_sign;
  return log1p(double(g*xdiff/(x_fix_sign-xn)));
 }
 ap_fixed<1 + 5 + 52, 1 + 5> pos = x_fix-xn;
 ap_fixed<1 + 5 + 52, 1 + 5> neg = xn-x_fix;
 ap_ufixed<-1 + 52, -1> x_idiff;
 if (~pos[57])
  x_idiff(50,0) = pos(50,0);
 else
  x_idiff(50,0) = neg(50,0);
 //double x_idiff = fabs(xn-x);
 pos = x0-xn;
 neg = xn-x0;
 ap_ufixed<-1 + 52, -1> x0_idiff;
 if (~pos[57])
  x0_idiff(50,0) = pos(50,0);
 else
  x0_idiff(50,0) = neg(50,0);
 //double x0_idiff = fabs(xn-x0_hi-x0_lo);
 double log_sinpi_ratio;
 if ( x0_idiff<(x_idiff>>1) ) {
 //if ( x0_idiff<x_idiff*0.5 ) {
  log_sinpi_ratio = log(lg_sinpi(x0_idiff)/lg_sinpi(x_idiff));
 }
 else
 {
  ap_fixed<1 - 1 + 52, 1 - 1> x0diff2;
  if (~i[0])
   x0diff2 = xdiff>>1;
  else
   x0diff2 = (-xdiff)>>1;
  //double x0diff2 = ((i2[0]==0) ? xdiff : -xdiff)*0.5;
  double sx0d2 = lg_sinpi(x0diff2);
  double cx0d2 = lg_cospi(x0diff2);
  log_sinpi_ratio = log1p(2*sx0d2*(-sx0d2+cx0d2*lg_cotpi(x_idiff)));
 }
 double log_gamma_ratio;
 ap_ufixed<5 + 52, 5> y0 = x0-1;
 //double y0 = 1-x0_hi;
 //double y0_eps = -x0_hi+(1-y0)-x0_lo;
 ap_ufixed<5 + 52, 5> y = x_fix+1;
 //double y = 1-x;
 //double y_eps = -x+(1-y);
 double log_gamma_adj = 0;
 if ( i<6 )
 {
  ap_uint<2> n_up = (7-i)/2;
  y0 += n_up;
  //int n_up = (7-i)/2;
  //double ny0 = y0+n_up;
  //double ny0_eps = y0-(ny0-n_up)+y0_eps;
  //y0 = ny0;
  //y0_eps = ny0_eps;
  //double ny = y+n_up;
  //double ny_eps = y-(ny-n_up)+y_eps;
  //y = ny;
  //y_eps = ny_eps;
  ap_ufixed<0 + 52, 0> prodm1 = lgamma_product(xdiff,y,n_up);
  //double prodm1 = lgamma_product(xdiff,y-n_up,y_eps,n_up);
  y += n_up;
  log_gamma_adj = -log1p(double(prodm1));
 }
 const ap_ufixed<2 + 52, 2> e = 0x2.b7e151628aed2p+0;
 //const double e_hi = 0x2.b7e151628aed2p+0;
 //const double e_lo = 0xa.6abf7158809dp-56;
 //const ap_fixed<1 + 8 + 52, 1 + 8> lgamma_coeff[12] = {   0x1.5555555555555p-4,    -0xb.60b60b60b60b8p-12,    0x3.4034034034034p-12,    -0x2.7027027027028p-12,
 //				    0x3.72a3c5631fe46p-12,    -0x7.daac36664f1f4p-12,    0x1.a41a41a41a41ap-8,    -0x7.90a1b2c3d4e6p-8,
 //				    0x2.dfd2c703c0dp-4,    -0x1.6476701181f3ap+0,    0xd.672219167003p+0,    -0x9.cd9292e6660d8p+4, };
 double log_gamma_high = ((double)xdiff)*log1p(double((y0-e)/e))+(double(y-(ap_ufixed<0 + 1, 0>)0.5)*log1p(double(xdiff/y)))+log_gamma_adj;
 //double log_gamma_high = (xdiff*log1p((y0-e_hi-e_lo+y0_eps)/e_hi)+(y-0.5+y_eps)*log1p(xdiff/y)+log_gamma_adj);
 /*ap_ufixed<0 + 52, 0> y0r = 1/y0;
	ap_ufixed<0 + 52, 0> yr = 1/y;
	ap_ufixed<0 + 52, 0> y0r2 = y0r*y0r;
	ap_ufixed<0 + 52, 0> yr2 = yr*yr;
	ap_fixed<1 + 0 + 52, 1 + 0> rdiff = -xdiff*yr*y0r;
	//double y0r = 1/y0;
	//double yr = 1/y;
	//double y0r2 = y0r*y0r;
	//double yr2 = yr*yr;
	//double rdiff = -xdiff/(y*y0);
	ap_fixed<1 + 8 + 52, 1 + 8> bterm[12];
	ap_fixed<1 + 0 + 52, 1 + 0> dlast = rdiff;
	ap_fixed<1 + 0 + 52, 1 + 0> elast = rdiff*yr*(yr+y0r);
	//double bterm[12];
	//double dlast = rdiff;
	//double elast = rdiff*yr*(yr+y0r);
	bterm[0] = dlast*lgamma_coeff[0];
	#pragma unroll
	for ( int j = 1; j < 12; j++ )
	{
		ap_fixed<1 + 0 + 52, 1 + 0> dnext = dlast*y0r2+elast;
		ap_fixed<1 + 0 + 52, 1 + 0> enext = elast*yr2;
		//double dnext = dlast*y0r2+elast;
		//double enext = elast*yr2;
		bterm[j] = dnext*lgamma_coeff[j];
		dlast = dnext;
		elast = enext;
	}
	ap_fixed<1 + 8 + 52, 1 + 8>  log_gamma_low = 0;
	#pragma unroll
	for ( int j = 0; j < 12; j++ )
		log_gamma_low += bterm[12-1-j];*/
 log_gamma_ratio = log_gamma_high/*+log_gamma_low*/;
 return log_sinpi_ratio+log_gamma_ratio;
}

/*static double sin_pi (double x)
{
#pragma HLS pipeline

	const double pi = 3.14159265358979311600e+00;
	const double two52=  4.50359962737049600000e+15; // 0x43300000, 0x00000000
	fp_struct<double> xs(x);
	double ix = fabs(x);
	if ( xs.exp<1021 )//if ( ix<0.25 )
		return sin(pi*x);
	ap_ufixed<1 + 52, 1> x_frac = 0;
	x_frac[51] = 1;
	x_frac(51,0) = xs.sig(51,0);
	int x_exp = xs.expv();
	if ( x_exp>0 )	x_frac <<= x_exp;
	else		x_frac >>= -x_exp;

	ap_ufixed<1 + 52, 1> y_frac;
	y_frac(51,0) = x_frac(51,0);
	ap_uint<3> n;
	n(2,0) = x_frac(52,50);
	//double y = -x;
	//double z = floor(y);
	//if ( z!=y ) {
	//	y *= 0.5;
	//	y = 2*(y-floor(y));
	//	n = (int)(y*4);
	//} else {
	//	if ( xs.exp>=1076 ) {
	//		y = 0;
	//		n = 0;
	//	} else {
	//		if ( xs.exp<1075 )
	//			z = y+two52;
	//		ap_int<2> n2 = z;
	//		ap_uint<1> n1;
	//		n1[0] = n2[0];
	//		n = n1;
	//		y = n;
	//		n <<= 2;
	//	}
	//}
	switch(n) {
	    case 0:   y =  sin(pi*y); break;
	    case 1:
	    case 2:   y =  cos(pi*(0.5-y)); break;
	    case 3:
	    case 4:   y =  sin(pi*(1-y)); break;
	    case 5:
	    case 6:   y = -cos(pi*(y-1.5)); break;
	    default:  y =  sin(pi*(y-2.0)); break;
	}
	return -y;
}
*/
static double lgamma_r (double x, int *signgamp)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<double> xs(x);
        fp_struct<double> out;
        out.sign[0] = 0;
        out.sig = 0;
        out.exp = fp_struct<double>::EXP_INFNAN;

 *signgamp = 1;
 //double ix = fabs(x);
 if ( ::hls::__isinf(x) )
  return out.to_ieee();
 if ( ::hls::__isnan(x) ) {
  out.sig = -1;
  return out.to_ieee();
 }
 if ( xs.exp==0 ) {
  if ( xs.sign[0] )
   *signgamp = -1;
  out.sig = -1;
  return out.to_ieee();
 }
 if ( xs.exp<953 ) {
  if ( xs.sign[0] )
   *signgamp = -1;
  return -log(fabs(x));
 }
 double nadj = 0;
 if ( xs.sign[0] ) {
  if ( xs.exp>=1075 ) {
   out.sig = -1;
   return out.to_ieee();
  }
         if ( (xs.exp>1 && xs.exp<4) || (xs.exp==1 && (xs.sig!=0)) || (xs.exp==4 && ~(xs.sig[51] & xs.sig[50])) )//if ( (x<-2)&&(x>-28) )
                 return lgamma_neg(x,signgamp);
  const double pi = 3.14159265358979311600e+00;
         double t = sin(pi*x);
  fp_struct<double> ts(t);
         if ( ts.exp==0 ) {
                 out.sig = -1;
                 return out.to_ieee();
         }
         nadj = log(pi/fabs(t*x));
  if ( ts.sign[0] )
   *signgamp = -1;
  x = -x;
  xs.sign[0] = 0;
 }
 double r;
 if ( (xs.sig==0) && ((xs.exp==1023)||(xs.exp==1024)) ) {
  r = 0;
 } else if ( xs.exp<1024 ) {//x<2
  double y,z,p,p1,p2,p3;
  int i;
  const double tc = 1.46163214496836224576e+00;
  const double tc_m1 = 0.46163214496836224576e+00;
  ap_uint<20> x_sig_hi = (xs.sig>>32);
  if ( (xs.exp<1022) || ((xs.exp==1022)&&(x_sig_hi<=838860)) ) {
   r = -log(x);
   if ( (xs.exp>1022) || ((xs.exp==1022)&&(x_sig_hi>=485700)) ) {
    y = 1-x;
    i = 0;
   } else if ( (xs.exp>1020) || ((xs.exp==1020)&&(x_sig_hi>=894561)) ) {
    y = x-tc_m1;
    i = 1;
   } else {
    y = x;
    i = 2;
   }
  } else {
   r = 0;
   if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=767171)) ) {
    y = 2-x;
    i = 0;
   } else if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=242884)) ) {
    y = x-tc;
    i = 1;
   } else {
    y = x-1;
    i = 2;
   }
  }
  switch(i) {

        case 0:
        {
   const double a0 = 7.72156649015328655494e-02; /* 0x3FB3C467, 0xE37DB0C8 */
   const double a1 = 3.22467033424113591611e-01; /* 0x3FD4A34C, 0xC4A60FAD */
   const double a2 = 6.73523010531292681824e-02; /* 0x3FB13E00, 0x1A5562A7 */
   const double a3 = 2.05808084325167332806e-02; /* 0x3F951322, 0xAC92547B */
   const double a4 = 7.38555086081402883957e-03; /* 0x3F7E404F, 0xB68FEFE8 */
   const double a5 = 2.89051383673415629091e-03; /* 0x3F67ADD8, 0xCCB7926B */
   const double a6 = 1.19270763183362067845e-03; /* 0x3F538A94, 0x116F3F5D */
   const double a7 = 5.10069792153511336608e-04; /* 0x3F40B6C6, 0x89B99C00 */
   const double a8 = 2.20862790713908385557e-04; /* 0x3F2CF2EC, 0xED10E54D */
   const double a9 = 1.08011567247583939954e-04; /* 0x3F1C5088, 0x987DFB07 */
   const double a10 = 2.52144565451257326939e-05; /* 0x3EFA7074, 0x428CFA52 */
   const double a11 = 4.48640949618915160150e-05; /* 0x3F07858E, 0x90A45837 */

   z = y*y;
   p1 = a0+z*(a2+z*(a4+z*(a6+z*(a8+z*a10))));
   p2 = z*(a1+z*(a3+z*(a5+z*(a7+z*(a9+z*a11)))));
   p = y*p1+p2;
   r += (p-0.5*y); break;
        }
        case 1:
                      {
   const double tf = -1.21486290535849611461e-01; /* 0xBFBF19B9, 0xBCC38A42 */
   const double tt = -3.63867699703950536541e-18; /* 0xBC50C7CA, 0xA48A971F */
   const double t0 = 4.83836122723810047042e-01; /* 0x3FDEF72B, 0xC8EE38A2 */
   const double t1 = -1.47587722994593911752e-01; /* 0xBFC2E427, 0x8DC6C509 */
   const double t2 = 6.46249402391333854778e-02; /* 0x3FB08B42, 0x94D5419B */
   const double t3 = -3.27885410759859649565e-02; /* 0xBFA0C9A8, 0xDF35B713 */
   const double t4 = 1.79706750811820387126e-02; /* 0x3F9266E7, 0x970AF9EC */
   const double t5 = -1.03142241298341437450e-02; /* 0xBF851F9F, 0xBA91EC6A */
   const double t6 = 6.10053870246291332635e-03; /* 0x3F78FCE0, 0xE370E344 */
   const double t7 = -3.68452016781138256760e-03; /* 0xBF6E2EFF, 0xB3E914D7 */
   const double t8 = 2.25964780900612472250e-03; /* 0x3F6282D3, 0x2E15C915 */
   const double t9 = -1.40346469989232843813e-03; /* 0xBF56FE8E, 0xBF2D1AF1 */
   const double t10 = 8.81081882437654011382e-04; /* 0x3F4CDF0C, 0xEF61A8E9 */
   const double t11 = -5.38595305356740546715e-04; /* 0xBF41A610, 0x9C73E0EC */
   const double t12 = 3.15632070903625950361e-04; /* 0x3F34AF6D, 0x6C0EBBF7 */
   const double t13 = -3.12754168375120860518e-04; /* 0xBF347F24, 0xECC38C38 */
   const double t14 = 3.35529192635519073543e-04; /* 0x3F35FD3E, 0xE8C2D3F4 */

   z = y*y;
   double w = z*y;
   p1 = t0+w*(t3+w*(t6+w*(t9 +w*t12)));
   p2 = t1+w*(t4+w*(t7+w*(t10+w*t13)));
   p3 = t2+w*(t5+w*(t8+w*(t11+w*t14)));
   p = z*p1-(tt-w*(p2+y*p3));
   r += (tf + p); break;
                      }
        case 2:
                      {
   const double u0 = -7.72156649015328655494e-02; /* 0xBFB3C467, 0xE37DB0C8 */
   const double u1 = 6.32827064025093366517e-01; /* 0x3FE4401E, 0x8B005DFF */
   const double u2 = 1.45492250137234768737e+00; /* 0x3FF7475C, 0xD119BD6F */
   const double u3 = 9.77717527963372745603e-01; /* 0x3FEF4976, 0x44EA8450 */
   const double u4 = 2.28963728064692451092e-01; /* 0x3FCD4EAE, 0xF6010924 */
   const double u5 = 1.33810918536787660377e-02; /* 0x3F8B678B, 0xBF2BAB09 */
   const double v1 = 2.45597793713041134822e+00; /* 0x4003A5D7, 0xC2BD619C */
   const double v2 = 2.12848976379893395361e+00; /* 0x40010725, 0xA42B18F5 */
   const double v3 = 7.69285150456672783825e-01; /* 0x3FE89DFB, 0xE45050AF */
   const double v4 = 1.04222645593369134254e-01; /* 0x3FBAAE55, 0xD6537C88 */
   const double v5 = 3.21709242282423911810e-03; /* 0x3F6A5ABB, 0x57D0CF61 */

   p1 = y*(u0+y*(u1+y*(u2+y*(u3+y*(u4+y*u5)))));
   p2 = 1+y*(v1+y*(v2+y*(v3+y*(v4+y*v5))));
   r += (-0.5*y + p1/p2);
                      }
  }
 }
 else if ( xs.exp<1026 ) {// x<8

  const double s0 = -7.72156649015328655494e-02; /* 0xBFB3C467, 0xE37DB0C8 */
  const double s1 = 2.14982415960608852501e-01; /* 0x3FCB848B, 0x36E20878 */
  const double s2 = 3.25778796408930981787e-01; /* 0x3FD4D98F, 0x4F139F59 */
  const double s3 = 1.46350472652464452805e-01; /* 0x3FC2BB9C, 0xBEE5F2F7 */
  const double s4 = 2.66422703033638609560e-02; /* 0x3F9B481C, 0x7E939961 */
  const double s5 = 1.84028451407337715652e-03; /* 0x3F5E26B6, 0x7368F239 */
  const double s6 = 3.19475326584100867617e-05; /* 0x3F00BFEC, 0xDD17E945 */
  const double r1 = 1.39200533467621045958e+00; /* 0x3FF645A7, 0x62C4AB74 */
  const double r2 = 7.21935547567138069525e-01; /* 0x3FE71A18, 0x93D3DCDC */
  const double r3 = 1.71933865632803078993e-01; /* 0x3FC601ED, 0xCCFBDF27 */
  const double r4 = 1.86459191715652901344e-02; /* 0x3F9317EA, 0x742ED475 */
  const double r5 = 7.77942496381893596434e-04; /* 0x3F497DDA, 0xCA41A95B */
  const double r6 = 7.32668430744625636189e-06; /* 0x3EDEBAF7, 0xA5B38140 */

  ap_uint<3> i;
  ap_uint<51> x_frac = 0;
  if (~xs.exp[0]) {
   i[2] = 0;
   i[1] = 1;
   i[0] = xs.sig[51];
   x_frac(50,0) = xs.sig(50,0);
  } else {
   i[2] = 1;
   i[1] = xs.sig[51];
   i[0] = xs.sig[50];
   x_frac(50,1) = xs.sig(49,0);
  }
  fp_struct<double> ys(double(0));
#pragma unroll
 for ( ap_uint<6> pos = 50; pos >=0; pos-- ) {
   if ( x_frac[pos] ) {
    ys.exp = pos - 51;
    ys.sig(51,51-pos) = x_frac(pos,0);
    break;
   }
  }
  double y = ys.to_ieee();
  //int i = (int)x;
  //double t = 0;
  //double y = x-(double)i;
  double p = y*(s0+y*(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6))))));
  double q = 1+y*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))));
         r = 0.5*y+p/q;
  double z = 1;
  switch(i) {
      case 7: z *= (y+6.0); /* FALLTHRU */
      case 6: z *= (y+5.0); /* FALLTHRU */
      case 5: z *= (y+4.0); /* FALLTHRU */
      case 4: z *= (y+3.0); /* FALLTHRU */
      case 3: z *= (y+2.0); /* FALLTHRU */
       r += log(z); break;
  }

 } else if ( xs.exp<1081 ) {

  const double w0 = 4.18938533204672725052e-01; /* 0x3FDACFE3, 0x90C97D69 */
  const double w1 = 8.33333333333329678849e-02; /* 0x3FB55555, 0x5555553B */
  const double w2 = -2.77777777728775536470e-03; /* 0xBF66C16C, 0x16B02E5C */
  const double w3 = 7.93650558643019558500e-04; /* 0x3F4A019F, 0x98CF38B6 */
  const double w4 = -5.95187557450339963135e-04; /* 0xBF4380CB, 0x8C0FE741 */
  const double w5 = 8.36339918996282139126e-04; /* 0x3F4B67BA, 0x4CDAD5D1 */
  const double w6 = -1.63092934096575273989e-03; /* 0xBF5AB89D, 0x0B9E43E4 */

  double t = log(x);
  double z = 1/x;
  double y = z*z;
  double w = w0+z*(w1+y*(w2+y*(w3+y*(w4+y*(w5+y*w6)))));
         r = (x-0.5)*(t-1)+w;

 } else
         r = x*(log(x)-1);
 if ( x<0 )
  r = nadj-r;
 return r;
}


static ap_fixed<20 + 52, 20> gamma_product (ap_ufixed<4 + 52, 4> x/*, double x_eps*/, ap_uint<3> n/*, double *eps*/)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 ap_fixed<20 + 52, 20> ret[6] = {0};
 ret[0] = x;
 //double eps_[6] = {0};
 //eps_[0] = x_eps/x;
#pragma unroll
 for ( ap_uint<3> i = 1; i < 6; i++ )
 {
  //eps_[i] = eps[i-1]+x_eps/(x+i);
  ret[i] = ret[i-1]*(x+i);
 }
 //*eps = eps_[n];
 return ret[n];
}

static double gamma_positive (double x, int *exp2_adj)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<double> xs(x);
 ap_ufixed<8 + 52, 8> x_fix = 1;
 x_fix(51,0) = xs.sig(51,0);
 ap_uint<3> shl;
 shl(2,0) = xs.exp(2,0);
 shl++;
 x_fix <<= shl;

 if ( xs.exp<126 )
 {
  *exp2_adj = 0;
  return exp(lgamma(x+1))/x;
 }
 else if ( (xs.exp<127)||((xs.exp==127)&&(xs.sig[51]==0)) )
 {
  *exp2_adj = 0;
  return exp(lgamma(x));
 }
 else if ( (xs.exp<129)||((xs.exp==129)&&(xs.sig(51,49)<5)) )
 {
  *exp2_adj = 0;
  ap_uint<4> nl;
  nl(3,0) = x_fix(54,51);
  nl -= 3;
  ap_uint<3> n;
  n(2,0) = nl(3,1);
  ap_ufixed<2 + 52, 2> x_adj;
  x_adj(51,0) = x_fix(51,0);
  x_adj[52] = x_fix[51];
  x_adj[53] = ~x_fix[51];
  //double n = ceil(x-1.5);
  //double x_adj = x-n;
  //double eps;
  double prod = gamma_product(x_adj/*,0*/,n/*,&eps*/);
  return (exp(lgamma(double(x_adj)))*prod/**(1+eps)*/);
 }
 else
 {
  ap_ufixed<8 + 52, 8> x_adj = x_fix;
  //double eps = 0;
  //double x_eps = 0;
  //double x_adj = x;
  double prod = 1;
  if ( (xs.exp<130)||((xs.exp==130)&&(xs.sig(51,50)<3)) )
  {
   ap_uint<4> xi = x_fix(55,52);
   ap_uint<3> n = 11-xi;
   x_adj[52] = 1;
   x_adj[53] = 1;
   x_adj[54] = 0;
   x_adj[55] = 1;
   if (x_fix(51,0)==0) {
    n++;
                                x_adj[52] = 0;
                                x_adj[53] = 0;
                                x_adj[54] = 1;
   }
   //double n = ceil(12-x);
   //x_adj = x+n;
   //x_eps = (x-(x_adj-n));
   prod = gamma_product(x_fix,n);
   //prod = gamma_product(x_adj-n,x_eps,n,&eps);
  }
  ap_uint<8> x_adj_int;
  x_adj_int(7,0) = x_adj(59,52) + x_adj[51];
  ap_fixed<1 - 1 + 52, 1 - 1> x_adj_frac;
  x_adj_frac(51,0) = x_adj(51,0);
  //double exp_adj = -eps;
  //double x_adj_int = round(x_adj);
  //double x_adj_frac = x_adj-x_adj_int;
  ap_uint<3> x_adj_log2;
  ap_ufixed<1 + 52, 1> x_adj_mant;
#pragma unroll
 for ( ap_uint<3> pos = 6; pos >= 2; pos-- ) {
   ap_uint<9> x_adj_hi;
   x_adj_hi(8,0) = x_adj(53+pos,45+pos);
   if ( x_adj_hi > 181 ) {
    x_adj_log2 = pos;
    x_adj_mant(52,0) = x_adj(53+pos,1+pos);
   }
  }
  //int x_adj_log2;
  //double x_adj_mant = frexp(x_adj,&x_adj_log2);
  //if ( x_adj_mant<M_SQRT1_2 )
  //{
  //	x_adj_log2--;
  //	x_adj_mant *= 2;
  //}
  *exp2_adj = x_adj_log2*x_adj_int;
  double ret = ( pow(double(x_adj_mant),double(x_adj)) * exp2(double(x_adj_log2*x_adj_frac)) * exp(double(-x_adj)) * sqrt(double((ap_fixed<3 + 52, 3>(3.14159265358979323846 /* pi */)<<1)/x_adj)) / prod );





  //exp_adj += x_eps*log(x_adj);
  const ap_fixed<1 - 3 + 52, 1 - 3> gamma_coeff[6] = { 0x1.5555555555555p-4, -0xb.60b60b60b60b8p-12, 0x3.4034034034034p-12,
          -0x2.7027027027028p-12, 0x3.72a3c5631fe46p-12, -0x7.daac36664f1f4p-12,
            };
_ssdm_SpecConstant(gamma_coeff);
# 778 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_gamma.h"

  ap_fixed<1 - 3 + 52, 1 - 3> bsum = gamma_coeff[5];
  ap_fixed<16 + 52, 16> x_adj2 = x_adj*x_adj;
  for ( ap_uint<3> i = 1; i <= 5; i++ )
   bsum = bsum/x_adj2+gamma_coeff[5-i];
  ap_fixed<1 - 3 + 52, 1 - 3> exp_adj = bsum/x_adj;
  return ret+ret*expm1(double(exp_adj));
 }
}

static double tgamma (double x)
{
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

 fp_struct<double> xs(x);
 fp_struct<double> out;
 out.sign[0] = 0;
 out.sig = 0;
 out.exp = fp_struct<double>::EXP_INFNAN;

        ap_ufixed<1 + 52, 1> x_sig = 1;
        x_sig(51,0) = xs.sig(51,0);
        int x_exp = xs.expv();
        if ( x_exp>0 ) x_sig <<= x_exp;

 if ( (xs.exp==0) || ((xs.sign[0])&(::hls::__isinf(x))) || (::hls::__isnan(x)) || ((xs.sign[0]==1)&&(x_exp>=0)&&(x_sig==0)) )
 {
  out.sig = -1;
  return out.to_ieee();
 }
 if ( (::hls::__isinf(x)) || ((xs.sign[0]==0)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,47)>=11)))) )
 {
  return out.to_ieee();
 }
 else
 {
  double ret;
  if ( ~xs.sign[0] )
  {
   int exp2_adj;
   double tret = gamma_positive(x,&exp2_adj);
   ret = scalbn(tret,exp2_adj);
  }
//		else if ( x>=-DBL_EPSILON/4 )
//		{
//			out.sig = -1;
//			return out.to_ieee();
//		}
  else
  {
                        fp_struct<double> xs(x);
                        ap_ufixed<8 + 52, 8> x_fix = 1;
                        x_fix(51,0) = xs.sig(51,0);
                        ap_uint<3> shl;
                        shl(2,0) = xs.exp(2,0);
                        shl++;
                        x_fix <<= shl;

   //double tx = trunc(x);
   if ( (xs.sign[0]==1)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,48)>=7))) )
    ret = 0;
   else
   {
    ap_ufixed<0 + 52, 0> frac;
    frac(51,0) = x_fix(51,0);
    //double frac = tx-x;
    if ( frac[51] )
     frac = 1-frac;
    double sinpix = ((~frac[51])&(~frac[50])) ? sin(double((ap_fixed<2 + 52, 2>)3.14159265358979323846 /* pi */*frac)) : cos(double((ap_fixed<2 + 52, 2>)3.14159265358979323846 /* pi */*((ap_ufixed<0 + 52, 0>)0.5-frac)));
    int exp2_adj;
    double tret = 3.14159265358979323846 /* pi *//(-x*sinpix*gamma_positive(-x,&exp2_adj));
    ret = scalbn(tret,-exp2_adj);
   }
  }
  return ret;
 }
}
# 973 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
static float lgamma_rf(float x, int *signgamp) {
    return hls::lgamma_r(x,signgamp);
}
static half half_lgamma_r(half x, int *signgamp) {
    return hls::lgamma_r(x,signgamp);
}
static double lgamma (double x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static float lgammaf(float x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static half half_lgamma(half x) {
    int *signgamp = 0;
    return hls::lgamma_r(x,signgamp);
}
static float tgammaf(float x) {
    return hls::tgamma(x);
}
static half half_tgamma(half x) {
    return hls::tgamma(x);
}

// Do nothing with the result of the filter.
template <typename T>
struct hls_filter_traits {
    typedef T T_data;
    typedef T T_accum;
    static T_data shift(T_accum in) {
        return in;
    }
};

struct hls_filter_traits_Q15 {
    typedef short T_data;
    typedef int T_accum;
    static T_data shift(T_accum in) {
        return (T_data)(in >> 15);
    }
};

/** Compute the dot product of x and y, returning the result.
 * @param x the first vector, with length n
 * @param y the second vector, with length n
 * @param n the size of the vectors.
 * @param T the type of the data
 * @param T_accum the type used for the accumulation
 */
template <typename T_accum, typename T>
T_accum dot(T *x, T *y, int n)
{
    // This volatile prevents the first tap from being constant-optimized.
    volatile T_accum r = 0;
    T_accum result = r;
dot_foreach_tap:
    for(int i = 0; i < n; i++) {
        result += x[i] * y[i];
    }
    return result;
}

/**
 * Block FIR filter, with data type T.  This function supports traits
 * which can be used to control the type used to perform the filter
 * accumultation.
 *
 * @param in the input data, with size incout.
 * @param state the filter state (size = numtaps), with the newest
 * sample in state[0].
 * @param out the filtered data, with size incout.
 * @param taps the filter taps (size = numtaps), stored in 'normal' order.
 * in and out are size incount.
 * @param incount
 * @param numtaps
 */
template <typename T, typename TRAITS>
void fir_blocksrl(T *in, T *taps, T *out, T *state, int incount, int numtaps)
{
_ssdm_InlineSelf(0, "");
fir_blocksrl_foreach_data:
    for(int n = 0; n < incount; n++) {
_ssdm_SpecExprBalance(0, "");
        for(int i = numtaps-1; i > 0; i--) {
            state[i] = state[i-1];
        }
        state[0] = in[n];
        out[n] = TRAITS::shift( dot<typename TRAITS::T_accum>(state, taps, numtaps));
    }
}

/**
 * Block FIR filter, with data type T.  This function should be used
 * when the type used for accumulation is the same as the type of the
 * output (e.g. 'float').
 *
 * @param in the input data, with size incout.
 * @param state the filter state (size = numtaps), with the newest
 * sample in state[0].
 * @param out the filtered data, with size incout.
 * @param taps the filter taps (size = numtaps), stored in 'normal' order.
 * in and out are size incount.
 * @param incount
 * @param numtaps
 */
template <typename T>
void fir_blocksrl(T *in, T *taps, T *out, T *state, int incount, int numtaps)
{
    fir_blocksrl<T, hls_filter_traits<T> >(in, taps, out, state, incount, numtaps);
}

/**
 * Block FIR filter, with Q15 datatypes modeled as 'short'.  The
 * result always includes the required right shift by 15.
 *
 * @param in the input data, with size incout.
 * @param state the filter state (size = numtaps), with the newest
 * sample in state[0].
 * @param out the filtered data, with size incout.
 * @param taps the filter taps (size = numtaps), stored in 'normal' order.
 * in and out are size incount.
 * @param incount
 * @param numtaps
 */
static void fir_blocksrl_Q15(short *in, short *taps, short *out, short *state, int incount, int numtaps)
{
    fir_blocksrl<short, hls_filter_traits_Q15>(in, taps, out, state, incount, numtaps);
}

} // namespace hls

namespace hls {



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_tanh.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2017 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/




namespace explog_based {

/*
  Method: 
  tanh(x), odd function
  input: nan           outout: nan
  input: inf           output: 1.0
  input: -inf          output: -1.0
  input: (0,2**-55]    output: x*(x+1)
  input: (2**-55,1.0)  output: -expm1(-2x) / (expm1(-2x)+2)
  input: [1.0,22)      output: 1.0 - 2.0/(expm1(2x)+2) 
  input: [22.0,inf)    output: 1.0
*/
  template<class T>
  T generic_tanh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;
_ssdm_SpecConstant(&exp_bias);
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_tanh.h"


    fp_struct<T> din(t_in);
    T abst_in = hls::fabs(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      if(din.sig != 0){
 resultf = ::hls::nan("");
      }
      else{
 resultf = (T)1.0;
      }
    }
    else if((din.exp<exp_bias-55) or
     (din.exp==exp_bias-55 and din.sig==0)){

      const T cst1 = 1.0;
      resultf = abst_in * (cst1 + abst_in);
    }
    else if(abst_in < (T)22.0){

      T x;
      if(din.exp < exp_bias){
 x = -abst_in - abst_in;
      }
      else{
 x = abst_in + abst_in;
      }

      T expx = hls::expm1(x);

      if(din.exp < exp_bias){

 const T cst2 = 2.0;
 resultf = - expx / (expx + cst2);
      }
      else{
 const T cst1 = 1.0;
 const T cst2 = 2.0;
 resultf = cst1 - cst2 / (expx + cst2);
      }
    }
    else{
      resultf = (T)1.0;
    }

    // return 
    if(din.sign == 0){ // positive 
      return resultf;
    }
    else{
      return -resultf;
    };
  }

  static
  double tanh(double t_in)
  {
    return generic_tanh(t_in);
  };

  static
  float tanh(float t_in)
  {
    return generic_tanh(t_in);
  };

  static half
  tanh(half t_in)
  {
    return generic_tanh(t_in);
  };

  static
  float tanhf(float t_in){
    return generic_tanh(t_in);
  };

  static
  half half_tanh(half t_in){
    return generic_tanh(t_in);
  };

}
# 1108 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_atanh.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2017 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/




namespace explog_based {

/*
  Method: 
  atanh(x), odd function
  input: nan           outout: nan
  input: inf           output: nan
  input: -inf          output: nan
  input: (1,inf)       output: nan
  input: 1.0           output: inf
  input: [0.0,0.5)     output: 0.5*log1p(2x+2x*x/(1-x))
  input: [0.5,1.0)     output: 0.5*log1p(2x/(1-x))
*/
  template<class T>
  T generic_atanh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;
_ssdm_SpecConstant(&exp_bias);
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_atanh.h"


    fp_struct<T> din(t_in);
    T abst_in = hls::fabs(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      resultf = ::hls::nan("");
    }
    else if((din.exp>exp_bias) or
     (din.exp==exp_bias and din.sig>0)){

      resultf = ::hls::nan("");
    }
    else if(din.exp==exp_bias and din.sig==0){

      fp_struct<T> out;
      out.sign = 0;
      out.exp = fp_struct<T>::EXP_INFNAN;
      out.sig = 0;
      resultf = out.to_ieee(); // +inf
    }
    else{

      const T cst1 = 1.0;
      const T cst05 = 0.5;
      T t = abst_in + abst_in;
      T x;
      if(din.exp<exp_bias-1){
 x = t + t*abst_in/(cst1-abst_in);
      }
      else{
 x = t/(cst1-abst_in);
      };

      resultf = cst05 * hls::log1p(x);
    }

    // return
    if(din.sign == 0){ // positive 
      return resultf;
    }
    else{
      return -resultf;
    };
  };

  static
  double atanh(double t_in)
  {
    return generic_atanh(t_in);
  };

  static
  float atanh(float t_in)
  {
    return generic_atanh(t_in);
  };

  static
  half atanh(half t_in)
  {
    return generic_atanh(t_in);
  };

  static
  float atanhf(float t_in){
    return generic_atanh(t_in);
  };

  static
  half half_atanh(half t_in){
    return generic_atanh(t_in);
  };

}
# 1109 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

static double tanh(double t_in)
{
  return explog_based::tanh(t_in);
}

static float tanh(float t_in)
{
  return explog_based::tanh(t_in);
}

static half tanh(half t_in)
{
  return explog_based::tanh(t_in);
}

static double atanh(double t_in)
{
  return explog_based::atanh(t_in);
}

static float atanh(float t_in)
{
  return explog_based::atanh(t_in);
}

static half atanh(half t_in)
{
  return explog_based::atanh(t_in);
}



# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_acosh.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2017 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/




namespace explog_based {

  /*
    Method: 
    acosh(x)
    input: nan           outout: nan
    input: inf           output: inf      
    input: -inf          output: nan 
    input: (-inf,1.0)    output: nan
    input: 1.0           output: 0.0
    input: (1.0,2.0]     output: log1p(x-1+sqrt(2*(x-1)+(x-1)**2))
    input: (2.0,2**28]   output: log(2*x-1/(x+sqrt(x**2-1)))
    input: (2**28, inf)  output: log(2x) = log(x) + log(2)
  */
  template<class T>
  T generic_acosh(T t_in){

    static const int exp_bias = fp_struct<T>::EXP_BIAS;
_ssdm_SpecConstant(&exp_bias);
# 52 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_acosh.h"


    fp_struct<T> din(t_in);
    T resultf;

    if(din.exp==fp_struct<T>::EXP_INFNAN){

      if(din.sig != 0){
 resultf = ::hls::nan("");
      }
      else{
 if(din.sign == 0){

   fp_struct<T> out;
   out.sign = 0;
   out.exp = fp_struct<T>::EXP_INFNAN;
   out.sig = 0;
   resultf = out.to_ieee(); // out=+inf
 }
 else{
   resultf = ::hls::nan("");
 }
      }
    }
    else if((din.sign==1) or (din.exp<exp_bias)){

      resultf = ::hls::nan("");
    }
    else if((din.exp==exp_bias) and (din.sig==0)){

      resultf = (T)0.0;
    }
    else if((din.exp==exp_bias and din.sig>0) or
     (din.exp==exp_bias+1 and din.sig==0)){

      const T cst1 = 1.0;
      T t = t_in - cst1;
      T x1 = t + (T)hls::sqrt(t+t+t*t);
      resultf = hls::log1p(x1);
    }
    else{

      T x;
      if(din.exp < exp_bias+28){
 const T cst1 = 1.0;
 x = t_in + t_in - cst1/(t_in+(T)hls::sqrt(t_in*t_in-cst1));
      }
      else{
 x = t_in;
      }

      T logx = hls::log(x);

      if(din.exp < exp_bias+28){
 resultf = logx;
      }
      else{
 const T ln2 = 6.93147180559945286227e-01; // 0x3FE62E42, 0xFEFA39EF 
 resultf = logx + ln2;
      };
    };

    return resultf;
  };

  static
  float acosh(float t_in){
    return generic_acosh(t_in);
  };

  static
  double acosh(double t_in){
    return generic_acosh(t_in);
  };

  static
  half acosh(half t_in){
    return generic_acosh(t_in);
  };

  static
  float acoshf(float t_in){
    return generic_acosh(t_in);
  };

  static
  half half_acosh(half t_in){
    return generic_acosh(t_in);
  };

}
# 1141 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_asinh.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE_HERE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2017 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/**
 * @file hls_asinh.h
 */



namespace explog_based {

  template <class T>
  T generic_asinh(T x)
  {
    const T ONE_HERE = 1.0;
    const int W = fp_struct<T>::EXP_BITS+fp_struct<T>::SIG_BITS+1;
    const int E = fp_struct<T>::EXP_BITS;
    const double LN2 = 6.93147180559945286227e-01;
    T ln2_t(LN2);
    fp_struct<T> fx(x);
    fp_struct<T> fxa(x);
    fp_struct<T> fx2(x);
    fx2.exp+=1;
    fx2.sign=0;
    fxa.sign=0;
    T x_abs = fxa.to_ieee();
    T x2 = fx2.to_ieee();

    // The value input is seperated :into 5  segments 
    // 1) NAN/INF: |x| >= INF, function returns x;
    // 2) ST1: 2^28/14/7< |x| < INF, reutrns log (fabs (x)) + ln2 
    // 3) ST2: ST1 >= |x| > 2.0, log, sqr, sqrt and divide are used by return value
    // 4) ST3: |x|< 2^-28/-14/-7<=|x|<ST2, log1p, sqr, sqrt and divide are used
    // 5) SML: |x|< 2^-28/-14/-7  function returns x
    // There are 3 segments flag variables needed  to be defined, which used different range_seg_exp for different data-type.
    const int range_seg_exp = 28>>(64/W-1);
    fp_struct<T> ST1((T)1.0);
    ST1.exp += range_seg_exp;//double 28; float 14;half 7;
    fp_struct<T> ST2((T)2.0);
    fp_struct<T> ST3((T)1.0);
    ST3.exp -= range_seg_exp;//double -28; float -14;half -7;
    bool is1sg = false;
    bool is2sg = false;
    bool is3sg = false;

    if(fxa.exp == ((1<<E)-1))//NAN/INF
      return x;
    else if( x_abs > ST1.to_ieee())//ST1
      is1sg = true;
    else if( x_abs > ST2.to_ieee())//ST2
      is2sg = true;
    else if( x_abs >= ST3.to_ieee())//SML//ST3
      is3sg = true;
    else return x;//SML
    // sqr and sqrt
    T x_sqr = x*x;
    T in_sqrt = x_sqr+ONE_HERE;
    T out_sqrt = hls::sqrt( in_sqrt );
    //divide
    T div2 = out_sqrt + x_abs;
    T div3 = out_sqrt + ONE_HERE;
    T inx_div = (T)0.0;
    T iny_div = (T)1.0;
    T out_div;
    if(is2sg){
      inx_div = ONE_HERE;
      iny_div = div2;
    }
    if(is3sg){
      inx_div = x_sqr;
      iny_div = div3;
    }
    out_div = inx_div / iny_div;
    //log 
    T in_log,in_log1p, out_log;
    if(is1sg)
      in_log = x_abs;
    else // if(is2sg)
      in_log = x2+out_div;
    in_log1p = (T)1.0 + x_abs+out_div ;
    if(is3sg)
      out_log = hls::log(in_log1p);
    else
      out_log = hls::log(in_log);

    if(is1sg)
      out_log = out_log + ln2_t;

    fp_struct<T> fz(out_log);
    fz.sign = fx.sign;
    return fz.to_ieee();
  }

  static
  double asinh(double x)
  {
    return generic_asinh<double>(x);
  }

  static
  float asinhf(float x)
  {
    return generic_asinh<float>(x);
  }

  static
  half half_asinh(half x)
  {
    return generic_asinh<half>(x);
  }

  static
  float asinh(float x)
  {
    return generic_asinh<float>(x);
  }
  static
  half asinh(half x)
  {
    return generic_asinh<half>(x);
  }

}
# 1142 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_math.h" 2

static double acosh(double t_in)
{
  return explog_based::acosh(t_in);
}

static float acosh(float t_in)
{
  return explog_based::acosh(t_in);
}

static half acosh(half t_in)
{
  return explog_based::acosh(t_in);
}

static double asinh(double t_in)
{
  return explog_based::asinh(t_in);
}

static float asinh(float t_in)
{
  return explog_based::asinh(t_in);
}

static half asinh(half t_in)
{
  return explog_based::asinh(t_in);
}


} // end of namespace





// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 50 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_stream.h" 1
/* -*- c++ -*-*/
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 *
 */




/*
 * This file contains a C++ model of hls::stream.
 * It defines AutoESL synthesis model.
 */







# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/etc/autopilot_enum.h" 1
/*
#-  (c) Copyright 2011-2017 Xilinx, Inc. All rights reserved.
#-
#-  This file contains confidential and proprietary information
#-  of Xilinx, Inc. and is protected under U.S. and
#-  international copyright and other intellectual property
#-  laws.
#-
#-  DISCLAIMER
#-  This disclaimer is not a license and does not grant any
#-  rights to the materials distributed herewith. Except as
#-  otherwise provided in a valid license issued to you by
#-  Xilinx, and to the maximum extent permitted by applicable
#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
#-  (2) Xilinx shall not be liable (whether in contract or tort,
#-  including negligence, or under any other theory of
#-  liability) for any loss or damage of any kind or nature
#-  related to, arising under or in connection with these
#-  materials, including for any direct, or any indirect,
#-  special, incidental, or consequential loss or damage
#-  (including loss of data, profits, goodwill, or any type of
#-  loss or damage suffered as a result of any action brought
#-  by a third party) even if such damage or loss was
#-  reasonably foreseeable or Xilinx had been advised of the
#-  possibility of the same.
#-
#-  CRITICAL APPLICATIONS
#-  Xilinx products are not designed or intended to be fail-
#-  safe, or for use in any application requiring fail-safe
#-  performance, such as life-support or safety devices or
#-  systems, Class III medical devices, nuclear facilities,
#-  applications related to the deployment of airbags, or any
#-  other applications that could lead to death, personal
#-  injury, or severe property or environmental damage
#-  (individually and collectively, "Critical
#-  Applications"). Customer assumes the sole risk and
#-  liability of any use of Xilinx products in Critical
#-  Applications, subject only to applicable laws and
#-  regulations governing limitations on product liability.
#-
#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
#-  PART OF THIS FILE AT ALL TIMES. 
#- ************************************************************************

 *
 * $Id$
 */





/* Data Types */
enum SsdmDataTypes {
    _ssdm_sc_int = 0,
    _ssdm_c_int = _ssdm_sc_int,
    _ssdm_sc_uint = 1,
    _ssdm_c_uint = _ssdm_sc_uint,
    _ssdm_sc_bigint = 2,
    _ssdm_sc_biguint = 3,
};


/* Ports */
enum SsdmPortTypes {
    _ssdm_sc_in = 0,
    _ssdm_sc_out = 1,
    _ssdm_sc_inout = 2,
    _ssdm_sc_in_clk,

    _ssdm_fifo_in,
    _ssdm_sc_fifo_in = _ssdm_fifo_in,
    _ssdm_tlm_fifo_in = _ssdm_fifo_in,
    _ssdm_fifo_out,
    _ssdm_sc_fifo_out = _ssdm_fifo_out,
    _ssdm_tlm_fifo_out = _ssdm_fifo_out,
    _ssdm_fifo_inout,
    _ssdm_sc_fifo_inout = _ssdm_fifo_inout,
    _ssdm_tlm_fifo_inout = _ssdm_fifo_inout,
    _ssdm_sc_bus,
    _ssdm_hls_bus_port = _ssdm_sc_bus,
    _ssdm_AXI4M_bus_port = _ssdm_sc_bus,
    _ssdm_port_end,
};


/* Threads (Processes) */
enum SsdmProcessTypes {
    _ssdm_method = 0,
    _ssdm_sc_method = _ssdm_method,
    _ssdm_thread = 1,
    _ssdm_sc_thread = _ssdm_thread,
    _ssdm_cthread = 2,
    _ssdm_sc_cthread = _ssdm_cthread,
    _ssdm_process_end,
};


/* Threads (Processes) */
enum SsdmSensitiveTypes {
    _ssdm_sensitive = 0,
    _ssdm_sensitive_pos,
    _ssdm_sensitive_neg,
    _ssdm_sensitive_reset0, /* Level = High*/
    _ssdm_sensitive_reset1, /* Level = Low*/
    _ssdm_sensitive_end,
};


/* Channels */
enum SsdmChannelTypes {
    _ssdm_sc_sig,
    _ssdm_fifo,
    _ssdm_sc_fifo = _ssdm_fifo,
    _ssdm_mem_fifo,
    _ssdm_sc_mem_fifo = _ssdm_mem_fifo,
};

/* Regions */
enum SsdmRegionTypes {
    _ssdm_region_reset,
    _ssdm_region_protocol,
    _ssdm_region_pipeline,
    _ssdm_region_parallel,
};




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 67 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_stream.h" 2


namespace hls {





//////////////////////////////////////////////
// Synthesis models for stream
//////////////////////////////////////////////
template<typename __STREAM_T__>
class stream
{
  public:
    /// Constructors
    inline __attribute__((always_inline)) stream() {
    }

    inline __attribute__((always_inline)) stream(const char* name) {
    }

  /// Make copy constructor and assignment operator private
  private:
    inline __attribute__((always_inline)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:
    /// Overload >> and << operators to implement read() and write()
    inline __attribute__((always_inline)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }

  /// Public API
  public:
    /// Empty & Full
    inline __attribute__((always_inline)) bool empty() const {
        bool tmp = _ssdm_StreamCanRead(&V);
        return !tmp;
    }

    inline __attribute__((always_inline)) bool full() const {
        bool tmp = _ssdm_StreamCanWrite(&V);
        return !tmp;
    }

    /// Blocking read
    inline __attribute__((always_inline)) void read(__STREAM_T__& dout) {
        __STREAM_T__ tmp;
        _ssdm_StreamRead(&V, &tmp);
        dout = tmp;
    }

    inline __attribute__((always_inline)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        _ssdm_StreamRead(&V, &tmp);
        return tmp;
    }

    /// Nonblocking read
    inline __attribute__((always_inline)) bool read_nb(__STREAM_T__& dout) {
        __STREAM_T__ tmp;
        bool empty_n = _ssdm_StreamNbRead(&V, &tmp);
        dout = tmp;
        return empty_n;
    }

    /// Blocking write
    inline __attribute__((always_inline)) void write(const __STREAM_T__& din) {
        __STREAM_T__ tmp = din;
        _ssdm_StreamWrite(&V, &tmp);
    }

    /// Nonblocking write
    inline __attribute__((always_inline)) bool write_nb(const __STREAM_T__& din) {
        __STREAM_T__ tmp = din;
        bool full_n = _ssdm_StreamNbWrite(&V, &tmp);
        return full_n;
    }

    /// Fifo size
    inline __attribute__((always_inline)) unsigned size() {
        unsigned size = _ssdm_StreamSize(&V);
        return size;
    }

  public:
    __STREAM_T__ V;
};

} // namespace hls




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 51 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2




# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is derived from OpenCV:
// opencv/modules/core/include/opencv2/core/types_c.h

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Types Header File
 */
# 177 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
template<int T> struct Type { typedef ap_int<T-12> name; static const int bitdepth = T-12;
public :
inline __attribute__((always_inline)) Type() { _ssdm_SpecConstant(&bitdepth); }
# 177 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<0> { typedef unsigned char name; static const int bitdepth = 8;
public :
inline __attribute__((always_inline)) Type<0>() { _ssdm_SpecConstant(&bitdepth); }
# 178 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<1> { typedef char name; static const int bitdepth = 8;
public :
inline __attribute__((always_inline)) Type<1>() { _ssdm_SpecConstant(&bitdepth); }
# 179 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<8> { typedef ap_uint<10> name; static const int bitdepth = 10;
public :
inline __attribute__((always_inline)) Type<8>() { _ssdm_SpecConstant(&bitdepth); }
# 180 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<9> { typedef ap_int<10> name; static const int bitdepth = 10;
public :
inline __attribute__((always_inline)) Type<9>() { _ssdm_SpecConstant(&bitdepth); }
# 181 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<10> { typedef ap_uint<12> name; static const int bitdepth = 12;
public :
inline __attribute__((always_inline)) Type<10>() { _ssdm_SpecConstant(&bitdepth); }
# 182 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<11> { typedef ap_int<12> name; static const int bitdepth = 12;
public :
inline __attribute__((always_inline)) Type<11>() { _ssdm_SpecConstant(&bitdepth); }
# 183 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<2> { typedef unsigned short name; static const int bitdepth = 16;
public :
inline __attribute__((always_inline)) Type<2>() { _ssdm_SpecConstant(&bitdepth); }
# 184 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<3> { typedef short name; static const int bitdepth = 16;
public :
inline __attribute__((always_inline)) Type<3>() { _ssdm_SpecConstant(&bitdepth); }
# 185 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<4> { typedef int name; static const int bitdepth = 32;
public :
inline __attribute__((always_inline)) Type<4>() { _ssdm_SpecConstant(&bitdepth); }
# 186 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<5> { typedef float name; static const int bitdepth = 32;
public :
inline __attribute__((always_inline)) Type<5>() { _ssdm_SpecConstant(&bitdepth); }
# 187 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Type<6> { typedef double name; static const int bitdepth = 64;
public :
inline __attribute__((always_inline)) Type<6>() { _ssdm_SpecConstant(&bitdepth); }
# 188 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};

template<typename PIXEL_T> struct pixel_op_type { typedef PIXEL_T T; };
template<> struct pixel_op_type<unsigned char> { typedef ap_uint<8> T; };
template<> struct pixel_op_type<char> { typedef ap_int<8> T; };
template<> struct pixel_op_type<unsigned short> { typedef ap_uint<16> T; };
template<> struct pixel_op_type<short> { typedef ap_int<16> T; };
template<> struct pixel_op_type<unsigned int> { typedef ap_uint<32> T; };
template<> struct pixel_op_type<int> { typedef ap_int<32> T; };
template<int W> struct pixel_op_type<ap_int<W> > { typedef ap_int<W> T; };
template<int W> struct pixel_op_type<ap_uint<W> > { typedef ap_uint<W> T; };
# 225 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
template<typename T> struct Name
{ static const int _min = -2147483647; static const int _max = 2147483647;
public :
inline __attribute__((always_inline)) Name() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 226 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Name<unsigned char>
{ static const int _min = 0; static const int _max = 255;
public :
inline __attribute__((always_inline)) Name<unsigned char>() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 228 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Name<char>
{ static const int _min = -127; static const int _max = 127;
public :
inline __attribute__((always_inline)) Name<char>() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 230 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Name<unsigned short>
{ static const int _min = 0; static const int _max = 65535;
public :
inline __attribute__((always_inline)) Name<unsigned short>() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 232 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Name<short>
{ static const int _min = -32767; static const int _max = 32767;
public :
inline __attribute__((always_inline)) Name<short>() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 234 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};
template<> struct Name<int>
{ static const int _min = -2147483647; static const int _max = 2147483647;
public :
inline __attribute__((always_inline)) Name<int>() { _ssdm_SpecConstant(&_min); _ssdm_SpecConstant(&_max); }
# 236 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_types.h"
};

template<typename T>
unsigned char Convert2uchar(T v)
{
    unsigned char result=0;
    if(v>=255)
    {
        result=255;
    }
    else if(v>=0&&v<255)
    {
        ap_fixed<9,9,SC_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
char Convert2char(T v)
{
    char result=-127;
    if(v>=127)
    {
        result=127;
    }
    else if(v>=-127&&v<127)
    {
        ap_fixed<9,9,SC_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
unsigned short Convert2ushort(T v)
{
    unsigned short result=0;
    if(v>=65535)
    {
        result=65535;
    }
    else if(v>=0&&v<65535)
    {
        ap_fixed<17,17,SC_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
short Convert2short(T v)
{
    short result=-32767;
    if(v>=32767)
    {
        result=32767;
    }
    else if(v>=-32767&&v<32767)
    {
        ap_fixed<17,17,SC_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
int Convert2int(T v)
{
    int result=-2147483647;
    if(v>=2147483647)
    {
        result=2147483647;
    }
    else if(v>=-2147483647&&v<2147483647)
    {
        ap_fixed<32,32,SC_RND> temp=v;
        result=temp;
    }
    return result;
}
typedef ap_uint<12> HLS_SIZE_T;
typedef ap_uint<5> HLS_CHANNEL_T;

namespace hls {

/* sr_cast: saturate and round cast: T1 -> T2 */

template<typename T2> class sr_cast_class { };

template<> class sr_cast_class<float> {
public:
    template<typename T1>
    inline float operator()(T1 v) { return v; }
    inline float operator()(double v) { return ((float)(v)); }
};

template<> class sr_cast_class<double> {
public:
    template<typename T1>
    inline double operator()(T1 v) { return v; }
    inline double operator()(float v) { return ((double)(v)); }
};

template<int N2> class sr_cast_class<ap_int<N2> > {
public:
    template<int N1>
    inline ap_int<N2> operator()(ap_int<N1> v) {
        return ap_fixed<N2,N2,SC_TRN,SC_SAT>(v);
    }
    template<int N1>
    inline ap_int<N2> operator()(ap_uint<N1> v) {
        return ap_fixed<N2,N2,SC_TRN,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_int<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_int<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_int<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_int<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_int<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_int<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_int<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_int<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_int<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_int<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<int N2> class sr_cast_class<ap_uint<N2> > {
public:
    template<int N1>
    inline ap_uint<N2> operator()(ap_int<N1> v) {
        return ap_ufixed<N2,N2,SC_TRN,SC_SAT>(v);
    }
    template<int N1>
    inline ap_uint<N2> operator()(ap_uint<N1> v) {
        return ap_ufixed<N2,N2,SC_TRN,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_uint<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_uint<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,SC_RND,SC_SAT>(v);
    }
    inline ap_uint<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_uint<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_uint<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_uint<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_uint<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_uint<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_uint<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_uint<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<> class sr_cast_class<unsigned char> : public sr_cast_class<ap_uint<8> > {
public:
    using sr_cast_class<ap_uint<8> >::operator();
};

template<> class sr_cast_class<char> : public sr_cast_class<ap_int<8> > {
public:
    using sr_cast_class<ap_int<8> >::operator();
};

template<> class sr_cast_class<unsigned short> : public sr_cast_class<ap_uint<16> > {
public:
    using sr_cast_class<ap_uint<16> >::operator();
};

template<> class sr_cast_class<short> : public sr_cast_class<ap_int<16> > {
public:
    using sr_cast_class<ap_int<16> >::operator();
};

template<> class sr_cast_class<unsigned int> : public sr_cast_class<ap_uint<32> > {
public:
    using sr_cast_class<ap_uint<32> >::operator();
};

template<> class sr_cast_class<int> : public sr_cast_class<ap_int<32> > {
public:
    using sr_cast_class<ap_int<32> >::operator();
};

template<> class sr_cast_class<unsigned long long> : public sr_cast_class<ap_uint<64> > {
public:
    using sr_cast_class<ap_uint<64> >::operator();
};

template<> class sr_cast_class<long long> : public sr_cast_class<ap_int<64> > {
public:
    using sr_cast_class<ap_int<64> >::operator();
};

template<typename T2, typename T1> inline T2 sr_cast(T1 v)
{
    ::hls::sr_cast_class<T2> V;
    return V(v);
}

/* Video Format Types defined on 8-bit boundaries */
typedef struct{
  unsigned char Y;
  char UV;
}yuv422_8;

typedef struct{
  unsigned char Y;
  char U;
  char V;
}yuv444_8;

typedef struct{
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgb_8;

typedef yuv422_8 yuv420_8;

typedef struct{
  char A;
  unsigned char Y;
  char UV;
}yuva422_8;

typedef struct{
  char A;
  unsigned char Y;
  char U;
  char V;
}yuva444_8;

typedef struct{
  char A;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgba_8;

typedef struct{
  char AUV;
  unsigned char Y;
}yuva420_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char UV;
}yuvd422_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char U;
  char V;
}yuvd444_8;

typedef struct{
  unsigned char D;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgbd_8;

typedef yuvd422_8 yuvd420_8;

typedef struct{
  unsigned char CMY;
}bayer_8;

typedef struct{
  unsigned char Y;
}luma_8;

} // namespace hls




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 56 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/*
 * HLS Video Memory Partition Header File
 */




//#define __DEBUG__





namespace hls {

/* Template class of Window */
template<int ROWS, int COLS, typename T>
class Window {
public:
    Window() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( val, 2, "COMPLETE", 0, "");
    };

    /* Window main APIs */
    void shift_pixels_left();
    void shift_pixels_right();
    void shift_pixels_up();
    void shift_pixels_down();
    void insert_pixel(T value, int row, int col);
    void insert_row(T value[COLS], int row);
    void insert_top_row(T value[COLS]);
    void insert_bottom_row(T value[COLS]);
    void insert_col(T value[ROWS], int col);
    void insert_left_col(T value[ROWS]);
    void insert_right_col(T value[ROWS]);
    T& getval(int row, int col);
    T& operator ()(int row, int col);

    /* Back compatible APIs */
    void shift_left();
    void shift_right();
    void shift_up();
    void shift_down();
    void insert(T value, int row, int col);
    void insert_top(T value[COLS]);
    void insert_bottom(T value[COLS]);
    void insert_left(T value[ROWS]);
    void insert_right(T value[ROWS]);
    //T& getval(int row, int col);
    //T& operator ()(int row, int col);

    T val[ROWS][COLS];





};

/* Member functions of Window class */
/* Origin in upper-left point */
/*       0   1        C-2 C-1
 *     +---+---+-...-+---+---+
 *  0  |   |   |     |   |   |
 *     +---+---+-...-+---+---+
 *  1  |   |   |     |   |   |
 *     +---+---+-...-+---+---+
 *       ...     ...    ...
 *     +---+---+-...-+---+---+
 * R-2 |   |   |     |   |   |
 *     +---+---+-...-+---+---+
 * R-1 |   |   |     |   |   |
 *     +---+---+-...-+---+---+
 * 
 */

/* 
 * Window content shift left
 * Assumes new values will be placed in right column = COLS-1
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_left() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS-1; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i][j+1];
        }
    }
# 145 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* 
 * Window content shift right
 * Assumes new values will be placed in left column = 0
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_right() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = COLS-1; j > 0; j--) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i][j-1];
        }
    }
# 183 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* 
 * Window content shift up
 * Assumes new values will be placed in bottom row = ROWS-1
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_up() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i+1][j];
        }
    }
# 221 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* 
 * Window content shift down
 * Assumes new values will be placed in top row = 0
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_down() {
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i, j;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
            val[i][j] = val[i-1][j];
        }
    }
# 259 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert pixel
 * Inserts a new value at any location of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {
_ssdm_InlineSelf(0, "");
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 266, __PRETTY_FUNCTION__));







    val[row][col] = value;
# 291 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert row
 * Inserts a set of values in any row of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {_ssdm_SpecArrayDimSize(value,COLS);
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T j;
    for(j = 0; j < COLS; j++) {
_ssdm_Unroll(0,0,0, "");
        val[row][j] = value[j];
    }
# 326 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert top row
 * Inserts a set of values in top row = 0 of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {_ssdm_SpecArrayDimSize(value,COLS);
_ssdm_InlineSelf(0, "");







    insert_row(value, 0);
# 357 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert bottom row
 * Inserts a set of values in bottom row = ROWS-1 of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {_ssdm_SpecArrayDimSize(value,COLS);
_ssdm_InlineSelf(0, "");







    insert_row(value, ROWS-1);
# 388 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert column
 * Inserts a set of values in any column of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");







    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = value[i];
    }
# 423 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert left column
 * Inserts a set of values in left column = 0 of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");







    insert_col(value, 0);
# 454 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window insert right column
 * Inserts a set of values in right column = COLS-1 of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");







    insert_col(value, COLS-1);
# 485 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* Window getval
 * Returns the data value in the window at position (row,col)
 */
template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 492, __PRETTY_FUNCTION__));
    return val[row][col];
}

/* Window getval
 * Returns the data value in the window at position (row,col)
 */
template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}
# 526 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window shift left, while contents shift right 
 * Assumes new values will be placed in left column(=COLS-1)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_left() {
_ssdm_InlineSelf(0, "");
    shift_pixels_left(); // take upper-left point as origin
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window shift right, while contents shift left
 * Assumes new values will be placed in right column(=0)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_right() {
_ssdm_InlineSelf(0, "");
    shift_pixels_right(); // take upper-left point as origin
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window shift up, while contents shift down
 * Assumes new values will be placed in top row(=ROWS-1)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_up() {
_ssdm_InlineSelf(0, "");
    shift_pixels_up(); // take upper-left point as origin
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window shift down, while contents shift up
 * Assumes new values will be placed in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_down() {
_ssdm_InlineSelf(0, "");
    shift_pixels_down(); // take upper-left point as origin
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window insert
 * Inserts a new value at any location of the window
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert(T value, int row, int col) {
_ssdm_InlineSelf(0, "");
    insert_pixel(value, row, col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window insert top
 * Inserts a set of values in top row(=ROWS-1)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top(T value[COLS]) {_ssdm_SpecArrayDimSize(value,COLS);
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value);
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window insert bottom
 * Inserts a set of values in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {_ssdm_SpecArrayDimSize(value,COLS);
_ssdm_InlineSelf(0, "");
    insert_top_row(value);
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window insert left
 * Inserts a set of values in left column(=COLS-1)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");
    insert_right_col(value);
}

/* NOTE: 
 * Back compatible APIs, take bottom-right point as the origin
 * Window insert right
 * Inserts a set of values in right column(=0)
 */
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");
    insert_left_col(value);
}

/* Template class of Line Buffer */
template<int ROWS, int COLS, typename T, int RESHAPE=0>
class LineBuffer;

template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 0> {
public:
    LineBuffer() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
_ssdm_SpecDependence( val, 0, 0, -1, 0, 1);
_ssdm_SpecDependence( val, 0, 0, -1, 0, 0);
    };
    /* LineBuffer main APIs */
    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);

    /* Back compatible APIs */
    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);
    //T& getval(int row, int col);
    //T& operator ()(int row, int col);

    T val[ROWS][COLS];





};

/* Member functions of LineBuffer class */
/* Origin in upper-left point */
/*       0   1            C-2 C-1
 *     +---+---+-... ...-+---+---+
 *  0  |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 *  1  |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 *       ...     ... ...    ...
 *     +---+---+-... ...-+---+---+
 * R-2 |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 * R-1 |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 * 
 */

/* Member functions of LineBuffer class */

/* 
 * LineBuffer content shift down 
 * Assumes new values will be placed in top row = 0 
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_down(int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 678, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i-1][col];
    }
# 710 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* 
 * LineBuffer content shift up
 * Assumes new values will be placed in top row = ROWS-1
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_up(int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 718, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i+1][col];
    }
# 750 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer insert bottom row 
 * Inserts a new value in bottom row= ROWS-1 of the linebuffer
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 757, __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
# 782 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer insert top row 
 * Inserts a new value in top row=0 of the linebuffer
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 789, __PRETTY_FUNCTION__));







    val[0][col] = value;
# 814 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer get a column 
 * Get a column value of the linebuffer
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::get_col(T value[ROWS], int col) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 821, __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        value[i] = val[i][col];
    }
}

/* Line buffer getval
 * Returns the data value in the line buffer at position row, col
 */
template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 834, __PRETTY_FUNCTION__));
    return val[row][col];
}

/* Line buffer getval
 * Returns the data value in the line buffer at position row, col
 */
template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer shift down, while contents shift up
 * Assumes new values will be placed in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_down(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_down(col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer shift up, while contents shift down
 * Assumes new values will be placed in top row(=ROWS-1)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_up(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_up(col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer insert
 * Inserts a new value in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_top_row(value, col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer insert
 * Inserts a new value in top row(=ROWS-1)
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value, col);
}
# 906 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
/* Template class of Line Buffer (array reshaped) */
template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 1> {
public:
    LineBuffer() {
_ssdm_SpecArrayReshape( val, 1, "complete", 0, "");
_ssdm_SpecDependence( val, 0, 0, -1, 0, 1);
_ssdm_SpecDependence( val, 0, 0, -1, 0, 0);
    };
    /* LineBuffer main APIs */
    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);

    /* Back compatible APIs */
    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);
    //T& getval(int row, int col);
    //T& operator ()(int row, int col);

    T val[ROWS][COLS];





};

/* Member functions of LineBuffer_reshape class */

/* Origin in upper-left point */
/*       0   1            C-2 C-1
 *     +---+---+-... ...-+---+---+
 *  0  |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 *  1  |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 *       ...     ... ...    ...
 *     +---+---+-... ...-+---+---+
 * R-2 |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 * R-1 |   |   |         |   |   |
 *     +---+---+-... ...-+---+---+
 * 
 */

/* Member functions of LineBuffer_reshape class */

/* 
 * LineBuffer content shift down 
 * Assumes new values will be placed in top row = 0 
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_down(int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 966, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = ROWS-1; i > 0; i--) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i-1][col];
    }
# 998 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* 
 * LineBuffer content shift up
 * Assumes new values will be placed in top row = ROWS-1
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_up(int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 1006, __PRETTY_FUNCTION__));







    HLS_SIZE_T i;
    for(i = 0; i < ROWS-1; i++) {
_ssdm_Unroll(0,0,0, "");
        val[i][col] = val[i+1][col];
    }
# 1038 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer insert bottom row 
 * Inserts a new value in bottom row= ROWS-1 of the linebuffer
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 1045, __PRETTY_FUNCTION__));







    val[ROWS-1][col] = value;
# 1070 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer insert top row 
 * Inserts a new value in top row=0 of the linebuffer
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top_row(T value, int col) {
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 1077, __PRETTY_FUNCTION__));







    val[0][col] = value;
# 1102 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
}

/* LineBuffer get a column 
 * Get a column value of the linebuffer
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::get_col(T value[ROWS], int col) {_ssdm_SpecArrayDimSize(value,ROWS);
_ssdm_InlineSelf(0, "");
    ((col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 1109, __PRETTY_FUNCTION__));
    HLS_SIZE_T i;
    for(i = 0; i < ROWS; i++) {
_ssdm_Unroll(0,0,0, "");
        value[i] = val[i][col];
    }
}

/* Line buffer getval
 * Returns the data value in the line buffer at position row, col
 */
template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::getval(int row, int col) {
_ssdm_InlineSelf(0, "");
    ((row >= 0 && row < ROWS && col >= 0 && col < COLS) ? static_cast<void> (0) : __assert_fail ("row >= 0 && row < ROWS && col >= 0 && col < COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h", 1122, __PRETTY_FUNCTION__));
    return val[row][col];
}

/* Line buffer getval
 * Returns the data value in the line buffer at position row, col
 */
template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::operator ()(int row, int col) {
_ssdm_InlineSelf(0, "");
    return getval(row, col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer shift down, while contents shift up
 * Assumes new values will be placed in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_down(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_down(col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer shift up, while contents shift down
 * Assumes new values will be placed in top row(=ROWS-1)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_up(int col) {
_ssdm_InlineSelf(0, "");
    shift_pixels_up(col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer insert
 * Inserts a new value in bottom row(=0)
 */
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_top_row(value, col);
}

/* NOTE: 
 * Back compatible APIs, take bottom-left point as the origin
 * LineBuffer insert
 * Inserts a new value in top row(=ROWS-1)
 */
template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top(T value, int col) {
_ssdm_InlineSelf(0, "");
    insert_bottom_row(value, col);
}
# 1194 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_mem.h"
} // namespace hls
# 57 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:
// opencv/modules/core/include/opencv2/core/core.hpp

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Core Structures Header File
 */




namespace hls {

/* Template class of Point_ */
template<typename T>
class Point_ {
public:
    Point_();
    Point_(T _x, T _y);
    Point_(const Point_& pt);
    ~Point_();

    T x, y;
};

/* Member functions of Point_ class */
template<typename T> inline Point_<T>::Point_() {}
template<typename T> inline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}
template<typename T> inline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}
template<typename T> inline Point_<T>::~Point_() {}

typedef Point_<int> Point;


/* Template class of Size_ */
template<typename T>
class Size_ {
public:
    Size_();
    Size_(T _width, T _height);
    Size_(const Size_<T>& sz);
    Size_(const Point_<T>& pt);
    T area();
    ~Size_();

    T width, height;
};

/* Member functions of Size_ class */
template<typename T> inline Size_<T>::Size_() {}
template<typename T> inline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}
template<typename T> inline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}
template<typename T> inline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}
template<typename T> inline T Size_<T>::area() { return width*height; }
template<typename T> inline Size_<T>::~Size_() {}

typedef Size_<int> Size;


/* Template class of Rect_ */
template<typename T>
class Rect_ {
public:
    Rect_();
    Rect_(T _x, T _y, T _width, T _height);
    Rect_(const Rect_& rect);
    Rect_(const Point_<T>& pt, const Size_<T>& sz);
    T area();
    Size_<T> size();
    Point_<T> tl(); // top-left point(inside);
    Point_<T> tr(); // top-right point(outside);
    Point_<T> bl(); // bottom-left point(outside);
    Point_<T> br(); // bottom-right point(outside);
    bool bContains(const Point_<T>& pt);
    ~Rect_();

    T x, y, width, height;
};

/* Member functions of Rect_ class */
template<typename T> inline Rect_<T>::Rect_() {}
template<typename T> inline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}
template<typename T> inline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}
template<typename T> inline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz) : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}
template<typename T> inline T Rect_<T>::area() { return width*height; }
template<typename T> inline Size_<T> Rect_<T>::size() { return Size_<T>(width, height); }
template<typename T> inline Point_<T> Rect_<T>::tl() { return Point_<T>(x, y); }
template<typename T> inline Point_<T> Rect_<T>::tr() { return Point_<T>(x+width, y); }
template<typename T> inline Point_<T> Rect_<T>::bl() { return Point_<T>(x, y+height); }
template<typename T> inline Point_<T> Rect_<T>::br() { return Point_<T>(x+width, y+height); }
template<typename T> inline bool Rect_<T>::bContains(const Point_<T>& pt) { return (pt.x >= x && pt.x < x+width && pt.y >= y && pt.y < y+height); }
template<typename T> inline Rect_<T>::~Rect_() {}

typedef Rect_<int> Rect;


/* Template class of Scalar */
template<int N, typename T>
class Scalar {
public:
    Scalar() {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        ((N > 0) ? static_cast<void> (0) : __assert_fail ("N > 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 175, __PRETTY_FUNCTION__));
    }
    Scalar(T v0) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        ((N >= 1 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 1 && \"Scalar must have enough channels for constructor.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 179, __PRETTY_FUNCTION__));
        val[0] = v0;
    }
    Scalar(T v0, T v1) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        ((N >= 2 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 2 && \"Scalar must have enough channels for constructor.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 184, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1;
    }
    Scalar(T v0, T v1, T v2) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        ((N >= 3 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 3 && \"Scalar must have enough channels for constructor.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 189, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2;
    }
    Scalar(T v0, T v1, T v2, T v3) {
_ssdm_SpecArrayPartition( val, 1, "COMPLETE", 0, "");
        ((N >= 4 && "Scalar must have enough channels for constructor.") ? static_cast<void> (0) : __assert_fail ("N >= 4 && \"Scalar must have enough channels for constructor.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 194, __PRETTY_FUNCTION__));
        val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    }

    void operator = (T value);
    Scalar<N, T> operator + (T value);
    Scalar<N, T> operator + (Scalar<N, T> s);
    Scalar<N, T> operator - (T value);
    Scalar<N, T> operator - (Scalar<N, T> s);
    Scalar<N, T> operator * (T value);
    Scalar<N, T> operator * (Scalar<N, T> s);
    Scalar<N, T> operator / (T value);
    Scalar<N, T> operator / (Scalar<N, T> s);

    T val[N];
};

template<int N, typename T>
void Scalar<N, T>::operator = (T value) {
_ssdm_InlineSelf(0, "");
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        val[k] = value;
    }
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] + value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] + s.val[k];
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] - value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] - s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] * value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] * s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (T value) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] / value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (Scalar<N, T> s) {
_ssdm_InlineSelf(0, "");
    Scalar<N, T> res;
    for (int k = 0; k < N; k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = val[k] / s.val[k];
    }
    return res;
}


/* convertors for different pixel types*/

/* yuv422_8 and yuv420_8 */
template<typename T>
yuv422_8 Scalar_to_yuv422_8(Scalar<2, T> scl) {
_ssdm_InlineSelf(0, "");
    yuv422_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.UV = (char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuv422_8_to_Scalar(yuv422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.UV;
    return scl;
}

/* yuv444_8 */
template<typename T>
yuv444_8 Scalar_to_yuv444_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuv444_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.U = (char)scl.val[1];
    pix.V = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuv444_8_to_Scalar(yuv444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.U;
    scl.val[2] = (T)pix.V;
    return scl;
}

/* rgb_8 */
template<typename T>
rgb_8 Scalar_to_rgb_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    rgb_8 pix;
    pix.R = (unsigned char)scl.val[0];
    pix.G = (unsigned char)scl.val[1];
    pix.B = (unsigned char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> rgb_8_to_Scalar(rgb_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.R;
    scl.val[1] = (T)pix.G;
    scl.val[2] = (T)pix.B;
    return scl;
}

/* yuva422_8 */
template<typename T>
yuva422_8 Scalar_to_yuva422_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva422_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuva422_8_to_Scalar(yuva422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}

/* yuva444_8 */
template<typename T>
yuva444_8 Scalar_to_yuva444_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva444_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuva444_8_to_Scalar(yuva444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}

/* rgba_8 */
template<typename T>
rgba_8 Scalar_to_rgba_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    rgba_8 pix;
    pix.A = (char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgba_8_to_Scalar(rgba_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}

/* yuva420_8 */
template<typename T>
yuva420_8 Scalar_to_yuva420_8(Scalar<2, T> scl) {
_ssdm_InlineSelf(0, "");
    yuva420_8 pix;
    pix.AUV = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuva420_8_to_Scalar(yuva420_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<2, T> scl;
    scl.val[0] = (T)pix.AUV;
    scl.val[1] = (T)pix.Y;
    return scl;
}

/* yuvd422_8 and yuvd420_8*/
template<typename T>
yuvd422_8 Scalar_to_yuvd422_8(Scalar<3, T> scl) {
_ssdm_InlineSelf(0, "");
    yuvd422_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuvd422_8_to_Scalar(yuvd422_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<3, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}

/* yuvd444_8 */
template<typename T>
yuvd444_8 Scalar_to_yuvd444_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    yuvd444_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuvd444_8_to_Scalar(yuvd444_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}

/* rgbd_8 */
template<typename T>
rgbd_8 Scalar_to_rgbd_8(Scalar<4, T> scl) {
_ssdm_InlineSelf(0, "");
    rgbd_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgbd_8_to_Scalar(rgbd_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}

/* bayer_8 */
template<typename T>
bayer_8 Scalar_to_bayer_8(Scalar<1, T> scl) {
_ssdm_InlineSelf(0, "");
    bayer_8 pix;
    pix.CMY = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> bayer_8_to_Scalar(bayer_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.CMY;
    return scl;
}

/* luma_8 */
template<typename T>
luma_8 Scalar_to_luma_8(Scalar<1, T> scl) {
_ssdm_InlineSelf(0, "");
    luma_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> luma_8_to_Scalar(luma_8 pix) {
_ssdm_InlineSelf(0, "");
    Scalar<1, T> scl;
    scl.val[0] = (T)pix.Y;
    return scl;
}


/* Template class of Mat */
template<int ROWS, int COLS, int T> // T: type of Mat
class Mat {
public:
    Mat(); // default constructor
    Mat(int _rows, int _cols);
    Mat(Size _sz);

    void init(int _rows, int _cols);
    void assignto(Mat<ROWS, COLS, T>& mat); // do not copy image data

    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> read(); // data_stream array readout a Scalar
    void read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s); // data_stream array readout a Scalar
    void write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s); // data_stream array writein a Scalar
    void operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s); // data_stream array readout a Scalar
    void operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s); // data_stream array writein a Scalar
    bool empty(); // check stream

    const int type() const; // return matrix type
    const int depth() const; // return matrix depth
    const int channels() const; // return matrix channels

    HLS_SIZE_T rows, cols; // actual image size

    hls::stream<typename Type<((T) & ((1 << 11) - 1))>::name> data_stream[((((T) & ((512 - 1) << 11)) >> 11) + 1)]; // image data stream array
};

/* Member functions of Mat class */
template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat() {
_ssdm_InlineSelf(0, "");
    init(ROWS, COLS);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(int _rows, int _cols) {
_ssdm_InlineSelf(0, "");
    init(_rows, _cols);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(Size _sz) {
_ssdm_InlineSelf(0, "");
    init(_sz.height, _sz.width);
}

template<int ROWS, int COLS, int T>
inline void Mat<ROWS, COLS, T>::init(int _rows, int _cols) {
_ssdm_InlineSelf(0, "");
    (((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && "The number of rows and columns must be less than the template arguments.") ? static_cast<void> (0) : __assert_fail ("(_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && \"The number of rows and columns must be less than the template arguments.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 600, __PRETTY_FUNCTION__));

    rows = _rows;
    cols = _cols;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::assignto(Mat<ROWS, COLS, T>& mat) {
_ssdm_InlineSelf(0, "");
    mat.rows = rows;
    mat.cols = cols;
}

template<int ROWS, int COLS, int T>
Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> Mat<ROWS, COLS, T>::read() {
_ssdm_InlineSelf(0, "");
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scl;
    HLS_CHANNEL_T i;
    {
        // Force stream reads to be scheduled together.  This avoids
        // issues where scheduling forces them apart, which would
        // require buffers
        _ssdm_op_SpecProtocol(0, "");
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
            data_stream[i] >> scl.val[i];
        }
    }
    return scl;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
_ssdm_InlineSelf(0, "");
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
_ssdm_InlineSelf(0, "");
_ssdm_DataPack( data_stream, 0, 0, "", "", "");
    HLS_CHANNEL_T i;
    {
        // Force stream reads to be scheduled together.  This avoids
        // issues where scheduling forces them apart, which would
        // require buffers
_ssdm_op_SpecProtocol(0, "");
        for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
            data_stream[i] << s.val[i];
        }
    }
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
_ssdm_InlineSelf(0, "");
    s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
_ssdm_InlineSelf(0, "");
    write(s);
}

template<int ROWS, int COLS, int T>
bool Mat<ROWS, COLS, T>::empty() {
_ssdm_InlineSelf(0, "");
    unsigned char flag = 0;
    for (HLS_CHANNEL_T i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
_ssdm_Unroll(0,0,0, "");
        flag += (data_stream[i].empty()) ? 1 : 0;
    }
    ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1) || flag == 0 && "Some channels are empty but others are not.") ? static_cast<void> (0) : __assert_fail ("flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1) || flag == 0 && \"Some channels are empty but others are not.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_core.h", 674, __PRETTY_FUNCTION__));

    return ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) ? true : false);
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::type() const {
_ssdm_InlineSelf(0, "");
    return ((T) & ((1 << 11)*512 - 1));
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::depth() const {
_ssdm_InlineSelf(0, "");
    return ((T) & ((1 << 11) - 1));
}
template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::channels() const {
_ssdm_InlineSelf(0, "");
    return ((((T) & ((512 - 1) << 11)) >> 11) + 1);
}

} // namespace hls




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 58 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:
// opencv/modules/imgproc/src/filter.cpp

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Image Base Functions Header File
 */



//#include <limits.h>
//#include <float.h>

namespace hls {

enum {MORPH_RECT,MORPH_CROSS,MORPH_ELLIPSE};

class border_mode {
public:
    enum values {BORDER_CONSTANT,BORDER_REPLICATE,BORDER_REFLECT,BORDER_WRAP,BORDER_REFLECT_101};
    typedef void isBorderMode;
};

class BORDER_CONSTANT : public border_mode { public: static const values value = border_mode::BORDER_CONSTANT;
public :
inline __attribute__((always_inline)) BORDER_CONSTANT() { _ssdm_SpecConstant(&value); }
# 96 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};
class BORDER_REPLICATE : public border_mode { public: static const values value = border_mode::BORDER_REPLICATE;
public :
inline __attribute__((always_inline)) BORDER_REPLICATE() { _ssdm_SpecConstant(&value); }
# 97 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};
class BORDER_REFLECT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT;
public :
inline __attribute__((always_inline)) BORDER_REFLECT() { _ssdm_SpecConstant(&value); }
# 98 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};
class BORDER_WRAP : public border_mode { public: static const values value = border_mode::BORDER_WRAP;
public :
inline __attribute__((always_inline)) BORDER_WRAP() { _ssdm_SpecConstant(&value); }
# 99 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};
class BORDER_REFLECT_101 : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101;
public :
inline __attribute__((always_inline)) BORDER_REFLECT_101() { _ssdm_SpecConstant(&value); }
# 100 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};
class BORDER_DEFAULT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101;
public :
inline __attribute__((always_inline)) BORDER_DEFAULT() { _ssdm_SpecConstant(&value); }
# 101 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h"
};

//Parameters: 0---based coordinate of the extrapolated pixel along one of the axes, likely <0 or >= len
//len - length of the array along the corresponding axis
 /*
 Various border types, image boundaries are denoted with '|'
 * BORDER_REPLICATE:     aaaaaa|abcdefgh|hhhhhhh
 * BORDER_REFLECT:       fedcba|abcdefgh|hgfedcb
 * BORDER_REFLECT_101:   gfedcb|abcdefgh|gfedcba
 * BORDER_WRAP:          cdefgh|abcdefgh|abcdefg//no support
 * BORDER_CONSTANT:      iiiiii|abcdefgh|iiiiiii  with some specified 'i'
 */
static int borderInterpolate( int p, int len, int borderType )
{
    _ssdm_InlineSelf(0, "");
    ((borderType != BORDER_WRAP::value && "BORDER_WRAP is not supported.") ? static_cast<void> (0) : __assert_fail ("borderType != BORDER_WRAP::value && \"BORDER_WRAP is not supported.\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h", 116, __PRETTY_FUNCTION__));

    if( p >= 0 && p < len )
        return p;
    else if( borderType == BORDER_REPLICATE::value )
        p = p < 0 ? 0 : len - 1;
    else if( borderType == BORDER_REFLECT::value)
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {
            p=-p-1;
        }
        if( p >= len )
        {
            p=2*len-p-1;
        }
    }
    else if(borderType == BORDER_REFLECT_101::value )
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {

            p=-p;
        }
        if( p >= len )
        {

            p=2*len-p-2;
        }
    }

    else if( borderType == BORDER_CONSTANT::value )
        p = -1;
    return p;
}
// Make sure the anchor in the right location
template <typename anchor_T,typename kernel_T>
inline void normalizeAnchor(
        hls::Point_<anchor_T> &anchor,
        hls::Size_<kernel_T> kernel_size)
{
_ssdm_InlineSelf(0, "");
    if(anchor.x==-1)
        anchor.x=kernel_size.width/2;
    if(anchor.y==-1)
        anchor.y=kernel_size.height/2;

    ((anchor.x>=0) ? static_cast<void> (0) : __assert_fail ("anchor.x>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h", 167, __PRETTY_FUNCTION__));
    ((anchor.x<=kernel_size.width-1) ? static_cast<void> (0) : __assert_fail ("anchor.x<=kernel_size.width-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h", 168, __PRETTY_FUNCTION__));
    ((anchor.y>=0) ? static_cast<void> (0) : __assert_fail ("anchor.y>=0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h", 169, __PRETTY_FUNCTION__));
    ((anchor.y<=kernel_size.height-1) ? static_cast<void> (0) : __assert_fail ("anchor.y<=kernel_size.height-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgbase.h", 170, __PRETTY_FUNCTION__));
}
template<int SRC_T,int ROWS,int COLS>
void DuplicateImageN(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, SRC_T> _dst[],
  int num
                )
{
    int cols=_src.cols;
    int rows=_src.rows;
 loop_size: for(int k=0;k<num;k++) {
        _dst[k].rows=rows;
        _dst[k].cols=cols;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for(int i= 0;i<rows;i++)
 {
_ssdm_op_SpecLoopTripCount(20, 2000, 1010, "");
    loop_width: for (int j= 0;j<cols;j++)
_ssdm_op_SpecLoopTripCount(20, 2000, 1010, "");
  {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                        _src >> s;
                        for(int k=0;k<num;k++)
                        _dst[k] << s;
                }
        }
}
}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 59 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

/*
 * HLS Video I/O Function Header File
 */






namespace hls {






// Unpack a AXI video stream into a hls::Mat<> object

template<int W, int ROWS, int COLS, int T>
int AXIvideo2Mat(stream<ap_axiu<W,1,1,1> >& AXI_video_strm,
                 Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    ap_axiu<W,1,1,1> axi;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    // std::cout << W << " " << depth << " " << HLS_MAT_CN(T) << "\n";
    ((W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 59, __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 62, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 63, __PRETTY_FUNCTION__));
    bool sof = 0;
 loop_wait_for_start: while (!sof) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_op_SpecLoopTripCount(0, 0, 0, "");
        AXI_video_strm >> axi;
        sof = axi.user.to_int();
    }
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
        bool eol = 0;
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if (sof || eol) {
                sof = 0;
                eol = axi.last.to_int();
            } else {
                // If we didn't reach EOL, then read the next pixel
                AXI_video_strm >> axi;
                eol = axi.last.to_int();
                bool user = axi.user.to_int();
                if(user) {
                    res |= (1 << 0);
                }
            }
            if (eol && (j != cols-1)) {
                res |= (1 << 0);
            }
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXIGetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    loop_wait_for_eol: while (!eol) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_op_SpecLoopTripCount(0, 0, 0, "");
            // Keep reading until we get to EOL
            AXI_video_strm >> axi;
            eol = axi.last.to_int();
            res |= (1 << 1);
        }
    }
    return res;
}

//Pack the data of a hls::Mat<> object into an AXI Video stream

template<int W, int ROWS, int COLS, int T>
int Mat2AXIvideo(Mat<ROWS, COLS, T>& img,
                 stream<ap_axiu<W,1,1,1> >& AXI_video_strm)
{
    int res = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    ap_axiu<W,1,1,1> axi;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    // std::cout << W << " " << depth << " " << HLS_MAT_CN(T) << "\n";
    ((W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 119, __PRETTY_FUNCTION__));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 122, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 123, __PRETTY_FUNCTION__));
    bool sof = 1;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if (sof) {
                axi.user = 1;
                sof = 0;
            } else {
                axi.user = 0;
            }
            if (j == (cols-1)) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }
            img >> pix;
            axi.data = -1;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXISetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            axi.keep = -1;
            AXI_video_strm << axi;
        }
    }
    return res;
}


// Read data from AXI-MM, store it to hls::Mat<>

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((cols <= rowStride) ? static_cast<void> (0) : __assert_fail ("cols <= rowStride", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 162, __PRETTY_FUNCTION__));
    ((rowStride <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("rowStride <= FB_COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 163, __PRETTY_FUNCTION__));
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 164, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 165, __PRETTY_FUNCTION__));
    ((COLS <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("COLS <= FB_COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 166, __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    ((fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 170, __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            FB_T fb_pix = fb[row*rowStride+col];
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            AXISetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
                AXIGetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS],
              Mat<ROWS, COLS, T>& img)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS],
             Mat<ROWS, COLS, T>& img)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, rowStride, img);
    return res;
}

// Read data from hls::Mat<>, store it to AXI-MM

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    ((cols <= rowStride) ? static_cast<void> (0) : __assert_fail ("cols <= rowStride", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 228, __PRETTY_FUNCTION__));
    ((rowStride <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("rowStride <= FB_COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 229, __PRETTY_FUNCTION__));
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 230, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 231, __PRETTY_FUNCTION__));
    ((COLS <= FB_COLS) ? static_cast<void> (0) : __assert_fail ("COLS <= FB_COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 232, __PRETTY_FUNCTION__));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    ((fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel") ? static_cast<void> (0) : __assert_fail ("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_io.h", 236, __PRETTY_FUNCTION__));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        for (HLS_SIZE_T col = 0; col < cols; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            img >> pix;
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
                AXISetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            FB_T fb_pix;
            AXIGetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
            fb[row*rowStride+col] = fb_pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
              FB_T fb[ROWS*FB_COLS])
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS])
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{_ssdm_SpecArrayDimSize(fb,ROWS*FB_COLS);
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, rowStride);
    return res;
}

} // namespace hls



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 60 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2

# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:
// opencv/modules/core/src/arithm.cpp

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Arithmetic Functions Header File
 */
# 88 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h"
namespace hls {
# 111 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h"
typedef ap_fixed<64,32,SC_RND> _AP_T;
typedef unsigned long long _SUM_T;

class kernel_min {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        //dst = __HLS_MIN(src1, src2);
        if(src1<src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_max {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        //dst = __HLS_MAX(src1, src2);
        if(src1>src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_absdiff {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename pixel_op_type<SRC1_T>::T src1_cast = src1;
        typename pixel_op_type<SRC2_T>::T src2_cast = src2;
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T >::ADD_T TEMP_TYPE;
        TEMP_TYPE diff = src1_cast-src2_cast;
        TEMP_TYPE mdiff = src2_cast-src1_cast;
        dst = sr_cast<DST_T>((src1_cast > src2_cast) ? diff : mdiff);
    }
};

template<typename P_T, typename SRC1_T, typename SRC2_T, typename DST_T>
void kernel_and_apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst) {
_ssdm_InlineSelf(0, "");
    dst = (sr_cast<DST_T>(src1)) & (sr_cast<DST_T>(src2)); // not work with float & float
}

template<typename P_T>
void kernel_and_apply(float& src1, float& src2, float& dst) {
_ssdm_InlineSelf(0, "");
    fp_struct<float> src1_fp(src1);
    fp_struct<float> src2_fp(src2);
    unsigned int dst_tmp = src1_fp.to_int() & src2_fp.to_int();
    fp_struct<float> dst_fp(dst_tmp);
    dst = dst_fp.to_float();
}

class kernel_and {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        kernel_and_apply<P_T>(src1, src2, dst);
    }
};

class kernel_not {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        dst = ~(sr_cast<DST_T>(src));
    }
};

class kernel_set {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        dst = sr_cast<DST_T>(val);
    }
};

class kernel_scale {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T;
        typedef typename x_traits<typename pixel_op_type<P_T>::T, MULT_T>::ADD_T ADD_T;
        MULT_T mult_t=(typename pixel_op_type<SRC1_T>::T)src * (typename pixel_op_type<P_T>::T)p0;
        ADD_T sum_t=mult_t + (typename pixel_op_type<P_T>::T)p1;
        //dst = sr_cast<DST_T>(p0*src+p1); 
        dst = sr_cast<DST_T>(sum_t);
    }
};

class kernel_add {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::ADD_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 + (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_sub {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 - (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_subR {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC2_T>::T)src2 - (typename pixel_op_type<SRC1_T>::T)src1;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_mul {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T, typename P2_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P2_T p1=0, P2_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T MULT_T;
        MULT_T t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;
        typename x_traits<MULT_T, typename pixel_op_type<P_T>::T>::MULT_T t2 = t1 * (typename pixel_op_type<P_T>::T)p0;
        //dst = sr_cast<DST_T>(p0*src1*src2); 
        dst = sr_cast<DST_T>(t2);
    }
};

class kernel_mul2 {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;
        //dst = sr_cast<DST_T>(src1*src2); 
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_addWeighted {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T1;
        MULT_T1 t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<P_T>::T)p0;
        typedef typename x_traits<typename pixel_op_type<SRC2_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T2;
        MULT_T2 t2 = (typename pixel_op_type<SRC2_T>::T)src2 * (typename pixel_op_type<P_T>::T)p1;
        typedef typename x_traits<MULT_T1, MULT_T2>::ADD_T ADD_T;
        ADD_T sum = t1 + t2 + p2;
        //dst = sr_cast<DST_T>(p0*src1+p1*src2+p2); 
        dst = sr_cast<DST_T>(sum);
    }
};

class kernel_cmp {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
_ssdm_InlineSelf(0, "");
        switch (p0) {
            case 0:
            dst = (src1==src2 ? 255 : 0);
            break;
            case 1:
            dst = (src1 >src2 ? 255 : 0);
            break;
            case 2:
            dst = (src1>=src2 ? 255 : 0);
            break;
            case 3:
            dst = (src1 <src2 ? 255 : 0);
            break;
            case 4:
            dst = (src1<=src2 ? 255 : 0);
            break;
            case 5:
            dst = (src1!=src2 ? 255 : 0);
            break;
            default:
            break;
        }
    }
};

class kernel_sum {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
_ssdm_InlineSelf(0, "");
        sum = sum+(_SUM_T)s;
    }
};

class kernel_avgsdv {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
_ssdm_InlineSelf(0, "");
        sum=sum+ (_SUM_T)s;
        sqsum=sqsum+ ((_SUM_T)s*(_SUM_T)s);
    }
};


// Min, Max, And(no mask), AbsDiff, Mul, AddWeighted, Cmp
template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 350, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 351, __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name > d;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src1 >> s1;
            src2 >> s2;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s1.val[k], s2.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}

// And (mask)
template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 381, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 382, __PRETTY_FUNCTION__));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src1 >> s1;
            src2 >> s2;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {
                    opr.template apply(s1.val[k], s2.val[k], d.val[k]);
                }
            }
            dst << d;
        }
    }
}

// Set, Not, MinS, MaxS, Scale, CmpS
// AddS, SubS, SubRS (no-mask)
template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 421, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 422, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                // std::cout << "in  @ " << i << "," << j << " " << s.val[k] << "\n";
                opr.template apply(s.val[k], _s.val[k], d.val[k], p0, p1, p2);
                // std::cout << "out @ " << i << "," << j << " " << d.val[k] << "\n";
            }
            dst << d;
        }
    }
}

// Set (no src)
template<typename KERNEL, int ROWS, int COLS, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 454, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 455, __PRETTY_FUNCTION__));
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            _T s = 0;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s, _s.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}

// AddS, SubS, SubRS (mask)
template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 484, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 485, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {
                    //std::cout << "in  @ " << i << "," << j << " " << s.val[k] << "\n";
                    opr.template apply(s.val[k], _s.val[k], d.val[k]);
                    //std::cout << "out @ " << i << "," << j << " " << d.val[k] << "\n";
                }
            }
            dst << d;
        }
    }
}

// Sum, Mean, Avg, AvgSdv (no mask)
template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 522, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 523, __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
            }
        }
    }
}

// Sum, Mean, Avg, AvgSdv (mask)
template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum,
            int& ncount,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 554, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 555, __PRETTY_FUNCTION__));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    ncount = 0;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            if (m.val[0]) {
            loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
                }
                ncount++;
            }
        }
    }
}

// Reduce 
template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void reduce_opr(
        Mat<ROWS, COLS, SRC_T> &src,
        Mat<DST_ROWS, DST_COLS, DST_T> &dst,
        int dim,
        int op=1)
{
    LineBuffer<1,DST_COLS,INTER_SUM_T> dst_buffer[((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)];
_ssdm_SpecArrayPartition( dst_buffer, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( dst_buffer, 2, "COMPLETE", 0, "");
    HLS_SIZE_T rows=src.rows;
    HLS_SIZE_T cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 593, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 594, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),INTER_SUM_T> internal;
 loop_init: for(HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        internal.val[k]=0;
    }
 loop_height: for(HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
        loop_channels: for(HLS_CHANNEL_T k= 0;k< ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_val;
                src.data_stream[k]>>src_val;
                if(dim==0) {
                    if(i!=0) {
                        internal.val[k]=(INTER_SUM_T)dst_buffer[k].val[i][0];
                    } else {
                        if(op==1||op==2)
                            internal.val[k]=0;
                        else if(op==3||op==4)
                            internal.val[k]=src_val;
                    }
                }
                switch (op) {
                    case 1:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 2:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 3:
                    internal.val[k]=(internal.val[k]>(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
                    case 4:
                    internal.val[k]=(internal.val[k]<(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
  }
                if(dim==0) {
                    if(i==rows-1) {
                        if(op==2)
                            dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/rows;
                        else
                            dst.data_stream[k]<< (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    } else {
                        dst_buffer[k].val[i][0]=internal.val[k];
                    }
                }
            }
            if(dim==1&&j==cols-1) {
            loop_output: for(HLS_CHANNEL_T k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                    if(op==2) {
                        dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/cols;
                    } else {
                        dst.data_stream[k] << (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    }
                    internal.val[k]=0;
                }
            }
        }
    }
}


/* video arithmetic functions. */
template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Min(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 666, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 669, __PRETTY_FUNCTION__));


    arithm_pro<kernel_min>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Max(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 681, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 684, __PRETTY_FUNCTION__));


    arithm_pro<kernel_max>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MinS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 695, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 697, __PRETTY_FUNCTION__));

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_min>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MaxS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 713, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 715, __PRETTY_FUNCTION__));

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_max>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 731, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 733, __PRETTY_FUNCTION__));

    arithm_pro<kernel_add>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 746, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 748, __PRETTY_FUNCTION__));

    arithm_pro<kernel_add>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 759, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 761, __PRETTY_FUNCTION__));

    arithm_pro<kernel_sub>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 774, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 776, __PRETTY_FUNCTION__));

    arithm_pro<kernel_sub>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 787, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 789, __PRETTY_FUNCTION__));

    arithm_pro<kernel_subR>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 802, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 804, __PRETTY_FUNCTION__));

    arithm_pro<kernel_subR>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 817, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 820, __PRETTY_FUNCTION__));


    arithm_pro<kernel_mul>(src1, src2, dst, scale, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 832, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 835, __PRETTY_FUNCTION__));


    arithm_pro<kernel_mul2>(src1, src2, dst, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void AddWeighted(
        Mat<ROWS, COLS, SRC1_T>& src1,
        P_T alpha,
        Mat<ROWS, COLS, SRC2_T>& src2,
        P_T beta,
        P_T gamma,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 850, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 853, __PRETTY_FUNCTION__));


    arithm_pro<kernel_addWeighted>(src1, src2, dst, alpha, beta, gamma);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Scale(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale=1.0,
        P_T shift=0.0)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 865, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 867, __PRETTY_FUNCTION__));

    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_scale>(src, scl, dst, scale, shift, (P_T)0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void Set(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 879, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 881, __PRETTY_FUNCTION__));

    arithm_pro<kernel_set>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, typename _T, int DST_T>
void Set(
        Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    arithm_pro<kernel_set>(scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Zero(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(src, s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int DST_T>
void Zero(
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void AbsDiff(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 926, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 929, __PRETTY_FUNCTION__));


    arithm_pro<kernel_absdiff>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Not(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 939, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 941, __PRETTY_FUNCTION__));

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_not>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Cmp(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 955, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 958, __PRETTY_FUNCTION__));


    arithm_pro<kernel_cmp>(src1, src2, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename P_T, int DST_T>
void CmpS(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T value,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 970, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 972, __PRETTY_FUNCTION__));

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), P_T> scl;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        scl.val[k] = (value);
    }
    arithm_pro<kernel_cmp>(src, scl, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 989, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 992, __PRETTY_FUNCTION__));


    arithm_pro<kernel_and>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1006, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1009, __PRETTY_FUNCTION__));


    arithm_pro<kernel_and>(src1, src2, dst, mask, dst_ref);
}

template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void Reduce(
         Mat<ROWS, COLS, SRC_T> &src,
         Mat<DST_ROWS, DST_COLS, DST_T> &dst,
         int dim,
         int op=1)
{
    reduce_opr<INTER_SUM_T>(src, dst, dim, op);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Range(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T start,
        P_T end)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1031, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1033, __PRETTY_FUNCTION__));

    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1035, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1038, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1039, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _AP_T _dis = end-start;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                d.val[k] = _dis*(i*cols+j)/(rows*cols);
            }
            dst << d;
        }
    }
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Sum(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> res;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        res.val[k] = sr_cast<DST_T>(sum.val[k]);
    }
    return res;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum, ncount, mask);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
_ssdm_Unroll(0,0,0, "");
        _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src);
    return avg.val[0];
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src, mask);
    return avg.val[0];
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    ap_fixed<64,40,SC_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    ap_fixed<64,40,SC_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum, ncount, mask);
    for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<typename S_T>
class MinMaxLoc_opr
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
_ssdm_InlineSelf(0, "");
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1178, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1181, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1182, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            if (s.val[0] < _min_val) {
                _min_val = s.val[0];
                min_loc.x = j;
                min_loc.y = i;
            }
            if (s.val[0] > _max_val) {
                _max_val = s.val[0];
                max_loc.x = j;
                max_loc.y = i;
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
_ssdm_InlineSelf(0, "");
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1219, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1222, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1223, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            if (m.val[0]) {
                if (s.val[0] < (_min_val)) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
                if (s.val[0] > (_max_val)) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template< >
class MinMaxLoc_opr<float>
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
_ssdm_InlineSelf(0, "");
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1269, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1272, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1273, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (min_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() > min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() < min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }

            if (max_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() < max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() > max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
_ssdm_InlineSelf(0, "");
    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1332, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1335, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1336, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            mask >> m;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (m.val[0]) {
                if (min_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() > min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() < min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }

                if (max_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() < max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() > max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc, mask);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Threshold(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name thresh,
        typename Type<((DST_T) & ((1 << 11) - 1))>::name maxval,
        int thresh_type)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1422, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1424, __PRETTY_FUNCTION__));

    (("Source must be single channel image" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source must be single channel image\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1426, __PRETTY_FUNCTION__));

    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1429, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1430, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _thresh = sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(thresh);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _maxval = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(maxval);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _zero = 0;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                switch (thresh_type) {
                    case 0:
                    d.val[k] = (s.val[k] > _thresh) ? (_maxval) : _zero;
                    break;
                    case 1:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (_maxval);
                    break;
                    case 2:
                    d.val[k] = (s.val[k] > _thresh) ? (_thresh) : s.val[k];
                    break;
                    case 3:
                    d.val[k] = (s.val[k] > _thresh) ? (s.val[k]) : _zero;
                    break;
                    case 4:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (s.val[k]);
                    break;
                    default:
                    d.val[k] = s.val[k];
                    break;
                }
            }
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T>
void Consume(
        Mat<ROWS, COLS, SRC_T>& src)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1474, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1475, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Duplicate(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1493, __PRETTY_FUNCTION__));

    (("Source and destination images must have same sizes" && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1496, __PRETTY_FUNCTION__));


    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1499, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1500, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            dst1 << s;
            dst2 << s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 2 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 2 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1521, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1524, __PRETTY_FUNCTION__));


    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1529, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1530, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 3 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 3 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1551, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1555, __PRETTY_FUNCTION__));



    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1560, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1561, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2,
        Mat<ROWS, COLS, DST_T>& dst3)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 4 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 4 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1584, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols) && ((src).rows == (dst3).rows && (src).cols == (dst3).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst0).rows && (src).cols == (dst0).cols) && ((src).rows == (dst1).rows && (src).cols == (dst1).cols) && ((src).rows == (dst2).rows && (src).cols == (dst2).cols) && ((src).rows == (dst3).rows && (src).cols == (dst3).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1589, __PRETTY_FUNCTION__));




    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1594, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1595, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
            d.val[0] = s.val[3]; dst3 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 2) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 2", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1617, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1620, __PRETTY_FUNCTION__));


    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1625, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1626, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 3) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 3", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1647, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1651, __PRETTY_FUNCTION__));



    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1656, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1657, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, SRC_T>& src3,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have required number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 4) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have required number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == 1 && ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) == 4", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1680, __PRETTY_FUNCTION__));


    (("Source and destination images must have same sizes" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols) && ((src3).rows == (dst).rows && (src3).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src0).rows == (dst).rows && (src0).cols == (dst).cols) && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols) && ((src3).rows == (dst).rows && (src3).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1685, __PRETTY_FUNCTION__));




    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1690, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_arithm.h", 1691, __PRETTY_FUNCTION__));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            src3 >> s; d.val[3] = s.val[0];
            dst << d;
        }
    }
}

} // namespace hls




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 62 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:
// opencv/modules/imgproc/src/morph.cpp

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Image Processing Functions Header File
 */
# 88 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
//#include <cmath>
//#include <cstdlib>

namespace hls {

inline void assert_cn(int SRC_T,int DST_T)
{
    (("Source and destination images must have same number of channels" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 96, __PRETTY_FUNCTION__));

}
inline void assert_cn(int SRC1_T,int SRC2_T,int DST_T)
{
    (("Source and destination images must have same number of channels" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same number of channels\" && ((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1) && ((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1) == ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 102, __PRETTY_FUNCTION__));


}
template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
inline void assert_size(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 112, __PRETTY_FUNCTION__));


}
template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
inline void assert_cn_size(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
    assert_cn(SRC1_T,SRC2_T,DST_T);
    (("Source and destination images must have same sizes" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src1).rows == (dst).rows && (src1).cols == (dst).cols) && ((src2).rows == (dst).rows && (src2).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 123, __PRETTY_FUNCTION__));


}
template<int ROWS, int COLS, int SRC_T, int DST_T>
inline void assert_size(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 131, __PRETTY_FUNCTION__));

}
template<int ROWS, int COLS, int SRC_T, int DST_T>
inline void assert_cn_size(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    assert_cn(SRC_T,DST_T);
    (("Source and destination images must have same sizes" && ((src).rows == (dst).rows && (src).cols == (dst).cols)) ? static_cast<void> (0) : __assert_fail ("\"Source and destination images must have same sizes\" && ((src).rows == (dst).rows && (src).cols == (dst).cols)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 140, __PRETTY_FUNCTION__));

}
class erode_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
_ssdm_InlineSelf(0, "");
        out = hls::numeric_limits<DST_T>::max();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp<out)
                        out=temp;
                }
            }
        }
    }
};

class dilate_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
_ssdm_InlineSelf(0, "");
    out = hls::numeric_limits<DST_T>::min();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp>out)
                        out=temp;
                }
            }
        }
    }
};

// For integer types, use reasonable ap_fixed defaults.
template <typename SRC_T, typename FILTER_T, int SIZE=0>
struct filter2d_traits {
    typedef typename fixed_type<SRC_T>::T SRC_CAST_T;
    typedef typename fixed_type<FILTER_T>::T FILTER_CAST_T;
    typedef typename x_traits<SRC_CAST_T, FILTER_CAST_T >::MULT_T MULT_T;
    typedef typename x_traits_d<MULT_T, SIZE>::ACCUM_T ACCUM_T;
    typedef typename x_traits<ACCUM_T, ap_fixed<1,1> >::MULT_T TEMP_T;
};
// For floating point types, we can make some assumptions to get II=1 accumulation.
template <int SIZE , int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
struct filter2d_traits<float, ap_fixed<W, I, _AP_Q, _AP_O>, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE, int W>
struct filter2d_traits<float, ap_int<W>, SIZE> {
    typedef float SRC_CAST_T;
    typedef ap_int<W> FILTER_CAST_T;
    typedef float MULT_T;
    typedef float ACCUM_T;
    typedef float TEMP_T;
};
template <int SIZE>
struct filter2d_traits<unsigned char,float, SIZE> {
    typedef unsigned char SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, unsigned char, SIZE> {
    typedef float SRC_CAST_T;
    typedef unsigned char FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, float, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, double, SIZE> {
    typedef double SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, double, SIZE> {
    typedef float SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, float, SIZE> {
    typedef double SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,SC_RND> MULT_T;
    typedef ap_fixed<64,32,SC_RND> ACCUM_T;
    typedef ap_fixed<64,32,SC_RND> TEMP_T;
};

class filter2d_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out,
               const bool cast)
    {
_ssdm_InlineSelf(0, "");
     typename filter2d_traits<SRC_T, FILTER_T>::SRC_CAST_T src_v;
     typename filter2d_traits<SRC_T, FILTER_T>::FILTER_CAST_T filter_v;
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
        typename filter2d_traits<SRC_T, FILTER_T>::MULT_T temp=0;
        loop_height: for(int m = 0; m < F_HEIGHT; m++) {
            loop_width: for(int n = 0; n < F_WIDTH; n++) {
                src_v = _kernel_pixel.val[F_HEIGHT-m-1][F_WIDTH-1-n];
                filter_v = _kernel_filter.val[m][n];
                temp = src_v * filter_v;
                sum = sum + temp;
            }
        }
        out=sum;
    }

    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out)
    {
_ssdm_InlineSelf(0, "");
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
     apply(_kernel_filter,_kernel_pixel,sum,true);
     out=sr_cast<DST_T>(sum);
    }
};

template <typename SRC_T,typename SIZE_T,typename POINT_T,int HEIGHT,int WIDTH>
void getStructuringElement(
        int shape,
        Size_<SIZE_T> ksize,
        Point_<POINT_T> anchor,
        Window<HEIGHT,WIDTH,SRC_T> &result)
{
_ssdm_InlineSelf(0, "");
    int i, j;
    int r = 0, c = 0;
    ap_fixed<31,11,SC_RND> inv_r2 = 0;

    if( ksize.width==1&&ksize.height == 1 )
        shape = MORPH_RECT;

    if( shape == MORPH_ELLIPSE )
    {
        r = ksize.height/2;
        c = ksize.width/2;
        if(r!=0)
        {
            inv_r2 =(ap_fixed<31,11,SC_RND>) 1/(r*r) ;
        }
        else
            inv_r2=0;
    }
 loop_height: for( i = 0; i < ksize.height; i++ )
    {
        int j1 = 0, j2 = 0;
        if( shape == MORPH_RECT || (shape ==MORPH_CROSS && i == anchor.y) )
            j2 = ksize.width;
        else if( shape == MORPH_CROSS ) {
            j1 = anchor.x;
            j2 = j1 + 1;
        } else
        {
            int dy = i - r;
            if( abs(dy) <= r )
            {
                ap_fixed<12,12,SC_RND> dxx = (c*::hls::sqrt(((r-dy)*(r+dy))*inv_r2));///////saturate_cast<int>  nearly rand
                int dx=dxx;
                j1 = (c - dx)> 0?( c - dx):0;
                j2 = (c + dx + 1)< ksize.width?(c + dx + 1):ksize.width;
            }
        }
    loop_width: for( j = 0; j < ksize.width; j++ ) {
            if(shape == MORPH_RECT || (j >= j1 && j < j2)) {
                result.val[i][j] = 1;
            } else {
                result.val[i][j] = 0;
            }
        }
    }
}


template<typename P_T,typename W_T,int W_HEIGHT, int W_WIDTH,typename BUF_T,int BUF_HEIGHT,int BUF_WIDTH >
void fill_pixelkernel(
        LineBuffer<BUF_HEIGHT,BUF_WIDTH,BUF_T> &col_buf,
        Window<W_HEIGHT,W_WIDTH,W_T> &kernel,
        Point_<P_T> curp,
        int borderType, int ref,
        int imgheight,int constval=0, bool forceconst = false)
{
_ssdm_InlineSelf(0, "");
 loop_fill: for(int buf_row= 0;buf_row<W_HEIGHT;buf_row++)
    {
        int locy;
        int t = borderInterpolate(curp.y,imgheight,borderType);
        locy = ref - t;
        curp.y--;
        kernel.val[buf_row][0] = (t < 0 || forceconst) ? constval : col_buf.val[locy][0];
    }
}

template<typename OPR_KERNEL, typename BORDERMODE>
class filter_opr {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
    {
_ssdm_InlineSelf(0, "");
    OPR_KERNEL fk_opr;
    // The main processing window
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // The main line buffer
    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // A small buffer keeping a few pixels from the line
    // buffer, so that we can complete right borders correctly.
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // Temporary storage for reading from the line buffers.
    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 405, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 406, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 407, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 408, __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    ((anchor.x >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.x >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 423, __PRETTY_FUNCTION__));
    ((anchor.x <= K_WIDTH-1) ? static_cast<void> (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 424, __PRETTY_FUNCTION__));
    ((anchor.y >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.y >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 425, __PRETTY_FUNCTION__));
    ((anchor.y <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 426, __PRETTY_FUNCTION__));

    int start_row; // start to output(actually output 0 on i=start_row+1)
    int row_index; // the index in k_buf for src input, determine k_buf height by 2*K_HEIGHT-row_index
    int col_index; // determine the right_border_buf width by col_index-0
    int stop_row; // stop shifting down the linebuffer
    get_parameters<K_HEIGHT, K_WIDTH>(rows, anchor, start_row, stop_row, row_index, col_index);
    ((start_row >= 0) ? static_cast<void> (0) : __assert_fail ("start_row >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 433, __PRETTY_FUNCTION__));
    ((start_row <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("start_row <= K_HEIGHT-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 434, __PRETTY_FUNCTION__));

    int heightloop= rows+start_row+1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
// This DEPENDENCE pragma is necessary because the border mode handling is not affine.
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    ImagLoc.x=j-anchor.x;
                    int x = borderInterpolate(ImagLoc.x, cols, BORDERMODE::value);
                    ((x < cols) ? static_cast<void> (0) : __assert_fail ("x < cols", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 451, __PRETTY_FUNCTION__));

                    // Fetch the column from the line buffer or right_border_buf to shift into the window.
                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                        if((i<stop_row) && (ImagLoc.x>=cols)) {
                            col_buf[k](buf_row,0)=right_border_buf[k](buf_row,cols-1-x);
                        } else {
                            col_buf[k](buf_row,0)=k_buf[k](K_HEIGHT+buf_row,x);
                        }
                    }

                    // Read in image stream and fill in k_buf with two different ways
                    if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                        if(i<=start_row) { // top border
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                            _src.data_stream[k] >> src_temp;
                            for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                                int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                                if(y==i) {
                                    k_buf[k](buf_row,x)=src_temp;
                                }
                            }
                        } else if(i<stop_row) {
                            // back up right border pixels with a window
                            //right_border_buf[k].shift_right();
                            for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                                for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                    if(buf_col <= col_index) {
                                         right_border_buf[k](buf_row,buf_col)=right_border_buf[k](buf_row,buf_col-1);
                                    }
                                }
                                right_border_buf[k](buf_row,0)=col_buf[k](buf_row,0);
                            }
                         //k_buf[k].shift_down(x);
                            for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                                if(buf_row>row_index) {
                                    k_buf[k](buf_row,x)=k_buf[k](buf_row-1,x);
                                }
                            }
                            if(i<rows) {
                                _src.data_stream[k] >> k_buf[k](row_index,x);
                            }
                        }
                    }

                    // column left shift
              src_kernel_win[k].shift_right();

                    for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                        if(i<=stop_row) {
                            src_kernel_win[k](buf_row,0)=col_buf[k](buf_row,0);
                        }
                        else {
                            int y = borderInterpolate((i-(stop_row-rows+1)-buf_row), rows, BORDERMODE::value);
                            src_kernel_win[k](buf_row,0)=col_buf[k](rows-1-y,0);
                        }
                    }

                    // figure out the output image pixel value
                    if(i > start_row && j >= K_WIDTH-1) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }

private:
template<int K_HEIGHT, int K_WIDTH, typename POINT_T>
static void get_parameters(int rows, Point_<POINT_T> anchor, int &start_row, int &stop_row, int &row_index, int &col_index)
    {
_ssdm_InlineSelf(0, "");
        switch(BORDERMODE::value) {
            case BORDER_REPLICATE::value:
                start_row=K_HEIGHT-1-anchor.y;
                row_index=K_HEIGHT;
                col_index=0;
                stop_row=rows;
                break;
            case BORDER_REFLECT::value:
                col_index=K_WIDTH-1-anchor.x-1;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y-1;
                    row_index=2*K_HEIGHT-2*anchor.y;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            case BORDER_REFLECT_101::value:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            default: //BORDER_DEFAULT::value:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
        }
    }

};

template<typename OPR_KERNEL>
class filter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
{
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
_ssdm_InlineSelf(0, "");
    OPR_KERNEL fk_opr;
    // The main processing window
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // The main line buffer
    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // Temporary storage for src_ker_win, to call insert_right(), use a 1 x K_HEIGHT window
    Window<1,K_HEIGHT,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");

    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 600, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 601, __PRETTY_FUNCTION__));

    // used for buffer image pixel
    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    ((anchor.x >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.x >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 611, __PRETTY_FUNCTION__));
    ((anchor.x <= K_WIDTH-1) ? static_cast<void> (0) : __assert_fail ("anchor.x <= K_WIDTH-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 612, __PRETTY_FUNCTION__));
    ((anchor.y >= 0) ? static_cast<void> (0) : __assert_fail ("anchor.y >= 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 613, __PRETTY_FUNCTION__));
    ((anchor.y <= K_HEIGHT-1) ? static_cast<void> (0) : __assert_fail ("anchor.y <= K_HEIGHT-1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 614, __PRETTY_FUNCTION__));

    int start_row=K_HEIGHT-1-anchor.y;
    int start_col=K_WIDTH-1-anchor.x;
    int heightloop= rows+start_row;
    int widthloop = cols+start_col;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                    if((j<cols) && (i<rows)) {
                        _src.data_stream[k] >> src_temp;
                    }

                    if(j<cols) {
                        for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                            col_buf[k](0,buf_row)=k_buf[k](buf_row-1,j);
                        }
                    } else {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            col_buf[k](0,buf_row)=fillvalue;
                        }
                    }

                    if(j<cols) {
                        if(i==0) {
                            for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                                k_buf[k](buf_row,j)=fillvalue;
                                col_buf[k](0,buf_row)=fillvalue;
                            }
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        } else {
                            if(i>=rows) {
                                src_temp=fillvalue;
                            }
                            k_buf[k].shift_down(j);
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        }
                    }

                    if(j==0) {
                        for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                src_kernel_win[k](buf_row,buf_col)=fillvalue;
                            }
                        }
                    } else {
                  src_kernel_win[k].shift_right();
                    }
              src_kernel_win[k].insert_right(col_buf[k].val[0]);

                    // figure out the output image pixel value
                    if(i >= start_row && j >= start_col) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }
};

template<typename OPR_KERNEL, typename BORDERMODE>
class sepfilter_opr {
private:

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, int SRC_T, typename DST_T,
         typename KNY_T, typename POINT_T, int K_HEIGHT>
static void column_filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        stream<DST_T> (&_dst)[CH],
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
        int cols)
{
    OPR_KERNEL fk_opr;
    // The main processing window
    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[CH];
    // A window buffer for keeping pixels value from k_buf tempory
    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[CH];
    // The main line buffer
    // its size depend on anchor.y
    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[CH];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 708, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 709, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 710, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 711, __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernelY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=1;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int start_row;
    int row_index;
    int stop_row;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            start_row=K_HEIGHT-1-anchor.y;
            row_index=K_HEIGHT;
            stop_row=rows;
            break;
        case BORDER_REFLECT::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y-1;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        case BORDER_REFLECT_101::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        default: //BORDER_DEFAULT::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
    }

    int heightloop = rows+start_row+1; // 1: inorder to update col_buf
    int widthloop = cols;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
    // This DEPENDENCE pragma is necessary because the border mode handling is not affine.
    _ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k= 0; k < CH; k++)
            {

                // Fetch the column from the line buffer to shift into the window.
                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                    col_buf[k](buf_row,0)=k_buf[k](2*K_HEIGHT-1-buf_row,j);
                }

                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                if (i<rows) {
                    _src.data_stream[k] >> src_temp;
                }

                if(i<=start_row) { // top border
                    for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                        int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                        if(y==i) {
                            k_buf[k](buf_row,j)=src_temp;
                        }
                    }
                } else if(i<stop_row) {
                    for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                        if(buf_row>row_index) {
                            k_buf[k](buf_row,j)=k_buf[k](buf_row-1,j);
                        }
                    }
                    if(i<rows) {
                        k_buf[k](row_index,j) = src_temp;
                    }
                }

                for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                    if(i<=stop_row) {
                        src_kernel_winY[k](buf_row,0)=col_buf[k](K_HEIGHT-1-buf_row,0);
                    }
                    else { // bottom border
                        int y = borderInterpolate(i-(stop_row-rows+1)-buf_row, rows, BORDERMODE::value);
                        //src_kernel_winY[k](buf_row,0)=col_buf[k](K_HEIGHT-1-(rows-1-y),0);
                        // get the pixel index at col_buf[k](0,0)
                        int index = (rows-K_HEIGHT>0) ? rows-K_HEIGHT : 0;
                        src_kernel_winY[k](buf_row,0)=col_buf[k](y-index,0);
                    }
                }

                if(i > start_row) {
                    DST_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);
                    _dst[k]<<tempY;
                }
            }
        }
    }
}

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, typename SRC_T, int DST_T,
         typename KNX_T, typename POINT_T, int K_WIDTH, typename SCALE_T>
static void row_filter(
        stream<SRC_T> (&_src)[CH],
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Point_<POINT_T> _anchor,
        int rows,
        int cols,
        SCALE_T scale)
{
    OPR_KERNEL fk_opr;
    // The main processing window
    Window<1,K_WIDTH,SRC_T> src_kernel_winX[CH];
    // a arrayFlatten bug with src_kernel_winX use Window<>
    SRC_T src_kernel_winX_temp[CH][K_WIDTH];
    // temporary buffer for row pixels
    // its size depend on anchor.x
    Window<1,2*K_WIDTH,SRC_T> row_buf[CH];
    // small buffer keeping border pixels
    // it should be LUT-RAM, its size depend on anchor.x
    // specific left and right border buffer, for 
    // special case when a window size bigger than total imgage
    LineBuffer<1,K_WIDTH,SRC_T> l_border_buf[CH];
    LineBuffer<1,K_WIDTH,SRC_T> r_border_buf[CH];

    ((rows >= 8) ? static_cast<void> (0) : __assert_fail ("rows >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 842, __PRETTY_FUNCTION__));
    ((cols >= 8) ? static_cast<void> (0) : __assert_fail ("cols >= 8", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 843, __PRETTY_FUNCTION__));
    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 844, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 845, __PRETTY_FUNCTION__));

_ssdm_SpecArrayPartition( &kernelX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX_temp, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( row_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( l_border_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( r_border_buf, 1, "COMPLETE", 0, "");

    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=1;
    normalizeAnchor(anchor,kernel_size);

    // parameters for different border modes and anchor position
    // buffer left border pixels to l_border_buf, then start read l_border_buf to create left border
    int left_border;
    // buffer right border pixels to r_border_buf, then start read r_border_buf to create right border
    int right_border;
    // index for writing src_temp to row_buf, then shift row_buf pixel left
    int index;
    // start loop trip to real processing
    int start;
    // stop shift pixel from row_buf, start read l_border_buf to create right border
    int stop;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            left_border = 0;
            right_border = cols-1;
            index = anchor.x;
            break;
        case BORDER_REFLECT::value:
            left_border = (anchor.x-1>0) ? anchor.x-1: 0;
            right_border = cols-(K_WIDTH-anchor.x)+1;
            index = (2*anchor.x-1>0) ? 2*anchor.x-1: 0;
            break;
        case BORDER_REFLECT_101::value:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
        default: //BORDER_DEFAULT::value:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
    }

    // for special case when a window size bigger than total imgage
    right_border = right_border<0 ? 0 : right_border;
    start = K_WIDTH+left_border;
    stop = cols+index;
    int heightloop= rows;
    int widthloop = cols+start;
    SRC_T src_temp;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
    // This DEPENDENCE pragma is necessary because the border mode handling is not affine.
    _ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k=0; k<CH; k++)
            {
                int x = borderInterpolate(j-index-1, cols, BORDERMODE::value);

                if (j<cols)
                    _src[k] >> src_temp;

              //src_kernel_winX[k].shift_right();
                for (int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if (j<=left_border) {
                    l_border_buf[k](0,j) = src_temp;
                }
                if ((j>=right_border) && (j<cols)) {
                    r_border_buf[k](0,cols-1-j) = src_temp;
                }

                if ((j>left_border) && (j<=index)) { // create left border
                    //src_kernel_winX[k](0,0) = l_border_buf[k](0,x);
                    src_kernel_winX_temp[k][0] = l_border_buf[k](0,x);
                } else if (j<=stop) { // j==index+1, row_buf[k](0,0) is the first pixel c0
                    //src_kernel_winX[k][0](0,0) = row_buf[k](0,0);
                    src_kernel_winX_temp[k][0] = row_buf[k](0,0);
                } else { // create right border
                    //]src_kernel_winX[k][0](0,0) = r_border_buf[k](0,cols-1-x);
                    src_kernel_winX_temp[k][0] = r_border_buf[k](0,cols-1-x);
                }

                for (int buf_col=0; buf_col<2*K_WIDTH; buf_col++) {
                    if (buf_col<index)
                        row_buf[k](0,buf_col) = row_buf[k](0,buf_col+1);
                }
                row_buf[k](0,index) = src_temp;

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }

                if(j >= start) {
                    typedef typename filter2d_traits<SRC_T, KNX_T, K_WIDTH*1-1>::TEMP_T tempX_T;
                    tempX_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH, typename SCALE_T>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)

{
_ssdm_InlineSelf(0, "");
_ssdm_op_SpecDataflowPipeline(-1, "");

    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;
    stream<tempY_T> tempY_stream[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    column_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(_src, tempY_stream, kernelY, Point_<POINT_T>(0,_anchor.y), rows, cols);

    row_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(tempY_stream, _dst, kernelX, Point_<POINT_T>(_anchor.x,0), rows, cols, scale);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)

{
_ssdm_InlineSelf(0, "");
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL>
class sepfilter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)
{
_ssdm_InlineSelf(0, "");
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
    OPR_KERNEL fk_opr;
    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;
    // The two main processing window
    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    Window<1,K_WIDTH,tempY_T> src_kernel_winX[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    tempY_T src_kernel_winX_temp[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)][K_WIDTH];
    // The main line buffer
    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( &kernelX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernelY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winX_temp, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_winY, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");

    ((rows <= IMG_HEIGHT) ? static_cast<void> (0) : __assert_fail ("rows <= IMG_HEIGHT", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1038, __PRETTY_FUNCTION__));
    ((cols <= IMG_WIDTH) ? static_cast<void> (0) : __assert_fail ("cols <= IMG_WIDTH", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1039, __PRETTY_FUNCTION__));

    // used for buffer image pixel
    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int heightloop= rows+K_HEIGHT-1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
    _ssdm_SpecLoopFlatten(1, "");
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++) {
                //fill data x,y are the coordinate in the image, it could be negative.    
                //For example (-1,-1) represents the interpolation pixel.
                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-anchor.y;

                //row filter window shift right  
                //src_kernel_winX[k].shift_right(); 
                for(int buf_col=K_WIDTH-1; buf_col>=1; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--) {
                        src_kernel_winY[k](buf_row,0)=k_buf[k](buf_row-1,ImagLoc.x);
                        k_buf[k](buf_row,ImagLoc.x)=k_buf[k](buf_row-1,ImagLoc.x);
                    }
                    //k_buf[k].shift_down(ImagLoc.x);
                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=fillvalue;
                    if(ImagLoc.y >= 0 && ImagLoc.y < rows) {
                        _src.data_stream[k] >> temp;
                    }
                    src_kernel_winY[k](0,0)=temp;
                    k_buf[k](0,ImagLoc.x)=temp;
                }

                // figure out the output image pixel value
                //column filter processing between interval of 
                //j in [anchor.x, cols_anchor.x] when i>=K_HEIGHT-1
                //accordingly,ImagLoc.x in [0,cols-1]
                if(ImagLoc.x < 0 || ImagLoc.x >= cols) {
                    //src_kernel_winX[k](0,0) = fillvalue;
                    src_kernel_winX_temp[k][0] = fillvalue;
                } else if(i >= (K_HEIGHT-1)) {
                    tempY_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);
                    //src_kernel_winX[k](0,0) = tempY;
                    src_kernel_winX_temp[k][0] = tempY;
                }

                for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }

                //row filter processing between interval of j in[K_WIDTH-1, cols+K_WIDTH-1] when i>=K_HEIGHT
                //wait K_WIDTH-anchor.x clocks after the column filter
                if(i >= (K_HEIGHT-1) && j >= (K_WIDTH-1)) {
                    typename filter2d_traits<tempY_T, KNX_T, 1*K_WIDTH>::ACCUM_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)
{
_ssdm_InlineSelf(0, "");
    filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_flow_more(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows, int cols
        )
{
    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int ITERATIONS,int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_iter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows,int cols )
{
_ssdm_op_SpecDataflowPipeline(-1, "");
    Mat<IMG_HEIGHT,IMG_WIDTH,DST_T> internal[ITERATIONS-1];
_ssdm_SpecArrayPartition( internal, 1, "complete", 0, "");
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(_src,internal[0],_kernel,anchor,rows,cols);
loop_iterations: for(int iter=0;iter<ITERATIONS-2;iter++)
    {
_ssdm_Unroll(0,0,0, "");
        filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[iter],internal[iter+1],_kernel,anchor,rows, cols);
    }
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[ITERATIONS-2],_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T,
    int IMG_HEIGHT,int IMG_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
_ssdm_InlineSelf(0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    Size_<int> size;
    Point_<int> anchor;
    anchor.x=1;
    anchor.y=1;
    size.width=2*1+1;
    size.height=2*1+1;
    Window<2*1+1,2*1+1,unsigned char> temp_kernel;
    getStructuringElement<unsigned char,int,int,2*1+1,2*1+1>(MORPH_RECT, size, anchor,temp_kernel);
    //iterations=1;
    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int Shape_type, int ITERATIONS, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
_ssdm_InlineSelf(0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    if((Shape_type==MORPH_RECT)&&ITERATIONS>1)
    {
        Size_<int> size;
        anchor.x=ITERATIONS*(anchor.x);
        anchor.y=ITERATIONS*(anchor.y);
        size.width=K_WIDTH+ITERATIONS*(K_WIDTH-1);
        size.height=K_HEIGHT+ITERATIONS*(K_HEIGHT-1);
        Window<K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1),KN_T> temp_kernel;
        getStructuringElement<KN_T,int,int,K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1)>(MORPH_RECT, size, anchor,temp_kernel);
        //iterations=1;
        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS==1)
    {
        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS>=2)
    {
        filter_opr_iter<OPR_KERNEL, BORDERMODE, ITERATIONS,SRC_T,DST_T,KN_T,POINT_T>(_src,_dst,_kernel,anchor,rows,cols);
    }
}
//void cvErode(
//		const CvArr* src,
//		CvArr* dst,
//		IplConvKernel* element=NULL,
//		int iterations=1 );---OPencv
template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
    assert_cn(SRC_T,DST_T);
    morp_opr<erode_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
_ssdm_InlineSelf(0, "");
    assert_cn(SRC_T,DST_T);
    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<erode_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}
//void cvDilate(
//	const CvArr* src,
//	CvArr* dst, IplConvKernel* element=NULL,
//	int iterations=1 );----OPencv
template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
    assert_cn(SRC_T,DST_T);
    morp_opr<dilate_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
_ssdm_InlineSelf(0, "");
    assert_cn(SRC_T,DST_T);
    Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<dilate_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}
//void cvFilter2D(const CvArr* src, CvArr* dst,
//		const CvMat* kernel,
//		CvPoint anchor=cvPoint(-1,-1));------oPencv
template<typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor,
        SCALE_T scale)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols,scale);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{
    assert_cn(SRC_T,DST_T);
    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}

//----------------------CvtColor---------------

class CvtColor_mode {
public:
    enum values {RGB2GRAY,BGR2GRAY,GRAY2RGB,GRAY2BGR,
                 BGR2XYZ, RGB2XYZ, XYZ2BGR, XYZ2RGB,
                 BGR2YCrCb, RGB2YCrCb, YCrCb2BGR, YCrCb2RGB,
                 BGR2HSV, RGB2HSV, HSV2BGR, HSV2RGB,
                 BGR2HLS, RGB2HLS, HLS2BGR, HLS2RGB};
    typedef void isCvtColorMode;
};

}

class HLS_RGB2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2GRAY;
public :
inline __attribute__((always_inline)) HLS_RGB2GRAY() { _ssdm_SpecConstant(&value); }
# 1354 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_BGR2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2GRAY;
public :
inline __attribute__((always_inline)) HLS_BGR2GRAY() { _ssdm_SpecConstant(&value); }
# 1355 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_GRAY2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2RGB;
public :
inline __attribute__((always_inline)) HLS_GRAY2RGB() { _ssdm_SpecConstant(&value); }
# 1356 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_GRAY2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2BGR;
public :
inline __attribute__((always_inline)) HLS_GRAY2BGR() { _ssdm_SpecConstant(&value); }
# 1357 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};

class HLS_RGB2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2XYZ;
public :
inline __attribute__((always_inline)) HLS_RGB2XYZ() { _ssdm_SpecConstant(&value); }
# 1359 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_BGR2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2XYZ;
public :
inline __attribute__((always_inline)) HLS_BGR2XYZ() { _ssdm_SpecConstant(&value); }
# 1360 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_XYZ2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2RGB;
public :
inline __attribute__((always_inline)) HLS_XYZ2RGB() { _ssdm_SpecConstant(&value); }
# 1361 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_XYZ2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2BGR;
public :
inline __attribute__((always_inline)) HLS_XYZ2BGR() { _ssdm_SpecConstant(&value); }
# 1362 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};

class HLS_RGB2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2YCrCb;
public :
inline __attribute__((always_inline)) HLS_RGB2YCrCb() { _ssdm_SpecConstant(&value); }
# 1364 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_BGR2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2YCrCb;
public :
inline __attribute__((always_inline)) HLS_BGR2YCrCb() { _ssdm_SpecConstant(&value); }
# 1365 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_YCrCb2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2RGB;
public :
inline __attribute__((always_inline)) HLS_YCrCb2RGB() { _ssdm_SpecConstant(&value); }
# 1366 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_YCrCb2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2BGR;
public :
inline __attribute__((always_inline)) HLS_YCrCb2BGR() { _ssdm_SpecConstant(&value); }
# 1367 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};

class HLS_RGB2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HSV;
public :
inline __attribute__((always_inline)) HLS_RGB2HSV() { _ssdm_SpecConstant(&value); }
# 1369 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_BGR2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HSV;
public :
inline __attribute__((always_inline)) HLS_BGR2HSV() { _ssdm_SpecConstant(&value); }
# 1370 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_HSV2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2RGB;
public :
inline __attribute__((always_inline)) HLS_HSV2RGB() { _ssdm_SpecConstant(&value); }
# 1371 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_HSV2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2BGR;
public :
inline __attribute__((always_inline)) HLS_HSV2BGR() { _ssdm_SpecConstant(&value); }
# 1372 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};

class HLS_RGB2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HLS;
public :
inline __attribute__((always_inline)) HLS_RGB2HLS() { _ssdm_SpecConstant(&value); }
# 1374 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_BGR2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HLS;
public :
inline __attribute__((always_inline)) HLS_BGR2HLS() { _ssdm_SpecConstant(&value); }
# 1375 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_HLS2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2RGB;
public :
inline __attribute__((always_inline)) HLS_HLS2RGB() { _ssdm_SpecConstant(&value); }
# 1376 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};
class HLS_HLS2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2BGR;
public :
inline __attribute__((always_inline)) HLS_HLS2BGR() { _ssdm_SpecConstant(&value); }
# 1377 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
};

namespace hls {

    template <typename T> class CvtColor_traits {
        // Only supported explicitly for types below.
    };

    template <> class CvtColor_traits<unsigned char> {
    public:
        typedef unsigned char T;
        typedef ap_fixed<25,3> COEFF_T; // Integer versions in OpenCV are computed with 14 fractional bits.
     typedef ap_ufixed<20,1,SC_RND> INV_T;
        //const unsigned int delta;
        const int delta;// modify unsigned int to int, for YCrCb2rgb, there is (Cr-CvtColor_traits<SRC_T>().delta) return a unsigned int, which should be int.
        const unsigned int hrange;
        const unsigned int scale;//255
        const INV_T inv_scale;//1/255
        const INV_T inv_hrange;// 6/180
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(128), hrange(180), scale(255),
       inv_scale(0.0039215686274509804), inv_hrange(0.0333333333333333333) {};//fixme, need values for 10, 12 etc bits.
    };
    template <int N> class CvtColor_traits< ap_uint<N> > {
    public:
        typedef ap_uint<N> T;
        typedef ap_fixed<25,3> COEFF_T; // Integer versions in OpenCV are computed with 14 fractional bits.
     typedef ap_ufixed<20,1,SC_RND> INV_T;
        //const unsigned int delta;
        const int delta;
        const unsigned int hrange;
        const unsigned int scale;//255
        const INV_T inv_scale;//1/255
        const INV_T inv_hrange;// 6/180
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(1 << (N-1)), hrange(180),
                            scale(::hls::numeric_limits<T>::max()),
                            inv_scale(1.0/::hls::numeric_limits<T>::max()),
                            inv_hrange(0.0333333333333333333) {};//fixme, need values for 10, 12 etc bits.
    };
    template <> class CvtColor_traits<float> {
    public:
        typedef float T;
        typedef float COEFF_T;
        typedef float INV_T;
        const float delta;
        const float hrange;
        const float scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;// 6/360
        typedef float MULT_T;
        typedef float ACCUM_T;
        typedef float SUB_T;
        typedef float ADD_T;
        typedef float H_MULT_T;
        typedef float S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
    };
    template <> class CvtColor_traits<double> {
    public:
        typedef double T;
        typedef double COEFF_T;
        typedef double INV_T;
        const double delta;
        const double hrange;
        const double scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;// 6/360
        typedef double MULT_T;
        typedef double ACCUM_T;
        typedef double SUB_T;
        typedef double ADD_T;
        typedef double H_MULT_T;
        typedef double S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
};

template <typename SRC_T, typename DST_T>
class ColorConverter {
public:
    template <int CN1>
    static void convert(Scalar<CN1,SRC_T>& _src, DST_T& result, Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par) {
_ssdm_InlineSelf(0, "");
        typename CvtColor_traits<SRC_T>::MULT_T b,g,r;
        r=par.val[0]*_src.val[0];
        b=par.val[1]*_src.val[1];
        g=par.val[2]*_src.val[2];
        typename CvtColor_traits<SRC_T>::ACCUM_T c;
        c=r+g+b;
        result=sr_cast<DST_T> (c);
    }
};

template <typename SRC_T, typename DST_T>
class MaxMin{
public:
    template <int CN1>
    static void max(Scalar<CN1,SRC_T>& _src, DST_T& result) {
_ssdm_InlineSelf(0, "");
 //result=HLS_8U_MIN;
 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]>result) ? _src.val[i] : result;
 }
    }

    template <int CN1>
    static void min(Scalar<CN1,SRC_T>& _src, DST_T& result) {
_ssdm_InlineSelf(0, "");
 //result=HLS_8U_MAX;
 for(int i=0; i<CN1; i++) {
   result=(_src.val[i]<result) ? _src.val[i] : result;
 }
    }
};

template <typename CONVERSION, typename SRC_T, typename DST_T>
class kernel_CvtColor {};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.114,0.587,0.299) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
_ssdm_InlineSelf(0, "");
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
_ssdm_InlineSelf(0, "");
        _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2XYZ, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parX;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parY;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parZ;
public:
    kernel_CvtColor() : parX(0.412453, 0.357580, 0.180423),
                        parY(0.212671, 0.715160, 0.072169),
                        parZ(0.019334, 0.119193, 0.950227) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parX);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parY);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parZ);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2XYZ, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2XYZ,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2RGB, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parR;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parG;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parB;
public:
    kernel_CvtColor() : parR( 3.240479, -1.53715, -0.498535),
                        parG(-0.969256, 1.875991, 0.041556),
                        parB( 0.055648, -0.204043, 1.057311) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parR);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parG);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parB);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_XYZ2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2YCrCb, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
    typename CvtColor_traits<SRC_T>::COEFF_T Cr;
    typename CvtColor_traits<SRC_T>::COEFF_T Cb;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114),Cr(.713),Cb(.564) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
        DST_T Y;
        ColorConverter<SRC_T,DST_T>::convert(_src, Y, par);
        _dst.val[0] = Y;
        _dst.val[1] = sr_cast<DST_T>((R-Y)*Cr+ CvtColor_traits<SRC_T>().delta);
        _dst.val[2] = sr_cast<DST_T>((B-Y)*Cb+ CvtColor_traits<SRC_T>().delta);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2YCrCb, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2YCrCb,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2RGB, SRC_T, DST_T> {
    typename CvtColor_traits<SRC_T>::COEFF_T parGr;
    typename CvtColor_traits<SRC_T>::COEFF_T parGb;
    typename CvtColor_traits<SRC_T>::COEFF_T parCr;
    typename CvtColor_traits<SRC_T>::COEFF_T parCb;
public:
    kernel_CvtColor() : parGr(-0.714), parGb(-0.344), parCr(1.403), parCb(1.773) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T Y = _src.val[0];
        SRC_T Cr = _src.val[1];
        SRC_T Cb = _src.val[2];
        _dst.val[0] = sr_cast<DST_T> (Y + parCr * (Cr-CvtColor_traits<SRC_T>().delta));
        _dst.val[1] = sr_cast<DST_T> (Y + parGr * (Cr-CvtColor_traits<SRC_T>().delta) + parGb * (Cb-CvtColor_traits<SRC_T>().delta));
        _dst.val[2] = sr_cast<DST_T> (Y + parCb * (Cb-CvtColor_traits<SRC_T>().delta));
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_YCrCb2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::INV_T inv_max = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;

 if(max!=0)
   inv_max = (typename CvtColor_traits<DST_T>::INV_T) 1/max;
 else
   inv_max = 0;

 S=inv_max*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = (180==CvtColor_traits<SRC_T>().hrange) ? sr_cast<DST_T>(255*S) : sr_cast<DST_T>(S);
        _dst.val[2] = max;
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HSV,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T H = _src.val[0];
        SRC_T S = _src.val[1];
        SRC_T V = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
_ssdm_SpecConstant(sector_data);
# 1757 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"

 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

 _ssdm_SpecArrayPartition( tab, 0, "COMPLETE", 0, "");

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)//for hrange=180, 0<H<255, then 0<h_i<8 
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 tab[0] = V;
 tab[1] = V*(1-S_scale);
 tab[2] = V*(1-f*S_scale);
 tab[3] = V*(1-S_scale+f*S_scale);

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HSV2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 DST_T L;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::ADD_T add;
 typename CvtColor_traits<DST_T>::INV_T inv_add = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_add_comp= 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;
 add=max+min;
 L=sr_cast<DST_T>((max+min)/2);

 if(add!=0)
   inv_add = (typename CvtColor_traits<DST_T>::INV_T) 1/add;
 else
   inv_add = 0;

    //assert(add < 2*CvtColor_traits<SRC_T>().scale);

 if((2*(CvtColor_traits<SRC_T>().scale)-add)!=0)
   inv_add_comp = (typename CvtColor_traits<DST_T>::INV_T) 1/(2*(CvtColor_traits<SRC_T>().scale)-add);
 else
   inv_add_comp = 0;

 if(L<=CvtColor_traits<SRC_T>().delta)//0.5*(CvtColor_traits<SRC_T>().scale))
   S=inv_add*diff;
 else
   S=inv_add_comp*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = L;
        _dst.val[2] = (180==CvtColor_traits<SRC_T>().hrange) ?
            sr_cast<DST_T>(CvtColor_traits<SRC_T>().scale*S) :
            sr_cast<DST_T>(S);

    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HLS,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
 _ssdm_InlineSelf(0, "");
        SRC_T H = _src.val[0];
        SRC_T L = _src.val[1];
        SRC_T S = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
_ssdm_SpecConstant(sector_data);
# 1890 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"

 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

 _ssdm_SpecArrayPartition( tab, 0, "COMPLETE", 0, "");

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)//for hrange=180, 0<H<255, then 0<h_i<8 
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 if(L<=0.5*CvtColor_traits<SRC_T>().scale)
   tab[0] = L+L*S_scale;
   //tab[0] = L*(1+S_scale);
 else
    tab[0] = L+S-L*S_scale;

 tab[1] = 2*L-tab[0];
 tab[2] = tab[0]-(tab[0]-tab[1])*f;
 tab[3] = tab[1]+(tab[0]-tab[1])*f;

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HLS2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename CONVERSION,int SRC_T, int DST_T,
    int ROWS,int COLS>
void CvtColor(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst
        )
{
    kernel_CvtColor<CONVERSION,typename Type<((SRC_T) & ((1 << 11) - 1))>::name,typename Type<((DST_T) & ((1 << 11) - 1))>::name> kernel_opr;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1943, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1944, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
 loop_height: for(int i= 0; i < rows; i++) {
    loop_width: for (int j= 0; j < cols; j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src >> _s;
            kernel_opr.apply(_s,_d);
            _dst << _d;
        }
    }
}
//---------------------integral---------------------
template<int SRC_T, int DST_T,
int ROWS,int COLS>
void Integral(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS+1, COLS+1, DST_T> &_sum
        )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1968, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 1969, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                _d.val[0]=0;
                sum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                _d.val[0]=sum+k_buf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
            }
            _sum<<_d;
        }
    }
}
template<int SRC_T, int DST_T,int DSTSQ_T,
    int ROWS,int COLS>
void Integral(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS+1, COLS+1, DST_T> &_sum,
  Mat<ROWS+1, COLS+1, DSTSQ_T> &_sqsum
                )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    LineBuffer<1,COLS+1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> k_sqbuf;
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2007, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2008, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    Scalar<1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> _sqd;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                k_sqbuf.val[0][j]=0;
                _d.val[0]=0;
                _sqd.val[0]=0;
                sum=0;
                sqsum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                sqsum=sqsum+_s.val[0]*_s.val[0];

                _d.val[0]=sum+k_buf.val[0][j];
                _sqd.val[0]=sqsum+k_sqbuf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
                k_sqbuf.val[0][j]=_sqd.val[0];
            }
            _sum<<_d;
            _sqsum<<_sqd;
        }
    }
}
//----------------Resize----------
// Bicubic Coefficient Generation:
// For a particular scaling ratio, the coefficients will be pre-calculated and stored to memory.
// This coefficient generation algorithm implements the Catmull-Rom spline:
// http://en.wikipedia.org/wiki/Cubic_interpolation
// This whole function is expected to be absorbed into initialization content for
// dual port distributed memory:
template <int NTAPS, int NPHASES, int COEFF_BITS,typename HT, typename VT>
void init_scale_coefficients(HT *Hcoefs, VT *Vcoefs) {

_ssdm_InlineSelf(2, "");
    static const float A = -0.5;
_ssdm_SpecConstant(&A);
# 2054 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h"
 // Coefficients will be stored in inverse 16.15 notation,
    double t; // Because Fixed point N.N-1 notation can not represent 1.0
    double coeff[NPHASES][NTAPS];
    int i,j;

    for (i=0; i<NPHASES; i++) {
        t=((double) i)/NPHASES;
        coeff[i][0] = A*(t*((2-t)*t-1)); //coeff[0] = A*(-  t*t*t + 2*t*t -  t    );
        coeff[i][1] = A*(t*t*(3*t-5)+2); //coeff[1] = A*( 3*t*t*t - 5*t*t      + 2);
        coeff[i][2] = A*(t*((4-3*t)*t+1)); //coeff[2] = A*(-3*t*t*t + 4*t*t  + t    );
        coeff[i][3] = A*((t-1)*t*t); //coeff[3] = A*(   t*t*t -   t*t         );
    }
    for (i = 0; i < NPHASES; i++) {
        for (j = 0; j < NTAPS; j++) {
            Hcoefs[(NTAPS*i)+j] = (HT)coeff[i][j];
            Vcoefs[(NTAPS*i)+j] = (VT)coeff[i][j];
        }
    }
}

template<int NTAPS, int COEFF_BITS, int T,typename FILTER_T>
hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scale_operator(hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> *samples, FILTER_T *coeffs) {

    typedef typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::SRC_CAST_T SRCT;
    int i,j,ch;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_out;
CHAN_LOOP : for (ch =0; ch<((((T) & ((512 - 1) << 11)) >> 11) + 1); ch++) { // Iterate over all color channels in parallel:
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::ACCUM_T t=0;
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::MULT_T temp;
    TAPS_LOOP : for (i = 0,t=0.5; i < NTAPS; i++) {
_ssdm_InlineSelf(0, "");
            typename Type<((T) & ((1 << 11) - 1))>::name sample = samples[i].val[ch]; // Pull out the color channel value
            temp = ((SRCT)sample)*coeffs[NTAPS-1-i];
            t = t - temp ;
        }
        pix_out.val[ch] = sr_cast<typename Type<((T) & ((1 << 11) - 1))>::name> (t);
    }
    return pix_out;
}

// Linear Scaler Function
template <int COLS, int ROWS,int DCOLS, int DROWS, int T>
void Resize_opr_bicubic(hls::Mat<ROWS, COLS, T>& _src, hls::Mat<DROWS, DCOLS, T>& _dst) {
    typedef ap_fixed<32, 16, SC_RND> FT;
    typedef short N16;
    const int NTAPS = 4;
    const int NPHASES = 16;
    const int COEFF_BITS = 16; // Maximum is 16 for S16 format
    const short ES = 2; // Edge size. 2 Rows and 2 columns are needed before processing can start.
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, SC_RND>, NTAPS>::FILTER_CAST_T hcoeffs[NPHASES][NTAPS];
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, SC_RND>, NTAPS>::FILTER_CAST_T vcoeffs[NPHASES][NTAPS];
    N16 row, col;
    N16 rows, cols;
    ap_uint<32> v_phase_acc; // Vertical Phase accumulator. This accumulator is at least 16bit fractional + 13 bit integer = 29 bits wide
    ap_uint<32> h_phase_acc; // Horizontal Phase accumulator

    hls::LineBuffer<NTAPS, (COLS>DCOLS?COLS:DCOLS) + 3, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > linebuf;
    hls::Window<1, NTAPS, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > h_shreg;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_in, h_fir_out, pix_out, h_fir[NTAPS], v_fir[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_in[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_out[NTAPS];
    typename Type<((T) & ((1 << 11) - 1))>::name pix_in_ch, pix_out_ch;

    N16 rows_rw = -1, cols_rw = -1;
    bool col_rd_en;
    bool row_rd_en;
    bool col_wr_en;
    bool row_wr_en;
    ap_uint<4> v_phase;
    ap_uint<4> h_phase;
_ssdm_SpecArrayPartition( temp_in, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( temp_out, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( h_fir, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( v_fir, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( hcoeffs, 2, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( vcoeffs, 2, "COMPLETE", 0, "");

    // Initialization:
    init_scale_coefficients<NTAPS, NPHASES, COEFF_BITS>(hcoeffs[0], vcoeffs[0]); // 4 Taps, 16 phases, 16 bit signed coefficients

    N16 rows_in = _src.rows;
    N16 cols_in = _src.cols;
    N16 rows_out = _dst.rows;
    N16 cols_out = _dst.cols;
    FT row_ratio = (FT(rows_out)) / (FT)rows_in;
    FT col_ratio = (FT(cols_out)) / (FT)cols_in;

    int row_rate = (ap_fixed<4, 2, SC_RND>(0.5) + row_ratio * 65536);
    int col_rate = (ap_fixed<4, 2, SC_RND>(0.5) + col_ratio * 65536);
    rows = (rows_in > rows_out) ? rows_in : rows_out;
    cols = (cols_in > cols_out) ? cols_in : cols_out;
    ((rows<=ROWS || rows<=DROWS) ? static_cast<void> (0) : __assert_fail ("rows<=ROWS || rows<=DROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2145, __PRETTY_FUNCTION__));
    ((cols<=COLS || cols<=DCOLS) ? static_cast<void> (0) : __assert_fail ("cols<=COLS || cols<=DCOLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2146, __PRETTY_FUNCTION__));
    v_phase_acc = 0;

 ROW_LOOP: for (row = 0; row < rows + 3; row++) {
    COL_LOOP: for (col = 0; col < cols + 3; col++) {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
              if (col == 0) {
                  v_phase = (v_phase_acc >> 12) & 15; // Slice out bits 15..12 from the phase accumulator (Consider rounding here!!!)
                  if (row_rate < 65536) { // Down scaling, writes are less frequent than reads
                      row_rd_en = true;
                      N16 drow = row * row_ratio;
                      if (rows_rw != drow) {
                          row_wr_en = true;
                          rows_rw = drow;
                      } else
                          row_wr_en = false;
                  } else { // Up scaling, reads are less frequent than writes
                      row_wr_en = true;
                      N16 drow = row / row_ratio;
                      if (rows_rw != drow) {
                          row_rd_en = true;
                          rows_rw = drow;
                      } else
                          row_rd_en = false;
                  }
                  if (row_rate < 65536 || row_rd_en)
                      v_phase_acc = v_phase_acc + row_rate;
              }

              h_phase = (h_phase_acc >> 12) & 15; // Slice out bits 15..12 from the phase accumulator
              if (col_rate < 65536) { // Down scaling, writes are less frequent than reads
                  col_rd_en = true;
                  N16 dcol = col * col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_wr_en = true;
                      cols_rw = dcol;
                  } else
                      col_wr_en = false;
              } else { // Up scaling, reads are less frequent than writes
                  col_wr_en = true;
                  N16 dcol = col / col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_rd_en = true;
                      cols_rw = dcol;
                  } else
                      col_rd_en = false;
              }

              if (col > 0 && (col_rate < 65536 || col_rd_en))
                  h_phase_acc = h_phase_acc + col_rate;
              else
                  h_phase_acc = col_rate;

              if (col_rd_en) {
                  h_shreg.shift_left();
                  if (row_rd_en) {
                      if (row < rows && col < cols) {
                          pix_in = _src.read();
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (col >= cols && row < rows) {
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (row >= rows) {
                          for (int m = 0; m < ((((T) & ((512 - 1) << 11)) >> 11) + 1); m++)
                              pix_in.val[0] = 0;
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      }
                  }
              }

              for (int i = 0; i < NTAPS; i++) {
                  temp_in[i] = linebuf.val[i][col];
              }

              if (col_wr_en) {
                  if ((row_rd_en) || (row < ES) || (row >= rows - ES)) {
                      for (int i = NTAPS - 1; i > 0; i--) {
                          temp_out[i] = temp_in[i - 1];
                      }
H_LOOP: for (int i = 0; i < NTAPS; i++) {
            h_fir[i] =
                (col > i) ?
                h_shreg.getval(0, i) :
                h_shreg.getval(0, NTAPS - 1 - col);
        }
        h_fir_out = scale_operator<NTAPS, COEFF_BITS, T>(h_fir,
                hcoeffs[h_phase]);
        temp_out[0] = h_fir_out;
        v_fir[NTAPS - 1] = h_fir_out;
                  } else {
                      for (int i = NTAPS - 1; i >= 0; i--) {
                          temp_out[i] = temp_in[i];
                      }
                      v_fir[NTAPS - 1] = temp_in[0];
                  }
V_LOOP: for (int i = 0; i < NTAPS - 1; i++) {
            v_fir[i] =
                (row > 0) ? temp_out[NTAPS - 1 - i] : temp_out[0];
        }
              }

              for (int i = 0; i < NTAPS; i++) {
                  linebuf.val[i][col] = (row > 0) ? temp_out[i] : temp_out[0];
              }

              if (row >= 3 && col >= 3 && row_wr_en && col_wr_en) {
                  pix_out = scale_operator<NTAPS, COEFF_BITS, T>(v_fir, vcoeffs[v_phase]);
                  _dst.write(pix_out);
              }
          }
          }
}

template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize_opr_linear (
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<DROWS, DCOLS, SRC_T> &_dst )
{
    LineBuffer<2,(COLS>DCOLS?COLS:DCOLS)+1,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > k_buf;
    Window<2,2,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;
    short dcols=_dst.cols;
    short drows=_dst.rows;
    short srows=_src.rows;
    short scols=_src.cols;
    ap_fixed<32,16,SC_RND> row_rate=((ap_fixed<32,16,SC_RND> )srows)/(ap_fixed<32,16,SC_RND>)drows;
    ap_fixed<32,16,SC_RND> col_rate=((ap_fixed<32,16,SC_RND> )scols)/(ap_fixed<32,16,SC_RND>)dcols;
    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<20,2,SC_RND> ,4>::FILTER_CAST_T u,v, u1,v1;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s, temp, d;
    ap_fixed<4,2,SC_RND> par=0.5;
    ap_fixed<20,10,SC_RND> offset_row=row_rate/2-par;
    ap_fixed<20,10,SC_RND> offset_col=col_rate/2-par;
    ap_fixed<32,16,SC_RND> fx=0;
    ap_fixed<32,16,SC_RND> fy=0;

    short rows=srows > drows ? srows : (drows+1);
    short cols=scols > dcols ? scols : (dcols+1);
    ((rows<=ROWS || rows<=DROWS+1) ? static_cast<void> (0) : __assert_fail ("rows<=ROWS || rows<=DROWS+1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2284, __PRETTY_FUNCTION__));
    ((cols<=COLS || cols<=DCOLS+1) ? static_cast<void> (0) : __assert_fail ("cols<=COLS || cols<=DCOLS+1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2285, __PRETTY_FUNCTION__));

    short x=0;
    short pre_fy=-10;
    short pre_fx=-10;
    bool row_rd=false;
    bool row_wr=false;

    for(short i= 0;i<rows;i++) {
        for(short j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");

            bool col_rd=false;
            bool col_wr=false;

            short dy = row_rate>1 ? (short)(i/row_rate):(i-1);
            short dx = col_rate>1 ? (short)(j/col_rate):(j-1);

            fy =(dy)*row_rate+offset_row;
            fx =(dx)*col_rate+offset_col;

            short sx=(short)fx;
            short sy=(short)fy;
            if(fx-sx>0)
                u=fx-sx;
            else
                u=0;
            if(fy-sy>0)
                v=fy-sy;
            else
                v=0;
            u1=1-u;
            v1=1-v;
            if(sx>scols-1)
            {
                sx=scols-1;
                u=0;
            }
            if(sy>srows-1)
            {
                sy=srows-1;
                v=0;
            }
            if(j==0)
            {
                x=0;
                pre_fx=-10;
                if(row_rate>1)
                {
                    row_rd=true;
                    row_wr= (sy==(i-1)) ? true : false;
                }
                else
                {
                    if(i==0){
                        row_rd=true;
                    }
                    else if(sy!=pre_fy)
                    {
                        row_rd=true;
                        pre_fy=sy;
                    }
                    else {
                        row_rd=false;
                    }
                    row_wr= i>0? true: false;
                }
            }
            if(col_rate>1)
            {
                col_rd=true;
                col_wr= (sx==(j-1)) ? true : false;
            }else{
                if(j==0){
                    col_rd=true;
                }
                else if(sx!=pre_fx)
                {
                    col_rd=true;
                    pre_fx=sx;
                }
                else
                    col_rd=false;
                col_wr= j>0? true: false;
            }
            if(col_rd)
            {
                for(int r= 0;r<2;r++)
                {
                    win.val[r][1]=win.val[r][0];
                }
                if(row_rd)
                {

                    k_buf.val[1][x]=k_buf.val[0][x];
                    win.val[1][0]=k_buf.val[0][x];
                    if(sy<srows-1&&sx<scols-1)
                    {
                        _src >> s;
                        k_buf.val[0][x]=s;
                        win.val[0][0]=k_buf.val[0][x];
                    }
                    else if(sx>=scols-1&&sy<srows-1){
                        k_buf.val[0][x]=s;//border
                    }
                    else if(sy>=srows-1){
                        win.val[0][0]=k_buf.val[0][x];
                    }
                }
                else
                {
                    for(int r= 0;r<2;r++)
                    {
                        win.val[r][0]=k_buf.val[r][x];
                    }
                }

                x++;
            }
            if(row_wr && col_wr)
            {
                for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
                {
                    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<15,1,SC_RND> ,4>::ACCUM_T t=0;
                    typedef typename fixed_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T SRCT;

                    t=((SRCT)win.val[1][1].val[k])*u1*v1+
                        ((SRCT)win.val[1][0].val[k])*v1*u+
                        ((SRCT)win.val[0][1].val[k])*u1*v+
                        ((SRCT)win.val[0][0].val[k])*u*v;
                    d.val[k]=sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(t);
                }
                _dst << d;
            }
        }
    }
}







template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, SRC_T> &_dst,
        int interpolation=1 )
{
    switch(interpolation) {
    case 0:
        (("hls::Resize: HLS_INTER_NEAREST not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_NEAREST not supported\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2439, __PRETTY_FUNCTION__));
        break;
    case 2:
        (("hls::Resize: HLS_INTER_AREA not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_AREA not supported\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2442, __PRETTY_FUNCTION__));
        break;
    case 4:
        (("hls::Resize: HLS_INTER_LANCZOS4 not supported") ? static_cast<void> (0) : __assert_fail ("\"hls::Resize: HLS_INTER_LANCZOS4 not supported\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2445, __PRETTY_FUNCTION__));
        break;
    case 3:
        Resize_opr_bicubic(_src,_dst);
        break;
    case 1:
        Resize_opr_linear(_src,_dst);
        break;
    }
}
//------------------
template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScale (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2467, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2468, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(_s.val[k]*alpha+beta);
            }
            _dst<<_d;
        }
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScaleAbs (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2496, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2497, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(abs(_s.val[k]*alpha+beta));
            }
            _dst<<_d;
        }
    }
}
template<int XORDER, int YORDER, int SIZE, typename T>
void Sobel_kernel(Window<SIZE,SIZE,T > &kernel)
{
    int kerI[SIZE+1];
    Window<1,SIZE,T> kernelX;
    Window<SIZE,1,T> kernelY;

    for(int k=0; k<2; k++)
    {
        int order = k == 0 ? XORDER : YORDER;

        if( SIZE==3 )
        {
            if(order==0 )
                kerI[0]=1, kerI[1]=2, kerI[2]=1;
            else if( order == 1 )
                kerI[0]=-1, kerI[1]=0, kerI[2]=1;
            else
                kerI[0]=1, kerI[1]=-2, kerI[2]=1;
        }
        else
        {
            int oldval, newval;
            kerI[0] = 1;
            for(int i=0; i<SIZE; i++)
                kerI[i+1] = 0;

            for(int i=0; i<SIZE-order-1; i++)
            {
                oldval = kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j]+kerI[j-1];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }

            for(int i = 0; i < order; i++ )
            {
                oldval = -kerI[0];
                for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j-1] - kerI[j];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }
        }

        for(int i=0; i<SIZE; i++) {
         if(k==0)
             kernelX(0,i)=kerI[i];
         else
             kernelY(i,0)=kerI[i];
     }
    }

    for(int i=0; i<SIZE; i++) {
        for(int j=0; j<SIZE; j++) {
            kernel(i,j)=kernelY(i,0)*kernelX(0,j);
     }
    }

}
//---------------sobel-------------------
template<int XORDER, int YORDER, int SIZE, typename BORDERMODE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
   (((SIZE==3 || SIZE==5||SIZE==7)) ? static_cast<void> (0) : __assert_fail ("(SIZE==3 || SIZE==5||SIZE==7)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2584, __PRETTY_FUNCTION__));

    Window<SIZE,SIZE,ap_int<8> > kernel;
    Sobel_kernel<XORDER, YORDER >(kernel);
    Point_<int> c_point;
    c_point.x=-1;
    c_point.y=-1;
    Filter2D<BORDERMODE>(_src,_dst,kernel, c_point);
}

template<int XORDER, int YORDER, int SIZE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
    Sobel<XORDER,YORDER,SIZE,BORDER_DEFAULT>(_src, _dst);
}

template<int KH,int KW,typename K_T,typename XT, typename YT>
void getGaussianKernel(
        Window<KH,KW,K_T> &kernel,
        XT sigmaX=0,
        YT sigmaY=0
        )
{
_ssdm_InlineSelf(2, "");
     float kval[KH][KW];
     float sum=0;
     if(sigmaX <= 0)
     {
         sigmaX=0.3*((KW-1)*0.5-1)+0.8;
     }
     if(sigmaY <= 0)
     {
         sigmaY=0.3*((KH-1)*0.5-1)+0.8;
     }
     for (int i = 0; i < KH; i++) {
            for (int j = 0; j < KW; j++) {
                float index1=powf( (i-(KH-1)/2),2)*1.0/(2*sigmaY*sigmaY);
                float index2=powf( (j-(KW-1)/2),2)*1.0/(2*sigmaX*sigmaX);
                float index= -index1-index2;
                kval[i][j] = expf(index);
                sum+=kval[i][j];
            }
        }
     for (int i = 0; i < KH; i++) {
         for (int j = 0; j < KW; j++) {
             kval[i][j]=kval[i][j]/sum;
             kernel.val[i][j]=kval[i][j];
         }
     }

}

template<int KH,int KW,typename BORDERMODE,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    Point_<int> anchor;
    anchor.x = -1;
    anchor.y = -1;
    Window<KW, KH, ap_fixed<16,2,SC_RND> > kernel;
    getGaussianKernel(kernel,sigmaX,sigmaY);
    Filter2D<BORDERMODE>(_src, _dst, kernel, anchor);
}

template<int KH,int KW,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    GaussianBlur<KH,KW,BORDER_DEFAULT>(_src, _dst, sigmaX, sigmaY);
}

//---------------BoxFilter-------------------
template <int KH,int KW>
void Box_kernel_1d(
        Window<1, KW, ap_ufixed<1,1> >& kernelX,
        Window<KH, 1, ap_ufixed<1,1> >& kernelY
        )
{
    float kval[KW];

    for (int i = 0; i < KW; i++) {
        kernelX.val[0][i] = 1;
    }

    for (int i = 0; i < KH; i++) {
        kernelY.val[i][0] = 1;
    }
}

template<int KH,int KW, bool NORMALIZE,typename BORDERMODE,
  int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    Window<1, KW, ap_ufixed<1,1> > kernelX;
    Window<KH, 1, ap_ufixed<1,1> > kernelY;
    Box_kernel_1d(kernelX,kernelY);

    if( NORMALIZE)
    {
        const int BW = BitWidth<KH*KW>::Value+Type<((SRC_T) & ((1 << 11) - 1))>::bitdepth;
        const ap_ufixed<BW+1,1> scale = 1.0/(KH*KW);
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor, scale);
    }
    else
    {
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor);
    }
}

template<int KH,int KW, typename BORDERMODE, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDERMODE>(_src, _dst, anchor);
}

template<int KH,int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDER_DEFAULT>(_src, _dst, anchor);
}

//-------------------------PyrUp---
template <typename T,typename FT, int KH,int KW>
void Pyr_kernel(
        Window<KH, KW, T>& kernel,
        FT factor
        )
{
    int k[25]={1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1};
    for(int i=0; i<5; i++)
        for(int j=0; j<5; j++)
            kernel.val[i][j]=k[i*5+j]*(1.0/256)*factor;
}
template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrUp_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2744, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2745, __PRETTY_FUNCTION__));
_ssdm_InlineSelf(0, "");
    // The main processing window
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // The main line buffer, case the border have to pre load so the row is K_HEIGHT rather than K_HEIGHT-1
    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // A small buffer keeping a few pixels from the line
    // buffer, so that we can complete right borders correctly.and avoid read k_buf port limit
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // Temporary storage for reading from the line buffers.
    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_< ap_int<14> > anchor;
    anchor.x=K_HEIGHT/2;
    anchor.y=K_WIDTH/2;
    ap_int<14> heightloop= 2*(rows+K_HEIGHT-1+K_HEIGHT);
    ap_int<14> widthloop = 2*(cols+K_WIDTH-1);//one pixel overlap, so it should minus one
    Point_<ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;
                ImagLoc.x=j/2-anchor.x; //fill data x,y are the coordinate in the image, it could be negative. For example (-1,-1) represents the interpolation pixel.
                ImagLoc.y=i/2-K_HEIGHT-anchor.y;
                int x= ImagLoc.x;
                if(ImagLoc.x<0)
                    x= -ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols- ImagLoc.x-1; // right and bottom insert 0 ,so border type is not 101
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    if(oddcol)
                    {
                        // column left shift
                        for(int row= 0;row<K_HEIGHT;row++)
                            for(int col= K_WIDTH-1;col>=1;col--)
                                src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                        for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                        {
                            // Fetch the column from the line buffer to shift into the window.
                            col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                        }

                        if((ImagLoc.y < (-anchor.y)) ||
                                (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 )) {
                            //Advance load and body process
                            if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0); //k_buf[k](K_HEIGHT-1,ImagLoc.x);
                                src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                                for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                {
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0); //k_buf[k](buf_row-1,ImagLoc.x);
                                    src_kernel_win[k](buf_row-1,0)=temp;
                                }
                                if(oddrow)
                                {
                                    if(ImagLoc.x >= cols - K_WIDTH)
                                    {
                                        right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                                    }
                                    for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                    {
                                        typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0); //k_buf[k](buf_row-1,ImagLoc.x);
                                        k_buf[k](buf_row,x)=temp;
                                        if(ImagLoc.x >= cols - K_WIDTH)
                                        {
                                            right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                        }
                                    }
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                                    _src.data_stream[k] >> temp;
                                    k_buf[k](0,x)=temp;
                                }
                            }
                            else if(ImagLoc.x < 0)
                            {
                                for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0); //k_buf[k](buf_row,x);
                                }
                            }
                            else if (ImagLoc.x >= cols) {
                                for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH)); //col_buf[k](buf_row+1,0); //k_buf[k](buf_row+1,x);
                                }
                                if(!oddrow)
                                {
                                   for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                     src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                                }

                            }
                        }
                        else if(ImagLoc.y > 0 )
                        {
                            ap_int<14> ref = K_HEIGHT-1;
                            if(ImagLoc.y >= rows-1)
                                ref = rows-1;
                            ap_int<14> y = ImagLoc.y;
                            for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                            {
                                ap_int<14> t=y;
                                if(y<0)
                                    t=-y;
                                else if( y >= rows )
                                    t=2*rows-y-1;

                                ap_int<14> locy = ref - t;
                                src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                                y--;
                            }
                           if(ImagLoc.y >= rows-1&&!oddrow)
                            {
                                for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                   src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                            }
                        }

                    }
                    // figure out the output image pixel value
                    if(i >= 2*(K_HEIGHT + K_HEIGHT - 1) && j >= 2*(K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, K_HEIGHT*K_WIDTH>::ACCUM_T result=0;
                        if(oddrow)
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n];
                            }
                            else
                            {
                                for(int m=0; m<K_HEIGHT; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n-1];
                            }
                        }else
                        {
                            if(oddcol)
                            {
                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n];
                            }
                            else
                            {

                                for(int m=0; m<K_HEIGHT-1; m++)
                                    for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n-1];
                            }
                        }
                        _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrUp(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    ((_src.rows*2== _dst.rows && _src.cols*2==_dst.cols) ? static_cast<void> (0) : __assert_fail ("_src.rows*2== _dst.rows && _src.cols*2==_dst.cols", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2923, __PRETTY_FUNCTION__));
    Window<5, 5, ap_fixed<16,2,SC_RND> > kernel;
    Pyr_kernel(kernel, 4);
    PyrUp_opr<3,3>(_src, _dst, kernel);
}
//-----------------------PyrDown----------
template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrDown_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
      (((_src.rows+1)/2== _dst.rows && (_src.cols+1)/2==_dst.cols) ? static_cast<void> (0) : __assert_fail ("(_src.rows+1)/2== _dst.rows && (_src.cols+1)/2==_dst.cols", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2937, __PRETTY_FUNCTION__));
_ssdm_InlineSelf(0, "");
    // The main processing window
    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // The main line buffer
    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // A small buffer keeping a few pixels from the line
    // buffer, so that we can complete right borders correctly.
    LineBuffer<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    // Temporary storage for reading from the line buffers.
    LineBuffer<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

_ssdm_SpecArrayPartition( col_buf, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &kernel, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( src_kernel_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( k_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( right_border_buf, 0, "COMPLETE", 0, "");

    Point_< ap_int<4> > anchor;// -1 ~3
    anchor.x=K_WIDTH/2;
    anchor.y=K_HEIGHT/2;

    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2961, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 2962, __PRETTY_FUNCTION__));
    HLS_SIZE_T heightloop= rows+K_HEIGHT-1+K_HEIGHT;
    HLS_SIZE_T widthloop = cols+K_WIDTH-1;//one pixel overlap, so it should minus one
    Point_< ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
                bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;
                //fill data x,y are the coordinate in the image, it could be negative. For example (-1,-1) represents the interpolation pixel.
                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-K_HEIGHT-anchor.y;
                int x=ImagLoc.x ;
                if(ImagLoc.x<0)
                    x=-ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols-ImagLoc.x-2;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    // column left shift
                    for(int row= 0;row<K_HEIGHT;row++)
                        for(int col= K_WIDTH-1;col>=1;col--)
                            src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                    for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                    {
                        // Fetch the column from the line buffer to shift into the window.
                        col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                    }
                    if((ImagLoc.y < (-anchor.y)) ||
                            (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 ))
                    {
                        //Advance load and body process
                        if(ImagLoc.x >= 0 && ImagLoc.x < cols)
                        {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0); //k_buf[k](K_HEIGHT-1,ImagLoc.x);
                            src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                            if(ImagLoc.x >= cols - K_WIDTH)
                            {
                                right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                            }
                            for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                            {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0); //k_buf[k](buf_row-1,ImagLoc.x);
                                src_kernel_win[k](buf_row-1,0)=temp;
                                k_buf[k](buf_row,x)=temp;
                                if(ImagLoc.x >= cols - K_WIDTH)
                                {
                                    right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                }
                            }
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                            _src.data_stream[k] >> temp;
                            k_buf[k](0,x)=temp;
                        }
                        else if(ImagLoc.x < 0)
                        {
                            for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0); //k_buf[k](buf_row,x);
                            }
                        }
                        else if (ImagLoc.x >= cols)
                        {
                            for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH)); //col_buf[k](buf_row+1,0); //k_buf[k](buf_row+1,x);
                            }
                        }
                    }
                    else if(ImagLoc.y >= 0) {

                        ap_int<14> ref = K_HEIGHT-1;
                        if(ImagLoc.y >= rows-1)
                            ref = rows-1;
                        ap_int<14> y = ImagLoc.y;
                        for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                        {
                            ap_int<14> t = y;
                            if(y<0)
                                t=-y;
                            else if( y>= rows )
                                t=2*rows-y-2;
                            ap_int<14> locy = ref - t;
                            ((t < 0 || (locy >= 0 && locy < K_HEIGHT)) ? static_cast<void> (0) : __assert_fail ("t < 0 || (locy >= 0 && locy < K_HEIGHT)", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_imgproc.h", 3050, __PRETTY_FUNCTION__));
                            src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                            y--;
                        }
                    }
                    // figure out the output image pixel value
                    if(i >= (K_HEIGHT + K_HEIGHT - 1) && j >= (K_WIDTH-1)) // && i < heightloop && j < widthloop)
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, 5*5>::ACCUM_T result=0;
                        if(!oddrow&&oddcol)
                        {
                            for(int m=0; m<K_HEIGHT; m++)
                                for(int n=0; n<K_WIDTH; n++)
                                    result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[m][n];
                            _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                        }
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrDown(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    Window<5, 5, ap_fixed<16,2,SC_RND> > kernel;
    Pyr_kernel(kernel, 1);
    PyrDown_opr<5,5>(_src, _dst, kernel);
}

}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 63 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_histogram.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_histogram.h"
namespace hls {

template<int SRC_T, int DST_T,int ROW, int COL, int N>
void Equalize(
 Mat<ROW, COL, SRC_T> &_src,
 Mat<ROW, COL, DST_T> &_dst,
    ap_uint<8> (&map)[N]
                      )
{
    // Assumed 8 bits per pixel
    const int NUM_STATES=4; // must be a even num
    Window<1,NUM_STATES,ap_uint<8> > addr_win;
    // The histogram needs to be able to count up to the number of pixels in the image.
    ap_uint<BitWidth<ROW*COL>::Value> hist_out[N];
    Window<1,NUM_STATES,ap_uint<BitWidth<ROW*COL>::Value> > hist_win;
    ap_uint<BitWidth<ROW*COL>::Value> hist;
    ap_uint<8> addr;
    ap_uint<8> addr_last;
    ap_uint<BitWidth<ROW*COL>::Value> hist_last;
    ap_uint<8> addr_flag;
    ap_uint<BitWidth<ROW*COL>::Value> hist_flag;
    ap_uint<8> addr_w;
    ap_uint<BitWidth<ROW*COL>::Value> hist_w;

    for(int i=0;i<NUM_STATES;i++) {
    _ssdm_Unroll(0,0,0, "");
        addr_win(0,i)=i;// initialize with NUM_STATES different address
        hist_win(0,i)=0;
    }

    for(int i=0;i<N;i++)
        hist_out[i]=0;

    int cols=_src.cols;
    int rows=_src.rows;
    ((rows<=ROW) ? static_cast<void> (0) : __assert_fail ("rows<=ROW", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_histogram.h", 74, __PRETTY_FUNCTION__));
    ((cols<=COL) ? static_cast<void> (0) : __assert_fail ("cols<=COL", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_histogram.h", 75, __PRETTY_FUNCTION__));
 loop_height: for(int i=0;i<rows;i++)
    {
    loop_width: for(int j=0;j<cols;j++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            ap_uint<4> flag=NUM_STATES;
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name tempsrc=0;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name tempdst=0;
            _src.data_stream[0].read(tempsrc);
            tempdst=map[tempsrc];
            _dst.data_stream[0]<<tempdst;

            for (int m=0; m<NUM_STATES; m++) {
                if (tempsrc==addr_win(0,m)) {
                    flag = m;
                    break;
                }
            }

            latency_region:{
            _ssdm_op_SpecLatency(0, 1, "");
            addr_last = addr_win(0,NUM_STATES-1);
            hist_last = hist_win(0,NUM_STATES-1)+1;

            for (int m=NUM_STATES-1; m>0; m--) {
                addr = addr_win(0,m-1);
                hist = hist_win(0,m-1);
                if (m==NUM_STATES/2) {
                    addr_w = addr;
                    if (m==flag+1) {
                        hist_w = hist+1;
                    } else {
                        hist_w = hist;
                    }
                }
                if (m==flag+1) {
                    addr_flag = addr;
                    hist_flag = hist+1;
                    addr_win(0,m) = addr_flag;
                    hist_win(0,m) = hist_flag;
                } else {
                    addr_win(0,m) = addr;
                    hist_win(0,m) = hist;
                }
            }

            if (flag==NUM_STATES) {
                hist_win(0,0) = hist_out[tempsrc]+1;
                addr_win(0,0) = tempsrc;
            } else if (flag==NUM_STATES-1) {
                addr_win(0,0) = addr_last;
                hist_win(0,0) = hist_last;
            } else if (flag>=NUM_STATES/2) {
                addr_win(0,0) = addr_flag;
                hist_win(0,0) = hist_flag;
            } else {
                addr_win(0,0) = addr_w;
                hist_win(0,0) = hist_w;
            }

            hist_out[addr_w] = hist_w;
            }//latency
        }
    }
    for (int m=0; m<NUM_STATES/2; m++) {
    _ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
        hist_out[addr_win(0,m)]=hist_win(0,m);
    }

    // floating point probably makes sense here, because cols*rows could be large or small.
    // This could probably be only 8 mantissa bits or so, though.
    float scale = 1.f; //255.0f/(cols*rows);
    ap_uint<BitWidth<ROW*COL>::Value> sum=0;
    bool flag = false;
 loop_normalize: for(int i=0;i<N;i++)
    {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
        // to keep consistent with opencv's implementation
        if (!flag) {
            if (hist_out[i] != 0) {
                flag = true;
                scale = 255.0f/(cols*rows - hist_out[i]);
                map[i] = 0;
                continue;
            }
        }

        sum+=hist_out[i];
        ap_uint<8> val=sr_cast< ap_uint<8> > (sum*scale);
        map[i]=val;
    }
    map[0]=0;
}

static ap_uint<8> lut[256];
template<int SRC_T, int DST_T,int ROW, int COL>
void EqualizeHist(
  Mat<ROW, COL, SRC_T> &_src,
  Mat<ROW, COL, DST_T> &_dst)
{
_ssdm_InlineSelf(0, "");
    Equalize(_src, _dst, lut);
}
}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 64 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/
# 39 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h"
namespace hls {

    template<int PSize,int KERNEL_SIZE,int NUM,typename SRC_T, typename DIFF_T>
int fast_pixel_diff(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> &win,
        SRC_T _threshold,
        ap_uint<2> (&flag_val)[NUM], // Either 0,1 or 2 depending on the threshold.
        DIFF_T (&flag_d)[NUM], // The difference between the center pixel and the pixel
        int (&flag)[PSize][2]) // The coordinate of the pixel
{
_ssdm_InlineSelf(0, "");
    DIFF_T d1,d2;
    int vt1,vt2;
    int x1,x2,y1,y2; // These are coordinates
    int result=3;
    int K=PSize/2;
    for(int index=0;index<K;index++) {
        int kernel_half=KERNEL_SIZE/2;
        x1=flag[index][0];
        y1=flag[index][1];
        x2=flag[index+K][0];
        y2=flag[index+K][1];
        d1=win.val[kernel_half][kernel_half]-win.val[ y1 ][ x1 ];
        d2=win.val[kernel_half][kernel_half]-win.val[ y2 ][ x2 ];
        flag_d[index]=d1;
        flag_d[index+K]=d2;
        flag_d[index+PSize]=d1;
        if (d1 > _threshold)
            vt1=1;
        else if(d1 < -_threshold)
            vt1=2;
        else
            vt1=0;
        if (d2 > _threshold)
            vt2=1;
        else if(d2 < -_threshold)
            vt2=2;
        else
            vt2=0;
        result &= vt1 | vt2;
        flag_val[index] = vt1;
        flag_val[index+K] = vt2;
        flag_val[index+PSize] = vt1;
    }
    flag_val[PSize/2+PSize] = flag_val[PSize/2];
    flag_d[PSize/2+PSize] = flag_d[PSize/2];
    return result;
}

    template<int PSize,int NUM, typename DIFF_T, typename SRC_T>
int coreScore(DIFF_T (&flag_d)[NUM], SRC_T _threshold)
{
_ssdm_InlineSelf(0, "");

    DIFF_T flag_d_min2[NUM-1];
    DIFF_T flag_d_max2[NUM-1];
    DIFF_T flag_d_min4[NUM-3];
    DIFF_T flag_d_max4[NUM-3];
    DIFF_T flag_d_min8[NUM-7];
    DIFF_T flag_d_max8[NUM-7];
_ssdm_SpecArrayPartition( flag_d_min2, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_max2, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_min4, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d_max4, 0, "complete", 0, "");
    if(PSize == 16) {
        for(int i=0;i<NUM-1;i++) {
            flag_d_min2[i] = reg(((flag_d[i]) < (flag_d[i+1]) ? (flag_d[i]) : (flag_d[i+1])));
            flag_d_max2[i] = reg(((flag_d[i]) > (flag_d[i+1]) ? (flag_d[i]) : (flag_d[i+1])));
        }
        for(int i=0;i<NUM-3;i++) {
            flag_d_min4[i] = reg(((flag_d_min2[i]) < (flag_d_min2[i+2]) ? (flag_d_min2[i]) : (flag_d_min2[i+2])));
            flag_d_max4[i] = reg(((flag_d_max2[i]) > (flag_d_max2[i+2]) ? (flag_d_max2[i]) : (flag_d_max2[i+2])));
        }

        for(int i=0;i<NUM-7;i++) {
            flag_d_min8[i] = reg(((flag_d_min4[i]) < (flag_d_min4[i+4]) ? (flag_d_min4[i]) : (flag_d_min4[i+4])));
            flag_d_max8[i] = reg(((flag_d_max4[i]) > (flag_d_max4[i+4]) ? (flag_d_max4[i]) : (flag_d_max4[i+4])));
        }
    } else {
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 118, __PRETTY_FUNCTION__));
    }

    DIFF_T a0 = _threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T a = hls::numeric_limits<DIFF_T>::max();
        if(PSize == 16) {
            a = flag_d_min8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                a=((a) < (flag_d[i+j]) ? (a) : (flag_d[i+j]));
            }
        }
        a0 = ((a0) > (((a) < (flag_d[i]) ? (a) : (flag_d[i]))) ? (a0) : (((a) < (flag_d[i]) ? (a) : (flag_d[i]))));
        a0 = ((a0) > (((a) < (flag_d[i+PSize/2 +1]) ? (a) : (flag_d[i+PSize/2 +1]))) ? (a0) : (((a) < (flag_d[i+PSize/2 +1]) ? (a) : (flag_d[i+PSize/2 +1]))));
    }
    DIFF_T b0 = -_threshold;
    for(int i=0;i<PSize;i+=2) {
        DIFF_T b = hls::numeric_limits<DIFF_T>::min();
        if(PSize == 16) {
            b = flag_d_max8[i+1];
        } else {
            for(int j=1;j<PSize/2+1;j++) {
                b=((b) > (flag_d[i+j]) ? (b) : (flag_d[i+j]));
            }
        }
        b0 = ((b0) < (((b) > (flag_d[i]) ? (b) : (flag_d[i]))) ? (b0) : (((b) > (flag_d[i]) ? (b) : (flag_d[i]))));
        b0 = ((b0) < (((b) > (flag_d[i+PSize/2 +1]) ? (b) : (flag_d[i+PSize/2 +1]))) ? (b0) : (((b) > (flag_d[i+PSize/2 +1]) ? (b) : (flag_d[i+PSize/2 +1]))));
    }
    return ((a0) > ((DIFF_T)-b0) ? (a0) : ((DIFF_T)-b0))-1;
}

template<int PSize,int KERNEL_SIZE,typename SRC_T, typename DIFF_T>
bool fast_judge(Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & win,
                SRC_T _threshold,
                ap_uint<2> (&flag_val)[PSize+PSize/2+1],
                DIFF_T (&flag_d)[PSize+PSize/2+1],
                int (&flag)[PSize][2], // Coordinates to use in comparison
                int &core,
                bool _nonmax_supression) {
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");

_ssdm_InlineSelf(0, "");
    bool iscorner=false;
    int kernel_half=KERNEL_SIZE/2;
    int result=fast_pixel_diff<PSize>(win,_threshold,flag_val,flag_d,flag);
    int count=1;
    for(int c=1;c<PSize+PSize/2+1;c++)
    {
        if(flag_val[c-1]==flag_val[c] && flag_val[c]>0)
        {
            count++;
            if(count>PSize/2)
            {
                iscorner=true;
            }
        }
        else
        {
            count=1;
        }
    }
    if(_nonmax_supression && iscorner) {
        core=coreScore<PSize>(flag_d,_threshold);
    }
    return iscorner;
}
template<int KERNEL_SIZE,typename SRC_T>
bool fast_nonmax(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & core_win
        )
{
_ssdm_InlineSelf(0, "");
    bool iscorner=true;
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[0][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[2][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    if(core_win.val[1][1]>core_win.val[1][0]&&core_win.val[1][1]>core_win.val[1][2])
        iscorner=iscorner && true;
    else
        iscorner=iscorner && false;
    return iscorner;
}
//generate mask
template<int PSize,int KERNEL_SIZE,int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]) {
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<(((((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((512 - 1) << 11)) >> 11) + 1),typename Type<(((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 228, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 229, __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");

    int index=0;
    int offset=KERNEL_SIZE/2;
    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            if((i<rows&&j<cols)) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];//column left shift
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }
                //-------
                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }
            //------core
            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];//column left shift
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;
            //output
            //if(i>=KERNEL_SIZE-1&&j>=KERNEL_SIZE-1)
            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {
                //process
                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    d.val[0]=255;
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(core_win.val[1][1]!=0&&i>=KERNEL_SIZE&&j>=KERNEL_SIZE)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                        d.val[0]=255;
                    }
                }
            }

            if(i>=offset&&j>=offset)
            {
                _mask<<d;
            }
        }
    }
}
template<int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
_ssdm_InlineSelf(0, "");
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_mask,_threshold,_nomax_supression,flag);
}
//generate array 
template<int PSize,int KERNEL_SIZE,typename T, int N, int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]
        )
{
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 345, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 346, __PRETTY_FUNCTION__));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
_ssdm_SpecArrayPartition( flag_val, 0, "complete", 0, "");
_ssdm_SpecArrayPartition( flag_d, 0, "complete", 0, "");
    int index=0;
    int offset=KERNEL_SIZE/2;

    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            if(i<rows&&j<cols) {
                for(int r= 0;r<KERNEL_SIZE;r++) {
                    for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];//column left shift
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }
                //-------
                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }
            //------core
            for(int r= 0;r<3;r++)
            {
                for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];//column left shift
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;
            //output
            //if(i>=KERNEL_SIZE-1&&j>=KERNEL_SIZE-1)
            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {
                //process
                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    if(index<N)
                    {
                    _keypoints[index].x=j-offset;
                    _keypoints[index].y=i-offset;
                    index++;
                    }
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(i>=KERNEL_SIZE&&j>=KERNEL_SIZE&&core_win.val[1][1]!=0)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                    if(index<N)
                    {
                        _keypoints[index].x=j-offset;
                        _keypoints[index].y=i-offset;
                        index++;
                    }
                    }
                }
            }

        }
    }
}
template<typename T, int N, int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
_ssdm_InlineSelf(0, "");
    int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_keypoints,_threshold,_nomax_supression,flag);
}
template<int SRC_T,int MASK_T,int ROWS,int COLS>
void PaintMask(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,MASK_T> &_mask,
        Mat<ROWS,COLS,SRC_T> &_dst,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _color
        )
{
    ((_src.rows == _mask.rows) ? static_cast<void> (0) : __assert_fail ("_src.rows == _mask.rows", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 457, __PRETTY_FUNCTION__));
    ((_src.rows == _dst.rows) ? static_cast<void> (0) : __assert_fail ("_src.rows == _dst.rows", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 458, __PRETTY_FUNCTION__));
    ((_src.cols == _mask.cols) ? static_cast<void> (0) : __assert_fail ("_src.cols == _mask.cols", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 459, __PRETTY_FUNCTION__));
    ((_src.cols == _dst.cols) ? static_cast<void> (0) : __assert_fail ("_src.cols == _dst.cols", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 460, __PRETTY_FUNCTION__));
    int rows= _src.rows;
    int cols= _src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 463, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_fast.h", 464, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MASK_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MASK_T) & ((1 << 11) - 1))>::name> m;
 loop_height: for(HLS_SIZE_T i=0;i<rows;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols;j++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            _src >> s;
            _mask >> m;
            if(m.val[0]!=0)
            {
                d = _color;
            }
            else
            {
                d = s;
            }
            _dst << d;
        }
    }
}
}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 65 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/
# 83 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
namespace hls {

template <int N, typename T,typename PT>
void LU( T A[N][N], PT pos[N])
{_ssdm_SpecArrayDimSize(A,N);_ssdm_SpecArrayDimSize(pos,N);
    int imax = 0;
    T lu[N] ;
    for (int i = 0; i < N; i++)
    {
        lu[i]=0;
    }
    for (int i = 0; i < N; i++) {
        T big = 0.0;
        for (int j = 0; j < N; j++) {
            T temp = ::hls::abs((double)A[i][j]);
            if (temp > big) big = temp;
        }
        lu[i] = ((T)1.0)/big;
    }
    for (int j = 0; j < N; j++) {
        for (int i = 0; i < j; i++) {
            T sum = A[i][j];
            for (int k = 0; k < i; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
        }
        T big = 0.0;
        for (int i = j; i < N; i++) {
            T sum = A[i][j];
            for (int k = 0; k < j; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
            T dum = lu[i] *((T) ::hls::abs((double)sum));
            if (dum >= big) {
                big = dum;
                imax = i;
            }
        }
        if (j != imax&&imax<N&&imax>=0) {
            for (int i = 0; i < N; i++) {
                T mid = A[imax][i];
                A[imax][i] = A[j][i];
                A[j][i] = mid;
            }
            T mid = lu[j];
            lu[j] = lu[imax];
            lu[imax] = mid;
        }
        pos[j] = imax;
        if (j != N - 1) {
            T dum = ((T)1.0)/(A[j][j]);
            for (int i = j + 1; i < N; i++) A[i][j] *= dum;
        }
    }
}
template <int N, typename T, typename PT,typename BT>
void LUex(T A[N][N], PT pos[N],BT b[N])
{_ssdm_SpecArrayDimSize(A,N);_ssdm_SpecArrayDimSize(b,N);_ssdm_SpecArrayDimSize(pos,N);
    int ii = 0;
    for (int i = 0; i < N; i++) {
        int ip = pos[i];
        T sum=0;
        if(ip<N&& ip>=0)
        {
            sum = b[ip];
            b[ip] = b[i];
        }
        if (ii != 0)
            for (int j = ii - 1; j < i; j++) sum -= A[i][j] * b[j];
        else
            ii = i + 1;
        b[i] = sum;
    }
    for (int i = N - 1; i >= 0; i--) {
        T sum = b[i];
        for (int j = i + 1; j < N; j++) sum -= A[i][j]*b[j];
        b[i] = (sum)*((T) 1.0/A[i][i]);
    }
}


template <int N,typename T>
void Invert(T A[N][N],T Ar[N][N], int flags=0)
{_ssdm_SpecArrayDimSize(A,N);_ssdm_SpecArrayDimSize(Ar,N);
    T b[N];
    int pos[N];
    for (int i = 0; i < N; i++) {
        b[i]=0;
        pos[i]=0;
    }
    LU<N>(A,pos);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) b[j] = 0;
        b[i] = 1.0;
        LUex<N>(A,pos,b);
        for (int j = 0; j < N; j++) Ar[j][i] = b[j];
    }
}
template<int AROW, int ACOL, int BCOL, typename AT, typename BT, typename CT>
void mul(
               AT A [AROW][ ACOL],
               BT B [AROW][ BCOL],
               CT C [AROW][ BCOL]
)
{_ssdm_SpecArrayDimSize(A,AROW);_ssdm_SpecArrayDimSize(B,AROW);_ssdm_SpecArrayDimSize(C,AROW);
 loop_i: for(int i=0; i<AROW; i++)
    {
    loop_j: for(int j=0; j<BCOL; j++)
        {
            CT sum=0;
        loop_k: for(int k=0; k<ACOL; k++)
                {
                sum=sum+A[i][k]*B[k][j];

            }
            C[i][j]=sum;
        }
    }
}





template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_nearest(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2
        //int bordertype=BORDER_CONSTANT
        //const Scalar<HLS_MAT_CN(SRC_T),HLS_NAME_MAT(SRC_T)> borderValue
        )
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW][COLS];
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 222, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 223, __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
_ssdm_SpecLoopFlatten(1, "");
    loop_width: for( int j=0; j< cols; j++)
        {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            buf[i % WIN_ROW][j] = s;
            r[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0]+1; // OpenCV is off by one?
                int y=m1.val[1]+1;

                bool in_range = (y>=0 && y<rows && r[y%WIN_ROW] == y && x>=0 && x<cols);
                if(in_range) {
                    d = buf[y%WIN_ROW][x];
                } else {
                    for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                        d.val[k]=0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_linear(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2
        //int bordertype=BORDER_CONSTANT
        //const Scalar<HLS_MAT_CN(SRC_T),HLS_NAME_MAT(SRC_T)> borderValue
        )
{
    // Add one to always get zero for boundary interpolation. Maybe need initialization here?
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW/2+1][2][COLS/2+1][2];
_ssdm_SpecArrayPartition( buf, 2, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( buf, 4, "COMPLETE", 0, "");
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 281, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 282, __PRETTY_FUNCTION__));
    int ishift=WIN_ROW/2;
    int r1[WIN_ROW] = {};
    int r2[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
_ssdm_SpecLoopFlatten(1, "");
    loop_width: for( int j=0; j< cols; j++)
        {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            if(i<rows&& j<cols)
            {
                src >> s;
            }
            if((i % WIN_ROW) % 2) {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            } else {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            }
            r1[i % WIN_ROW] = i;
            r2[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0];
                int y=m1.val[1];

                int ynext = y+1;

                ap_ufixed<5, 0> iu, iv;
                iu(5 -1, 0) = m2.val[0] & (32 -1);
                iv(5 -1, 0) = (m2.val[0] >> 5) & (32 -1);

                // Note that the range here is larger than expected by 1 horizontal and 1 vertical pixel, to allow
                // Interpolating at the edge of the image
                bool in_range = (y>=0 && y<rows && r1[y%WIN_ROW] == y && r2[ynext%WIN_ROW] == ynext && x>=0 && x<cols);

                int xa0, xa1, ya0, ya1;
                // The buffer is essentially cyclic partitioned, but we have
                // to do this manually because HLS can't figure it out.
                // The code below is wierd, but it is this code expanded.
               //  if ((y % WIN_ROW) % 2) {
//                     // Case 1, where y hits in bank 1 and ynext in bank 0
//                     ya0 = (ynext%WIN_ROW)/2;
//                     ya1 = (y%WIN_ROW)/2;
//                 } else {
//                     // The simpler case, where y hits in bank 0 and ynext hits in bank 1
//                     ya0 = (y%WIN_ROW)/2;
//                     ya1 = (ynext%WIN_ROW)/2;
//                 }
                // Both cases reduce to this, if WIN_ROW is a power of two.
                ((((WIN_ROW & (WIN_ROW-1)) == 0) && "WIN_ROW must be a power of two") ? static_cast<void> (0) : __assert_fail ("((WIN_ROW & (WIN_ROW-1)) == 0) && \"WIN_ROW must be a power of two\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 337, __PRETTY_FUNCTION__));
                xa0 = x/2 + x%2;
                xa1 = x/2;
                ya0 = (y/2 + y%2)%(WIN_ROW/2);
                ya1 = (y/2)%(WIN_ROW/2);

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d00,d01,d10,d11;
                d00=buf[ya0][0][xa0][0];
                d01=buf[ya0][0][xa1][1];
                d10=buf[ya1][1][xa0][0];
                d11=buf[ya1][1][xa1][1];

                if(x%2) {
                    std::swap(d00,d01);
                    std::swap(d10,d11);
                }
                if(y%2) {
                    std::swap(d00,d10);
                    std::swap(d01,d11);
                }
                ap_ufixed<2*5 + 1, 1> k01 = (1-iv)*( iu); // iu-iu*iv
                ap_ufixed<2*5 + 1, 1> k10 = ( iv)*(1-iu); // iv-iu*iv
                ap_ufixed<2*5 + 1, 1> k11 = ( iv)*( iu); // iu*iv
                ap_ufixed<2*5 + 1, 1> k00 = 1-iv-k01; //(1-iv)*(1-iu) = 1-iu-iv+iu*iv = 1-iv-k01
                ((k00 + k01 + k10 + k11 == 1) ? static_cast<void> (0) : __assert_fail ("k00 + k01 + k10 + k11 == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 361, __PRETTY_FUNCTION__));

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;

                for(int k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    if(in_range) {
                        d.val[k] =
                            d00.val[k] * k00 +
                            d01.val[k] * k01 +
                            d10.val[k] * k10 +
                            d11.val[k] * k11;
                    } else {
                        d.val[k] = 0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2,
           int interpolation=0
        //int bordertype=BORDER_CONSTANT
        //const Scalar<HLS_MAT_CN(SRC_T),HLS_NAME_MAT(SRC_T)> borderValue
        )
{
    if(interpolation==0) {
        Remap_nearest<WIN_ROW>(src, dst, map1, map2);
    } else if(interpolation==1) {
        Remap_linear<WIN_ROW>(src, dst, map1, map2);
    }
}

//#define DEBUG

template <typename T>
class RangeAnalyzer {
public:
# 416 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
 void operator ()(T x) {};


    //    friend std::ostream& operator<<(std::ostream& os, const RangeAnalyzer<T>& ra);
};
# 437 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
// Approximation of 1/x around x=1.
// In most cases (e.g. float), we just do computation in type T.
template<typename T>
T one_over_x_approx(T x) {
    return T(1.0)/x;
}

// if x is ~ 1+delta, then 1/x is 1-delta+..., or 2-x;
template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_x_approx(ap_fixed<W,I,Q,O> x) {
    return 2-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 2-x;
}

// Approximation of 1/(1+x) around x=0.
// In most cases (e.g. float), we just do computation in type T.
template<typename T>
T one_over_one_plus_x_approx(T x) {
    return T(1.0)/(T(1.0)+x);
}

// if x is ~ 1+delta, then 1/x is 1-delta+delta^2-...
template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_one_plus_x_approx(ap_fixed<W,I,Q,O> x) {
    return 1-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_one_plus_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 1-x;
}

template <typename FRAMET, typename FRAME2T, typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, typename CMT, typename DT, typename ICMT, int N>
void computeUndistortCoordinates(Window<3,3, CMT> cameraMatrix,
                                 DT (&distCoeffs)[N],
                                 Window<3,3, ICMT> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];


    // FRAMET is the type of normalized coordinates.
    // If IR is float, then FRAMET will also be float
    // If IR is ap_fixed, then FRAMET will be some ap_fixed type with more integer bits
    //             typedef typename x_traits<typename x_traits<ROWT,ICMT>::MULT_T,
    //                                       typename x_traits<COLT,ICMT>::MULT_T >::ADD_T FRAMET;
    //    typedef ap_fixed<18,2, AP_TRN, AP_SAT> FRAMET; // Assume frame coordinates are in [-1,1)
    //    typedef CMT FRAMET;
    //typedef float FRAMET;

    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    float x_gold = ((float)i*(float)ir.val[0][1] + (float)j*(float)ir.val[0][0] + (float)ir.val[0][2]);
    if(noRotation) {
        // A special case if there is no rotation: equivalent to cv::initUndistortMap
        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        FRAMET winv = one_over_x_approx(w);
        float winv_gold = 1.0f/((float)i*(float)ir.val[2][1] + (float)j*(float)ir.val[2][0] + (float)ir.val[2][2]);





        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
        x_gold = x_gold*winv_gold;
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y; // Full precision result here.
    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    FRAME2T krd = FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2;

    if(N >5) kr = kr*one_over_one_plus_x_approx(krd);

    float kr_gold = (1 + (((float)k3*(float)r2 + (float)k2)*(float)r2 + (float)k1)*(float)r2)/
                    (1 + (((float)k6*(float)r2 + (float)k5)*(float)r2 + (float)k4)*(float)r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 556 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
}

template <typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, int N>
void computeUndistortCoordinatesRef(Window<3,3, float> cameraMatrix,
                                 float (&distCoeffs)[N],
                                 Window<3,3, float> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {
    typedef float DT;
    typedef float CMT;
    typedef float FRAMET;
    typedef float FRAME2T;

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];


    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    if(noRotation) {
        // A special case if there is no rotation: equivalent to cv::initUndistortMap
        ((ir.val[2][0] == 0) ? static_cast<void> (0) : __assert_fail ("ir.val[2][0] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 591, __PRETTY_FUNCTION__));
        ((ir.val[2][1] == 0) ? static_cast<void> (0) : __assert_fail ("ir.val[2][1] == 0", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 592, __PRETTY_FUNCTION__));
        ((ir.val[2][1] == 1) ? static_cast<void> (0) : __assert_fail ("ir.val[2][1] == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 593, __PRETTY_FUNCTION__));
        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        float winv = 1.0f/w;




        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y; // Full precision result here.

    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    if(N >5) kr = kr/
        (1 + FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 632 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
}

template<typename T>
struct InitUndistortRectifyMap_traits {
    typedef T FRAMET;
    typedef T FRAME2T;
};

template<int W, int I>
struct InitUndistortRectifyMap_traits<ap_fixed<W,I> > {
    typedef ap_fixed<18,2> FRAMET;
    typedef ap_fixed<23,4,SC_RND,SC_SAT> FRAME2T;
};
template<typename CMT, typename DT, typename ICMT, int ROWS, int COLS, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMapInverse (
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, ICMT> ir,
                            Mat<ROWS, COLS, MAP1_T> &map1,
                            Mat<ROWS, COLS, MAP2_T> &map2,
                            int noRotation=false)
{
_ssdm_SpecArrayPartition( distCoeffs, 1, "COMPLETE", 0, "");
    int rows= map1.rows;
    int cols= map1.cols;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;

    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 660, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 661, __PRETTY_FUNCTION__));

    static RangeAnalyzer<float> rau, rav;
    static RangeAnalyzer<float> rauerr, raverr;

 loop_height: for(int i=0; i< rows; i++) {
    loop_width: for(int j=0; j< cols; j++) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            typedef ap_uint<BitWidth<ROWS>::Value> ROWT;
            typedef ap_uint<BitWidth<COLS>::Value> COLT;
            ROWT ifixed = i;
            COLT jfixed = j;

            ap_fixed<1+BitWidth<COLS>::Value+5, 1+BitWidth<COLS>::Value, SC_RND, SC_SAT> u;
            ap_fixed<1+BitWidth<ROWS>::Value+5, 1+BitWidth<ROWS>::Value, SC_RND, SC_SAT> v;
            computeUndistortCoordinates
                <typename InitUndistortRectifyMap_traits<CMT>::FRAMET, typename InitUndistortRectifyMap_traits<CMT>::FRAME2T>
                (cameraMatrix, distCoeffs, ir, noRotation,ifixed,jfixed,u,v);
# 700 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h"
 ((MAP1_T==(((3) & ((1 << 11) - 1)) + (((2)-1) << 11))) ? static_cast<void> (0) : __assert_fail ("MAP1_T==(((3) & ((1 << 11) - 1)) + (((2)-1) << 11))", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_undistort.h", 700, __PRETTY_FUNCTION__));
            {
                int iu = sr_cast<int>(u*32);
                int iv = sr_cast<int>(v*32);
                m1.val[0]=(iu >> 5);
                m1.val[1]=(iv >> 5);
                m2.val[0]=(unsigned short)((iv &(32 -1))*32 + (iu & (32 -1)));
            }
//             else
//             {
//                 m1.val[0]=sr_cast<HLS_TNAME(MAP1_T)>(u);
//                 m1.val[1]=sr_cast<HLS_TNAME(MAP1_T)>(v);

//             }
            map1<< m1;
            map2<< m2;
        }
    }







}
template< typename CMT, typename RT, typename DT, int ROWS, int COL, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMap(
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, RT> R,
                            Window<3,3, CMT> newcameraMatrix,
                            Mat<ROWS, COL, MAP1_T> &map1,
                            Mat<ROWS, COL, MAP2_T> &map2
                            )
{
    Window<3,3, RT> iR;
    Window<3,3, RT> ir;
    mul<3, 3, 3>(newcameraMatrix.val, R.val, iR.val);
    Invert<3>(iR.val, ir.val);
    InitUndistortRectifyMapInverse(cameraMatrix, distCoeffs,ir,map1,map2);
}
}



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 66 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_hough.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/
# 83 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_hough.h"
namespace hls {

typedef ap_fixed<19,2,SC_RND> angleAccuracy_T;

template<typename AT,typename RT>
struct Polar_
{
 AT angle;
 RT rho;
};

template<unsigned int theta,unsigned int rho,typename ACCUMT,int SRC_T, int ROW,int COL, typename S_T>
void HoughPolar(
        Mat<ROW,COL,SRC_T> &_src,
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    ACCUMT addr[180/theta];
    ACCUMT accbuf[2][180/theta];
_ssdm_SpecArrayPartition( addr, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( accbuf, 0, "COMPLETE", 0, "");
    int rows=_src.rows;
    int cols=_src.cols;
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;
    unsigned int AngleN= 180/theta;
_ssdm_SpecArrayPartition( sinval, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( cosval, 0, "COMPLETE", 0, "");
 loop_init_r: for(int r=0;r<rhoN+2;r++)
    {
    loop_init_n: for(int n=0;n<AngleN+2;n++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            accum[n][r]=0;
        }
    }

 loop_init: for(int n = 0; n < AngleN; n++ )
    {
        addr[n]=0;
        accbuf[0][n]=accum[n+1][Half_rhoN+1];
        sinval[n]=sinval[n]/rho;
        cosval[n]=cosval[n]/rho;
    }
    // stage 1. fill accumulator

 loop_height: for( int i = 0; i < rows; i++ )
    {
    loop_width: for( int j = 0; j < cols; j++ )
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp;
            _src.data_stream[0]>>temp;
            if(temp!=0&&!(i==0&&j==0))
            {
            loop_angle: for(int n = 0; n < AngleN; n++ )
                {
                    accbuf[1][n]=accbuf[0][n];
                    ACCUMT r=j*cosval[n]+i*sinval[n];
                    r+=Half_rhoN;
                    accbuf[0][n]=accum[n+1][r+1];//if read after write operation then it will have denpendecy problem
                    if(r==addr[n])
                        accbuf[0][n]=accbuf[0][n]+1;

                    accum[n+1][addr[n]+1]=accbuf[1][n]+1;
                    addr[n]=r;
                }
            }

        }
    }
 loop_exit: for(int n = 0; n < AngleN; n++ )
    {
        accum[n+1][addr[n]+1]=accbuf[0][n]+1;
    }
}
template<int rho,int ROW,int COL,typename ACCUMT, typename AT, typename RT,int linesMax>
void Sort_insert(
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        Polar_<AT,RT> (&lines)[linesMax],
        unsigned int threshold,
        unsigned int theta,
        unsigned int& storenum)
{
    LineBuffer<2,((2*(COL+ROW)+1)/rho+2),ACCUMT> accum_buf;// used for get local max or min
    Window<3,3,ACCUMT> accum_win;
    ACCUMT lines_val[linesMax+1];
    ap_uint<1> lines_flag[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int AngleN= 180/theta;
    unsigned int Half_rhoN=(rhoN-1)/2;

_ssdm_SpecArrayPartition( &accum_buf, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines_val, 1, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( &accum_win, 0, "COMPLETE", 0, "");
_ssdm_SpecArrayPartition( lines_flag, 0, "COMPLETE", 0, "");

 loop_init: for(int i=0;i<linesMax;i++)
    {
        lines[i].angle=0;
        lines[i].rho=0;
        lines_val[i]=0;//
        lines_flag[i]=0;//
    }
        lines_val[linesMax]=0;//
        lines_flag[linesMax]=0;//
    // find the location and sort descent
 loop_n: for(int n=0;n<AngleN+2;n++)
    {
    loop_r: for(int r=0;r<rhoN+2;r++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 0);
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            for(int row=2;row>=0;row--)
            {
                for(int col=2;col>=1;col--)
                {
                    accum_win.val[row][col]=accum_win.val[row][col-1];// window col shift
                }
            }

            ACCUMT temp=accum[n][r];

            ACCUMT accum_buf0=accum_buf.val[0][r];

            accum_win.val[2][0]=accum_buf.val[1][r];
            accum_win.val[1][0]=accum_buf0;
            accum_win.val[0][0]=temp;

            accum_buf.val[1][r]=accum_buf0;// buffer shift

            accum_buf.val[0][r]=temp;

            if(r>=2&&r!=Half_rhoN+2&&r<rhoN+2&&n>=2&&n<AngleN+2)
            {
                if((accum_win.val[1][1]>threshold)&&(accum_win.val[1][1]>accum_win.val[1][2])&&(accum_win.val[1][1]>=accum_win.val[1][0])&&(accum_win.val[1][1]>accum_win.val[2][1])&&(accum_win.val[1][1]>=accum_win.val[0][1] ))
                {

                loop_lines: for(int i=linesMax-2;i>=0;i--)
                    {
                        ACCUMT max=lines_val[i];
                        if(accum_win.val[1][1]>max)
                        {
                            lines[i+1].rho=lines[i].rho;
                            lines[i+1].angle=lines[i].angle;
                            lines_val[i+1]=max;
                            lines_flag[i]=0;
                        }
                        else
                        {
                            lines_flag[i]=1;
                        }
                    }
                    int sum=0;
                loop_sum: for(int i=0;i<linesMax;i++)
                        sum+=lines_flag[i];

                    lines[sum].rho=r-1;
                    lines[sum].angle=n-1;
                    lines_val[sum]=accum_win.val[1][1];
                    storenum++;
                }
            }
        }
    }
}
template<typename _AT, typename _RT,typename AT, typename RT,int linesMax>
void inline GetTopLines(
        Polar_<_AT,_RT> (&_lines)[linesMax],
        Polar_<AT,RT> (&lines)[linesMax+1],
        unsigned int storenum,
        unsigned int theta,
        unsigned int rho,
        unsigned int Half_rhoN)
{
    angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
loop_lines: for(int i=0;i<linesMax;i++)
    {
        if(i<storenum)
        {
            RT r=lines[i].rho-1;
            AT n=lines[i].angle-1;
            _RT _rho = (r - Half_rhoN) * rho;
            _AT _angle = n * Angle_accuracy;
            _lines[i].rho=_rho;
            _lines[i].angle=_angle;
        }
        else
        {
                _lines[i].rho=0;
                _lines[i].angle=0;
        }
    }
}

//static void icvHoughLinesStandard( const CvMat* img, float rho, float theta,
//                       int threshold, CvSeq *lines, int linesMax )--opencv
template<unsigned int theta,unsigned int rho,typename AT,typename RT,typename ACCUMT,int SRC_T,int ROW,int COL,unsigned int linesMax, typename S_T>
void HoughLinesStandard(
        Mat<ROW,COL,SRC_T> &_src,
        Polar_<AT,RT> (&_lines)[linesMax],
        ACCUMT _accum[][(2*(COL+ROW)+1)/rho+2],
        unsigned int _threshold,
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    unsigned int storenum=0;
    Polar_<ap_uint<10>,ACCUMT > lines[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;

    HoughPolar<theta,rho>(_src,_accum, sinval, cosval);
    Sort_insert<rho,ROW,COL>(_accum,lines, _threshold,theta,storenum);
    GetTopLines(_lines,lines,storenum,theta,rho,Half_rhoN);
}
//CV_IMPL CvSeq*
//cvHoughLines2( CvArr* src_image, void* lineStorage, int method,
//               double rho, double theta, int threshold,
//               double param1, double param2 )---opencv
//
//extern define int accum[theta+2][2*(COL+ROW)+3];
//extern define CvSeq_data lines[linemaxs];

template<unsigned int theta,unsigned int rho,typename AT,typename RT,int SRC_T,int ROW,int COL,unsigned int linesMax>
void HoughLines2(
        Mat<ROW,COL,SRC_T> & _src,
 Polar_<AT,RT> (&_lines)[linesMax],
 unsigned int threshold
        )
{
 static ap_uint<12> _accum[180/theta+2][(2*(COL+ROW)+1)/rho+2];
 _ssdm_SpecArrayPartition( _accum, 1, "COMPLETE", 0, "");
        ap_fixed<19,2,SC_RND> sinval[180/theta];
        ap_fixed<19,2,SC_RND> cosval[180/theta];
        angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
 loop_init: for(int i=0;i<180/theta;i++)
        {
            sinval[i]=::hls::sinf((i*Angle_accuracy));
            cosval[i]=::hls::cosf(i*Angle_accuracy);
        }
 HoughLinesStandard<theta,rho>(_src,_lines,_accum,threshold, sinval,cosval);
}

}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 67 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_harris.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/

// This code is partially derived from OpenCV:

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/
# 83 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_harris.h"
namespace hls {

template<int KH,int KW, typename SRC_T>
bool IsMax(Window<KH,KW,SRC_T> & core_win)
{
_ssdm_InlineSelf(0, "");
    bool isMax=true;
    for(int i=0;i<KH;i++) {
        for(int j=0;j<KW;j++) {
            if(((i!=KH/2)||(j!=KW/2))&&core_win.val[i][j]>core_win.val[KH/2][KW/2])
                isMax=false;
        }
    }
    return isMax;
}
template<int KH, int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void FindMax(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name threshold
                )
{
    LineBuffer<KH-1,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf;
    Window<KH,KW,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    int ioffset=KH/2+1;
    int joffset=KH/2+1;
    for(HLS_SIZE_T i=0;i<rows+ioffset;i++)
    {
_ssdm_op_SpecLoopTripCount(0, ROWS, 0, "");
        for(HLS_SIZE_T j=0;j<cols+joffset;j++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecLoopTripCount(0, COLS, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            for(int r= 0;r<KH;r++)
            {
                for(int c=0;c<KW-1;c++)
                {
                    win.val[r][c]=win.val[r][c+1];//column left shift
                }
            }
            if(i<rows&&j<cols)
            {
                win.val[0][KW-1]=k_buf.val[0][j];
                for(int buf_row= 1;buf_row< KH-1;buf_row++)
                {
                    win.val[buf_row][KW-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }
                //-------
                _src>>s;
                win.val[KH-1][KW-1]=s.val[0];
                k_buf.val[KH-2][j]=s.val[0];
            }
            else if(j>=cols)
            {

                for(int i= 1;i< KW;i++)
                    win.val[i][KW-1]=0;
            }
            if(win.val[1][1]>=threshold&&i>=KH&&j>=KW)
            {
                bool _ismax=IsMax(win);
                if(_ismax)
                {
                   // d.val[0]=s.val[0];
                    d.val[0]=255;
                }
            }

            if(i>=ioffset&&j>=joffset)
            {
                _dst<<d;
            }
        }
    }
}
template<typename KT, typename ST, int X2_T,int Y2_T,int XY_T,int DST_T,int ROWS,int COLS>
void CalCim(
  Mat<ROWS, COLS, X2_T> &_gradx,
  Mat<ROWS, COLS, Y2_T> &_grady,
  Mat<ROWS, COLS, XY_T> &_gradxy,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale
        )
{
    Scalar<((((X2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((X2_T) & ((1 << 11) - 1))>::name> gx;
    Scalar<((((Y2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((Y2_T) & ((1 << 11) - 1))>::name> gy;
    Scalar<((((XY_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((XY_T) & ((1 << 11) - 1))>::name> gxy;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _grady.rows;
    int cols= _grady.cols;
    for(HLS_SIZE_T i=0;i<rows;i++)
    {
_ssdm_op_SpecLoopTripCount(0, ROWS, 0, "");
        for(HLS_SIZE_T j=0;j<cols;j++)
        {
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);
_ssdm_op_SpecLoopTripCount(0, COLS, 0, "");
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            d.val[0]=0;
            _gradx>> gx;
            _grady>> gy;
            _gradxy>> gxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgx = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gx.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgy = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgxy= sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gxy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name det = lgx*lgy - lgxy*lgxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name trac= lgx + lgy;

            typename Type<((DST_T) & ((1 << 11) - 1))>::name cim = det - k*(trac)*(trac);
            d.val[0] = cim;
            _dst<<d;
        }
    }
}
template<int blockSize,int Ksize, bool NORMALIZE, class BORDERMODEL, int GT, int G2T, typename ST, typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale)
{
_ssdm_InlineSelf(0, "");
_ssdm_op_SpecDataflowPipeline(-1, "");
    ((Ksize==3||Ksize==5||Ksize==7) ? static_cast<void> (0) : __assert_fail ("Ksize==3||Ksize==5||Ksize==7", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_harris.h", 216, __PRETTY_FUNCTION__));
    int rows = _src.rows;
    int cols = _src.cols;
    Mat<ROWS,COLS,SRC_T> gray1(rows,cols);
    Mat<ROWS,COLS,SRC_T> gray2(rows,cols);

    Mat<ROWS,COLS,GT> grad_x(rows,cols);
    Mat<ROWS,COLS,GT> grad_x1(rows,cols);
    Mat<ROWS,COLS,GT> grad_x2(rows,cols);
    Mat<ROWS,COLS,GT> grad_x3(rows,cols);
    Mat<ROWS,COLS,GT> grad_x4(rows,cols);

    Mat<ROWS,COLS,GT> grad_y(rows,cols);
    Mat<ROWS,COLS,GT> grad_y1(rows,cols);
    Mat<ROWS,COLS,GT> grad_y2(rows,cols);
    Mat<ROWS,COLS,GT> grad_y3(rows,cols);
    Mat<ROWS,COLS,GT> grad_y4(rows,cols);

    Mat<ROWS,COLS,G2T> grad_xx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_yy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_xy(rows,cols);

    Mat<ROWS,COLS,G2T> grad_gx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gxy(rows,cols);

    Duplicate(_src,gray1,gray2);

    Sobel<1,0,Ksize,BORDERMODEL>(gray1,grad_x);
    Duplicate(grad_x,grad_x1,grad_x2);
    Duplicate(grad_x1,grad_x3,grad_x4);
    Sobel<0,1,Ksize,BORDERMODEL>(gray2,grad_y);
    Duplicate(grad_y,grad_y1,grad_y2);
    Duplicate(grad_y1,grad_y3,grad_y4);

    Mul(grad_x3,grad_x4,grad_xx);
    Mul(grad_y3,grad_y4,grad_yy);
    Mul(grad_x2,grad_y2,grad_xy);

    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xx,grad_gx);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_yy,grad_gy);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xy,grad_gxy);

    CalCim(grad_gx,grad_gy,grad_gxy, _dst,k, scale);
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void CornerHarris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k)
{
_ssdm_InlineSelf(0, "");
    ap_uint<9> sc=(1 << ((Ksize>0 ? Ksize:3)-1))*blockSize;
    ((SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))) ? static_cast<void> (0) : __assert_fail ("SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_harris.h", 270, __PRETTY_FUNCTION__));
    if(SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11)))
    {
        ap_fixed<25,-7-Ksize> scale = (ap_fixed<25,2>(1.0f)/255) / sc;
        switch(Ksize) {
            case 3:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 5:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((14 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((28 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 7:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((18 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((36 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            default: // by default Ksize=3
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10 +1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20 +1 +BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
        }
        //Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, MatType<ap_int<20>,1>::type_id, MatType<ap_int<40>,1>::type_id>(_src, _dst, k,scale);
    }
    else
    {
        float scale = 1.0f / sc;
        Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((5) & ((1 << 11) - 1)) + (((1)-1) << 11)), (((5) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
    }
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        int threshold)
{
_ssdm_InlineSelf(0, "");
    Mat<ROWS,COLS,(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))> res(_src.rows,_src.cols);
    CornerHarris<blockSize,Ksize>(_src, res, k);
    FindMax<3,3>(res,_dst,threshold);
}

}


// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 68 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_haar.h" 1
/*****************************************************************************
 *
 *     Author: Xilinx, Inc.
 *
 *     This text contains proprietary, confidential information of
 *     Xilinx, Inc. , is distributed by under license from Xilinx,
 *     Inc., and may be used, copied and/or disclosed only pursuant to
 *     the terms of a valid license agreement with Xilinx, Inc.
 *
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
 *     AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
 *     SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
 *     OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
 *     APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
 *     THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
 *     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
 *     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
 *     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
 *     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
 *     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
 *     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE.
 *
 *     Xilinx products are not intended for use in life support appliances,
 *     devices, or systems. Use in such applications is expressly prohibited.
 *
 *     (c) Copyright 2012-2013 Xilinx Inc.
 *     All rights reserved.
 *
 *****************************************************************************/
# 41 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_haar.h"
namespace hls {

typedef ap_fixed<12,6,SC_RND> VAR_T;
typedef ap_uint<3> WEIGHT_T;
typedef unsigned int STHRESHOLD_T;
typedef short CTHRESHOLD_T;
typedef unsigned short ALPHA_T;
//------------------haar--
struct HaarRect
{
    Rect_< ap_uint<6> > r;// max size 64x64
    WEIGHT_T weight;
};
struct HaarFeature
{
    public:
    HaarFeature()
    {
_ssdm_SpecArrayPartition( rect, 1, "COMPLETE", 0, "");
    };
    HaarRect rect[3];
    //int     tilted;
};
template <int FEATURE_MAX>
struct HaarClassifier
{
    public:
    HaarClassifier()
    {
_ssdm_SpecArrayPartition( haar_feature, 1, "COMPLETE", 0, "");
        };
        unsigned short count;
        HaarFeature haar_feature[FEATURE_MAX];
        CTHRESHOLD_T threshold[FEATURE_MAX];
        ap_int<5> left[FEATURE_MAX];
        ap_int<5> right[FEATURE_MAX];
        ALPHA_T alpha[FEATURE_MAX+1];
        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarStageClassifier
{
    public:
    HaarStageClassifier()
    {
_ssdm_SpecArrayPartition( classifier, 1, "COMPLETE", 0, "");
        };
        unsigned char count[STAGE];// max calssifer each stage is 255
        STHRESHOLD_T threshold[STAGE];
        HaarClassifier<FEATURE_MAX> classifier[CLASSIFIER_ALL];
       // int     next[STAGE];
       // int     child[STAGE];
       // int     parent[STAGE];

        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarClassifierCascade
{
    public:
        HaarClassifierCascade()
        {
        };
        unsigned short count;
        Size_<unsigned char> real_window_size;
        HaarStageClassifier<STAGE,CLASSIFIER_ALL,FEATURE_MAX> stage_classifier;
};
//---------------load--------------------------------------
class HaarLoadData
{
        public:
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
HaarLoadData(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,
        //const  int ca_flags,
        const int ca_count,
        //const  float ca_scale,
        const Size_<unsigned char> ca_real_window_size,
        const int s_count[],
        const float s_threshold[],
        const int c_left[][FEATURE_MAX],
        const int c_right[][FEATURE_MAX],
        const float c_threshold[][FEATURE_MAX],
        const float c_alpha[][FEATURE_MAX+1],
        const unsigned int haar_feature[][FEATURE_MAX][4*3],
        const float haar_feature_weight[][FEATURE_MAX][3]
        //const  int s_next[],
        //const  int s_child[],
        //const  int s_parent[],
        //const  int c_count[]
        )
{
       // cascade.flags=ca_flags;
        cascade.count=ca_count;
       // cascade.scale=ca_scale;
        cascade.real_window_size=ca_real_window_size;
        for(int i=0;i<STAGE;i++)
        {
                cascade.stage_classifier.count[i]=s_count[i];
                cascade.stage_classifier.threshold[i]=s_threshold[i];
               // cascade.stage_classifier.next[i]=s_next[i];
               // cascade.stage_classifier.child[i]=s_child[i];
               // cascade.stage_classifier.parent[i]=s_parent[i];
        }
        for(int i=0;i<CLASSIFIER_ALL;i++)
        {
              //        cascade.stage_classifier.classifier[i].count=c_count[i];
               for(int j=0;j<FEATURE_MAX;j++)
               {
                      cascade.stage_classifier.classifier[i].left[j]=c_left[i][j];
                      cascade.stage_classifier.classifier[i].right[j]=c_right[i][j];
                      cascade.stage_classifier.classifier[i].threshold[j]=c_threshold[i][j];
                      cascade.stage_classifier.classifier[i].alpha[j]=c_alpha[i][j];
                      cascade.stage_classifier.classifier[i].alpha[FEATURE_MAX]=c_alpha[i][FEATURE_MAX];
                      //cascade.stage_classifier.classifier[i].haar_feature[j].tilted=haar_feature[i][j][0];
                      for(int n=0;n<3;n++)
                      {
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.x=haar_feature[i][j][n*4+0];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.y=haar_feature[i][j][n*4+1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.width=haar_feature[i][j][n*4+2];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.height=haar_feature[i][j][n*4+3];
                       }
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[0].weight=-1;
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[1].weight=haar_feature_weight[i][j][1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[2].weight=haar_feature_weight[i][j][2];
                 }
        }
}
};
//---------------calculate window integral -------------
template<typename SUMT, typename VART,int ROWS,int COLS>
void intergral_win(
        Window<ROWS,COLS,VART> &win_var,
        SUMT &var
        )
{
_ssdm_InlineSelf(0, "");
    var=0;
    for(int j=0;j<COLS;j++)
    {
        SUMT t = 0;
        for(int i=0;i<ROWS;i++)
        {
            var=var+win_var.val[i][j];
            t += win_var.val[i][j];
        }
        //        std::cout << "col " << j << " " << t << "\n";
    }
}
//---------------------------calculate classifier---------------
template< typename SRC_T,int ROWS,int COLS,int FEATURE_MAX>
ALPHA_T icvEvalHidHaarClassifier(HaarClassifier<FEATURE_MAX> & classifier,Window<ROWS,COLS,SRC_T>& win,VAR_T &variance )
{
_ssdm_InlineSelf(2, "");
_ssdm_SpecFuncInstantiation(&classifier, "");

    // double factor=1.0/(20*20);//num form 18 to 20 , the face num form 103 to 108
    int m=0,i=0;
    for(m=0;m<FEATURE_MAX;m++)// classifier is tree  ,haar_feature[]  is parallel arry 
    {
        Rect_<ap_uint<6> > rr=classifier.haar_feature[i].rect[0].r;
        if(i>0||(i==0&&m==0))
        {
            // FIXME: sum is ap_uint<8+BitWidth<WEIGHT_T>+BitWidth<ROWS*COLS*HLS_HAAR_FEATURE_MAX>::val >
            CTHRESHOLD_T sum=-(win.val[rr.height][rr.width]-win.val[rr.height][rr.x]-win.val[rr.y][rr.width]+win.val[rr.y][rr.x]);//?
            for(int j=1;j<3;j++)
            {
                WEIGHT_T weight=classifier.haar_feature[i].rect[j].weight;
                Rect_< ap_uint<6> > rj=classifier.haar_feature[i].rect[j].r;
                sum+=(win.val[rj.height][rj.width]-win.val[rj.height][rj.x]-win.val[rj.y][rj.width]+win.val[rj.y][rj.x])*weight;//?
            }
            if(sum<classifier.threshold[i]*variance)
            {
                i=classifier.left[i];
            }
            else
            {
                i=classifier.right[i];
            }
        }
        // if (i<=0)
        //         break;
    }
    return classifier.alpha[-i] ;
}
//---------------------------calculate stage_classifier--------------
template< typename SRC_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
bool RunHaarClassifierCascade(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,Window<ROWS,COLS,SRC_T>&win,VAR_T &variance )
{
_ssdm_InlineSelf(0, "");
    ALPHA_T sum=0;
    bool result=true;
    unsigned char stage_index=0;//max classifier of each stage is 255
    unsigned char stage_count=0;
    for (int i=0;i<CLASSIFIER_ALL;i++)//in the face trning data there is no ralition between diffierent trees(stage_classifier),is an line no next,just child and parent. stage_classifier is  trees(classifier) group.
    {
        sum+=icvEvalHidHaarClassifier(cascade.stage_classifier.classifier[i],win,variance);
        stage_count++;
        if(cascade.stage_classifier.count[stage_index]==stage_count)
        {
            if(sum < cascade.stage_classifier.threshold[stage_index])
            {
                result =false;
            }
            sum=0;
            stage_count=0;
            stage_index++;
        }
    }
    return result;
}
template < typename T>
T TaylorExp(T &t)
{
   return (1+((T)0.5)*(t)-((T)0.125)*(t)*(t));
}
//------------------------haar scan the whole imge - --------------
template< int K_H,int K_W,int S_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX, int DST_T>
void HaarClassifierObject_opr(
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,
  Mat<ROWS, COLS, S_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask
  )
{
    int storage_count=0;






    Window<1,K_W+1,ap_uint<16+16> > sqwin; // 5 = ceil(log2(COLS))
    Window<K_H+1,K_W+1,ap_uint<8+16> > swin; // 16 = ceil(log2(K_H*COLS))
    LineBuffer<K_H,COLS,typename Type<((S_T) & ((1 << 11) - 1))>::name> sbuf;

    int rows=_src.rows;
    int cols=_src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_haar.h", 275, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_haar.h", 276, __PRETTY_FUNCTION__));
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> m;
    Scalar<((((S_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((S_T) & ((1 << 11) - 1))>::name> ss;

    for(int i=0;i<rows;i++)
    {
        for(int j=0;j<cols;j++)
        {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
_ssdm_SpecDependence( 0, 1, 0, -1, 0, 1);

            {
_ssdm_SpecExprBalance(0, "");
            sqwin.shift_left();
            swin.shift_left();//column left shift
            swin.val[0][K_W]=(j == 0 ? ap_uint<24>(0) :swin.val[0][K_W-1])+sbuf.val[0][j];
            ap_uint<16> col_sum=sbuf.val[0][j];
            ap_uint<32> col_sum_sq=0;
            for(int buf_row= 1;buf_row<K_H;buf_row++)
            {
                ss.val[0]=sbuf.val[buf_row][j];
                sbuf.val[buf_row-1][j]=ss.val[0];
                col_sum += ss.val[0];
                col_sum_sq += ss.val[0] * ss.val[0];
                swin.val[buf_row][K_W] = (j == 0 ? ap_uint<24>(0) :swin.val[buf_row][K_W-1]) + col_sum;
            }
            _src >> ss;
            sbuf.val[K_H-1][j]=ss.val[0];
            col_sum += ss.val[0];
            col_sum_sq += ss.val[0] * ss.val[0];
            swin.val[K_H][K_W] = (j == 0 ? ap_uint<24>(0) : swin.val[K_H][K_W-1]) + col_sum;
            sqwin.val[0][K_W] = (j == 0 ? ap_uint<32>(0) : sqwin.val[0][K_W-1]) + col_sum_sq;
# 321 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_haar.h"
 //            std::cout << "var = " << col_sum_sq << " " << sqwin.val[0][0] << " " << sqwin.val[0][K_W] << "\n";
            }

            m.val[0]=0;
            if(i>=K_H && j>=K_W &&( (j & 1)==0 ))//?
            {
                int b=K_H,s=0;
                // FIXME: perhaps ap_ufixed<16,0> ?
                float inv_window_area=1.0/(K_H*K_W);
                ap_uint<26> varsum=sqwin.val[0][K_W] - sqwin.val[0][0];






                ap_uint<17> meansum=swin.val[b][b]-swin.val[b][s]-swin.val[s][b]+swin.val[s][s];
                ap_fixed<32,18,SC_RND> mean=(meansum)*inv_window_area;
                ap_fixed<32,18,SC_RND> meansq=mean*mean;
                ap_fixed<32,18,SC_RND> var_a=varsum*inv_window_area;
                ap_fixed<32,18,SC_RND> variance=var_a-meansq;
                if(variance>0)
                {
                    //variance = ::hls::sqrtf(variance);
                    variance = (variance/100);
                    ap_fixed<32,18,SC_RND> t=variance-1;
                    if(variance<=4)
                        variance= TaylorExp(t)+1;
                    else if(variance >4 && variance <=16)
                    {
                        ap_fixed<32,18,SC_RND> tt=t/4;
                        variance= 2*TaylorExp(tt)+1;
                    }
                    else if(variance >16 && variance <=64)
                    {
                        ap_fixed<32,18,SC_RND> tt=t/16;
                        variance= 4*TaylorExp(tt)+1;
                    }
                    else if(variance >64 && variance <=256)
                    {
                        ap_fixed<32,18,SC_RND> tt=t/64;
                        variance= 8*TaylorExp(tt)+1;
                    }
                    else
                        variance=16;
                }
                else
                {
                    variance = 1;
                }
                //variance=variance/10; // FIXME: Why?  At least use a power of 2.
                ap_fixed<12,6,SC_RND> var=variance;
                bool Isface=RunHaarClassifierCascade(cascade,swin,var);
                if(Isface)
                {
                    if(variance>65)
                    {
                        variance=65;
                    }
                    variance=variance*1000; // FIXME: Why?  At least use a power of 2.
                    storage_count++;
                    //m.val[0]=(unsigned short)variance;
                    m.val[0]=(unsigned char)variance;
                }
            }
            _mask << m;
        }
    }
    //printf("Face detected %d\n",storage_count);  
}
template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
_ssdm_InlineSelf(0, "");
//         int rows =_src.rows;
//         int cols =_src.cols;
// 	Mat<ROWS, COLS, HLS_16UC1>	    sqsrc(rows,cols);
// 	Mat<ROWS, COLS, HLS_8UC1>	    gray0(rows,cols);
// 	Mat<ROWS, COLS, HLS_8UC1>	    gray1(rows,cols);
// 	Mat<ROWS, COLS, HLS_8UC1>	    gray2(rows,cols);
// 	Mat<ROWS, COLS, HLS_8UC1>	    gray3(rows,cols);
//         Duplicate(_src,gray0,gray1);
//         Duplicate(gray0,gray2,gray3);
//         Mul(gray1,gray2,sqsrc,1);
        HaarClassifierObject_opr<K_H,K_W>(_cascade,_src, _mask);
}
//-------------------------combin storage-----------------
template<typename RECT_T>
void CombineStorage(Rect_<RECT_T> _storage_group[][300],int m, Rect_<RECT_T> _storage[],int num)
{
        int count=0;
        for(int i=0;i<m;i++)
        {
                for(int j=0;j<num;j++)
                {
                        if(count<num&&_storage_group[i][j].width!=0&&_storage_group[i][j].height!=0)
                        {
                            _storage[count++]=_storage_group[i][j];
                        }
                }
        }
        for(int i=0;i<num;i++)
        {
         if(i>=count)
            {
               _storage[count].x=0;
               _storage[count].y=0;
               _storage[count].width=0;
               _storage[count].height=0;

            }
         }
}
template<int SRC_T, int DST_T,int ROWS,int COLS>
void Combin_mask(
  Mat<ROWS, COLS, SRC_T> &mask0,
  Mat<ROWS/2, COLS/2, SRC_T> &mask1,
  Mat<ROWS/4, COLS/4, SRC_T> &mask2,
  Mat<ROWS/8, COLS/8, SRC_T> &mask3,
  Mat<ROWS, COLS, DST_T> &dst
                )
{
    int rows =mask0.rows;
    int cols =mask0.cols;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> m;

    int i1=0;
    int i2=0;
    int i3=0;
    for(int i=0;i<rows;i++)
    {
        int j1=0;
        int j2=0;
        int j3=0;
        for(int j=0;j<cols;j++)
        {
_ssdm_op_SpecPipeline(-1, 1, 1, 0, "");
            s.val[0]=0;
            mask0>> m;
            if(m.val[0]!=0)
                s.val[0]=255;
            if(i==i1*2&&j==j1*2)
            {
                mask1>>m;
                s.val[0]=s.val[0]|m.val[0];
                j1++;
            }
            if(i==i2*4&&j==j2*4)
            {
                mask2>>m;
                s.val[0]=s.val[0]|m.val[0];
                j2++;
            }
            if(i==i3*8&&j==j3*8)
            {
                mask3>>m;
                s.val[0]=s.val[0]|m.val[0];
                j3++;
            }
            dst<<s;
        }
        if(i==i1*2)
            i1++;
        if(i==i2*4)
            i2++;
        if(i==i3*8)
            i3++;
    }
}
//-------------------------haar detect- with different size of image--------------
template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject_group(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
_ssdm_InlineSelf(0, "");
        int rows =_src.rows;
        int cols =_src.cols;
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray1(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray2(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray3(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray4(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray5(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray6(rows,cols);
        Duplicate(_src, gray1, gray2 );
        Duplicate(gray1, gray3, gray4 );
        Duplicate(gray2, gray5, gray6 );
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_3(rows/8,cols/8);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_0(rows,cols);
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_3(rows/8,cols/8);
        Resize(gray4,internal_1);
        Resize(gray5,internal_2);
        Resize(gray6,internal_3);
        HaarClassifierObject<K_H, K_W > ( gray3, mask_0, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_1, mask_1, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_2, mask_2, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_3, mask_3, _cascade);
        Combin_mask<DST_T,DST_T,ROWS,COLS>(mask_0,mask_1,mask_2,mask_3,_mask);
}

}




// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 69 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2
# 1 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h" 1
/***************************************************************************

*    Copyright 2013 Xilinx, Inc. All rights reserved. 

*   This file contains confidential and proprietary information of Xilinx,
*   Inc. and is protected under U.S. and international copyright and other
*   intellectual property laws. 

*   DISCLAIMER
*   This disclaimer is not a license and does not grant any rights to the
*   materials distributed herewith. Except as otherwise provided in a valid
*   license issued to you by Xilinx, and to the maximum extent permitted by
*   applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH
*   ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, 
*   EXPRESS, IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES
*   OF MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR 
*   PURPOSE; and (2) Xilinx shall not be liable (whether in contract or 
*   tort, including negligence, or under any other theory of liability)
*   for any loss or damage of any kind or nature related to, arising under
*   or in connection with these materials, including for any direct, or any
*   indirect, special, incidental, or consequential loss or damage (including
*   loss of data, profits, goodwill, or any type of loss or damage suffered 
*   as a result of any action brought by a third party) even if such damage
*   or loss was reasonably foreseeable or Xilinx had been advised of the 
*   possibility of the same. 

*   CRITICAL APPLICATIONS 
*   Xilinx products are not designed or intended to be fail-safe, or for use
*   in any application requiring fail-safe performance, such as life-support
*   or safety devices or systems, Class III medical devices, nuclear facilities,
*   applications related to the deployment of airbags, or any other applications
*   that could lead to death, personal injury, or severe property or environmental
*   damage (individually and collectively, "Critical Applications"). Customer
*   assumes the sole risk and liability of any use of Xilinx products in Critical
*   Applications, subject only to applicable laws and regulations governing 
*   limitations on product liability. 

*   THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT 
*   ALL TIMES.

***************************************************************************/

// This code is partially derived from OpenCV:
// opencv/modules/calib3d/src/stereobm.cpp

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                          License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

/*
 * HLS Video Stereo Block Matching Header File
 */
# 100 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h"
namespace hls {







template<int WSIZE, int NDISP, int NDISP_UNIT>
class StereoBMState {
public:
    // pre-filtering (normalization of input images)
    int preFilterType; // =HLS_STEREO_BM_XSOBEL
    int preFilterSize; // averaging window size: ~5x5..21x21
    int preFilterCap; // the output of pre-filtering is clipped by [-preFilterCap,preFilterCap]

    // correspondence using Sum of Absolute Difference (SAD)
    int SADWindowSize; // ~5x5..21x21 // defined in macro
    int minDisparity; // minimum disparity (can be negative)
    int numberOfDisparities; // maximum disparity - minimum disparity (> 0)

    // post-filtering
    int textureThreshold; // the disparity is only computed for pixels
                           // with textured enough neighborhood
    int uniquenessRatio; // accept the computed disparity d* only if
                           // SAD(d) >= SAD(d*)*(1 + uniquenessRatio/100.)
                           // for any d != d*+/-1 within the search range.
    //int speckleWindowSize; // disparity variation window
    //int speckleRange; // acceptable range of variation in window

    int ndisp_unit;
    int sweepFactor;
    int remainder;

    StereoBMState() {
        preFilterType = 1; //HLS_STEREO_BM_NORMALIZED_RESPONSE;
        preFilterSize = WSIZE;
        preFilterCap = 32; // prevent mismatch of CV_SSE2 result
        SADWindowSize = WSIZE;
        minDisparity = 0;
        numberOfDisparities = NDISP;
        textureThreshold = 10;
        uniquenessRatio = 15;
        sweepFactor = (NDISP/NDISP_UNIT) + ((NDISP%NDISP_UNIT) != 0);
        ndisp_unit = NDISP_UNIT;
        remainder = NDISP_UNIT*sweepFactor - NDISP;
    }
};

template<int PWSIZE, int SRC_T, int DST_T, int ROWS, int COLS>
void PreFilterNorm(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    int rows = src.rows;
    int cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 157, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 158, __PRETTY_FUNCTION__));

    LineBuffer<PWSIZE, COLS+PWSIZE-1, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > buff;
    Window<PWSIZE, PWSIZE, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> tmp[PWSIZE];
_ssdm_SpecArrayPartition( tmp, 0, "COMPLETE", 0, "");
    int sum_cols[PWSIZE];
_ssdm_SpecArrayPartition( tmp, 0, "COMPLETE", 0, "");
    int sum;

loop_sum_row:
    for (int row = 0; row < rows+PWSIZE-1; row++) {
loop_sum_init:
        for (int i = 0; i < PWSIZE; i++) {
            sum_cols[i] = 0;
        }
        sum = 0;
loop_sum_col:
        for (int col = 0; col < cols+PWSIZE-1; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> pix_in(0);
            buff.shift_down(col);
            if (!(row < (PWSIZE-1)/2 || row >= rows+(PWSIZE-1)/2 || col < (PWSIZE-1)/2 || col >= cols+(PWSIZE-1)/2)) {
                src >> pix_in;
            }
            buff.insert_bottom(pix_in, col);
            for (int i = 0; i< PWSIZE; i++) {
                tmp[i] = buff.val[i][col];
            }

            // compute sum incrementally;
            int a_sum = 0, b_sum = 0;
            for (int i = 0; i < PWSIZE; i++) {
                b_sum += tmp[i].val[0];
            }
            a_sum = sum_cols[PWSIZE-1];
            for (int j = PWSIZE-1; j > 0; j--) {
                sum_cols[j] = sum_cols[j-1];
            }
            sum_cols[0] = b_sum;
            sum = sum - a_sum + b_sum;
            win.shift_right();
            win.insert_right(tmp);

            if (row >= PWSIZE-1 && col >= PWSIZE-1) {
                int avg = sum / (PWSIZE*PWSIZE);
                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> pix_out;
                int center = win.val[PWSIZE/2][PWSIZE/2].val[0];
                pix_out.val[0] = ((((center-avg) > (-cap) ? (center-avg) : (-cap))) < (cap) ? (((center-avg) > (-cap) ? (center-avg) : (-cap))) : (cap)) + cap;
                dst << pix_out;
            }
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Clip(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 223, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 224, __PRETTY_FUNCTION__));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    for (HLS_SIZE_T i = 0; i < rows; i++) {
        for (HLS_SIZE_T j = 0; j < cols; j++) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
            src >> s;
            for (HLS_SIZE_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                s.val[k] = s.val[k] < -cap ? 0 : s.val[k] > cap ? cap*2 : s.val[k] + cap;
                d.val[k] = s.val[k];
            }
            dst << d;
        }
    }
}

template<typename T>
T absdiff(T a, T b) {
_ssdm_InlineSelf(0, "");
    long long x = a-b;
    long long y = b-a;
    T r;
    if(x < 0) { // signbit check.
        r = y; ((r == y) ? static_cast<void> (0) : __assert_fail ("r == y", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 247, __PRETTY_FUNCTION__));
    } else {
        r = x; ((r == x) ? static_cast<void> (0) : __assert_fail ("r == x", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 249, __PRETTY_FUNCTION__));
    }
    return r;
}

template<int WSIZE, class T>
void UpdateTexture(
            Window<WSIZE, WSIZE, T>& window,
            T* col_tbi,
            int& text_sum,
            int row,
            int col,
            T cap)
{
_ssdm_InlineSelf(0, "");
    int tmp = 0;
    for (int i = 0; i < WSIZE; i++) {
        //text_sum += (i > row? 0 : absdiff(col_tbi[i], cap)) - ((col < WSIZE || i > row) ? 0 : absdiff(window.val[i][WSIZE-1], cap));
        tmp += (i > row? 0 : absdiff(col_tbi[i], cap)) - ((col < WSIZE || i > row) ? 0 : absdiff(window.val[i][WSIZE-1], cap));
    }
    text_sum += tmp;
}

template<int WSIZE, int L_WIN_COLS, int R_WIN_COLS, typename T>
int SAD_compute_inc(
            Window<WSIZE, L_WIN_COLS, T>& l_win,
            Window<WSIZE, R_WIN_COLS, T>& r_win_s,
            int d,
            int col,
            int sad_cols_d[WSIZE])
{_ssdm_SpecArrayDimSize(sad_cols_d,WSIZE);
_ssdm_InlineSelf(0, "");
    int a_sum = 0, b_sum = 0;
    // compute new column sads;
    for (int i = 0; i < WSIZE; i++) {
        b_sum += absdiff(l_win.val[i][0], r_win_s.val[i][d]);
    }
    // valid guard;
    if (col < d) b_sum = 0;
    // get previous sad_cols value;
    a_sum = sad_cols_d[WSIZE-1];
    // shift sad_cols[d];
    for (int j = WSIZE-1; j > 0; j--) {
        sad_cols_d[j] = sad_cols_d[j-1];
    }
    // fill in sad_cols with newly computed values;
    sad_cols_d[0] = b_sum;

    return (-a_sum+b_sum);
}

template<int SIZE>
class MinSAD {
public:
    template <typename T, typename T_idx>
    static void find(T a[SIZE], T_idx &loc, T &val) {_ssdm_SpecArrayDimSize(a,SIZE);
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        T a1[SIZE/2];
        T a2[SIZE-SIZE/2];
        for(int i = 0; i < SIZE/2; i++) {
            a1[i] = a[i];
        }
        for(int i = 0; i < SIZE-SIZE/2; i++) {
            a2[i] = a[i+SIZE/2];
        }
        T_idx l1,l2;
        T v1,v2;
        MinSAD<SIZE/2>::find(a1,l1,v1);
        MinSAD<SIZE-SIZE/2>::find(a2,l2,v2);
        if(v1 >= v2) {
            val = v2;
            loc = l2+SIZE/2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<>
class MinSAD<1> {
public:
    template <typename T, typename T_idx>
    static void find(T a[1], T_idx &loc, T &val) {_ssdm_SpecArrayDimSize(a,1);
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        loc = 0;
        val = a[0];
    }
};

template<>
class MinSAD<2> {
public:
    template <typename T, typename T_idx>
    static void find(T a[2], T_idx &loc, T &val) {_ssdm_SpecArrayDimSize(a,2);
_ssdm_InlineSelf(0, "");
_ssdm_SpecArrayPartition( a, 0, "COMPLETE", 0, "");
        T_idx l1=0, l2=1;
        T v1=a[0], v2=a[1];
        if(v1 >= v2) {
            val = v2;
            loc = l2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void SADBlockMatching(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)
//just for clang compiler



{
    int rows = left.rows;
    int cols = left.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 373, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 374, __PRETTY_FUNCTION__));
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_buff;
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_buff;
    Window<WSIZE, WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_window;
    Window<WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_window_search;
    int ndisp = state.numberOfDisparities;
    int mindisp = 0; // cameras parellel setting

    typename Type<((DST_T) & ((1 << 11) - 1))>::name FILTERED = (typename Type<((DST_T) & ((1 << 11) - 1))>::name)((mindisp - 1) << 4);
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name cap = state.preFilterCap;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name l_tmp[WSIZE];
_ssdm_SpecArrayPartition( l_tmp, 0, "COMPLETE", 0, "");
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name r_tmp[WSIZE];
_ssdm_SpecArrayPartition( r_tmp, 0, "COMPLETE", 0, "");
    int text_sum = 0;
    int sad[NDISP_UNIT];
_ssdm_SpecArrayPartition( sad, 0, "COMPLETE", 0, "");
    int sad_cols[NDISP_UNIT][WSIZE];
_ssdm_SpecArrayPartition( sad_cols, 0, "COMPLETE", 0, "");
    int minsad[COLS+WSIZE-1];
    int mind[COLS+WSIZE-1];
    int skip[COLS+WSIZE-1];
    int skip_val[COLS+WSIZE-1];
    int edge_neighbor[COLS+WSIZE-1];
    int edge[COLS+WSIZE-1];
    int minsad_p[COLS+WSIZE-1];
    int minsad_n[COLS+WSIZE-1];

    int d = 0;
loop_row:
    for (int row = 0; row < rows+WSIZE-1; row++) {
loop_mux:
        for (int sweep = 0; sweep < state.sweepFactor; sweep++) {
loop_col:
            for (int col = 0; col < cols+WSIZE-1; col++) {
_ssdm_SpecLoopFlatten(1, "");
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
                if (col == 0) {
loop_sad_init:
                    for (d = 0; d < NDISP_UNIT; d++) {
_ssdm_Unroll(0,0,0, "");
                        sad[d] = 0;
                        for (int i = 0; i < WSIZE; i++) {
_ssdm_Unroll(0,0,0, "");
                            sad_cols[d][i] = 0;
                        }
                    }
                }

                Scalar<1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_in(cap), r_in(cap);
                if (sweep == 0) {
                    // load and shifting buffs
                    l_buff.shift_down(col);
                    r_buff.shift_down(col);
                    if (!(row < (WSIZE-1)/2 || row >= rows+(WSIZE-1)/2 || col < (WSIZE-1)/2 || col >= cols+(WSIZE-1)/2)) {
                        left >> l_in;
                        right >> r_in;
                    }
                    l_buff.insert_bottom(l_in.val[0], col);
                    r_buff.insert_bottom(r_in.val[0], col);
loop_get_data_from_linebuff:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col];
                    }
                } else {
                    int offset = sweep * NDISP_UNIT;
loop_get_data_from_linebuff_with_offset:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col-offset < 0 ? 0 : col-offset];
                    }
                }

                UpdateTexture<WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, l_tmp, text_sum, row, col, cap);

                l_window.shift_right();
                r_window_search.shift_right();
                l_window.insert_right(l_tmp);
                r_window_search.insert_right(r_tmp);

loop_sad_compute:
                for (d = 0; d < NDISP_UNIT; d++) {
                    sad[d] += SAD_compute_inc<WSIZE, WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, r_window_search, d, col, sad_cols[d]);
                    if (sweep == state.sweepFactor-1 && d >= (NDISP_UNIT-state.remainder)) sad[d] = 2147483647;
                }

                // SAD computing and store output
                if (row >= WSIZE-1 && col >= WSIZE-1) {
                    int skip_flag = 0;
                    Scalar<1, typename Type<((DST_T) & ((1 << 11) - 1))>::name> out_pix;
                    if (text_sum < state.textureThreshold) skip_flag = 1;
                    if ((row - WSIZE+1) < (WSIZE-1)/2 || (row - WSIZE+1) >= rows - (WSIZE-1)/2) skip_flag = 1;
                    if ((col - WSIZE+1) < NDISP-1 + (WSIZE-1)/2 || (col - WSIZE+1) >= cols - (WSIZE-1)/2) skip_flag = 1;
                    int gminsad = ((sweep > 0) ? minsad[col] : 2147483647);
                    int gmind = ((sweep > 0) ? mind[col] : 0);
                    int gskip = ((sweep > 0) ? skip[col] : 0);
                    int gskip_val = ((sweep > 0) ? skip_val[col] : 2147483647);
                    int gedge_neighbor = ((sweep > 0) ? edge_neighbor[col] : 2147483647); // for uniqueness check
                    int gedge = ((sweep > 0) ? edge[col] : sad[1]); // for subpixel interpolation
                    int lminsad = 2147483647;
                    int lmind = 0;
                    int gminsad_p = ((sweep > 0) ? minsad_p[col] : 2147483647);
                    int gminsad_n = ((sweep > 0) ? (gmind == sweep*NDISP_UNIT-1 ? sad[0] : minsad_n[col]) : 2147483647);
                    MinSAD<NDISP_UNIT>::find(sad, lmind, lminsad);

                    if (lminsad <= gminsad) {
                        gskip = 0;
                        if (state.uniquenessRatio > 0) {
                            int thresh = lminsad + (lminsad * state.uniquenessRatio / 100);
                            if (gminsad <= thresh && lmind+sweep*NDISP_UNIT > gmind+1) {
                                gskip = 1;
                                gskip_val = gminsad;
                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gskip_val <= thresh) {
                                gskip = 1;
                                // gskip_val unchanged;
                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gedge_neighbor <= thresh) {
                                gskip = 1;
                                gskip_val = gedge_neighbor;
                            }
loop_unique_search_0:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && (d < lmind-1 || d > lmind+1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }
                        // update global values;
                        gminsad_p = (lmind == 0 ? gedge : sad[lmind-1]);
                        gminsad_n = sad[lmind == NDISP_UNIT-1 ? lmind-1 : lmind+1];
                        gminsad = lminsad;
                        gmind = lmind + sweep*NDISP_UNIT;
                    } else {
                        if (state.uniquenessRatio > 0) {
                            int thresh = gminsad + (gminsad * state.uniquenessRatio / 100);
loop_unique_search_1:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && ((gmind == (sweep*NDISP_UNIT-1)) ? (d > 0) : 1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }
                    }
                    minsad[col] = gminsad;
                    mind[col] = gmind;
                    skip[col] = gskip;
                    skip_val[col] = gskip_val;
                    edge_neighbor[col] = sad[NDISP_UNIT-2];
                    edge[col] = sad[NDISP_UNIT-1];
                    minsad_p[col] = gminsad_p;
                    minsad_n[col] = gminsad_n;

                    if (sweep == state.sweepFactor-1) {
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> p = gminsad_p;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> n = gminsad_n;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> k = p + n - 2*gminsad + absdiff(p, n);
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value+8> num = p - n;
                        num = num << 8;
                        ap_int<10> delta = 0;
                        if (k != 0) delta = num/k;
                        out_pix.val[0] = ((gmind*256 + delta + 15) >> 4);
                        //out_pix.val[0] = ((gmind*256 + (k != 0 ? (p-n)*256/k : 0) + 15) >> 4);
                        skip_flag |= gskip;
                        if (skip_flag) out_pix.val[0] = FILTERED;
                        disp << out_pix;
                    }
                }
            }
        }
    }
}


template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void FindStereoCorrespondenceBM(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)
{
    ((left.rows == right.rows && left.cols == right.cols && "All the images must have the same size") ? static_cast<void> (0) : __assert_fail ("left.rows == right.rows && left.cols == right.cols && \"All the images must have the same size\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 556, __PRETTY_FUNCTION__));
    ((SRC_T == (((0) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Both input images must have HLS_8UC1 format") ? static_cast<void> (0) : __assert_fail ("SRC_T == (((0) & ((1 << 11) - 1)) + (((1)-1) << 11)) && \"Both input images must have HLS_8UC1 format\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 557, __PRETTY_FUNCTION__));
    ((DST_T == (((3) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Disparity image must have HLS_16SC1 format") ? static_cast<void> (0) : __assert_fail ("DST_T == (((3) & ((1 << 11) - 1)) + (((1)-1) << 11)) && \"Disparity image must have HLS_16SC1 format\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 558, __PRETTY_FUNCTION__));
    ((state.preFilterType == 0 || state.preFilterType == 1) ? static_cast<void> (0) : __assert_fail ("state.preFilterType == 0 || state.preFilterType == 1", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 559, __PRETTY_FUNCTION__));
    ((state.preFilterSize >= 5 && state.preFilterSize <= 21 && (state.preFilterSize & 1) && "preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE") ? static_cast<void> (0) : __assert_fail ("state.preFilterSize >= 5 && state.preFilterSize <= 21 && (state.preFilterSize & 1) && \"preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 560, __PRETTY_FUNCTION__));
    ((state.preFilterCap >=1 && state.preFilterCap <= 63 && "preFilterCap must be within 1..63") ? static_cast<void> (0) : __assert_fail ("state.preFilterCap >=1 && state.preFilterCap <= 63 && \"preFilterCap must be within 1..63\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 561, __PRETTY_FUNCTION__));
    ((state.SADWindowSize >= 5 && state.SADWindowSize <= 21 && (state.SADWindowSize & 1) && state.SADWindowSize < ((left.rows) < (left.cols) ? (left.rows) : (left.cols)) && "SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height") ? static_cast<void> (0) : __assert_fail ("state.SADWindowSize >= 5 && state.SADWindowSize <= 21 && (state.SADWindowSize & 1) && state.SADWindowSize < ((left.rows) < (left.cols) ? (left.rows) : (left.cols)) && \"SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 562, __PRETTY_FUNCTION__));
    ((NDISP > 1 && "numberOfDisparities must be greater than 1") ? static_cast<void> (0) : __assert_fail ("NDISP > 1 && \"numberOfDisparities must be greater than 1\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 563, __PRETTY_FUNCTION__));
    ((NDISP >= NDISP_UNIT && "numberOfDisparities must be not less than ndisp_unit") ? static_cast<void> (0) : __assert_fail ("NDISP >= NDISP_UNIT && \"numberOfDisparities must be not less than ndisp_unit\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 564, __PRETTY_FUNCTION__));
    ((state.textureThreshold >= 0 && "texture threshold must be non-negative") ? static_cast<void> (0) : __assert_fail ("state.textureThreshold >= 0 && \"texture threshold must be non-negative\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 565, __PRETTY_FUNCTION__));
    ((state.uniquenessRatio >= 0 && "uniqueness ratio must be non-negative") ? static_cast<void> (0) : __assert_fail ("state.uniquenessRatio >= 0 && \"uniqueness ratio must be non-negative\"", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 566, __PRETTY_FUNCTION__));
    int rows = left.rows;
    int cols = left.cols;
    ((rows <= ROWS) ? static_cast<void> (0) : __assert_fail ("rows <= ROWS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 569, __PRETTY_FUNCTION__));
    ((cols <= COLS) ? static_cast<void> (0) : __assert_fail ("cols <= COLS", "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls/hls_video_stereobm.h", 570, __PRETTY_FUNCTION__));
    Mat<ROWS, COLS, SRC_T> _left_0(rows, cols);
    Mat<ROWS, COLS, SRC_T> _right_0(rows, cols);
_ssdm_op_SpecDataflowPipeline(-1, "");
    if (state.preFilterType == 0) {
        PreFilterNorm<WSIZE>(left, _left_0, state.preFilterCap);
        PreFilterNorm<WSIZE>(right, _right_0, state.preFilterCap);
    } else {
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> left_sobel(rows, cols);
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> right_sobel(rows, cols);
        Sobel<1, 0, 3>(left, left_sobel);
        Sobel<1, 0, 3>(right, right_sobel);
        Clip(left_sobel, _left_0, state.preFilterCap);
        Clip(right_sobel, _right_0, state.preFilterCap);
    }
    SADBlockMatching(_left_0, _right_0, disp, state);
}

} // namespace hls



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 70 "/scratch/xilinx/SDx/2017.1/Vivado_HLS/common/technology/autopilot/hls_video.h" 2



// 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
# 10 "optical_flow.cpp" 2
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
# 45 "/usr/include/assert.h" 3 4
/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
# 66 "/usr/include/assert.h" 3 4
extern "C" {

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 100 "/usr/include/assert.h" 3 4
/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# 11 "optical_flow.cpp" 2

const int max_width = 1024; // so that it can be used in a pragma

void optical_flow(pixel_t frame1[436][1024],
    pixel_t frame2[436][1024],
    pixel_t frame3[436][1024],
    pixel_t frame4[436][1024],
    pixel_t frame5[436][1024],
    velocity_t output[436][1024],
    gradient_t grad[436][1024],
    tensor_t tensor_out[436][1024]
)
{_ssdm_SpecArrayDimSize(output,436);_ssdm_SpecArrayDimSize(frame3,436);_ssdm_SpecArrayDimSize(frame4,436);_ssdm_SpecArrayDimSize(frame1,436);_ssdm_SpecArrayDimSize(frame2,436);_ssdm_SpecArrayDimSize(frame5,436);_ssdm_SpecArrayDimSize(tensor_out,436);_ssdm_SpecArrayDimSize(grad,436);
_ssdm_op_SpecInterface(frame3, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecDataflowPipeline(-1, "");

 static pixel_t gradient_x[436][1024];
_ssdm_SpecStream( gradient_x, 0, 1, "");
 static pixel_t gradient_y[436][1024];
_ssdm_SpecStream( gradient_y, 0, 1, "");
 static pixel_t gradient_z[436][1024];
_ssdm_SpecStream( gradient_z, 0, max_width*4, "");
 static gradient_t y_filtered[436][1024];
_ssdm_SpecStream( y_filtered, 0, 1, "");
 static gradient_t filtered_gradient[436][1024];
_ssdm_SpecStream( filtered_gradient, 0, 1, "");
 static outer_t out_product[436][1024];
_ssdm_SpecStream( out_product, 0, 1, "");
_ssdm_DataPack( out_product, 0, 0, "", "", "");
 static tensor_t tensor_y[436][1024];
_ssdm_SpecStream( tensor_y, 0, 1, "");
_ssdm_DataPack( tensor_y, 0, 0, "", "", "");
 static tensor_t tensor[436][1024];
_ssdm_SpecStream( tensor, 0, 1, "");
_ssdm_DataPack( tensor, 0, 0, "", "", "");

 // Need to duplicate frame3 for the two calculations
    static pixel_t frame3_a[436][1024];
_ssdm_SpecStream( frame3_a, 0, 1, "");
 static pixel_t frame3_b[436][1024];
_ssdm_SpecStream( frame3_b, 0, 1, "");
 for (int r=0; r<436; r++) {
      for (int c=0; c<1024; c++) {
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 55, __PRETTY_FUNCTION__));
        ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 56, __PRETTY_FUNCTION__));
        pixel_t pix = frame3[r][c];
        frame3_a[r][c] = pix;
        frame3_b[r][c] = pix;
      }
    }


    gradient_xy_calc(frame3_a, gradient_x, gradient_y);
    gradient_z_calc(frame1, frame2, frame3_b, frame4, frame5, gradient_z);
    gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);
    gradient_weight_x(y_filtered, filtered_gradient);
    for (int r=0; r<436; r++) {
      for (int c=0; c<1024; c++) {
        grad[r][c].x = gradient_x[r][c];
        grad[r][c].y = gradient_y[r][c];
        grad[r][c].z = gradient_z[r][c];
      }
    }
    outer_product(filtered_gradient, out_product);
    tensor_weight_y(out_product, tensor_y);
    tensor_weight_x(tensor_y, tensor);
    flow_calc(tensor, output);

    for (int r=0; r<436; r++) {
      for (int c=0; c<1024; c++) {
        for (int k=0; k<6; k++) {
          tensor_out[r][c].val[k] = tensor[r][c].val[k];
        }
      }
    }
}



void gradient_xy_calc(pixel_t frame[436][1024],
    pixel_t gradient_x[436][1024],
    pixel_t gradient_y[436][1024])
{_ssdm_SpecArrayDimSize(gradient_y,436);_ssdm_SpecArrayDimSize(frame,436);_ssdm_SpecArrayDimSize(gradient_x,436);
_ssdm_op_SpecInterface(frame, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(gradient_x, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(gradient_y, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 hls::LineBuffer<5,1024,pixel_t> buf;
    hls::Window<5,5,pixel_t> window;
    for(int r=0; r<436 +2; r++){
        for(int c=0; c<1024 +2; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 if(r<436 && c<1024){
        ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 104, __PRETTY_FUNCTION__));
        ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 105, __PRETTY_FUNCTION__));
                buf.shift_pixels_up(c);
                buf.insert_bottom_row(frame[r][c],c);
            }
            else if(c<1024){
                buf.shift_pixels_up(c);
                buf.insert_bottom_row(0,c);
            }
            pixel_t x_grad = 0;
            pixel_t y_grad = 0;
            if(r<436 && c<1024){
                window.shift_pixels_left();
                window.insert_pixel(buf.getval(0,c),0,4);
                window.insert_pixel(buf.getval(1,c),1,4);
                window.insert_pixel(buf.getval(2,c),2,4);
                window.insert_pixel(buf.getval(3,c),3,4);
                window.insert_pixel(buf.getval(4,c),4,4);
            }
            else{
                window.shift_pixels_left();
                window.insert_pixel(0,0,4);
                window.insert_pixel(0,1,4);
                window.insert_pixel(0,2,4);
                window.insert_pixel(0,3,4);
                window.insert_pixel(0,4,4);
            }
            if(r>=4 && r<436 && c>=4 && c<1024){
                for(int i=0; i<5; i++){
                    x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];
                    y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];
                }
        (((r-2) >= 0 && (r-2) < 436) ? static_cast<void> (0) : __assert_fail ("(r-2) >= 0 && (r-2) < 436", "optical_flow.cpp", 136, __PRETTY_FUNCTION__));
        (((c-2) >= 0 && (c-2) < 1024) ? static_cast<void> (0) : __assert_fail ("(c-2) >= 0 && (c-2) < 1024", "optical_flow.cpp", 137, __PRETTY_FUNCTION__));
                gradient_x[r-2][c-2] = x_grad/12;
                gradient_y[r-2][c-2] = y_grad/12;
            }
            else if(r>=2 && c>=2){
        (((r-2) >= 0 && (r-2) < 436) ? static_cast<void> (0) : __assert_fail ("(r-2) >= 0 && (r-2) < 436", "optical_flow.cpp", 142, __PRETTY_FUNCTION__));
        (((c-2) >= 0 && (c-2) < 1024) ? static_cast<void> (0) : __assert_fail ("(c-2) >= 0 && (c-2) < 1024", "optical_flow.cpp", 143, __PRETTY_FUNCTION__));
                gradient_x[r-2][c-2] = 0;
                gradient_y[r-2][c-2] = 0;
            }
        }
    }
}

/*
void gradient_xy_calc(pixel_t frame[MAX_HEIGHT][MAX_WIDTH],
    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],
    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])
{
    for(int r=0; r<MAX_HEIGHT+2; r++){
        for(int c=0; c<MAX_WIDTH; c++){
            pixel_t x_grad = 0;
            pixel_t y_grad = 0;
            for(int i=-2; i<3; i++){
                if(c+i>=0 && c+i < MAX_WIDTH){
                    x_grad += frame[r][c+i]*GRAD_WEIGHTS[i+2];
                }
                if(r+i>=0 && r+i < MAX_HEIGHT){
                    y_grad += frame[r+i][c]*GRAD_WEIGHTS[i+2];
                }
            }
            gradient_x[r][c] = x_grad/12;
            gradient_y[r][c] = y_grad/12;
        }
    }
}
*/

void gradient_z_calc(pixel_t frame1[436][1024],
    pixel_t frame2[436][1024],
    pixel_t frame3[436][1024],
    pixel_t frame4[436][1024],
    pixel_t frame5[436][1024],
    pixel_t gradient_z[436][1024])
{_ssdm_SpecArrayDimSize(frame3,436);_ssdm_SpecArrayDimSize(frame4,436);_ssdm_SpecArrayDimSize(frame1,436);_ssdm_SpecArrayDimSize(frame2,436);_ssdm_SpecArrayDimSize(frame5,436);_ssdm_SpecArrayDimSize(gradient_z,436);
_ssdm_op_SpecInterface(frame1, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(frame2, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(frame3, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(frame4, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(frame5, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(gradient_z, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 for(int r=0; r<436; r++){
        for(int c=0; c<1024; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 191, __PRETTY_FUNCTION__));
            ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 192, __PRETTY_FUNCTION__));
            gradient_z[r][c] = (frame1[r][c]*GRAD_WEIGHTS[0]
                + frame2[r][c]*GRAD_WEIGHTS[1]
                + frame3[r][c]*GRAD_WEIGHTS[2]
                + frame4[r][c]*GRAD_WEIGHTS[3]
                + frame5[r][c]*GRAD_WEIGHTS[4])/12;
        }
    }
}

void gradient_weight_y(pixel_t gradient_x[436][1024],
    pixel_t gradient_y[436][1024],
    pixel_t gradient_z[436][1024],
    gradient_t filt_grad[436][1024])
{_ssdm_SpecArrayDimSize(gradient_y,436);_ssdm_SpecArrayDimSize(filt_grad,436);_ssdm_SpecArrayDimSize(gradient_z,436);_ssdm_SpecArrayDimSize(gradient_x,436);
_ssdm_op_SpecInterface(gradient_x, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(gradient_y, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(gradient_z, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(filt_grad, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 hls::LineBuffer<7,1024,gradient_t> buf;
    for(int r=0; r<436 +3; r++){
        for(int c=0; c<1024; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 //std::cout << gradient_x[r][c] << " r" << r << " c" << c << std::endl;

            if(r<436){
                buf.shift_pixels_up(c);
                gradient_t tmp;
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 220, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 221, __PRETTY_FUNCTION__));
                tmp.x = gradient_x[r][c];
                tmp.y = gradient_y[r][c];
                tmp.z = gradient_z[r][c];
                buf.insert_bottom_row(tmp,c);
            }
            else{
                buf.shift_pixels_up(c);
                gradient_t tmp;
                tmp.x = 0;
                tmp.y = 0;
                tmp.z = 0;
                buf.insert_bottom_row(tmp,c);
            }

            gradient_t acc;
            acc.x = 0;
            acc.y = 0;
            acc.z = 0;
            if(r >= 6 && r<436){
                for(int i=0; i<7; i++){
                        acc.x += buf.getval(i,c).x*GRAD_FILTER[i];
                        acc.y += buf.getval(i,c).y*GRAD_FILTER[i];
                        acc.z += buf.getval(i,c).z*GRAD_FILTER[i];
                }
                (((r-3) >= 0 && (r-3) < 436) ? static_cast<void> (0) : __assert_fail ("(r-3) >= 0 && (r-3) < 436", "optical_flow.cpp", 246, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 247, __PRETTY_FUNCTION__));
                filt_grad[r-3][c] = acc;
            }
            else if(r>=3){
                (((r-3) >= 0 && (r-3) < 436) ? static_cast<void> (0) : __assert_fail ("(r-3) >= 0 && (r-3) < 436", "optical_flow.cpp", 251, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 252, __PRETTY_FUNCTION__));
                filt_grad[r-3][c] = acc;
            }
        }
    }
}

void gradient_weight_x(gradient_t y_filt[436][1024],
    gradient_t filt_grad[436][1024])
{_ssdm_SpecArrayDimSize(y_filt,436);_ssdm_SpecArrayDimSize(filt_grad,436);
_ssdm_op_SpecInterface(y_filt, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(filt_grad, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 hls::Window<1,7,gradient_t> buf;
    for(int r=0; r<436; r++){
        for(int c=0; c<1024 +3; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 buf.shift_pixels_left();
            gradient_t tmp;
            if(c<1024){
                //std::cout << y_filt[r][c].x << " r" << r << " c" << c << std::endl;
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 272, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 273, __PRETTY_FUNCTION__));
                tmp = y_filt[r][c];
            }
            else{
                tmp.x = 0;
                tmp.y = 0;
                tmp.z = 0;
            }
            buf.insert_pixel(tmp,0,6);

            gradient_t acc;
            acc.x = 0;
            acc.y = 0;
            acc.z = 0;
            if(c >= 6 && c<1024){
                for(int i=0; i<7; i++){
                    acc.x += buf.getval(0,i).x*GRAD_FILTER[i];
                    acc.y += buf.getval(0,i).y*GRAD_FILTER[i];
                    acc.z += buf.getval(0,i).z*GRAD_FILTER[i];
                }
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 293, __PRETTY_FUNCTION__));
                (((c-3) >= 0 && (c-3) < 1024) ? static_cast<void> (0) : __assert_fail ("(c-3) >= 0 && (c-3) < 1024", "optical_flow.cpp", 294, __PRETTY_FUNCTION__));
                filt_grad[r][c-3] = acc;
            }
            else if(c>=3){
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 298, __PRETTY_FUNCTION__));
                (((c-3) >= 0 && (c-3) < 1024) ? static_cast<void> (0) : __assert_fail ("(c-3) >= 0 && (c-3) < 1024", "optical_flow.cpp", 299, __PRETTY_FUNCTION__));
                filt_grad[r][c-3] = acc;
            }
        }
    }
}

void outer_product(gradient_t gradient[436][1024],
     outer_t outer_product[436][1024])
{_ssdm_SpecArrayDimSize(gradient,436);_ssdm_SpecArrayDimSize(outer_product,436);
_ssdm_op_SpecInterface(gradient, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(outer_product, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");

 for(int r=0; r<436; r++){
        for(int c=0; c<1024; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 315, __PRETTY_FUNCTION__));
            ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 316, __PRETTY_FUNCTION__));
            gradient_t grad = gradient[r][c];
            outer_t out;
            out.val[0] = grad.x*grad.x;
            out.val[1] = grad.y*grad.y;
            out.val[2] = grad.z*grad.z;
            out.val[3] = grad.x*grad.y;
            out.val[4] = grad.x*grad.z;
            out.val[5] = grad.y*grad.z;
            outer_product[r][c] = out;
        }
    }
}
/*
void tensor_weight(outer_t outer[MAX_HEIGHT][MAX_WIDTH],
    tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])
{
    tensor_t tmp[MAX_HEIGHT][MAX_WIDTH];
    for(int r=0; r<MAX_HEIGHT; r++){
        for(int c=0; c<MAX_WIDTH; c++){
            for(int k=0; k<6; k++){
                tmp[r][c].val[k] = 0;
                for(int i=0; i<3; i++){
                    if(c+i-1>=0 && c+i-1<MAX_WIDTH){
                        tmp[r][c].val[k] += outer[r][c+i-1].val[k]*TENSOR_FILTER[i];
                    }
                }
            }            
        }
    }
    for(int r=0; r<MAX_HEIGHT; r++){
        for(int c=0; c<MAX_WIDTH; c++){
            for(int k=0; k<6; k++){
                tensor[r][c].val[k] = 0;
                for(int i=0; i<3; i++){
                    if(r+i-1>=0 && r+i-1<MAX_HEIGHT){
                        tensor[r][c].val[k] += tmp[r+i-1][c].val[k]*TENSOR_FILTER[i];
                    }
                }
               //std::cout << tensor[r][c].val[k] << " r" << r << " c" << c << std::endl;
            }            
        }
    }
}
*/
void tensor_weight_y(outer_t outer[436][1024],
    tensor_t tensor_y[436][1024])
{_ssdm_SpecArrayDimSize(outer,436);_ssdm_SpecArrayDimSize(tensor_y,436);
_ssdm_op_SpecInterface(outer, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(tensor_y, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 hls::LineBuffer<3,1024,outer_t> buf;
    for(int r=0; r<436 +1; r++){
        for(int c=0; c<1024; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 //std::cout << gradient_x[r][c] << " r" << r << " c" << c << std::endl;

            outer_t tmp;
_ssdm_DataPack( &tmp, 0, 0, "", "", "");
_ssdm_DataPack( buf.val[0], 0, 0, "", "", "");
 buf.shift_pixels_up(c);
            if(r<436){
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 377, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 378, __PRETTY_FUNCTION__));
                tmp = outer[r][c];
            }
            else{
                for(int i=0; i<6; i++){
                    tmp.val[i] = 0;
                }
            }
            buf.insert_bottom_row(tmp,c);

            tensor_t acc;
            for(int k =0; k<6; k++){
                acc.val[k] = 0;
            }
            if (r >= 2 && r < 436) {
                for(int i=0; i<3; i++){
                    tmp = buf.getval(i,c);
                    pixel_t k = TENSOR_FILTER[i];
                    dumb:for(int component=0; component<6; component++){
                        acc.val[component] += tmp.val[component]*k;
                    }
                }
            }
            if(r >= 1){
                (((r-1) >= 0 && (r-1) < 436) ? static_cast<void> (0) : __assert_fail ("(r-1) >= 0 && (r-1) < 436", "optical_flow.cpp", 402, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 403, __PRETTY_FUNCTION__));
                tensor_y[r-1][c] = acc;
            }
        }
    }
}

void tensor_weight_x(tensor_t tensor_y[436][1024],
    tensor_t tensor[436][1024])
{_ssdm_SpecArrayDimSize(tensor_y,436);_ssdm_SpecArrayDimSize(tensor,436);
_ssdm_op_SpecInterface(tensor_y, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(tensor, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 hls::Window<1,3,tensor_t> buf;
    for(int r=0; r<436; r++){
        for(int c=0; c<1024 +1; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 buf.shift_pixels_left();
            tensor_t tmp;
            if(c<1024){
                //std::cout << y_filt[r][c].x << " r" << r << " c" << c << std::endl;
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 423, __PRETTY_FUNCTION__));
                ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 424, __PRETTY_FUNCTION__));
                tmp = tensor_y[r][c];
            }
            else{
                for(int i=0; i<6; i++){
                    tmp.val[i] = 0;
                }
            }
            buf.insert_pixel(tmp,0,2);

            tensor_t acc;
            for(int k =0; k<6; k++){
                acc.val[k] = 0;
            }
            if (c >= 2 && c < 1024) {
                for(int i=0; i<3; i++){
                    tmp = buf.getval(0,i);
                    stupid:for(int component=0; component<6; component++){
                        acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];
                    }
                }
            }
            if(c>=1){
                ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 447, __PRETTY_FUNCTION__));
                (((c-1) >= 0 && (c-1) < 1024) ? static_cast<void> (0) : __assert_fail ("(c-1) >= 0 && (c-1) < 1024", "optical_flow.cpp", 448, __PRETTY_FUNCTION__));
                tensor[r][c-1] = acc;
            }
        }
    }
}

void flow_calc(tensor_t tensors[436][1024],
    velocity_t output[436][1024])
{_ssdm_SpecArrayDimSize(output,436);_ssdm_SpecArrayDimSize(tensors,436);
_ssdm_op_SpecInterface(tensors, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
_ssdm_op_SpecInterface(output, "ap_fifo", 0, 0, "", 0, 0, "", "", "", 0, 0, 0, 0, "", "");
 for(int r=0; r<436; r++){
        for(int c=0; c<1024; c++){
_ssdm_op_SpecPipeline(1, 1, 1, 0, "");
 ((r >= 0 && r < 436) ? static_cast<void> (0) : __assert_fail ("r >= 0 && r < 436", "optical_flow.cpp", 463, __PRETTY_FUNCTION__));
            ((c >= 0 && c < 1024) ? static_cast<void> (0) : __assert_fail ("c >= 0 && c < 1024", "optical_flow.cpp", 464, __PRETTY_FUNCTION__));
            if(r>=2 && r<436 -2 && c>=2 && c<1024 -2){
                pixel_t denom = tensors[r][c].val[0]*tensors[r][c].val[1]-
                    tensors[r][c].val[3]*tensors[r][c].val[3];
                //if(denom > 0.001){
                    output[r][c].x = (tensors[r][c].val[5]*tensors[r][c].val[3]-
                        tensors[r][c].val[4]*tensors[r][c].val[1]) / denom;
                    output[r][c].y = (tensors[r][c].val[4]*tensors[r][c].val[3]-
                        tensors[r][c].val[5]*tensors[r][c].val[0]) / denom;
                //std::cout << "x" << output[r][c].x << " y" << output[r][c].y 
                //<< " r" << r << " c" << c << std::endl;
                //} else {
                //  output[r][c].x = 0;
                //  output[r][c].y = 0;
                //}
            }
            else{
                output[r][c].x = 0;
                output[r][c].y = 0;
            }
        }
    }
}

class ssdm_global_array_optical_flowpp0cppaplinecpp {
 public:
   inline __attribute__((always_inline)) ssdm_global_array_optical_flowpp0cppaplinecpp() {
   _ssdm_SpecConstant(GRAD_WEIGHTS);
   _ssdm_SpecConstant(GRAD_FILTER);
   _ssdm_SpecConstant(TENSOR_FILTER);
   _ssdm_SpecConstant(&hls::log_reduce::p0);
   _ssdm_SpecConstant(&hls::log_reduce::alpha0);
   _ssdm_SpecConstant(&hls::log_reduce::p1);
   _ssdm_SpecConstant(&hls::log_reduce::alpha1);
   _ssdm_SpecConstant(&hls::log_reduce::p2);
   _ssdm_SpecConstant(&hls::log_reduce::alpha2);
   _ssdm_SpecConstant(&hls::log_reduce::p3);
   _ssdm_SpecConstant(&hls::log_reduce::alpha3);
   _ssdm_SpecConstant(&hls::log_reduce::p4);
   _ssdm_SpecConstant(&hls::log_reduce::alpha4);
   _ssdm_SpecConstant(&hls::log_reduce::p5);
   _ssdm_SpecConstant(&hls::log_reduce::alpha5);
   _ssdm_SpecConstant(&hls::log_reduce::p6);
   _ssdm_SpecConstant(&hls::log_reduce::alpha6);
   _ssdm_SpecConstant(&hls::log_reduce::p7);
   _ssdm_SpecConstant(&hls::log_reduce::alpha7);
   _ssdm_SpecConstant(&hls::log_reduce::p8);
   _ssdm_SpecConstant(&hls::pow_reduce::p0);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha0);
   _ssdm_SpecConstant(&hls::pow_reduce::p1);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha1);
   _ssdm_SpecConstant(&hls::pow_reduce::p2);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha2);
   _ssdm_SpecConstant(&hls::pow_reduce::p3);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha3);
   _ssdm_SpecConstant(&hls::pow_reduce::p4);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha4);
   _ssdm_SpecConstant(&hls::pow_reduce::p5);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha5);
   _ssdm_SpecConstant(&hls::pow_reduce::p6);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha6);
   _ssdm_SpecConstant(&hls::pow_reduce::p7);
   _ssdm_SpecConstant(&hls::pow_reduce::alpha7);
   _ssdm_SpecConstant(&hls::pow_reduce::p8);
   _ssdm_SpecConstant(&hls::ref_cordic);
   _ssdm_SpecConstant(&hls::ref_4oPi_512);
   _ssdm_SpecConstant(hls::ref_4oPi_table_256);
   _ssdm_SpecConstant(hls::ref_4oPi_table_100);
   _ssdm_SpecConstant(hls::ref_4oPi_table_80);
   _ssdm_SpecConstant(&hls::ref_Pio4_400);
   _ssdm_SpecConstant(hls::ref_Pio4_table);
   _ssdm_SpecConstant(hls::cordic_ctab_table_int_128);
   _ssdm_SpecConstant(hls::cordic_ctab_table_128);
   _ssdm_SpecConstant(hls::cordic_ctab_table_floatdouble_128);
   _ssdm_SpecConstant(hls::cordic_hyperb_table_floatdouble_128);
   _ssdm_SpecConstant(hls::cordic_hyperb_table_128);
   _ssdm_SpecConstant(hls::cordic_hyperb_table_128_160);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::cos_K0);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::cos_K1);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::cos_K2);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_K0);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_K1);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_K2);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_cos_K0);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_cos_K1);
   _ssdm_SpecConstant(hls::hotbm::second_order_float::sin_cos_K2);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::cos_K0);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::cos_K1);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::sin_K0);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::sin_K1);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::sin_cos_K0);
   _ssdm_SpecConstant(hls::hotbm::first_order_half::sin_cos_K1);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::cos_K0);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::cos_K1);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::cos_K2);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::cos_K3);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::cos_K4);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_K0);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_K1);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_K2);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_K3);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_K4);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_cos_K0);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_cos_K1);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_cos_K2);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_cos_K3);
   _ssdm_SpecConstant(hls::hotbm::fourth_order_double::sin_cos_K4);
   _ssdm_SpecConstant(hls::hotbm::first_order_fixed_16::sin_cos_K0);
   _ssdm_SpecConstant(hls::hotbm::first_order_fixed_16::sin_cos_K1);
   _ssdm_SpecConstant(hls::hotbm::second_tanh_K0);
   _ssdm_SpecConstant(hls::hotbm::second_tanh_K1);
   _ssdm_SpecConstant(hls::hotbm::second_tanh_K2);
   _ssdm_SpecConstant(hls::hotbm::second_atanh_K0);
   _ssdm_SpecConstant(hls::hotbm::second_atanh_K1);
   _ssdm_SpecConstant(hls::hotbm::second_atanh_K2);
   _ssdm_SpecConstant(hls::hotbm::first_tanh_K0);
   _ssdm_SpecConstant(hls::hotbm::first_tanh_K1);
   _ssdm_SpecConstant(&hls::asin_acos_approx::Infinity);
   _ssdm_SpecConstant(&hls::asin_acos_approx::Tiny);
   _ssdm_SpecConstant(&max_width);
  }
};
static ssdm_global_array_optical_flowpp0cppaplinecpp ssdm_global_array_ins;
