#include "bandit.h"
#include <cmath>
#include <cfloat>
#include <cstdio>
#include <cassert>
#include <queue>
#include <vector>
#include <map>
#include <utility>
#include "structure.h"

using namespace std;

Bandit::Bandit(int arms){
  this->c = 0.05;
  this->window = 500;
  this->numofArms = arms;
  this->best_reward = +DBL_MAX; //minimization
  for(int i = 1; i <= arms; i++) {
    this->use_counts.insert(pair<int,int>(i,0));
    this->auc_sum.insert(pair<int,int>(i,0));
    this->auc_decay.insert(pair<int,int>(i,0));
  }
}
Bandit::~Bandit(){}

void Bandit::check_arms(map<int,Space*> space_buffer) {
  assert(space_buffer.size() == use_counts.size());
  for(map<int,int>::iterator it = use_counts.begin();
    it != use_counts.end(); it++) {
    assert(space_buffer.count(it->first) > 0);
  }
}
float Bandit::exploitation_term(int index) {
  assert(auc_sum.count(index) > 0);
  assert(use_counts.count(index) > 0);

  float score = auc_sum.find(index)->second;
  int pos = use_counts.find(index)->second;
  if(pos > 0)
    return score*2.0/(pos*(pos+1.0));
  else
    return 0.0;
}
float Bandit::exploitation_ucb(int index, std::map<int,std::vector<Result*> >& points){
  if(points.size() == 0 ||points.count(index) <= 0) return -100;
  float average_score = 0;
  vector<Result*> results = points.find(index)->second;
  int num = 0;
  for(int i = 0; i < results.size(); i++) {
    float wns = results[i]->score;
    if(fabs(wns) == 10000) {
       continue;
    }
    average_score += wns;
    num++;
  }
  if(num > 0) average_score = average_score/num;
  else average_score = 100; //fake num
  return -1*average_score;
}


float Bandit::exploration_term(int index) {
  assert(use_counts.count(index) > 0);
  int use_num = use_counts.find(index)->second;
  if(use_num > 0) return sqrt(2.0*log(history.size())/use_num);
  else return 1000000;
}

float Bandit::bandit_score(int index) {
  return exploitation_term(index) + c*exploration_term(index);
}
float Bandit::ucb_score(int index, std::map<int,std::vector<Result*> >& points) {
  float myexploitation = exploitation_ucb(index, points);
  float myexploration = exploration_term(index);

  //printf("debug ucb score: exploitation %f, normalized: %f, exploration %f\n")
  return myexploitation + myexploration;
}

void Bandit::push_history(int index, float score) {
  assert(use_counts.count(index) > 0);
  assert(auc_sum.count(index) > 0);
  assert(auc_decay.count(index) > 0);
  history.push(index);
  use_counts.find(index)->second++;
  if(score < best_reward) {
    //new global best???
#ifdef DEBUG_MSG
    printf("new best result %f, generated by %d\n",score,index);
#endif
    best_reward = score;
    was_best.push(1);
    auc_sum.find(index)->second += use_counts.find(index)->second;   
    auc_decay.find(index)->second += 1;
  }
  else was_best.push(0);
}

void Bandit::pop_history() {
  //To do check
  //Lazy update now since window size is too large Later build like old index => new index
  if(history.size() > window) {
    for(int i = 0; i < window - history.size(); i++) {
      int taskid = history.front();
      history.pop();
      int value = was_best.front();
      was_best.pop();
      if(use_counts.count(taskid) > 0) use_counts.find(taskid)->second--;
      if(auc_sum.count(taskid) > 0) {
        assert(auc_decay.count(taskid) > 0);
        auc_sum.find(taskid)->second -= auc_decay.find(taskid)->second;
        if(value) auc_decay.find(taskid)->second -= 1;
      }
    }
  }
}
void Bandit::on_result(int index, float score) {
  push_history(index,score);
  pop_history();
}

float Bandit::normalized_score(float min, float max, float score) {
  if(max == min) {assert(score == min); return 1;}
  return 1-(max-score)/(max-min);
}

void Bandit::cal_rewards(std::map<int,std::vector<Result*> >& points, vector<pair<int,float> >& reward) {
  //Mind index starting from 0
  //reward.resize(tasknum);
  assert(use_counts.size() == auc_sum.size());
  assert(use_counts.size() == auc_decay.size());
  reward.resize(0);
  float max = -DBL_MAX;
  float min = +DBL_MAX;

  for(map<int,int>::iterator it = use_counts.begin(); it != use_counts.end(); it++) {
    float score = exploitation_ucb(it->first, points);
    max = max < score ? score : max;
    min = min > score ? score : min;
  }

  for(map<int,int>::iterator it = use_counts.begin(); it != use_counts.end(); it++) {
    int index = it->first;
    //float score = bandit_score(index);
    //try ucb score
    float score;
    float my_explot = 0.0;
    float my_explor = exploration_term(index);
    my_explot = normalized_score(min,max,exploitation_ucb(it->first, points)); 
    score = my_explot+c*my_explor;
#ifdef DEBUG_MSG
    printf("debug score exploit_score %f, normalized_score %f, exploration %f\n",exploitation_ucb(it->first,points),my_explot,my_explor);
#endif
    pair<int,float> tmp = make_pair(index, score);
    reward.push_back(tmp);
  }
  return;
}

int Bandit::update_bandit(int remove, int add_num) {
  assert(use_counts.count(remove) > 0);
  assert(auc_sum.count(remove) > 0);
  assert(auc_decay.count(remove) > 0);
  int old_use_count = use_counts.find(remove)->second;
  int old_auc_sum = auc_sum.find(remove)->second;
  int old_auc_decay = auc_decay.find(remove)->second;
  for(int i = 1; i <= add_num; i++) {
    int index = numofArms+i;
    use_counts.insert(pair<int,int>(index,old_use_count));
    auc_sum.insert(pair<int,int>(index,old_auc_sum));
    auc_decay.insert(pair<int,int>(index,old_auc_decay));
  }
  numofArms+=add_num;
  use_counts.erase(remove);
  auc_sum.erase(remove);
  auc_decay.erase(remove);
  return numofArms;
}

