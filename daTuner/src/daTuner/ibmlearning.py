#Import opentuner search module, results database , do some API calls 
#API calls for openTuner - sqlalchemy
#Import itertools from python and import itemgetter from operator

from opentuner.search import technique
from opentuner.resultsdb.models import *
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy import create_engine
from sqlalchemy.orm import relationship, backref
from sqlalchemy import (Column, Integer, String, DateTime, Boolean, Enum,Float, PickleType, ForeignKey, Text, func, Index)
import sqlalchemy
from operator import itemgetter
import itertools



#Check if there is a difference between any two configurations generated by the manipulator
#If there is a difference, return 'False' else return 'True'
def check_diff(manipulator,cfg1,cfg2):
	opt=list()
	for param in manipulator.get_param(cfg1):
		opt.append(param.get_value(cfg1))
	x=0
	for param in manipulator.get_param(cfg2):
		if (opt[x]!=param.get_value(cfg2)):
			return False
		x=x+1
	return True


#Generate configurations taking arguments manipulator,initial_set,driver and index
#Check if the length of initial set of cfgs is zero return Nothing else
#Get the configuration of the initial set and save the copy in cfg for comparison
#Checks if the parameter in the initial set is "OptDirective" or "PlacementDirective" or "RouteDirective"
#If so, then set the parameter value to teh default "DEFAULT" value
#Else check if the parameter name is "PhysicalOptDesign" if so, then set all its parameter values to 0
#Iterate through the index list, check if a parameter in an index list of scenarios  is "OptDirective" or "PlacementDirective" or "RouteDirective"
#If so, get the parameteric values of the top index list, if the values are not default get the respective parameter values
#Repeat the same thing for "PhysicalOptDesign"
#Store it in variable cfg and return cfg
def gen_cfg(manipulator,initial_set,driver,index):
	if(len(initial_set)==0):
		return None
	cfg=initial_set[0].data.copy()
	for param in manipulator.get_param(cfg):
		if (param.name=="OptDirective" or param.name=="PlacementDirective" or param.name=="RouteDirective"):
			param.set_value(cfg,"Default")
		else:
			param.set_value(cfg,"Off")
	for ix in range(len(index)):
		for param in manipulator.get_param(initial_set[index[ix]]):
			if (param.name=="OptDirective" or param.name=="PlacementDirective" or param.name=="RouteDirective"):
        if (param.get_value(initial_set[index[ix]].data)!="Default"):
          param.set_value(cfg,param.get_value(initial_set[index[ix]])
			else:
				if(param.get_value(initial_set[index[ix]]).data)!="Off"):
					param.set_value(cfg,param.get_value(initial_set[index[ix]])
	cfg=driver.get_configuration(cfg)
	return cfg


#Get the parameters of all the configurations in the manipulator (OpenTuner Data structure)
#Iterate through all the parameters in cfg if they are "OptDirective" or "PlacementDirective" or "RouteDirective"
#Then check if the values are "Default" if so, do nothing if not return the configuration parameter values
#Repeat the same thing for "PhysicalOptDesign" - check if the default value is not "Off" if so then
#return the parameters 
def get_param(manipulator,cfg):
	for param in manipulator.parameters(cfg):
		if(param.name=="OptDirective" or param.name=="PlacementDirective" or param.name=="RouteDirective"):
			if(param.get_value(cfg)!="Default"):
				return param.name
		else:
			if(param.get_value(cfg)!="Off"):
				return param.name

#Generate the configuration sets in combinations using itertools.combinations
#Create a new_scenarios list. On iteration through the list of all configurations generate i scenarious per each configuration
#Get the cfg using function call get_cfg()  
#Append the cfgs to the list new_scenarios and print the cfg.data
#Sort the new_scenarios by their WNS (metric) and return the new_scenarios
def compute_generations(List,i):
    new_scenarios=[]
    for iy in itertools.combinations(list(range(0,len(List))),i):
        cfg=get_cfg(iy,List,self.driver,self,manipulator)
        if cfg is None:
        	continue
        #self.yield.nonblocking(cfg)
       	new_scenarios.append(cfg)
        print cfg.data
    sorted(new_scenarios,key=itemgetter(1))
    #yield None
    #print "Combinations of %d"%i
    return new_scenarios1

#COST FUNCTION : Coarse Cost
"""
Cost function basically takes the combined list of configurations (combinations of twos and threes) and
computes the average of all the configurations. It then sorts the configurations based on the average of costs
i.e Worst Negative Slacks in this case. Sort the Top-k scenarios as per the (resultant) combined cost in the
descending order.
Implementation details: Created a Combined_sum list that has combinations of two's and three's and finds the average
cost of individual scenarios and sorts the list accordingly. The average costs are added to the list as the last tuple
and sorted accordingly; Sorted list is printed
"""
def cost_function(List):
    Combined_sum=[]
    Combined_sum=List
    k=[]
    print "Combined List"
    for i in range(len(Combined_sum)):
        print Combined_sum[i][0].data
        print Combined_sum[i][1]
    ##########################Have to change#########################
    for i in range(len(Combined_sum)):
        k.append(Combined_sum[i][1])
        avg=0.0
        for j in xrange(len(k)):
            avg += k[j]
        avg = avg /(len(k))
        Combined_sum[i] = Combined_sum[i] + (avg,)
        print '\n'
        #print Combined_sum[i][-1]


    Combined_sum.sort(key=lambda tup: tup[-1], reverse=True)    #sorted(Combined_sum,key=lambda x:x[-1])
    print '\n'
    print "Cost function sorted list"
    for i in range(len(Combined_sum)):
        print Combined_sum[i][0].data
        print Combined_sum[i][1]

#Learning_Search technique()
# gets the objective, driver and manipulator in opentUner datastructure
# assigns refernce config by getting some random opentuner generated configuration using get_configuration() function
# Iterates through the reference config and cehceks if the parameters are "OptDirective" or "PlacementDirective" or "RouteDirective"
# If so, then initially sets its parameter value to "Default" 
# Else if the parameter is "PhysicalOptDesign" then it sets the reference configuration value to "Off"
# Creates a initail_scenarios list and yeilds the config_reference value which basically are used by generator in python
# It precisely returns the value of variables without destroying the local copies of the variable
# Unlike a function, generator resumes where the function was last left
# Append config_reference to initail_scenarios list and check whether the config_reference is found in the OpenTuner results database
# If so then store it in res and print the WNS of the default configuration
 
# Sensitivity test : Iterates through the refernce configurations and runs through the parameter options
# Sets cfg to the copy of reference configuration and set the cfg to the various parameter options for comparison
# Checks if there is any duplication or repetition in the configurations by calling check_diff()
# If there is no duplication then cfg takes the new unique configuration and call yeild_nonblocking(cfg) to make sure that the parallelisation is consistent with the cfgs from parallel servers
# Append it to the initial_scenarios and yeild None to synchronise the results 
# Sort the initial_scenarios and after debugging check if sorted res configurations WNS is worse than the baseline, 
# If not , then count the number of unique configurations and append them in set s1
# Print the set s1
# Compute the generations of scenarios by passing how many scenarios need to be displayed (eq: 2 and 3) per each configurationa dn call teh cost function
# Finally, evaluate the tuples of the results database and print the outputs of the evaluated tupels
class Learning_Search(technique.SequentialSearchTechnique):

	def main_generator(self):

		objective=self.objective
		driver=self.driver
		manipulator=self.manipulator

		config_reference=driver.get_configuration(maniplator.random())
		for param in manipulator.parameters(config_reference.data):
			if (param.name=="OptDirective" or param.name=="PlacementDirective" or param.name=="RouteDirective"):
				param.set_value(config_reference.data,"Default")
			else:
				param_set_value(config_reference.data,"Off")
		print config_reference.data
		initial_scenarios=list()
		yield config_reference
		initial_scenarios.append(config_reference)
		res=self.driver.session.query(Results).filter(Result.configuration==config_reference).first()
		default_object=res.time()
		print "default value"
		print default_object
		
		#sensitivity test
		for param in manipulator.parameters(config_reference.data):
			for ix in range(len(param.options)):
				cfg=manipulator.copy(config_reference.data)
				param.set_value(cfg,param.options[ix])
				if(check_diff(manipulator,config_reference.data,cfg))==False:
					cfg=driver.get_configuration(cfg)
					self.yield_nonblocking(cfg)#parallelise
					initial_scenarios.append(cfg)
		yield None #Synchronise results
		
		#sort results
		initial_scenarios.sort(cmp=objective.compare)
		sorted_Result=[]
		
		new_scenarios=[]
		#debug initial scenarios
		for ix in range(len(initial_scenarios)):
			print initial_scenarios[ix].data
			res=self.driver.session.query(Results).filter(Result.configuration==initial_scenarios[ix]).first()
			print res.configuration.data
			sorted_Result.append(res.configuration,res.time)
			sorted(sorted_Result,key=itemgetter(1))
			
		check_if_exist=[]
		s1=[]
		#Survivor set //change
		for ix in range(len(sorted_Result)):
			 print sorted_Result[ix][0].data
			 print sorted_Result[ix][1]
			 if(sorted_Result[ix][1]<default_object):
			 	if(check_if_exist.count(get_param(manipulator,sorted_Result[ix][0].data))==0):
			 		check_if_exist.append(get_param(manipulator,sorted_Result[ix][0].data))
			 		s1.append(sorted_Result[ix][0].data)

		#check survivor //change
		for s in s1:
			print s.data
			print get_param(manipulator,s.data)


		

		#iterative combinations
		#List1=compute_generations(List,2)
        #List2=compute_generations(List,3)
        List1=[]
        List2=[]
		for ix in range(9):
			comb=ix+2
			print comb
			if(comb==2):
				List1=compute_generations(s1,comb)
				s1=list(List1)
			if(comb==3):
				List2=compute_generations(s1,comb)
				s1=list(List2)
		combined_List=[]
		combined_List=List1+List2		
		"""sec_iteration_scenarios=[]
		for i in range(len(combined_List)):
			print combined_List[i][0].data
			print combined_List[i][1]
			if(combined_List[ix][1]<sorted_Result[ix][1]):
			 	if(check_if_exist.count(get_param(manipulator,combined_List[ix][0].data))==0):
			 		check_if_exist.append(get_param(manipulator,combined_List[ix][0].data))
			 		sec_iteration_scenarios.append(combined_List[ix][0].data)"""

		cost_function(Combined_list)


		#check survivor //change
		for m in sec_iteration_scenarios:
			print m.data
			get_param(manipulator,m.data)



			"""for iy in itertools.combinations(list(range(0,len(s1))),comb):
				cfg=get_cfg(iy,s1,self.driver,self.manipulator)
				if cfg is None:
					continue
				self.yield_nonblocking(cfg)
				new_scenarios.append(cfg)
				print cfg.data
			yield None"""

		#check all tuples
		eval_tuples=[]
		for res in self.driver.session.query(Results).all():
			eval_tuples.append(res.configuration,res.time)
		sorted(eval_tuples,key=itemgetter(1))
		for ix in range(len(eval_tuples)):
			print eval_tuples[ix][0].data
			print eval_tuples[ix][1]
		
		print "done"



technique.register(Learning_Search)




